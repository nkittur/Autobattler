<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>BattleTech Arena - MechBuilder</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            padding: 0;
            background: #0a0a12;
            font-family: 'Courier New', monospace;
            color: #00ff88;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        /* ============================================
           GAME CONTAINER
           ============================================ */
        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        /* ============================================
           MECHBUILDER UI OVERLAY
           ============================================ */
        #mechBuilderUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
        }

        /* Top bar - Header Panel */
        #statsPanel {
            pointer-events: auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: linear-gradient(180deg, rgba(0,20,10,0.95) 0%, rgba(0,20,10,0.7) 100%);
            border-bottom: 2px solid #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.3);
        }

        #statsPanel .nav-spacer {
            flex: 1;
        }

        .header-nav-btn {
            pointer-events: auto;
            padding: 10px 20px;
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .header-nav-btn:hover:not(:disabled) {
            background: rgba(0, 255, 136, 0.4);
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
        }

        .header-nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #555;
            color: #555;
        }

        .header-nav-btn.warning {
            border-color: #ff4444;
            color: #ff4444;
        }

        /* Mech Stats (above grid) */
        #mechStats {
            display: flex;
            justify-content: center;
            gap: 30px;
            padding: 10px;
            pointer-events: auto;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .stat-label {
            font-size: 10px;
            color: #00aa66;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-bar {
            width: 150px;
            height: 16px;
            background: rgba(0,0,0,0.6);
            border: 1px solid #00ff88;
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }

        .stat-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .stat-fill.weight {
            background: linear-gradient(90deg, #666666, #999999);
        }

        .stat-fill.energy {
            background: linear-gradient(90deg, #00aaff, #88ddff);
        }

        .stat-fill.over-limit {
            background: linear-gradient(90deg, #ff4444, #ff8888);
        }

        .stat-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            color: #fff;
            text-shadow: 0 0 4px #000;
        }

        .stat-fill.hp {
            background: linear-gradient(90deg, #ff4444, #ff8888);
        }

        .stat-fill.armor {
            background: linear-gradient(90deg, #888888, #aaaaaa);
        }

        .stat-fill.accuracy {
            background: linear-gradient(90deg, #ffaa00, #ffcc44);
        }

        /* Loadout Main Layout - Bench on left, Mech Grid on right */
        #loadoutMain {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;  /* For absolute positioning of mechGridArea */
        }

        /* Left Bench Panel */
        #benchPanel {
            width: 200px;
            min-width: 200px;
            background: linear-gradient(90deg, rgba(0,20,10,0.95) 0%, rgba(0,20,10,0.8) 100%);
            border-right: 2px solid #00ff88;
            display: flex;
            flex-direction: column;
            pointer-events: auto;
        }

        #benchHeader {
            padding: 15px;
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
            text-align: center;
        }

        #benchTitle {
            font-size: 14px;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
        }

        #benchSubtitle {
            font-size: 10px;
            color: #00aa66;
        }

        #benchScroll {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .bench-item-vertical {
            position: relative;
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(0, 40, 20, 0.6);
            border: 2px solid #00aa66;
            border-radius: 6px;
            cursor: grab;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bench-item-vertical:hover {
            background: rgba(0, 60, 30, 0.8);
            border-color: #00ff88;
            transform: translateX(3px);
        }

        .bench-item-vertical:active {
            cursor: grabbing;
        }

        .bench-item-vertical.dragging {
            opacity: 0.5;
        }

        .bench-item-vertical .item-icon {
            font-size: 24px;
            flex-shrink: 0;
        }

        .bench-item-vertical .item-info {
            flex: 1;
            min-width: 0;
        }

        .bench-item-vertical .item-name {
            font-size: 11px;
            color: #00ff88;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .bench-item-vertical .item-stats {
            font-size: 9px;
            color: #00aa66;
        }

        /* Item stat icons row */
        .item-stat-row {
            display: flex;
            gap: 8px;
            font-size: 10px;
            margin-top: 3px;
            flex-wrap: wrap;
        }

        .item-stat {
            display: flex;
            align-items: center;
            gap: 2px;
            color: #aaa;
        }

        .item-stat.damage { color: #ff6644; font-size: 14px; }
        .item-stat.damage .item-stat-icon { font-size: 14px; }
        .item-stat.damage .item-stat-value { font-size: 13px; }
        .item-stat.energy { color: #4488ff; }
        .item-stat.weight { color: #888; }
        .item-stat.armor { color: #4488ff; }
        .item-stat.squares { color: #00aa66; }

        /* Secondary stats row (energy, weight) for bottom left */
        .item-secondary-stats {
            display: flex;
            gap: 8px;
            font-size: 13px;
        }

        .item-secondary-stats .item-stat {
            font-size: 13px;
        }

        .item-secondary-stats .item-stat-icon {
            font-size: 13px;
        }

        .item-secondary-stats .item-stat-value {
            font-size: 12px;
        }

        .item-stat-icon {
            font-size: 10px;
        }

        .item-stat-value {
            font-weight: bold;
        }

        /* Item shape preview (shown on hover) - default above */
        .item-shape-preview {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 10, 0.95);
            border: 1px solid #00aa66;
            border-radius: 4px;
            padding: 6px;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
            margin-bottom: 5px;
        }

        .shop-sell-item:hover .item-shape-preview {
            opacity: 1;
        }

        /* Bottom row for items (secondary stats + shape) */
        .item-bottom-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .shape-grid {
            display: inline-grid;
            gap: 2px;
        }

        .shape-cell {
            width: 10px;
            height: 10px;
            border-radius: 2px;
        }

        .shape-cell.filled {
            border: 1px solid rgba(255,255,255,0.3);
        }

        .shape-cell.empty {
            background: transparent;
        }

        .bench-item-vertical.weapon { border-color: #ff6644; }
        .bench-item-vertical.weapon .item-icon { color: #ff6644; }
        .bench-item-vertical.armor { border-color: #4488ff; }
        .bench-item-vertical.armor .item-icon { color: #4488ff; }
        .bench-item-vertical.reactor { border-color: #ffaa00; }
        .bench-item-vertical.reactor .item-icon { color: #ffaa00; }
        .bench-item-vertical.system { border-color: #aa44ff; }
        .bench-item-vertical.system .item-icon { color: #aa44ff; }
        .bench-item-vertical.cooling { border-color: #44ddff; }
        .bench-item-vertical.cooling .item-icon { color: #44ddff; }

        #benchEmpty {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
            font-size: 11px;
        }

        /* Mech Grid Area - positioned to center over 3D mech on full viewport */
        #mechGridArea {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            pointer-events: none;  /* Allow clicks through except on grid */
        }

        /* Unified Mech Grid */
        #unifiedMechGrid {
            display: grid;
            gap: 2px;
            padding: 10px;
            background: rgba(0, 20, 10, 0.9);
            border: 2px solid rgba(0, 255, 136, 0.6);
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            pointer-events: auto;
            position: relative;  /* Required for absolute positioned placed items */
        }

        .mech-cell {
            width: 45px;
            height: 45px;
            background: rgba(0, 255, 136, 0.15);
            border: 1px solid rgba(0, 255, 136, 0.5);
            border-radius: 3px;
            transition: all 0.2s ease;
            position: relative;
        }

        .mech-cell.invalid {
            background: transparent;
            border-color: transparent;
            pointer-events: none;
        }

        .mech-cell:not(.invalid):hover {
            background: rgba(0, 255, 136, 0.25);
            border-color: #00ff88;
        }

        .mech-cell.valid-drop {
            background: rgba(0, 255, 136, 0.4);
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0,255,136,0.5);
        }

        .mech-cell.invalid-drop {
            background: rgba(255, 68, 68, 0.4);
            border-color: #ff4444;
        }

        .mech-cell.occupied {
            background: rgba(0, 170, 255, 0.3);
            border-color: #00aaff;
        }

        /* Placed items in unified grid */
        .placed-item-unified {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-size: 20px;
            cursor: grab;
            z-index: 10;
            transition: transform 0.1s;
        }

        .placed-item-unified:hover {
            transform: scale(1.05);
            z-index: 20;
        }

        .placed-item-unified.weapon { --item-bg: rgba(255, 102, 68, 0.7); --item-border: #ff6644; }
        .placed-item-unified.armor { --item-bg: rgba(68, 136, 255, 0.7); --item-border: #4488ff; }
        .placed-item-unified.reactor { --item-bg: rgba(255, 170, 0, 0.7); --item-border: #ffaa00; }
        .placed-item-unified.system { --item-bg: rgba(170, 68, 255, 0.7); --item-border: #aa44ff; }
        .placed-item-unified.cooling { --item-bg: rgba(68, 221, 255, 0.7); --item-border: #44ddff; }

        /* Blocked rotation flash effect */
        .placed-item-unified.rotation-blocked {
            animation: rotationBlocked 0.3s ease-out;
        }
        .placed-item-unified.rotation-blocked .item-shape-cell {
            background: rgba(255, 50, 50, 0.8) !important;
            border-color: #ff3333 !important;
        }
        @keyframes rotationBlocked {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(1.05) rotate(-3deg); }
            50% { transform: scale(1.05) rotate(3deg); }
            75% { transform: scale(1.05) rotate(-2deg); }
        }

        /* Tooltips for placed items in unified grid */
        .placed-item-unified .item-tooltip {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 10, 0.95);
            border: 2px solid currentColor;
            border-radius: 6px;
            padding: 10px 14px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 100;
            pointer-events: none;
            text-align: left;
        }

        .placed-item-unified:hover .item-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .placed-item-unified .item-tooltip .tooltip-name {
            font-weight: bold;
            font-size: 13px;
            margin-bottom: 6px;
        }

        .placed-item-unified .item-tooltip .tooltip-stats {
            color: #aaa;
        }

        .placed-item-unified .item-tooltip .tooltip-stats div {
            margin: 3px 0;
        }

        .placed-item-unified .item-tooltip .tooltip-special {
            margin-top: 8px;
            padding-top: 6px;
            border-top: 1px solid rgba(255,255,255,0.2);
            color: #ffcc00;
            font-style: italic;
            font-size: 10px;
        }

        /* Shop inventory sellable items */
        .shop-sell-item {
            position: relative;
            display: flex;
            align-items: center;
            padding: 8px 10px;
            margin-bottom: 6px;
            background: rgba(0, 40, 20, 0.6);
            border: 2px solid #00aa66;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            gap: 8px;
        }

        .shop-sell-item:hover {
            background: rgba(255, 170, 0, 0.2);
            border-color: #ffaa00;
        }

        .shop-sell-item .item-icon {
            font-size: 18px;
            flex-shrink: 0;
        }

        .shop-sell-item .item-info {
            flex: 1;
            min-width: 0;
        }

        .shop-sell-item .item-name {
            font-size: 10px;
            color: #00ff88;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .shop-sell-item .item-sell-price {
            font-size: 10px;
            color: #ffaa00;
            font-weight: bold;
        }

        .shop-sell-item.weapon { border-color: #ff6644; }
        .shop-sell-item.weapon .item-icon { color: #ff6644; }
        .shop-sell-item.armor { border-color: #4488ff; }
        .shop-sell-item.armor .item-icon { color: #4488ff; }
        .shop-sell-item.reactor { border-color: #ffaa00; }
        .shop-sell-item.reactor .item-icon { color: #ffaa00; }
        .shop-sell-item.system { border-color: #aa44ff; }
        .shop-sell-item.system .item-icon { color: #aa44ff; }
        .shop-sell-item.cooling { border-color: #44ddff; }
        .shop-sell-item.cooling .item-icon { color: #44ddff; }

        .shop-empty-msg {
            text-align: center;
            color: #666;
            font-style: italic;
            font-size: 11px;
            padding: 10px;
        }

        #pileViewerClose {
            margin-top: 20px;
            padding: 10px 30px;
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            border-radius: 4px;
        }

        #gameTitle {
            font-size: 18px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            letter-spacing: 2px;
        }

        /* Middle area - Grid Overlays (compact layout) */
        #gridOverlayContainer {
            flex: 1;
            pointer-events: none;
            display: grid;
            grid-template-columns: auto auto auto;
            grid-template-rows: auto auto;
            grid-template-areas:
                "leftArm torso rightArm"
                "legs legs legs";
            gap: 5px;
            padding: 20px 10px 20px 10px;
            justify-content: center;
            align-content: center;
            align-items: start;
            overflow-y: auto;
        }

        #legsContainer {
            grid-area: legs;
            display: flex;
            justify-content: center;
            gap: 5px;
            pointer-events: none;
        }

        .mech-grid-overlay {
            position: relative;
            pointer-events: auto;
            display: grid;
            gap: 2px;
            padding: 4px;
            background: rgba(0, 20, 10, 0.9);
            border: 2px solid rgba(0, 255, 136, 0.6);
            border-radius: 4px;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
            transition: border-color 0.15s, box-shadow 0.15s;
        }

        .mech-grid-overlay[data-slot="torso"] { grid-area: torso; }
        .mech-grid-overlay[data-slot="leftArm"] { grid-area: leftArm; }
        .mech-grid-overlay[data-slot="rightArm"] { grid-area: rightArm; }

        .mech-grid-overlay.slot-valid {
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .mech-grid-overlay.slot-invalid {
            border-color: #ff4444;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.4);
            opacity: 0.6;
        }

        .mech-grid-overlay.slot-invalid .grid-label {
            color: #ff6666;
        }

        .grid-cell {
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 136, 0.15);
            border: 1px solid rgba(0, 255, 136, 0.5);
            border-radius: 2px;
            transition: all 0.2s ease;
        }

        .grid-cell:hover {
            background: rgba(0, 255, 136, 0.25);
            border-color: #00ff88;
        }

        .grid-cell.valid-drop {
            background: rgba(0, 255, 136, 0.4);
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0,255,136,0.5);
        }

        .grid-cell.invalid-drop {
            background: rgba(255, 68, 68, 0.4);
            border-color: #ff4444;
            box-shadow: 0 0 10px rgba(255,68,68,0.5);
        }

        .grid-cell.occupied {
            background: rgba(0, 170, 255, 0.3);
            border-color: #00aaff;
        }

        .grid-label {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #00aa66;
            text-transform: uppercase;
            letter-spacing: 1px;
            white-space: nowrap;
        }

        /* Bottom area - The Bench (Hand) */
        #benchContainer {
            pointer-events: auto;
            padding: 15px 20px;
            background: linear-gradient(0deg, rgba(0,20,10,0.95) 0%, rgba(0,20,10,0.7) 100%);
            border-top: 2px solid #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.3);
            transition: border-color 0.15s, box-shadow 0.15s;
        }

        #benchContainer.drop-target {
            border-top-color: #00ffaa;
            box-shadow: 0 0 30px rgba(0,255,170,0.5);
            background: linear-gradient(0deg, rgba(0,40,20,0.95) 0%, rgba(0,30,15,0.8) 100%);
        }

        #benchLabel {
            font-size: 12px;
            color: #00aa66;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
            text-align: center;
        }

        #bench {
            display: flex;
            gap: 15px;
            overflow-x: auto;
            overflow-y: visible;
            padding: 10px 0;
            padding-top: 120px;
            margin-top: -110px;
            min-height: 100px;
            justify-content: center;
        }

        .bench-item {
            flex-shrink: 0;
            width: 80px;
            height: 80px;
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: grab;
            transition: all 0.2s ease;
            position: relative;
        }

        .bench-item:hover {
            background: rgba(0, 255, 136, 0.2);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,255,136,0.3);
        }

        .bench-item:active {
            cursor: grabbing;
        }

        .bench-item.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .bench-item .item-icon {
            font-size: 28px;
            margin-bottom: 4px;
        }

        .bench-item .item-name {
            font-size: 9px;
            color: #00ff88;
            text-align: center;
            padding: 0 4px;
        }

        .bench-item .item-shape {
            display: none;  /* Hidden, replaced by visual grid */
        }

        .bench-item .shape-preview {
            display: grid;
            gap: 1px;
            margin-top: 4px;
        }

        .bench-item .shape-cell {
            width: 10px;
            height: 10px;
            background: currentColor;
            opacity: 0.6;
            border-radius: 1px;
        }

        .bench-item .shape-cell.empty {
            background: transparent;
        }

        .bench-item.weapon { border-color: #ff6644; }
        .bench-item.weapon .item-icon { color: #ff6644; }
        .bench-item.armor { border-color: #4488ff; }
        .bench-item.armor .item-icon { color: #4488ff; }
        .bench-item.reactor { border-color: #ffaa00; }
        .bench-item.reactor .item-icon { color: #ffaa00; }
        .bench-item.system { border-color: #aa44ff; }
        .bench-item.system .item-icon { color: #aa44ff; }
        .bench-item.cooling { border-color: #44ddff; }
        .bench-item.cooling .item-icon { color: #44ddff; }

        /* Rotate button on bench items */
        .bench-item .rotate-btn,
        .bench-item-vertical .rotate-btn {
            position: absolute;
            top: -8px;
            left: -8px;
            width: 22px;
            height: 22px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid currentColor;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s, visibility 0.15s, transform 0.15s;
            z-index: 50;
        }
        .bench-item:hover .rotate-btn,
        .bench-item-vertical:hover .rotate-btn {
            opacity: 1;
            visibility: visible;
        }
        .bench-item .rotate-btn:hover,
        .bench-item-vertical .rotate-btn:hover {
            transform: scale(1.2);
            background: rgba(0, 255, 136, 0.3);
        }
        .bench-item .rotate-btn:active,
        .bench-item-vertical .rotate-btn:active {
            transform: scale(0.9);
        }

        /* Bench item tooltip */
        .bench-item .bench-tooltip {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 10, 0.95);
            border: 1px solid currentColor;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s, visibility 0.15s;
            z-index: 100;
            pointer-events: none;
        }

        .bench-item:hover .bench-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .bench-item .bench-tooltip .tooltip-name {
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 4px;
        }

        .bench-item .bench-tooltip .tooltip-stats {
            color: #aaa;
        }

        .bench-item .bench-tooltip .tooltip-stats span {
            display: block;
            margin: 2px 0;
        }

        .bench-item .bench-tooltip .tooltip-slots {
            color: #666;
            font-size: 9px;
            margin-top: 4px;
            border-top: 1px solid #333;
            padding-top: 4px;
        }

        .bench-item .bench-tooltip .tooltip-special {
            color: #44ddff;
            font-size: 9px;
            margin-top: 4px;
            border-top: 1px solid #44ddff44;
            padding-top: 4px;
        }

        .bench-item .bench-tooltip .tooltip-special span {
            display: block;
            margin: 2px 0;
        }

        /* Mission Selection - Hidden (use tab instead) */
        #missionContainer {
            display: none;
        }

        #missionLabel {
            font-size: 12px;
            color: #00aa66;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 12px;
            text-align: center;
        }

        .mission-card {
            background: rgba(0, 255, 136, 0.05);
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-radius: 6px;
            padding: 10px 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .mission-card:hover {
            background: rgba(0, 255, 136, 0.15);
            border-color: #00ff88;
            transform: translateX(-3px);
        }

        .mission-card.selected {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0,255,136,0.4);
        }

        .mission-card.easy { border-left: 4px solid #44ff44; }
        .mission-card.medium { border-left: 4px solid #ffaa00; }
        .mission-card.hard { border-left: 4px solid #ff4444; }

        .mission-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .mission-name {
            font-size: 13px;
            font-weight: bold;
            color: #00ff88;
        }

        .mission-difficulty {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            text-transform: uppercase;
        }

        .mission-difficulty.easy { background: rgba(68, 255, 68, 0.3); color: #44ff44; }
        .mission-difficulty.medium { background: rgba(255, 170, 0, 0.3); color: #ffaa00; }
        .mission-difficulty.hard { background: rgba(255, 68, 68, 0.3); color: #ff4444; }

        .mission-desc {
            font-size: 10px;
            color: #888;
            margin-bottom: 8px;
        }

        .mission-reward {
            font-size: 10px;
            color: #ffcc00;
        }

        .mission-reward span {
            margin-right: 12px;
        }

        /* Mission enemy tooltip */
        .mission-card .enemy-tooltip {
            position: absolute;
            left: calc(100% + 10px);
            top: 0;
            width: 200px;
            background: rgba(10, 0, 0, 0.95);
            border: 1px solid #ff4444;
            border-radius: 4px;
            padding: 10px;
            font-size: 10px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s, visibility 0.15s;
            z-index: 100;
            pointer-events: none;
        }

        .mission-card:hover .enemy-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .enemy-tooltip .enemy-name {
            font-weight: bold;
            color: #ff6666;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .enemy-tooltip .enemy-chassis {
            color: #888;
            margin-bottom: 8px;
        }

        .enemy-tooltip .enemy-stats {
            color: #aaa;
        }

        .enemy-tooltip .enemy-stats div {
            margin: 3px 0;
        }

        .enemy-tooltip .enemy-equipment {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #333;
            color: #888;
        }

        .enemy-tooltip .enemy-equipment div {
            margin: 2px 0;
        }

        /* Drag ghost element */
        #dragGhost {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.9;
            transform: translate(-50%, -50%) scale(1.1);
            transition: transform 0.1s ease;
        }

        #dragGhost .ghost-grid {
            display: grid;
            gap: 2px;
            padding: 4px;
            background: rgba(0, 255, 136, 0.3);
            border: 2px solid #00ff88;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
        }

        #dragGhost .ghost-cell {
            width: 38px;
            height: 38px;
            background: rgba(0, 255, 136, 0.5);
            border: 1px solid #00ff88;
            border-radius: 2px;
        }

        #dragGhost .ghost-cell-empty {
            width: 38px;
            height: 38px;
            background: transparent;
            border: none;
        }

        #dragGhost.invalid .ghost-grid {
            background: rgba(255, 68, 68, 0.3);
            border-color: #ff4444;
            box-shadow: 0 0 20px rgba(255,68,68,0.5);
        }

        #dragGhost.invalid .ghost-cell {
            background: rgba(255, 68, 68, 0.5);
            border-color: #ff4444;
        }

        /* Placed items on grid */
        .placed-item {
            position: absolute;
            display: grid;
            gap: 2px;
            padding: 2px;
            background: rgba(0, 170, 255, 0.2);
            border: 2px solid #00aaff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .placed-item:hover {
            background: rgba(0, 170, 255, 0.4);
            box-shadow: 0 0 15px rgba(0,170,255,0.6);
            z-index: 10;
        }

        .placed-item .placed-cell {
            width: 36px;
            height: 36px;
            background: rgba(0, 170, 255, 0.3);
            border: 1px solid rgba(0, 170, 255, 0.6);
            border-radius: 2px;
        }

        .placed-item.weapon { border-color: #ff6644; background: rgba(255,102,68,0.2); }
        .placed-item.weapon .placed-cell { background: rgba(255,102,68,0.3); border-color: rgba(255,102,68,0.6); }
        .placed-item.armor { border-color: #4488ff; background: rgba(68,136,255,0.2); }
        .placed-item.armor .placed-cell { background: rgba(68,136,255,0.3); border-color: rgba(68,136,255,0.6); }
        .placed-item.reactor { border-color: #ffaa00; background: rgba(255,170,0,0.2); }
        .placed-item.reactor .placed-cell { background: rgba(255,170,0,0.3); border-color: rgba(255,170,0,0.6); }
        .placed-item.system { border-color: #aa44ff; background: rgba(170,68,255,0.2); }
        .placed-item.system .placed-cell { background: rgba(170,68,255,0.3); border-color: rgba(170,68,255,0.6); }
        .placed-item.cooling { border-color: #44ddff; background: rgba(68,221,255,0.2); }
        .placed-item.cooling .placed-cell { background: rgba(68,221,255,0.3); border-color: rgba(68,221,255,0.6); }
        .placed-item.locked { opacity: 0.7; }
        .placed-item.locked::after {
            content: 'ðŸ”’';
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 10px;
        }

        .placed-item .item-icon-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            opacity: 0.9;
            text-shadow: 0 0 8px rgba(0,0,0,0.8);
            pointer-events: none;
        }

        .placed-item .item-tooltip {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 10, 0.95);
            border: 1px solid currentColor;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 100;
            pointer-events: none;
        }

        .placed-item:hover .item-tooltip,
        .placed-item.show-tooltip .item-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .placed-item .item-tooltip .tooltip-name {
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 4px;
        }

        .placed-item .item-tooltip .tooltip-stats {
            color: #aaa;
        }

        .placed-item .item-tooltip .tooltip-stats span {
            display: block;
            margin: 2px 0;
        }

        .placed-item .item-tooltip .tooltip-hint {
            margin-top: 6px;
            color: #666;
            font-style: italic;
        }


        /* Hidden during battle */
        .battle-mode #mechBuilderUI {
            display: none;
        }

        /* ============================================
           BATTLE UI
           ============================================ */
        #battleUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
        }

        .battle-mode #battleUI {
            display: block;
        }

        .battle-mode #mechBuilderUI {
            display: none;
        }

        #battleHeader {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        #missionTitle {
            font-size: 24px;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 20px rgba(0,255,136,0.5);
        }

        #battleStatus {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            border: 2px solid #00ff88;
            border-radius: 8px;
            padding: 15px 30px;
            display: flex;
            align-items: center;
            gap: 30px;
            pointer-events: auto;
        }

        #battleVS {
            font-size: 24px;
            font-weight: bold;
            color: #ffcc00;
            text-shadow: 0 0 10px rgba(255,204,0,0.5);
        }

        .team-status {
            text-align: center;
            min-width: 180px;
        }

        .team-status.player { color: #00ff88; }
        .team-status.enemy { color: #ff4444; }

        #playerMechName, #enemyMechName {
            font-size: 11px;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        .hp-bar {
            width: 180px;
            height: 16px;
            background: #222;
            border-radius: 3px;
            overflow: hidden;
            margin: 6px 0;
            border: 1px solid #444;
        }

        .hp-fill {
            height: 100%;
            transition: width 0.3s;
        }

        .hp-fill.player { background: linear-gradient(90deg, #00aa55, #00ff88); }
        .hp-fill.enemy { background: linear-gradient(90deg, #aa2222, #ff4444); }

        #battleLog {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            max-height: 200px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #00aa66;
            border-radius: 6px;
            padding: 10px 15px;
            overflow-y: auto;
            pointer-events: auto;
        }

        #battleLogContent {
            font-size: 12px;
            color: #aaa;
        }

        .log-entry {
            margin: 4px 0;
            padding: 4px 0;
            border-bottom: 1px solid #333;
        }

        .log-entry.player-action { color: #00ff88; }
        .log-entry.enemy-action { color: #ff6666; }
        .log-entry.damage { color: #ffaa00; }
        .log-entry.victory { color: #44ff44; font-weight: bold; }
        .log-entry.defeat { color: #ff4444; font-weight: bold; }

        #battleResult {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,20,10,0.95);
            border: 3px solid #00ff88;
            border-radius: 12px;
            padding: 40px 60px;
            text-align: center;
            pointer-events: auto;
            box-shadow: 0 0 50px rgba(0,255,136,0.4);
        }

        #resultTitle {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 0 0 20px currentColor;
        }

        #resultTitle.victory { color: #44ff44; }
        #resultTitle.defeat { color: #ff4444; }

        #resultRewards {
            font-size: 16px;
            color: #ffcc00;
            margin-bottom: 25px;
        }

        #resultRewards div {
            margin: 8px 0;
        }

        #returnToBuilderBtn {
            padding: 12px 30px;
            font-size: 16px;
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            border-radius: 6px;
            font-family: monospace;
            transition: all 0.2s;
        }

        #returnToBuilderBtn:hover {
            background: rgba(0, 255, 136, 0.4);
            transform: scale(1.05);
        }

        /* Tab Content Areas */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        #loadoutTab {
            display: none;
            flex-direction: column;
            flex: 1;
            position: relative;
        }

        #loadoutTab.active {
            display: flex;
        }

        #shopTab {
            display: none;
            flex-direction: column;
            flex: 1;
        }

        #shopTab.active {
            display: flex;
        }

        /* Tab Navigation Headers */
        .tab-nav-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(0, 20, 10, 0.8);
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
            pointer-events: auto;
        }

        .tab-nav-header .nav-btn {
            padding: 8px 16px;
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .tab-nav-header .nav-btn:hover:not(:disabled) {
            background: rgba(0, 255, 136, 0.4);
            box-shadow: 0 0 15px rgba(0,255,136,0.4);
        }

        .tab-nav-header .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #555;
            color: #555;
        }

        .tab-nav-header .nav-btn.primary {
            background: rgba(0, 255, 136, 0.3);
        }

        .tab-nav-header .nav-btn.primary:hover:not(:disabled) {
            background: rgba(0, 255, 136, 0.5);
        }

        .tab-nav-header .nav-btn.warning {
            border-color: #ff4444;
            color: #ff4444;
        }

        .tab-nav-header .nav-spacer {
            flex: 1;
        }

        .tab-nav-header .nav-title {
            font-size: 14px;
            color: #00aa66;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Mission Tab - Full screen panel */
        #missionTab {
            display: none;
            flex-direction: column;
            flex: 1;
            background: rgba(0, 10, 5, 0.98);
            overflow-y: auto;
            pointer-events: auto;
        }

        #missionTab.active {
            display: flex;
        }

        #missionTab .mission-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        #missionTab .mission-header {
            text-align: center;
            margin-bottom: 20px;
        }

        #missionTab .mission-title {
            font-size: 24px;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 8px;
        }

        #missionTab .mission-subtitle {
            font-size: 12px;
            color: #00aa66;
        }

        #missionTab .mission-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            max-width: 900px;
            margin: 0 auto;
        }

        #missionTab .mission-card {
            background: rgba(0, 255, 136, 0.05);
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #missionTab .mission-card:hover {
            background: rgba(0, 255, 136, 0.15);
            border-color: #00ff88;
            transform: translateY(-2px);
        }

        #missionTab .mission-card.selected {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.4);
        }

        #missionTab .mission-card.easy { border-left: 4px solid #44ff44; }
        #missionTab .mission-card.medium { border-left: 4px solid #ffaa00; }
        #missionTab .mission-card.hard { border-left: 4px solid #ff4444; }

        #missionTab .mission-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        #missionTab .mission-name {
            font-size: 16px;
            font-weight: bold;
            color: #00ff88;
        }

        #missionTab .mission-difficulty {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 4px;
            text-transform: uppercase;
            font-weight: bold;
        }

        #missionTab .mission-difficulty.easy { background: rgba(68, 255, 68, 0.3); color: #44ff44; }
        #missionTab .mission-difficulty.medium { background: rgba(255, 170, 0, 0.3); color: #ffaa00; }
        #missionTab .mission-difficulty.hard { background: rgba(255, 68, 68, 0.3); color: #ff4444; }

        #missionTab .mission-desc {
            font-size: 12px;
            color: #888;
            margin-bottom: 12px;
            line-height: 1.4;
        }

        #missionTab .mission-details {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            flex-wrap: wrap;
            gap: 10px;
        }

        #missionTab .mission-reward {
            font-size: 12px;
            color: #ffcc00;
        }

        #missionTab .mission-reward span {
            display: block;
            margin: 3px 0;
        }

        #missionTab .mission-enemy {
            font-size: 11px;
            color: #ff6666;
            text-align: right;
        }

        #missionTab .mission-enemy-name {
            font-weight: bold;
            margin-bottom: 3px;
        }

        /* Background Selector */
        .background-selector {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid rgba(0, 255, 136, 0.2);
        }

        .background-selector-title {
            font-size: 14px;
            color: #00aa66;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 12px;
            text-align: center;
        }

        .background-options {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .background-option {
            padding: 10px 16px;
            background: rgba(0, 255, 136, 0.05);
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            min-width: 100px;
        }

        .background-option:hover {
            background: rgba(0, 255, 136, 0.15);
            border-color: #00ff88;
        }

        .background-option.selected {
            background: rgba(0, 255, 136, 0.25);
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }

        .background-option-name {
            font-size: 12px;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 4px;
        }

        .background-option-desc {
            font-size: 10px;
            color: #888;
        }

        /* Piloting Mode Toggle */
        .piloting-mode-selector {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(0, 255, 136, 0.2);
        }

        .piloting-mode-title {
            font-size: 14px;
            color: #00aa66;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 12px;
            text-align: center;
        }

        .piloting-toggle-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
        }

        .piloting-toggle {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            background: rgba(0, 255, 136, 0.05);
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .piloting-toggle:hover {
            background: rgba(0, 255, 136, 0.15);
            border-color: #00ff88;
        }

        .piloting-toggle.active {
            background: rgba(255, 170, 0, 0.2);
            border-color: #ffaa00;
            box-shadow: 0 0 15px rgba(255, 170, 0, 0.3);
        }

        .piloting-toggle-switch {
            width: 44px;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            position: relative;
            transition: all 0.2s ease;
        }

        .piloting-toggle.active .piloting-toggle-switch {
            background: rgba(255, 170, 0, 0.4);
        }

        .piloting-toggle-switch::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background: #666;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: all 0.2s ease;
        }

        .piloting-toggle.active .piloting-toggle-switch::after {
            left: 23px;
            background: #ffaa00;
        }

        .piloting-toggle-label {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .piloting-toggle-name {
            font-size: 13px;
            font-weight: bold;
            color: #00ff88;
        }

        .piloting-toggle.active .piloting-toggle-name {
            color: #ffaa00;
        }

        .piloting-toggle-desc {
            font-size: 10px;
            color: #888;
        }

        /* ============================================
           MOBILE RESPONSIVE STYLES
           ============================================ */
        @media (max-width: 768px) {
            /* Stats Panel - Compact for mobile */
            #statsPanel {
                flex-wrap: wrap;
                padding: 8px 12px;
                gap: 8px;
            }

            .stat-group {
                gap: 15px;
                order: 2;
                flex: 1;
            }

            .stat-bar {
                width: 100px;
                height: 14px;
            }

            .stat-label {
                font-size: 9px;
            }

            .stat-text {
                font-size: 9px;
            }

            #gameTitle {
                font-size: 14px;
                order: 1;
                width: 100%;
                text-align: center;
                margin-bottom: 5px;
            }

            #battleReadyBtn {
                order: 3;
                padding: 8px 15px;
                font-size: 11px;
            }

            /* Grid cells smaller on mobile */
            .grid-cell {
                width: 32px;
                height: 32px;
            }

            .placed-item .placed-cell {
                width: 28px;
                height: 28px;
            }

            /* Bench smaller on mobile */
            #benchContainer {
                padding: 10px 12px;
            }

            #benchLabel {
                font-size: 10px;
                margin-bottom: 8px;
            }

            #bench {
                gap: 10px;
                min-height: 80px;
            }

            .bench-item {
                width: 65px;
                height: 65px;
            }

            .bench-item .item-icon {
                font-size: 22px;
            }

            .bench-item .item-name {
                font-size: 8px;
            }

            /* Adjust grid label size */
            .grid-label {
                font-size: 8px;
                top: -16px;
            }

            /* Mission tab padding */
            #missionTab {
                padding: 15px;
            }

            #missionTab .mission-title {
                font-size: 20px;
            }
        }

        /* Very small screens */
        @media (max-width: 480px) {
            .grid-cell {
                width: 28px;
                height: 28px;
            }

            .placed-item .placed-cell {
                width: 24px;
                height: 24px;
            }

            .placed-item .item-icon-overlay {
                font-size: 16px;
            }

            .stat-bar {
                width: 80px;
            }

            .bench-item {
                width: 55px;
                height: 55px;
            }

            .bench-item .item-icon {
                font-size: 18px;
            }

            #missionTab .mission-grid {
                grid-template-columns: 1fr;
            }

            /* Smaller grid layout */
            #gridOverlayContainer {
                gap: 5px;
                padding: 5px;
            }
        }

        /* Landscape mobile - side by side layout */
        @media (max-width: 900px) and (orientation: landscape) {
            #mechBuilderUI {
                flex-direction: row;
                flex-wrap: wrap;
            }

            #statsPanel {
                width: 100%;
            }

            #loadoutTab {
                flex-direction: row;
            }

            #gridOverlayContainer {
                flex: 1;
            }

            #benchContainer {
                width: 200px;
                height: calc(100vh - 120px);
                border-top: none;
                border-left: 2px solid #00ff88;
            }

            #bench {
                flex-direction: column;
                overflow-y: auto;
                overflow-x: hidden;
                max-height: 100%;
            }
        }
    </style>
</head>
<body>
    <!-- Global floating tooltip for item details -->
    <div id="itemTooltip" style="
        display: none;
        position: fixed;
        z-index: 10000;
        background: rgba(0, 10, 5, 0.95);
        border: 2px solid #00ff88;
        border-radius: 8px;
        padding: 12px;
        max-width: 280px;
        font-size: 11px;
        color: #00ff88;
        pointer-events: none;
        box-shadow: 0 4px 20px rgba(0, 255, 136, 0.3);
    "></div>
    <div id="gameContainer">
        <canvas id="renderCanvas"></canvas>

        <!-- MechBuilder UI Overlay -->
        <div id="mechBuilderUI">
            <!-- Header Panel -->
            <div id="statsPanel">
                <div id="gameTitle">Loadout</div>
                <div id="headerInfo" style="display: flex; gap: 20px; align-items: center;">
                    <div id="roundDisplay" style="color: #00aa66; font-size: 12px;">Round <span id="roundNum">1</span></div>
                    <div id="goldDisplay" style="color: #ffcc00; font-size: 14px; font-weight: bold;">ðŸ’° <span id="goldAmount">10</span></div>
                </div>
                <div class="nav-spacer"></div>
                <button id="goToShopBtn" class="header-nav-btn" style="margin-right: 10px;">Shop</button>
                <button id="goToMissionsBtn" class="header-nav-btn" disabled>Battle â†’</button>
            </div>

            <!-- Loadout Tab Content -->
            <div id="loadoutTab" class="tab-content active">
                <!-- Weight/Energy Stats (above mech) -->
                <div id="mechStats">
                    <div class="stat-item">
                        <span class="stat-label">HP</span>
                        <div class="stat-bar">
                            <div class="stat-fill hp" id="hpFill" style="width: 100%"></div>
                            <span class="stat-text" id="hpText">100</span>
                        </div>
                    </div>
                    <div class="stat-item" id="armorStatItem" style="display: none;">
                        <span class="stat-label">Armor</span>
                        <div class="stat-bar">
                            <div class="stat-fill armor" id="armorFill" style="width: 0%"></div>
                            <span class="stat-text" id="armorText">0</span>
                        </div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Accuracy</span>
                        <div class="stat-bar">
                            <div class="stat-fill accuracy" id="accuracyFill" style="width: 60%"></div>
                            <span class="stat-text" id="accuracyText">60%</span>
                        </div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Weight</span>
                        <div class="stat-bar">
                            <div class="stat-fill weight" id="weightFill" style="width: 0%"></div>
                            <span class="stat-text" id="weightText">0 / 100</span>
                        </div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Energy</span>
                        <div class="stat-bar">
                            <div class="stat-fill energy" id="energyFill" style="width: 0%"></div>
                            <span class="stat-text" id="energyText">0 / 50</span>
                        </div>
                    </div>
                </div>

                <!-- Main Layout: Bench on left, Mech Grid on right -->
                <div id="loadoutMain">
                    <!-- Left Bench Panel -->
                    <div id="benchPanel">
                        <div id="benchHeader">
                            <div id="benchTitle">Equipment</div>
                            <div id="benchSubtitle">Drag to equip</div>
                        </div>
                        <div id="benchScroll">
                            <!-- Items populated by JS -->
                        </div>
                        <div id="benchEmpty" style="display: none;">No items available</div>
                    </div>

                    <!-- Mech Grid Area -->
                    <div id="mechGridArea">
                        <div id="unifiedMechGrid">
                            <!-- Unified mech-shaped grid populated by JS -->
                        </div>
                    </div>
                </div>

            </div>

            <!-- Mission Tab Content -->
            <div id="missionTab" class="tab-content">
                <!-- Navigation Header -->
                <div class="tab-nav-header">
                    <button class="nav-btn" onclick="switchTab('loadout')">â† Back to Loadout</button>
                    <div class="nav-spacer"></div>
                    <button class="nav-btn primary" id="missionContinueBtn" onclick="startBattleFromMission()" disabled>
                        Continue to Battle â†’
                    </button>
                </div>

                <div class="mission-content">
                    <div class="mission-header">
                        <div class="mission-title">Select Mission</div>
                        <div class="mission-subtitle">Choose your next deployment</div>
                    </div>
                    <div class="mission-grid" id="missionTabList">
                        <!-- Missions populated by JS -->
                    </div>

                    <!-- Background Selector -->
                    <div class="background-selector">
                        <div class="background-selector-title">Arena Environment</div>
                        <div class="background-options" id="backgroundOptions">
                            <!-- Populated by JS -->
                        </div>
                    </div>

                    <!-- Piloting Mode Toggle -->
                    <div class="piloting-mode-selector">
                        <div class="piloting-mode-title">Combat Mode</div>
                        <div class="piloting-toggle-container">
                            <div class="piloting-toggle" id="pilotingToggle" onclick="togglePilotingMode()">
                                <div class="piloting-toggle-switch"></div>
                                <div class="piloting-toggle-label">
                                    <div class="piloting-toggle-name">Manual Pilot</div>
                                    <div class="piloting-toggle-desc">Control targeting and weapons from the cockpit</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Shop Tab Content (solid background to hide 3D mech) -->
            <div id="shopTab" class="tab-content" style="background: linear-gradient(180deg, #0a1a0f 0%, #051008 100%); position: relative; z-index: 100;">
                <div class="tab-nav-header" style="pointer-events: auto;">
                    <button class="nav-btn" onclick="switchTab('loadout')">â† Back to Loadout</button>
                    <div class="nav-spacer"></div>
                    <div style="color: #ffcc00; font-size: 16px; font-weight: bold;">ðŸ’° <span id="shopGoldDisplay">10</span> Gold</div>
                </div>
                <div class="shop-layout" style="display: flex; flex: 1; overflow: hidden; pointer-events: auto;">
                    <!-- Left Panel: Your Inventory -->
                    <div class="shop-inventory-panel" style="width: 250px; min-width: 250px; background: rgba(0,20,10,0.95); border-right: 2px solid #00aa66; display: flex; flex-direction: column;">
                        <div style="padding: 15px; border-bottom: 1px solid rgba(0,255,136,0.3); text-align: center;">
                            <div style="font-size: 14px; color: #ffaa00; letter-spacing: 2px;">YOUR ITEMS</div>
                            <div style="font-size: 10px; color: #888; margin-top: 5px;">Click to sell</div>
                        </div>
                        <div id="shopInventoryScroll" style="flex: 1; overflow-y: auto; padding: 10px;">
                            <!-- Equipped Items Section -->
                            <div style="margin-bottom: 15px;">
                                <div style="font-size: 11px; color: #00aa66; margin-bottom: 8px; letter-spacing: 1px;">EQUIPPED</div>
                                <div id="shopEquippedItems">
                                    <!-- Populated by JS -->
                                </div>
                            </div>
                            <!-- Bench Items Section -->
                            <div style="margin-bottom: 15px;">
                                <div style="font-size: 11px; color: #00aa66; margin-bottom: 8px; letter-spacing: 1px;">BENCH</div>
                                <div id="shopBenchItems">
                                    <!-- Populated by JS -->
                                </div>
                            </div>
                            <!-- Buyback Section -->
                            <div>
                                <div style="font-size: 11px; color: #ffaa00; margin-bottom: 8px; letter-spacing: 1px;">ðŸ”„ BUYBACK (1g)</div>
                                <div id="shopBuybackItems">
                                    <!-- Populated by JS -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Right Panel: Shop Items for Sale -->
                    <div class="shop-content" style="flex: 1; padding: 20px; overflow-y: auto; background: rgba(0,10,5,0.95);">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 24px; color: #00ff88; letter-spacing: 3px;">SHOP</div>
                            <div style="font-size: 12px; color: #666;">Buy mechs and weapons to strengthen your arsenal</div>
                        </div>

                        <!-- Mechs Section -->
                        <div style="margin-bottom: 30px;">
                            <div style="font-size: 14px; color: #00aa66; margin-bottom: 15px; letter-spacing: 2px; border-bottom: 1px solid #00aa66; padding-bottom: 5px;">MECHS FOR SALE</div>
                            <div id="shopMechsContainer" style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center;">
                                <!-- Populated by JS -->
                            </div>
                        </div>

                        <!-- Weapons Section -->
                        <div style="margin-bottom: 30px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 1px solid #00aa66; padding-bottom: 5px;">
                                <div style="font-size: 14px; color: #00aa66; letter-spacing: 2px;">WEAPONS FOR SALE</div>
                                <button id="refreshShopBtn" onclick="handleRefreshShop()" style="padding: 6px 15px; background: rgba(255, 170, 0, 0.2); border: 1px solid #ffaa00; color: #ffaa00; cursor: pointer; border-radius: 4px; font-family: monospace; font-size: 11px;">
                                    Refresh (2g)
                                </button>
                            </div>
                            <div id="shopWeaponsContainer" style="display: flex; flex-wrap: wrap; gap: 12px; justify-content: center;">
                                <!-- Populated by JS -->
                            </div>
                        </div>

                        <!-- Owned Mechs Section -->
                        <div>
                            <div style="font-size: 14px; color: #00aa66; margin-bottom: 15px; letter-spacing: 2px; border-bottom: 1px solid #00aa66; padding-bottom: 5px;">YOUR MECHS</div>
                            <div id="ownedMechsContainer" style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center;">
                                <!-- Populated by JS -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <!-- Battle UI Overlay (hidden during builder) -->
        <div id="battleUI">
            <div id="battleHeader">
                <div id="missionTitle">Mission: Border Patrol</div>
            </div>

            <div id="battleStatus">
                <div class="team-status player">
                    <strong>YOUR MECH</strong>
                    <div id="playerMechName">Timber Wolf</div>
                    <div class="hp-bar"><div class="hp-fill player" id="playerHP" style="width: 100%"></div></div>
                    <div id="playerHPText">HP: 150/150</div>
                </div>
                <div id="battleVS">VS</div>
                <div class="team-status enemy">
                    <strong>ENEMY</strong>
                    <div id="enemyMechName">Scout Mech</div>
                    <div class="hp-bar"><div class="hp-fill enemy" id="enemyHP" style="width: 100%"></div></div>
                    <div id="enemyHPText">HP: 80/80</div>
                </div>
            </div>

            <div id="battleLog">
                <div id="battleLogContent">
                    <!-- Battle events will be logged here -->
                </div>
            </div>

            <div id="battleResult" style="display: none;">
                <div id="resultTitle">VICTORY!</div>
                <div id="resultRewards">
                    <div>ðŸ’° Credits: +500</div>
                    <div>â­ XP: +100</div>
                </div>
                <button id="returnToBuilderBtn" onclick="returnToBuilder()">Return to Loadout</button>
            </div>

        </div>

        <!-- Drag Ghost (hidden until dragging) -->
        <div id="dragGhost" style="display: none;"></div>

        <!-- Battle UI Overlay (hidden initially) -->
        <div id="battleUI" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; flex-direction: column;">
            <!-- Battle Status Bar -->
            <div style="pointer-events: auto; display: flex; justify-content: space-between; padding: 15px 30px; background: linear-gradient(180deg, rgba(0,20,10,0.95) 0%, rgba(0,20,10,0.7) 100%); border-bottom: 2px solid #00ff88;">
                <!-- Player HP -->
                <div style="flex: 1; max-width: 300px;">
                    <div style="font-size: 14px; color: #00ff88; margin-bottom: 5px;" id="playerName">PLAYER</div>
                    <div style="height: 20px; background: #333; border: 1px solid #00ff88; border-radius: 3px; overflow: hidden;">
                        <div id="playerHP" style="height: 100%; width: 100%; background: linear-gradient(90deg, #00ff88, #44ff88); transition: width 0.3s;"></div>
                    </div>
                </div>
                <!-- VS -->
                <div style="font-size: 24px; color: #ffaa00; padding: 0 30px;">VS</div>
                <!-- Enemy HP -->
                <div style="flex: 1; max-width: 300px;">
                    <div style="font-size: 14px; color: #ff4444; margin-bottom: 5px; text-align: right;" id="enemyName">ENEMY</div>
                    <div style="height: 20px; background: #333; border: 1px solid #ff4444; border-radius: 3px; overflow: hidden;">
                        <div id="enemyHP" style="height: 100%; width: 100%; background: linear-gradient(90deg, #ff4444, #ff6644); transition: width 0.3s;"></div>
                    </div>
                </div>
            </div>

            <!-- Battle Result Overlay -->
            <div id="battleResultOverlay" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); justify-content: center; align-items: center; flex-direction: column; pointer-events: auto;">
                <div id="battleResult" style="font-size: 64px; font-weight: bold; text-shadow: 0 0 30px currentColor;">VICTORY!</div>
                <button onclick="returnToLoadout()" style="margin-top: 30px; padding: 15px 40px; font-size: 18px; background: rgba(0, 255, 136, 0.2); border: 2px solid #00ff88; color: #00ff88; cursor: pointer; border-radius: 5px;">Return to Loadout</button>
            </div>
        </div>

        <!-- Battle iframe (loads the original physics simulation) -->
        <iframe id="battleFrame" src="" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; z-index: 1000;"></iframe>
    </div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>

    <script>
        // ============================================
        // GAME STATE & PHASE MANAGEMENT
        // ============================================
        const GamePhase = {
            MECHBUILDER: 'mechbuilder',
            BATTLE: 'battle'
        };

        let currentPhase = GamePhase.MECHBUILDER;
        let engine, scene, camera, havokInstance, havokPlugin;
        let builderCamera, battleCamera;
        let gameTime = 0;

        // ============================================
        // MECHBUILDER DATA STRUCTURES
        // ============================================

        // Mech Chassis Definition - Unified grid shape
        const MECH_CHASSIS = {
            id: 'starter_chassis',
            name: 'Timber Wolf Chassis',
            maxWeight: 4,
            baseEnergy: 2,
            // Unified mech-shaped grid (7 cols x 7 rows) - slimmed down ~30%
            // 1 = valid cell, 0 = empty/invalid
            gridCols: 7,
            gridRows: 7,
            gridShape: [
                // Row 0: Head (slim)
                [0, 0, 0, 1, 0, 0, 0],
                // Row 1: Shoulders (narrow)
                [0, 0, 1, 1, 1, 0, 0],
                // Row 2: Arms + Torso (reduced)
                [0, 1, 1, 1, 1, 1, 0],
                // Row 3: Arms + Torso (reduced)
                [0, 1, 1, 1, 1, 1, 0],
                // Row 4: Waist (slim)
                [0, 0, 0, 1, 0, 0, 0],
                // Row 5: Upper Legs (split)
                [0, 0, 1, 0, 1, 0, 0],
                // Row 6: Lower Legs (split)
                [0, 0, 1, 0, 1, 0, 0]
            ],
            // For backwards compat - map old slot names to grid regions (not used with unified grid)
            slots: {}
        };

        // Item Database - populated at runtime by generated items
        // All items (starter and generated) use ITEM_TEMPLATES
        const ITEM_DATABASE = {};

        // Starter item configuration - generates level 0 items (weaker than shop items)
        const STARTER_ITEMS = [
            { template: 'railgun', name: 'Training Railgun', id: 'start_railgun' },
            { template: 'laser', name: 'Training Laser', id: 'start_laser' },
            { template: 'missile', name: 'Training Missiles', id: 'start_missile' },
            { template: 'power_cell', name: 'Basic Reactor', id: 'start_reactor' },
            { template: 'ballistic_plating', name: 'Basic Plating', id: 'start_armor' },
            { template: 'targeting_link', name: 'Basic Targeting', id: 'start_targeting' }
        ];

        // ============================================
        // COMPONENT GENERATION SYSTEM (v2)
        // ============================================
        //
        // BUDGET FORMULA:
        //   Budget Earned = Cells + Weight
        //   Budget Spent = Damage + EnergyÃ—2 + other stats
        //   Level 1 prototype should have Budget â‰ˆ 0
        //
        // LEVEL SCALING:
        //   Each level adds +1 budget, allocated proportionally to prototype stats
        //   Weight/Energy can only decrease by 1 total from prototype
        //   Knockback does NOT scale with level
        //
        // RARITY SCALING:
        //   Levels 1-5:  +1 budget per rarity tier
        //   Levels 6-10: +2 budget per rarity tier
        //   Levels 11+:  +3 budget per rarity tier
        //   Tiers: Common(0), Uncommon(1), Rare(2), Epic(3), Legendary(4)
        //
        // MODIFIERS:
        //   Only uncommon+ items can have modifiers
        //   Higher level = higher chance of modifier
        //   Modifier budget: 1-3 based on rarity
        // ============================================

        const COMPONENT_GENERATION = {
            // Feature flags
            useRandomShapes: true,  // Generate random shapes instead of template shapes (same cell count)

            // Master budget exchange rates
            // Positive = earns budget, Negative = costs budget
            budgetRates: {
                // Budget sources (positive)
                cell: 1,              // Each cell adds 1 budget
                weight: 1,            // Each weight adds 1 budget (compensation)

                // Budget costs (negative) - what you spend budget on
                damage: 1,            // 1 budget = 1 damage
                energyCost: 2,        // 1 budget = 0.5 energy (energy costs 2 budget each)
                damageReduction: 1,   // 1 budget = 1 DR
                hp: 0.4,              // 1 budget = 2.5 HP
                energyProvided: 1,    // 1 budget = 1 energy provided
                knockback: 0.2,       // 1 budget = 5 knockback (doesn't scale!)

                // Expensive effects (multi-budget costs)
                targetingDamage1Dir: 1,    // 1 budget = +1 dmg one direction
                targetingDamageAllDir: 3,  // 3 budget = +1 dmg all adjacent
                accuracyBonus: 0.25,       // 1 budget = 4% accuracy

                // Cooling/utility
                energyReduction: 3,        // 3 budget = 1 energy reduction to adjacent
                heatCapacity: 0.125        // 1 budget = 8 heat capacity
            },

            // Stats that can be improved with level budget (and their relative weights from prototype)
            scalableStats: ['damage', 'damageReduction', 'hp', 'energyProvided', 'targetingDamage1Dir', 'targetingDamageAllDir'],

            // Stats that can be reduced (max 1 reduction each from prototype)
            reducibleStats: ['weight', 'energyCost'],

            // Stats that do NOT scale with level
            fixedStats: ['knockback', 'shotsPerRound'],

            // Rarity budget bonus per tier (multiplied by tier number 0-4)
            rarityBudgetPerTier: {
                low: 1,      // Levels 1-5
                mid: 2,      // Levels 6-10
                high: 3      // Levels 11+
            },

            // Rarity tier numbers
            rarityTiers: {
                common: 0,
                uncommon: 1,
                rare: 2,
                epic: 3,
                legendary: 4
            },

            // Rarity colors for display
            rarityColors: {
                common: '#aaaaaa',
                uncommon: '#00ff88',
                rare: '#4488ff',
                epic: '#aa44ff',
                legendary: '#ffaa00'
            },

            // ============================================
            // MODIFIER SYSTEM
            // ============================================
            // Modifiers only appear on uncommon+ items
            // Higher level = higher chance of getting a modifier
            // Modifier power scales with budget cost (1-3)

            // Chance of getting a modifier by level (uncommon+ only)
            modifierChanceByLevel: {
                1: 0.1,   // 10% at level 1
                3: 0.2,   // 20% at level 3
                5: 0.3,   // 30% at level 5
                7: 0.5,   // 50% at level 7
                10: 0.7,  // 70% at level 10
                15: 0.9   // 90% at level 15
            },

            // Max modifier budget by rarity
            maxModifierBudget: {
                uncommon: 1,
                rare: 2,
                epic: 3,
                legendary: 3
            },

            // Available modifiers by budget cost
            modifiers: {
                // 1-budget modifiers (minor effects)
                1: [
                    {
                        id: 'first_strike',
                        name: 'First Strike',
                        description: 'First shot deals 2Ã— damage',
                        appliesTo: ['WEAPON'],
                        effect: { firstShotMultiplier: 2 }
                    },
                    {
                        id: 'lightweight',
                        name: 'Lightweight',
                        description: '-1 weight',
                        appliesTo: ['WEAPON', 'ARMOR', 'SYSTEM'],
                        effect: { weightBonus: -1 }
                    },
                    {
                        id: 'efficient',
                        name: 'Efficient',
                        description: '-1 energy cost',
                        appliesTo: ['WEAPON', 'SYSTEM'],
                        effect: { energyBonus: -1 }
                    },
                    {
                        id: 'hardened',
                        name: 'Hardened',
                        description: '+1 DR',
                        appliesTo: ['ARMOR'],
                        effect: { drBonus: 1 }
                    },
                    // === POSITIONAL MODIFIERS (Cost 1) ===
                    {
                        id: 'top_mounted',
                        name: 'Top Mounted',
                        description: '+2 damage when in top row (head area)',
                        appliesTo: ['WEAPON'],
                        effect: { topRowDamageBonus: 2 }
                    },
                    {
                        id: 'grounded',
                        name: 'Grounded',
                        description: '+3 HP when in bottom row (leg area)',
                        appliesTo: ['ARMOR'],
                        effect: { bottomRowHPBonus: 3 }
                    },
                    {
                        id: 'flanker',
                        name: 'Flanker',
                        description: '+1 damage when on left or right edge',
                        appliesTo: ['WEAPON'],
                        effect: { edgeDamageBonus: 1 }
                    },
                    {
                        id: 'compact',
                        name: 'Compact',
                        description: '+1 energy when in center (not on edge)',
                        appliesTo: ['REACTOR'],
                        effect: { centralEnergyBonus: 1 }
                    }
                ],

                // 2-budget modifiers (moderate effects)
                2: [
                    {
                        id: 'devastating',
                        name: 'Devastating',
                        description: 'First shot deals 2.5Ã— damage',
                        appliesTo: ['WEAPON'],
                        effect: { firstShotMultiplier: 2.5 }
                    },
                    {
                        id: 'reactor_synergy',
                        name: 'Reactor Synergy',
                        description: '+0.5 damage per adjacent reactor',
                        appliesTo: ['WEAPON'],
                        tags: ['energy'],
                        effect: { damagePerReactor: 0.5 }
                    },
                    {
                        id: 'weapon_link',
                        name: 'Weapon Link',
                        description: '+1 damage per adjacent weapon',
                        appliesTo: ['WEAPON'],
                        effect: { damagePerWeapon: 1 }
                    },
                    {
                        id: 'fortified',
                        name: 'Fortified',
                        description: '+5 HP',
                        appliesTo: ['ARMOR'],
                        effect: { hpBonus: 5 }
                    },
                    {
                        id: 'overcharged',
                        name: 'Overcharged',
                        description: '+1 energy provided',
                        appliesTo: ['REACTOR'],
                        effect: { energyProvidedBonus: 1 }
                    },
                    // === POSITIONAL MODIFIERS (Cost 2) ===
                    {
                        id: 'weapon_array',
                        name: 'Weapon Array',
                        description: '+0.5 damage per adjacent weapon',
                        appliesTo: ['WEAPON'],
                        effect: { damagePerAdjacentWeapon: 0.5 }
                    },
                    {
                        id: 'armor_mesh',
                        name: 'Armor Mesh',
                        description: '+2 HP per adjacent armor piece',
                        appliesTo: ['ARMOR'],
                        effect: { hpPerAdjacentArmor: 2 }
                    },
                    {
                        id: 'power_grid',
                        name: 'Power Grid',
                        description: '+0.5 energy per adjacent reactor',
                        appliesTo: ['REACTOR'],
                        effect: { energyPerAdjacentReactor: 0.5 }
                    },
                    {
                        id: 'lone_wolf',
                        name: 'Lone Wolf',
                        description: '+3 damage when not adjacent to any other items',
                        appliesTo: ['WEAPON'],
                        effect: { isolationDamageBonus: 3 }
                    },
                    {
                        id: 'hermit_plating',
                        name: 'Hermit Plating',
                        description: '+5 HP when not adjacent to any other items',
                        appliesTo: ['ARMOR'],
                        effect: { isolationHPBonus: 5 }
                    },
                    {
                        id: 'corner_pocket',
                        name: 'Corner Pocket',
                        description: '+2 damage when in a corner position',
                        appliesTo: ['WEAPON'],
                        effect: { cornerDamageBonus: 2 }
                    },
                    {
                        id: 'symmetry_bonus',
                        name: 'Mirror Match',
                        description: '+2 HP if same item type on opposite side',
                        appliesTo: ['ARMOR'],
                        effect: { symmetryHPBonus: 2 }
                    }
                ],

                // 3-budget modifiers (powerful effects)
                3: [
                    {
                        id: 'alpha_strike',
                        name: 'Alpha Strike',
                        description: 'First shot deals 3Ã— damage',
                        appliesTo: ['WEAPON'],
                        effect: { firstShotMultiplier: 3 }
                    },
                    {
                        id: 'reactor_amplifier',
                        name: 'Reactor Amplifier',
                        description: '+1 damage per adjacent reactor',
                        appliesTo: ['WEAPON'],
                        tags: ['energy'],
                        effect: { damagePerReactor: 1 }
                    },
                    {
                        id: 'adaptive_plating',
                        name: 'Adaptive Plating',
                        description: '+2 DR, -1 weight',
                        appliesTo: ['ARMOR'],
                        effect: { drBonus: 2, weightBonus: -1 }
                    },
                    {
                        id: 'power_surge',
                        name: 'Power Surge',
                        description: '+2 energy provided',
                        appliesTo: ['REACTOR'],
                        effect: { energyProvidedBonus: 2 }
                    },
                    {
                        id: 'targeting_matrix',
                        name: 'Targeting Matrix',
                        description: '+1 damage to all adjacent weapons',
                        appliesTo: ['SYSTEM'],
                        effect: { adjacentDamageBonus: 1 }
                    },
                    // === POSITIONAL MODIFIERS (Cost 3) ===
                    {
                        id: 'weapon_chain',
                        name: 'Weapon Chain',
                        description: '+1 damage per weapon in longest connected chain',
                        appliesTo: ['WEAPON'],
                        effect: { damagePerChainWeapon: 1 }
                    },
                    {
                        id: 'armor_chain',
                        name: 'Armor Chain',
                        description: '+2 HP per armor in longest connected chain',
                        appliesTo: ['ARMOR'],
                        effect: { hpPerChainArmor: 2 }
                    },
                    {
                        id: 'row_complete',
                        name: 'Row Dominator',
                        description: '+3 damage if any row is completely filled',
                        appliesTo: ['WEAPON'],
                        effect: { rowCompleteDamageBonus: 3 }
                    },
                    {
                        id: 'column_complete',
                        name: 'Column Master',
                        description: '+5 HP if any column is completely filled',
                        appliesTo: ['ARMOR'],
                        effect: { columnCompleteHPBonus: 5 }
                    }
                ]
            },

            // === POSITIONAL MODIFIER CONFIGURATION ===
            // These modifiers give bonuses based on item placement
            positionalModifiers: {
                // Position checks use the mech grid coordinate system
                // Grid is typically 7 cols x 7 rows (MECH_CHASSIS.gridCols/gridRows)

                // Budget 1: Simple position checks
                topRowBonus: {
                    description: 'Bonus when item occupies top row (row 0)',
                    checkFn: 'isInTopRow'
                },
                bottomRowBonus: {
                    description: 'Bonus when item occupies bottom row',
                    checkFn: 'isInBottomRow'
                },
                edgeBonus: {
                    description: 'Bonus when item is on left or right edge',
                    checkFn: 'isOnEdge'
                },

                // Budget 2: Adjacency counts
                adjacentWeaponCount: {
                    description: 'Bonus per adjacent weapon',
                    checkFn: 'countAdjacentWeapons'
                },
                adjacentArmorCount: {
                    description: 'Bonus per adjacent armor',
                    checkFn: 'countAdjacentArmor'
                },
                adjacentReactorCount: {
                    description: 'Bonus per adjacent reactor',
                    checkFn: 'countAdjacentReactors'
                },
                isolationBonus: {
                    description: 'Bonus when not adjacent to any other items',
                    checkFn: 'isIsolated'
                },
                centralBonus: {
                    description: 'Bonus when not touching any edge',
                    checkFn: 'isCentral'
                },

                // Budget 3: Complex chain/completion checks
                chainLength: {
                    description: 'Bonus per item in longest connected chain of same type',
                    checkFn: 'getLongestChainOfType'
                },
                rowComplete: {
                    description: 'Bonus if any row is completely filled',
                    checkFn: 'hasCompleteRow'
                },
                columnComplete: {
                    description: 'Bonus if any column is completely filled',
                    checkFn: 'hasCompleteColumn'
                }
            }
        };

        // Base item templates - define the "class" of item with typical shape/stats
        // Scaled for smaller economy: weight limit 6, energy ~6, small grid
        // Item sizes average 4-5 squares to make inventory management challenging
        const ITEM_TEMPLATES = {
            // WEAPONS - base stats ~25% better than starters (damage 4-5), shapes 4+ squares
            railgun: {
                type: 'WEAPON',
                category: 'weapon',
                icon: 'ðŸ”«',
                namePrefix: ['Light', 'Standard', 'Heavy', 'Precision', 'Rapid'],
                nameSuffix: ['Railgun', 'Cannon', 'Driver', 'Accelerator'],
                baseShape: [[1], [1], [1], [1]],  // 1x4 vertical (4 squares)
                validSlots: ['leftArm', 'rightArm'],
                baseStats: {
                    weight: 2,  // Light but long - high knockback specialist
                    energyDraw: 1,
                    damage: 5  // Balanced: cost 4 (2+1Ã—2), +1 from shape bonus, high KB (25) is key advantage
                },
                baseBattle: {
                    projectileSpeed: 55,
                    projectileSize: 0.15,
                    knockback: 25,
                    recoil: 0.12,
                    shotsPerRound: 1,
                    color: [1, 0.9, 0.3],
                    isProjectile: true
                },
                statWeights: { damage: 0.6, knockback: 0.2, projectileSpeed: 0.2 },
                synergies: ['kinetic', 'precision', 'alpha-strike'],
                synergyDescription: 'High single-shot damage. Best with crit/alpha strike builds.'
            },
            laser: {
                type: 'WEAPON',
                category: 'weapon',
                icon: 'âš¡',
                namePrefix: ['ER', 'Pulse', 'Focused', 'Burst', 'Heavy'],
                nameSuffix: ['Laser', 'Beam', 'Array', 'Emitter'],
                baseShape: [[1, 1]],  // 2x1 (2 squares) - very compact energy weapon
                validSlots: ['torso', 'leftArm', 'rightArm'],
                baseStats: {
                    weight: 1,
                    energyDraw: 2,
                    damage: 4  // Balanced: cost 5 (1+2Ã—2), compact size is the advantage
                },
                baseBattle: {
                    isBeam: true,
                    beamDuration: 200,
                    knockback: 5,  // Low knockback - precision weapon, not impact
                    recoil: 0.15,
                    shotsPerRound: 1,
                    color: [0.2, 1, 0.3]
                },
                statWeights: { damage: 0.8, knockback: 0.2 },
                synergies: ['energy', 'precision'],
                synergyDescription: 'Energy weapon with instant hit. Pairs well with energy synergies.'
            },
            missile: {
                type: 'WEAPON',
                category: 'weapon',
                icon: 'ðŸš€',
                namePrefix: ['Light', 'Cluster', 'Heavy', 'Guided', 'Swarm'],
                nameSuffix: ['Missile', 'Rocket', 'Launcher', 'Pod'],
                baseShape: [[1, 1], [1, 1]],  // 2x2 (4 squares) - 1 shot per 2 cells
                validSlots: ['torso', 'leftArm', 'rightArm'],
                baseStats: {
                    weight: 1,
                    energyDraw: 0,
                    damage: 1  // Low per-shot, but multi-hit synergy weapon
                },
                baseBattle: {
                    projectileSpeed: 30,
                    projectileSize: 0.2,
                    knockback: 10,  // Moderate KB - railgun is the knockback king
                    recoil: 0.2,
                    shotsPerRound: 2,  // 1 shot per 2 cells = 2 shots
                    color: [1, 0.4, 0.2],
                    isProjectile: true
                },
                statWeights: { damage: 0.6, knockback: 0.4 },
                synergies: ['explosive', 'multi-hit', 'synergy-payoff'],
                synergyDescription: 'SYNERGY: 1Ã—2=2 base. +2 flat damage = 3Ã—2=6 (3x multiplier!)'
            },
            machinegun: {
                type: 'WEAPON',
                category: 'weapon',
                icon: 'ðŸ”¥',
                namePrefix: ['Rapid', 'Twin', 'Auto', 'Light'],
                nameSuffix: ['Cannon', 'Gun', 'Repeater', 'MG'],
                baseShape: [[1, 1, 1]],  // 3x1 (3 squares)
                validSlots: ['leftArm', 'rightArm'],
                baseStats: {
                    weight: 1,
                    energyDraw: 0,
                    damage: 1  // Fixed - no scaling for multi-hit
                },
                baseBattle: {
                    projectileSpeed: 60,
                    projectileSize: 0.08,
                    knockback: 3,
                    recoil: 0.05,
                    shotsPerRound: 2,  // 2 shots Ã— 1 dmg = 2 DPR
                    color: [1, 1, 0.5],
                    isProjectile: true
                },
                statWeights: { projectileSpeed: 0.5 },  // No damage scaling!
                synergies: ['kinetic', 'multi-hit', 'sustained']
            },

            // MULTI-HIT WEAPONS - Low damage per shot, many shots = flat damage bonuses multiply!
            // Example: Chain Gun does 1x8=8 damage. With +2 flat damage bonus: 3x8=24 damage (3x multiplier!)
            minigun: {
                type: 'WEAPON',
                category: 'weapon',
                icon: 'â›“ï¸',
                namePrefix: ['Rotary', 'Gatling', 'Spinning', 'Mini'],
                nameSuffix: ['Gun', 'Cannon', 'Minigun', 'Shredder'],
                baseShape: [[1, 1, 1, 1]],  // 4x1 horizontal (4 squares)
                validSlots: ['leftArm', 'rightArm', 'torso'],
                baseStats: {
                    weight: 2,
                    energyDraw: 1,
                    damage: 1  // Fixed - no scaling for multi-hit
                },
                baseBattle: {
                    projectileSpeed: 65,
                    projectileSize: 0.06,
                    knockback: 2,
                    recoil: 0.03,
                    shotsPerRound: 8,  // 8 shots Ã— 1 dmg = 8 DPR
                    color: [1, 0.8, 0.3],
                    isProjectile: true
                },
                statWeights: { projectileSpeed: 0.5 },  // No damage scaling!
                synergies: ['kinetic', 'multi-hit', 'shredder'],
                synergyDescription: 'SYNERGY: +1 flat damage = +8 total! Perfect with Targeting Hub.'
            },
            pulse_laser: {
                type: 'WEAPON',
                category: 'weapon',
                icon: 'ðŸ’«',
                namePrefix: ['Pulse', 'Rapid', 'Burst', 'Strobe'],
                nameSuffix: ['Laser', 'Emitter', 'Array', 'Projector'],
                baseShape: [[1], [1], [1]],  // 1x3 vertical (3 squares)
                validSlots: ['leftArm', 'rightArm', 'torso'],
                baseStats: {
                    weight: 1,
                    energyDraw: 2,
                    damage: 1  // Fixed - no scaling for multi-hit
                },
                baseBattle: {
                    isBeam: true,
                    beamDuration: 80,  // Quick pulses
                    knockback: 3,
                    recoil: 0.02,
                    shotsPerRound: 5,  // 5 shots Ã— 1 dmg = 5 DPR
                    color: [0.5, 1, 0.5]
                },
                statWeights: { knockback: 0.5 },  // No damage scaling!
                synergies: ['energy', 'multi-hit', 'precision'],
                synergyDescription: 'SYNERGY: 1x5=5 base. +2 flat damage = 3x5=15 (3x multiplier!)'
            },
            swarm_missiles: {
                type: 'WEAPON',
                category: 'weapon',
                icon: 'ðŸ',
                namePrefix: ['Swarm', 'Cluster', 'Micro', 'Hive'],
                nameSuffix: ['Missiles', 'Rockets', 'Pods', 'Volley'],
                baseShape: [[1, 1, 1], [1, 1, 1]],  // 2x3 (6 squares) - 1 shot per 2 cells
                validSlots: ['torso', 'leftArm', 'rightArm'],
                baseStats: {
                    weight: 1,
                    energyDraw: 0,
                    damage: 1  // Low per-shot, multi-hit synergy weapon
                },
                baseBattle: {
                    projectileSpeed: 25,
                    projectileSize: 0.12,
                    knockback: 10,
                    recoil: 0.08,
                    shotsPerRound: 3,  // 1 shot per 2 cells = 3 shots
                    color: [1, 0.5, 0.2],
                    isProjectile: true,
                    isMissile: true
                },
                statWeights: { damage: 0.6, knockback: 0.4 },
                synergies: ['explosive', 'multi-hit', 'synergy-payoff'],
                synergyDescription: 'SYNERGY: 1Ã—3=3 base. +2 flat damage = 3Ã—3=9 (3x multiplier!)'
            },

            // ARMOR - Three types: damage reduction, HP boost, and energy shield
            // Ballistic Plating - reduces incoming ballistic/missile damage
            ballistic_plating: {
                type: 'ARMOR',
                category: 'armor',
                icon: 'ðŸ›¡ï¸',
                namePrefix: ['Light', 'Standard', 'Heavy', 'Reinforced', 'Composite'],
                nameSuffix: ['Plating', 'Armor', 'Carapace', 'Shell'],
                baseShape: [[1, 0], [1, 1]],  // L-shape (3 squares)
                validSlots: ['torso', 'leftLeg', 'rightLeg'],
                baseStats: {
                    weight: 2,  // DR is powerful, requires weight investment
                    energyDraw: 0,
                    damageReduction: 2  // -2 damage from each hit (highest only)
                },
                statWeights: { damageReduction: 1.0 }
            },
            // Reactive Armor - better damage reduction, energy-powered
            reactive_plating: {
                type: 'ARMOR',
                category: 'armor',
                icon: 'ðŸ’¥',
                namePrefix: ['Reactive', 'Ablative', 'Hardened', 'Explosive'],
                nameSuffix: ['Plates', 'Panels', 'Coating', 'Layer'],
                baseShape: [[1, 1], [1, 0]],  // L-shape (3 squares)
                validSlots: ['torso'],
                baseStats: {
                    weight: 2,  // DR is powerful, requires weight investment
                    energyDraw: 1,
                    damageReduction: 3  // -3 damage from each hit (highest only)
                },
                statWeights: { damageReduction: 1.0 }
            },
            // HULL ARMOR - HP bonus scales with size: cells Ã— 3 + (cells-1) Ã— 1
            // 1 cell = 3 HP, 2 cells = 7 HP, 3 cells = 11 HP, 4 cells = 15 HP, etc.

            // Small Armor - 1 cell, 3 HP
            armor_small: {
                type: 'ARMOR',
                category: 'armor',
                icon: 'ðŸ”˜',
                namePrefix: ['Tiny', 'Small', 'Mini', 'Compact'],
                nameSuffix: ['Plate', 'Guard', 'Patch', 'Cover'],
                baseShape: [[1]],  // 1 cell
                validSlots: ['torso', 'leftArm', 'rightArm', 'leftLeg', 'rightLeg', 'head'],
                baseStats: {
                    weight: 0,
                    energyDraw: 0,
                    hpBonus: 3  // 1Ã—3 + 0Ã—1 = 3 HP
                },
                statWeights: { hpBonus: 1.0 }
            },
            // Light Armor - 2 cells, 7 HP
            armor_light: {
                type: 'ARMOR',
                category: 'armor',
                icon: 'ðŸ›¡ï¸',
                namePrefix: ['Light', 'Thin', 'Basic', 'Simple'],
                nameSuffix: ['Armor', 'Plating', 'Shell', 'Guard'],
                baseShape: [[1, 1]],  // 2 cells
                validSlots: ['torso', 'leftArm', 'rightArm', 'leftLeg', 'rightLeg'],
                baseStats: {
                    weight: 0,
                    energyDraw: 0,
                    hpBonus: 7  // 2Ã—3 + 1Ã—1 = 7 HP
                },
                statWeights: { hpBonus: 1.0 }
            },
            // Medium Armor - 3 cells, 11 HP
            armor_medium: {
                type: 'ARMOR',
                category: 'armor',
                icon: 'â¤ï¸',
                namePrefix: ['Standard', 'Medium', 'Regular', 'Solid'],
                nameSuffix: ['Hull', 'Frame', 'Armor', 'Plating'],
                baseShape: [[1, 1, 1]],  // 3 cells
                validSlots: ['torso', 'leftLeg', 'rightLeg'],
                baseStats: {
                    weight: 1,
                    energyDraw: 0,
                    hpBonus: 11  // 3Ã—3 + 2Ã—1 = 11 HP
                },
                statWeights: { hpBonus: 1.0 }
            },
            // Heavy Armor - 4 cells, 15 HP
            armor_heavy: {
                type: 'ARMOR',
                category: 'armor',
                icon: 'ðŸ’ª',
                namePrefix: ['Heavy', 'Thick', 'Dense', 'Reinforced'],
                nameSuffix: ['Hull', 'Bulkhead', 'Plating', 'Chassis'],
                baseShape: [[1, 1], [1, 1]],  // 4 cells
                validSlots: ['torso', 'leftLeg', 'rightLeg'],
                baseStats: {
                    weight: 1,
                    energyDraw: 0,
                    hpBonus: 15  // 4Ã—3 + 3Ã—1 = 15 HP
                },
                statWeights: { hpBonus: 1.0 }
            },
            // Reinforced Armor - 5 cells, 19 HP
            armor_reinforced: {
                type: 'ARMOR',
                category: 'armor',
                icon: 'ðŸ‹ï¸',
                namePrefix: ['Reinforced', 'Fortified', 'Hardened', 'Layered'],
                nameSuffix: ['Plating', 'Armor', 'Shell', 'Carapace'],
                baseShape: [[1, 1, 1], [1, 1, 0]],  // 5 cells (L-shape)
                validSlots: ['torso'],
                baseStats: {
                    weight: 2,
                    energyDraw: 0,
                    hpBonus: 19  // 5Ã—3 + 4Ã—1 = 19 HP
                },
                statWeights: { hpBonus: 1.0 }
            },
            // Titan Armor - 6 cells, 23 HP
            armor_titan: {
                type: 'ARMOR',
                category: 'armor',
                icon: 'ðŸ¦¾',
                namePrefix: ['Titan', 'Massive', 'Juggernaut', 'Colossal'],
                nameSuffix: ['Hull', 'Frame', 'Bulwark', 'Fortress'],
                baseShape: [[1, 1, 1], [1, 1, 1]],  // 6 cells (2x3)
                validSlots: ['torso'],
                baseStats: {
                    weight: 2,
                    energyDraw: 0,
                    hpBonus: 23  // 6Ã—3 + 5Ã—1 = 23 HP
                },
                statWeights: { hpBonus: 1.0 }
            },
            // Energy Shield - absorbs energy weapon damage only
            energy_shield: {
                type: 'ARMOR',
                category: 'armor',
                icon: 'ðŸ”µ',
                namePrefix: ['Light', 'Standard', 'Heavy', 'Hardened'],
                nameSuffix: ['Shield', 'Barrier', 'Screen', 'Ward'],
                baseShape: [[1], [1], [1], [1]],  // 1x4 vertical (4 squares)
                validSlots: ['torso', 'leftArm', 'rightArm'],
                baseStats: {
                    weight: 1,
                    energyDraw: 1,  // Shields need energy to run
                    energyShieldHP: 10  // Absorbs 10 HP of energy damage at level 1
                },
                statWeights: { energyShieldHP: 1.0 }
            },

            // REACTORS - provide energy, 3+ squares
            reactor: {
                type: 'REACTOR',
                category: 'reactor',
                icon: 'âš›ï¸',
                namePrefix: ['Compact', 'Standard', 'High-Output', 'Fusion', 'Plasma'],
                nameSuffix: ['Reactor', 'Core', 'Generator', 'Cell'],
                baseShape: [[1], [1], [1], [1]],  // 1x4 vertical (4 squares)
                validSlots: ['torso'],
                baseStats: {
                    weight: 2,
                    energyDraw: -3,  // Provides 3 energy
                    heatCapacity: 15
                },
                statWeights: { energyProvided: 0.8, heatCapacity: 0.2 }
            },
            power_cell: {
                type: 'REACTOR',
                category: 'reactor',
                icon: 'ðŸ”‹',
                namePrefix: ['Emergency', 'Backup', 'Auxiliary', 'Compact'],
                nameSuffix: ['Cell', 'Battery', 'Pack', 'Unit'],
                baseShape: [[1, 1, 1]],  // 3x1 (3 squares)
                validSlots: ['torso', 'leftLeg', 'rightLeg'],
                baseStats: {
                    weight: 1,
                    energyDraw: -2,
                    heatCapacity: 10
                },
                statWeights: { energyProvided: 0.9, weight: 0.1 }
            },

            // TARGETING SYSTEMS - add damage to adjacent weapons
            // KEY SYNERGY: These provide FLAT damage bonuses that MULTIPLY with multi-hit weapons!
            targeting_link: {
                type: 'SYSTEM',
                category: 'system',
                icon: 'ðŸŽ¯',
                namePrefix: ['Basic', 'Light', 'Compact', 'Simple'],
                nameSuffix: ['Link', 'Connector', 'Coupler', 'Interface'],
                baseShape: [[1], [1]],  // 1x2 vertical
                validSlots: ['torso', 'leftArm', 'rightArm'],
                baseStats: {
                    weight: 0,
                    energyDraw: 0,
                    directionalDamageBonus: 1  // +1 damage in one direction only
                },
                special: {
                    adjacentEffect: 'directionalDamage',
                    effectDirection: 'up',  // Default, can be rotated
                    effectValue: 1
                },
                statWeights: {},  // No scaling, fixed effect
                synergies: ['precision', 'multi-hit-synergy'],
                synergyDescription: 'MULTIPLIER! +1 dmg to adjacent weapon. Chain Gun: 1x8â†’2x8=+8 damage!'
            },
            targeting_hub: {
                type: 'SYSTEM',
                category: 'system',
                icon: 'ðŸŽ¯',
                namePrefix: ['Advanced', 'Precision', 'Neural', 'Quantum'],
                nameSuffix: ['Hub', 'Nexus', 'Core', 'Matrix'],
                baseShape: [[0, 1, 0], [1, 1, 1], [0, 1, 0]],  // Plus shape (5 squares)
                validSlots: ['torso', 'leftArm', 'rightArm'],
                baseStats: {
                    weight: 1,
                    energyDraw: 1,
                    adjacentDamageBonus: 2  // +2 damage to ALL adjacent weapons (buffed!)
                },
                special: {
                    adjacentEffect: 'weaponDamage',
                    effectValue: 2
                },
                statWeights: {},  // No scaling, fixed effect
                synergies: ['precision', 'multi-hit-synergy', 'amplifier'],
                synergyDescription: 'MULTIPLIER! +2 dmg to ALL adjacent weapons. Chain Gun: 1x8â†’3x8=+16 dmg!'
            },
            gyro: {
                type: 'SYSTEM',
                category: 'system',
                icon: 'ðŸ”„',
                namePrefix: ['Light', 'Standard', 'Heavy', 'Stabilized'],
                nameSuffix: ['Gyro', 'Stabilizer', 'Balance Unit'],
                baseShape: [[1], [1], [1], [1]],  // 1x4 vertical (4 squares)
                validSlots: ['torso', 'leftLeg', 'rightLeg'],
                baseStats: {
                    weight: 1,
                    energyDraw: 1,
                    accuracyBonus: 8
                },
                statWeights: { accuracy: 0.7, weight: 0.3 }
            },

            // COOLING - heat sinks reduce energy cost of adjacent weapons
            heat_sink: {
                type: 'COOLING',
                category: 'cooling',
                icon: 'â„ï¸',
                namePrefix: ['Double', 'Enhanced', 'Cryo', 'Advanced'],
                nameSuffix: ['Heat Sink', 'Cooler', 'Radiator', 'Vent'],
                baseShape: [[1, 1, 1, 1]],  // 4x1 horizontal (4 squares)
                validSlots: ['torso', 'leftArm', 'rightArm', 'leftLeg', 'rightLeg'],
                baseStats: {
                    weight: 1,
                    energyDraw: 0,
                    energyReduction: 1
                },
                special: {
                    adjacentEffect: 'reduceEnergy',
                    locksOnPlace: true
                },
                statWeights: { energyReduction: 1.0 }
            },
            cooling_system: {
                type: 'COOLING',
                category: 'cooling',
                icon: 'ðŸŒ¡ï¸',
                namePrefix: ['Advanced', 'Integrated', 'Active', 'Elite'],
                nameSuffix: ['Cooling', 'System', 'Module', 'Array'],
                baseShape: [[1, 1, 1], [1, 1, 1]],  // 3x2 (6 squares - larger = more efficient)
                validSlots: ['torso', 'leftArm', 'rightArm'],
                baseStats: {
                    weight: 2,
                    energyDraw: 0,
                    energyReduction: 2
                },
                special: {
                    adjacentEffect: 'reduceEnergy'
                },
                statWeights: { energyReduction: 0.8, weight: 0.2 }
            },

            // SYNERGY EQUIPMENT - affects adjacent items
            // Weapon Amplifier - STACKS with targeting systems for massive multipliers!
            weapon_amplifier: {
                type: 'SYSTEM',
                category: 'system',
                icon: 'âš¡',
                namePrefix: ['Tactical', 'Combat', 'Strike', 'War'],
                nameSuffix: ['Amplifier', 'Booster', 'Enhancer', 'Module'],
                baseShape: [[1], [1], [1]],  // 1x3 vertical (3 squares)
                validSlots: ['torso', 'leftArm', 'rightArm'],
                baseStats: {
                    weight: 1,
                    energyDraw: 1,
                    adjacentDamageBonus: 1  // +1 damage to adjacent weapons
                },
                special: {
                    adjacentEffect: 'weaponDamage',
                    effectValue: 1
                },
                statWeights: { weight: 0.5 },
                synergies: ['amplifier', 'multi-hit-synergy'],
                synergyDescription: 'STACKS! +1 dmg to adjacent weapons. Stack with Targeting Hub for +3!'
            },
            armor_linkage: {
                type: 'SYSTEM',
                category: 'system',
                icon: 'ðŸ›¡ï¸',
                namePrefix: ['Reactive', 'Adaptive', 'Linked', 'Network'],
                nameSuffix: ['Linkage', 'Matrix', 'Network', 'Grid'],
                baseShape: [[1, 1, 1, 1]],  // 4x1 horizontal (4 squares)
                validSlots: ['torso'],
                baseStats: {
                    weight: 1,
                    energyDraw: 1,
                    adjacentArmorBonus: 1  // +1 armor to adjacent armor pieces
                },
                special: {
                    adjacentEffect: 'armorBonus',
                    effectValue: 1
                },
                statWeights: { weight: 0.5 }
            },
            capacitor: {
                type: 'REACTOR',
                category: 'reactor',
                icon: 'âš¡',
                namePrefix: ['Flux', 'Charged', 'Power', 'Energy'],
                nameSuffix: ['Capacitor', 'Bank', 'Store', 'Reserve'],
                baseShape: [[1, 1], [1, 1]],  // 2x2 square (4 squares)
                validSlots: ['torso', 'leftArm', 'rightArm'],
                baseStats: {
                    weight: 1,
                    energyDraw: -2,  // Provides 2 energy
                    adjacentEnergyBonus: 1  // +1 energy to adjacent reactors
                },
                special: {
                    adjacentEffect: 'reactorBonus',
                    effectValue: 1
                },
                statWeights: { energyProvided: 0.8, weight: 0.2 }
            }
        };

        // Variant modifications that can be applied to generated items
        const ITEM_VARIANTS = {
            // Shape variants
            extended: {
                name: 'Extended',
                shapeModifier: (shape) => {
                    // Add one row
                    const newShape = [...shape.map(row => [...row])];
                    newShape.push(new Array(shape[0].length).fill(1));
                    return newShape;
                },
                budgetCost: -1  // Costs 1 budget square (larger = more space used)
            },
            compact: {
                name: 'Compact',
                shapeModifier: (shape) => {
                    // Remove one row if possible
                    if (shape.length > 1) {
                        return shape.slice(0, -1).map(row => [...row]);
                    }
                    return shape.map(row => [...row]);
                },
                budgetCost: 1  // Gives 1 budget square (smaller = bonus)
            },
            widened: {
                name: 'Wide',
                shapeModifier: (shape) => {
                    // Add one column
                    return shape.map(row => [...row, 1]);
                },
                budgetCost: -1
            },

            // Stat variants
            overcharged: {
                name: 'Overcharged',
                statModifier: (stats) => ({
                    ...stats,
                    damage: Math.round((stats.damage || 0) * 1.25),
                    energyDraw: Math.round((stats.energyDraw || 0) * 1.4)
                }),
                budgetCost: 0  // Trade-off, no net budget change
            },
            lightweight: {
                name: 'Lightweight',
                statModifier: (stats) => ({
                    ...stats,
                    weight: Math.round((stats.weight || 0) * 0.7),
                    armorBonus: Math.round((stats.armorBonus || 0) * 0.85)
                }),
                budgetCost: 0.5
            },
            armored: {
                name: 'Armored',
                statModifier: (stats) => ({
                    ...stats,
                    weight: Math.round((stats.weight || 0) * 1.3),
                    armorBonus: (stats.armorBonus || 0) + 15
                }),
                budgetCost: 0
            },
            efficient: {
                name: 'Efficient',
                statModifier: (stats) => ({
                    ...stats,
                    energyDraw: Math.round((stats.energyDraw || 0) * 0.75)
                }),
                budgetCost: -0.5
            },
            rapid: {
                name: 'Rapid',
                battleModifier: (battle) => ({
                    ...battle,
                    shotsPerRound: (battle.shotsPerRound || 1) + 1  // Fire one extra time per round
                }),
                budgetCost: -1
            },
            heavy: {
                name: 'Heavy',
                statModifier: (stats) => ({
                    ...stats,
                    damage: Math.round((stats.damage || 0) * 1.15),
                    weight: Math.round((stats.weight || 0) * 1.25)
                }),
                budgetCost: 0
            }
        };

        // Track enemy level progression
        let currentEnemyLevel = 1;

        // Generate a unique ID for generated items
        let generatedItemCounter = 0;
        function generateItemId(templateType, rarity, level) {
            generatedItemCounter++;
            return `gen_${templateType}_${rarity}_l${level}_${generatedItemCounter}_${Date.now()}`;
        }

        // Count cells in a shape
        function countShapeCells(shape) {
            let cells = 0;
            for (let row of shape) {
                for (let cell of row) {
                    if (cell === 1) cells++;
                }
            }
            return cells;
        }

        // Generate a random connected shape with the specified number of cells
        // All cells are guaranteed to be adjacent to at least one other cell
        // Algorithm picks a random existing cell to expand from, creating varied shapes
        function generateRandomShape(cellCount) {
            if (cellCount <= 0) return [[1]];
            if (cellCount === 1) return [[1]];

            // Start with a larger grid to allow growth in any direction
            const maxSize = Math.max(5, Math.ceil(Math.sqrt(cellCount) * 2.5));
            const grid = Array(maxSize).fill(null).map(() => Array(maxSize).fill(0));

            // Start in the center
            const centerX = Math.floor(maxSize / 2);
            const centerY = Math.floor(maxSize / 2);
            grid[centerY][centerX] = 1;

            const filled = [{x: centerX, y: centerY}];
            const directions = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];

            // Grow the shape by randomly picking an existing cell and expanding from it
            while (filled.length < cellCount) {
                // Shuffle filled cells to try them in random order
                const shuffled = [...filled].sort(() => Math.random() - 0.5);
                let foundCandidate = false;

                for (const cell of shuffled) {
                    // Find valid expansion points from THIS cell only
                    const candidates = [];
                    for (const dir of directions) {
                        const nx = cell.x + dir.dx;
                        const ny = cell.y + dir.dy;
                        if (nx >= 0 && nx < maxSize && ny >= 0 && ny < maxSize && grid[ny][nx] === 0) {
                            candidates.push({x: nx, y: ny});
                        }
                    }

                    if (candidates.length > 0) {
                        // Pick a random direction from this cell
                        const chosen = candidates[Math.floor(Math.random() * candidates.length)];
                        grid[chosen.y][chosen.x] = 1;
                        filled.push(chosen);
                        foundCandidate = true;
                        break;  // Successfully added a cell, continue to next iteration
                    }
                }

                if (!foundCandidate) break;  // No more room to grow anywhere
            }

            // Trim the grid to remove empty rows/columns
            let minX = maxSize, maxX = 0, minY = maxSize, maxY = 0;
            for (let y = 0; y < maxSize; y++) {
                for (let x = 0; x < maxSize; x++) {
                    if (grid[y][x] === 1) {
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }

            // Extract the trimmed shape
            const trimmed = [];
            for (let y = minY; y <= maxY; y++) {
                const row = [];
                for (let x = minX; x <= maxX; x++) {
                    row.push(grid[y][x]);
                }
                trimmed.push(row);
            }

            return trimmed.length > 0 ? trimmed : [[1]];
        }

        // ============================================
        // BUDGET BALANCE & MINIMUM LEVEL CALCULATION
        // ============================================
        // Calculate the budget balance for a template at prototype (level 1)
        // Positive = underpowered, Negative = overpowered (needs higher level)
        function calculateTemplateBudgetBalance(template) {
            const rates = COMPONENT_GENERATION.budgetRates;
            const stats = template.baseStats;
            const battle = template.baseBattle || {};
            const cells = countShapeCells(template.baseShape);

            // Budget EARNED (cost to player = justifies item power)
            let budgetEarned = 0;
            budgetEarned += cells * rates.cell;
            budgetEarned += (stats.weight || 0) * rates.weight;
            budgetEarned += (stats.energyDraw || 0) * rates.energyCost;

            // Budget SPENT (item's value)
            let budgetSpent = 0;

            // Damage value
            const shots = battle.shotsPerRound || 1;
            const baseDamage = stats.damage || 0;
            budgetSpent += baseDamage * shots * rates.damage;

            // Multi-hit synergy bonus: 50% of (shots - 1)
            // Represents the multiplicative value of flat damage bonuses
            if (shots > 1) {
                const multiHitBonus = 0.5 * (shots - 1);
                budgetSpent += multiHitBonus;
            }

            // Defensive stats
            budgetSpent += (stats.damageReduction || 0) * rates.damageReduction;
            budgetSpent += (stats.hpBonus || 0) * rates.hp;

            // Energy provided (reactors) - negative energyDraw = provides energy
            if (stats.energyDraw < 0) {
                budgetSpent += Math.abs(stats.energyDraw) * rates.energyProvided;
            }

            // Knockback (doesn't scale, but still has value)
            budgetSpent += (battle.knockback || 0) * rates.knockback;

            // Targeting bonuses
            budgetSpent += (stats.directionalDamageBonus || 0) * rates.targetingDamage1Dir;
            budgetSpent += (stats.adjacentDamageBonus || 0) * rates.targetingDamageAllDir;

            // Energy reduction for cooling items
            budgetSpent += (stats.energyReduction || 0) * rates.energyReduction;

            // Heat capacity bonus
            budgetSpent += (stats.heatCapacity || 0) * rates.heatCapacity;

            return {
                budgetEarned,
                budgetSpent,
                netBalance: budgetEarned - budgetSpent,  // Positive = underpowered
                cells,
                shots
            };
        }

        // Calculate the minimum level an item should appear at
        // Based on how "over budget" it is at prototype
        function getTemplateMinLevel(template) {
            const balance = calculateTemplateBudgetBalance(template);

            // If netBalance >= 0, item is balanced or underpowered at level 1
            if (balance.netBalance >= 0) {
                return 1;
            }

            // If netBalance < 0, item is overpowered and needs level budget to compensate
            // Level N gives (N-1) budget, so minLevel = ceil(-netBalance) + 1
            const deficit = -balance.netBalance;
            return Math.ceil(deficit) + 1;
        }

        // Cache of minimum levels for all templates
        let TEMPLATE_MIN_LEVELS = null;

        function getMinLevelCache() {
            if (TEMPLATE_MIN_LEVELS === null) {
                TEMPLATE_MIN_LEVELS = {};
                for (const [key, template] of Object.entries(ITEM_TEMPLATES)) {
                    TEMPLATE_MIN_LEVELS[key] = getTemplateMinLevel(template);
                }
                console.log('Template minimum levels:', TEMPLATE_MIN_LEVELS);
            }
            return TEMPLATE_MIN_LEVELS;
        }

        // Calculate rarity budget bonus based on level and rarity tier
        function calculateRarityBudget(level, rarity) {
            const tier = COMPONENT_GENERATION.rarityTiers[rarity] || 0;
            if (tier === 0) return 0;  // Common gets no bonus

            let budgetPerTier;
            if (level <= 5) {
                budgetPerTier = COMPONENT_GENERATION.rarityBudgetPerTier.low;
            } else if (level <= 10) {
                budgetPerTier = COMPONENT_GENERATION.rarityBudgetPerTier.mid;
            } else {
                budgetPerTier = COMPONENT_GENERATION.rarityBudgetPerTier.high;
            }

            return tier * budgetPerTier;
        }

        // Get modifier chance based on level
        function getModifierChance(level) {
            const chances = COMPONENT_GENERATION.modifierChanceByLevel;
            let chance = 0;
            for (const [lvl, chanceVal] of Object.entries(chances)) {
                if (level >= parseInt(lvl)) {
                    chance = chanceVal;
                }
            }
            return chance;
        }

        // Select a random modifier for an item
        function selectModifier(itemType, maxBudget) {
            const allModifiers = COMPONENT_GENERATION.modifiers;
            const validModifiers = [];

            // Collect all valid modifiers up to maxBudget
            for (let cost = 1; cost <= maxBudget; cost++) {
                const modsAtCost = allModifiers[cost] || [];
                for (const mod of modsAtCost) {
                    if (mod.appliesTo.includes(itemType)) {
                        validModifiers.push({ ...mod, cost });
                    }
                }
            }

            if (validModifiers.length === 0) return null;

            // Weight towards higher cost modifiers slightly
            const weighted = [];
            for (const mod of validModifiers) {
                const weight = mod.cost;  // Higher cost = more weight
                for (let i = 0; i < weight; i++) {
                    weighted.push(mod);
                }
            }

            return weighted[Math.floor(Math.random() * weighted.length)];
        }

        // Generate a random component based on template, level, and rarity
        // NEW BUDGET SYSTEM:
        //   - Level 1 = prototype stats (from template.baseStats)
        //   - Each level adds +1 budget, allocated proportionally to prototype
        //   - Rarity adds fixed budget based on level range
        //   - Weight/energy can only decrease by 1 from prototype
        //   - Knockback and shotsPerRound don't scale
        //   - Modifiers only for uncommon+ items
        function generateComponent(templateType, level = 1, rarity = 'common', options = {}) {
            const template = ITEM_TEMPLATES[templateType];
            if (!template) {
                console.error(`Unknown template type: ${templateType}`);
                return null;
            }

            // Generate shape - either random or from template
            let shape;
            if (COMPONENT_GENERATION.useRandomShapes) {
                // Generate random connected shape with same cell count as template
                const cellCount = countShapeCells(template.baseShape);
                shape = generateRandomShape(cellCount);
            } else {
                // Clone base shape from template
                shape = template.baseShape.map(row => [...row]);
            }

            // Variants disabled in new budget system
            let appliedVariants = [];

            // Clone prototype stats (level 1 base)
            let stats = { ...template.baseStats };
            let battle = template.baseBattle ? { ...template.baseBattle } : null;

            // Calculate cells for budget info
            const cells = countShapeCells(shape);

            // ============================================
            // BUDGET CALCULATION (v2 System)
            // ============================================
            // Level budget: +1 per level above 1
            const levelBudget = Math.max(0, level - 1);

            // Rarity budget: fixed amount based on level range and tier
            const rarityBudget = calculateRarityBudget(level, rarity);

            // Total extra budget to allocate
            const totalBudget = levelBudget + rarityBudget;

            // ============================================
            // PROPORTIONAL STAT ALLOCATION
            // ============================================
            // Calculate prototype "spend" to determine proportions
            const rates = COMPONENT_GENERATION.budgetRates;
            const prototypeSpend = {};
            let totalPrototypeSpend = 0;

            // Calculate how much budget each stat "costs" in the prototype
            if (stats.damage > 0) {
                prototypeSpend.damage = stats.damage * rates.damage;
                totalPrototypeSpend += prototypeSpend.damage;
            }
            if (stats.damageReduction > 0) {
                prototypeSpend.damageReduction = stats.damageReduction * rates.damageReduction;
                totalPrototypeSpend += prototypeSpend.damageReduction;
            }
            if (stats.hpBonus > 0) {
                prototypeSpend.hpBonus = stats.hpBonus * rates.hp;
                totalPrototypeSpend += prototypeSpend.hpBonus;
            }
            if (stats.energyDraw < 0) {  // Negative = provides energy
                prototypeSpend.energyProvided = Math.abs(stats.energyDraw) * rates.energyProvided;
                totalPrototypeSpend += prototypeSpend.energyProvided;
            }
            if (stats.directionalDamageBonus > 0) {
                prototypeSpend.directionalDamageBonus = stats.directionalDamageBonus * rates.targetingDamage1Dir;
                totalPrototypeSpend += prototypeSpend.directionalDamageBonus;
            }
            if (stats.adjacentDamageBonus > 0) {
                prototypeSpend.adjacentDamageBonus = stats.adjacentDamageBonus * rates.targetingDamageAllDir;
                totalPrototypeSpend += prototypeSpend.adjacentDamageBonus;
            }
            if (stats.energyReduction > 0) {
                prototypeSpend.energyReduction = stats.energyReduction * rates.energyReduction;
                totalPrototypeSpend += prototypeSpend.energyReduction;
            }

            // Track reductions applied (max 1 each)
            let weightReduced = 0;
            let energyReduced = 0;

            // Allocate budget proportionally
            if (totalBudget > 0 && totalPrototypeSpend > 0) {
                let remainingBudget = totalBudget;

                // First, try to reduce weight/energy (max 1 each, costs 1 budget each)
                // 30% chance to apply reduction if item has high weight/energy
                if (remainingBudget > 0 && stats.weight > 1 && Math.random() < 0.3) {
                    stats.weight -= 1;
                    weightReduced = 1;
                    remainingBudget -= 1;
                }
                if (remainingBudget > 0 && stats.energyDraw > 0 && Math.random() < 0.3) {
                    stats.energyDraw -= 1;
                    energyReduced = 1;
                    remainingBudget -= 1;
                }

                // Allocate remaining budget to scalable stats proportionally
                for (const [stat, spendAmount] of Object.entries(prototypeSpend)) {
                    if (remainingBudget <= 0) break;

                    const proportion = spendAmount / totalPrototypeSpend;
                    const budgetForStat = Math.floor(remainingBudget * proportion);
                    if (budgetForStat <= 0) continue;

                    switch (stat) {
                        case 'damage':
                            // Don't scale damage for multi-hit weapons (shotsPerRound > 1)
                            if (!battle || battle.shotsPerRound <= 1) {
                                const damageIncrease = Math.floor(budgetForStat / rates.damage);
                                stats.damage += damageIncrease;
                            }
                            break;
                        case 'damageReduction':
                            const drIncrease = Math.floor(budgetForStat / rates.damageReduction);
                            stats.damageReduction += drIncrease;
                            break;
                        case 'hpBonus':
                            const hpIncrease = Math.floor(budgetForStat / rates.hp);
                            stats.hpBonus += hpIncrease;
                            break;
                        case 'energyProvided':
                            const energyIncrease = Math.floor(budgetForStat / rates.energyProvided);
                            stats.energyDraw -= energyIncrease;  // More negative = more energy
                            break;
                        case 'directionalDamageBonus':
                            const dir1Increase = Math.floor(budgetForStat / rates.targetingDamage1Dir);
                            stats.directionalDamageBonus += dir1Increase;
                            break;
                        case 'adjacentDamageBonus':
                            const adjIncrease = Math.floor(budgetForStat / rates.targetingDamageAllDir);
                            stats.adjacentDamageBonus += adjIncrease;
                            break;
                        case 'energyReduction':
                            const reductionIncrease = Math.floor(budgetForStat / rates.energyReduction);
                            stats.energyReduction += reductionIncrease;
                            break;
                    }
                }
            }

            // ============================================
            // MODIFIER SYSTEM (uncommon+ only)
            // ============================================
            let appliedModifier = null;

            if (rarity !== 'common') {
                const modifierChance = getModifierChance(level);
                if (Math.random() < modifierChance) {
                    const maxModBudget = COMPONENT_GENERATION.maxModifierBudget[rarity] || 1;
                    appliedModifier = selectModifier(template.type, maxModBudget);

                    if (appliedModifier) {
                        // Apply modifier effects to stats
                        const effect = appliedModifier.effect;
                        if (effect.weightBonus) stats.weight = Math.max(0, stats.weight + effect.weightBonus);
                        if (effect.energyBonus) stats.energyDraw = Math.max(0, stats.energyDraw + effect.energyBonus);
                        if (effect.drBonus) stats.damageReduction = (stats.damageReduction || 0) + effect.drBonus;
                        if (effect.hpBonus) stats.hpBonus = (stats.hpBonus || 0) + effect.hpBonus;
                        if (effect.energyProvidedBonus) stats.energyDraw = (stats.energyDraw || 0) - effect.energyProvidedBonus;
                        if (effect.adjacentDamageBonus) stats.adjacentDamageBonus = (stats.adjacentDamageBonus || 0) + effect.adjacentDamageBonus;

                        // Store battle-related modifier effects for combat resolution
                        if (effect.firstShotMultiplier || effect.damagePerReactor || effect.damagePerWeapon) {
                            stats.modifier = appliedModifier;
                        }
                    }
                }
            }

            // Generate name
            const prefix = template.namePrefix[Math.floor(Math.random() * template.namePrefix.length)];
            const suffix = template.nameSuffix[Math.floor(Math.random() * template.nameSuffix.length)];
            let name = `${prefix} ${suffix}`;

            // Add modifier name if present
            if (appliedModifier) {
                name = `${appliedModifier.name} ${name}`;
            }

            // Add level indicator for higher levels
            if (level > 1) {
                name = `${name} Mk.${level}`;
            }

            // Generate unique ID
            const id = generateItemId(templateType, rarity, level);

            // Calculate grid dimensions
            const gridDimensions = {
                w: shape[0] ? shape[0].length : 1,
                h: shape.length
            };

            // Build the complete item
            const generatedItem = {
                id,
                name,
                type: template.type,
                category: template.category,
                icon: template.icon,
                gridShape: shape,
                gridDimensions,
                stats,
                constraints: {
                    validSlots: [...template.validSlots]
                },
                // Metadata for display
                rarity,
                level,
                isGenerated: true,
                templateType,
                appliedVariants,
                // Budget info for debugging/tooltips
                budgetInfo: {
                    cells,
                    levelBudget,
                    rarityBudget,
                    totalBudget,
                    weightReduced,
                    energyReduced
                },
                // Modifier info if present
                modifier: appliedModifier
            };

            // Add battle properties if weapon
            if (battle) {
                generatedItem.battle = battle;
            }

            // Add special properties if they exist
            if (template.special) {
                generatedItem.special = { ...template.special };
            }

            // Add synergy properties - IMPORTANT for the multiplicative damage system!
            if (template.synergies) {
                generatedItem.synergies = [...template.synergies];
            }
            if (template.synergyDescription) {
                generatedItem.synergyDescription = template.synergyDescription;
            }

            return generatedItem;
        }

        // Generate random rarity based on probabilities
        function getRandomRarity(enemyLevel = 1) {
            // Higher enemy levels increase chance of better rarity
            const levelBonus = (enemyLevel - 1) * 0.02;  // 2% better per level

            const rand = Math.random() - levelBonus;

            if (rand < 0.02) return 'legendary';      // 2% base
            if (rand < 0.08) return 'epic';           // 6% base
            if (rand < 0.22) return 'rare';           // 14% base
            if (rand < 0.45) return 'uncommon';       // 23% base
            return 'common';                           // 55% base
        }

        // Get rarity based on mission difficulty
        function getSalvageRarity(missionDifficulty = 'Easy') {
            const rates = SALVAGE.rarityRates[missionDifficulty] || SALVAGE.rarityRates.Easy;
            const rand = Math.random();
            let cumulative = 0;

            for (const [rarity, chance] of Object.entries(rates)) {
                cumulative += chance;
                if (rand < cumulative) return rarity;
            }
            return 'common';
        }

        // Body part salvage penalty configuration (mirrors battle-arena.html)
        const BODY_PART_SALVAGE = {
            penalties: {
                torso: 1.0,      // Full penalty for torso damage
                head: 0.0,       // No penalty for head damage - preserves salvage
                leftArm: 1.0,    // Full penalty
                rightArm: 1.0,
                leftLeg: 0.3,    // Only 30% penalty for leg damage
                rightLeg: 0.3
            },
            baseScrapChance: 0.5  // Even perfect kills have 50% chance per component to become scrap
        };

        // Calculate salvage quality based on body part damage
        // Returns a value from 0 (all scrap) to 1 (perfect salvage)
        function calculateSalvageQuality(enemyDamageData) {
            if (!enemyDamageData || enemyDamageData.length === 0) {
                return 0.5; // Default moderate quality if no data
            }

            let totalPenalty = 0;
            let enemyCount = 0;

            enemyDamageData.forEach(enemy => {
                if (!enemy.bodyParts || !enemy.isDestroyed) return;
                enemyCount++;

                const dmg = enemy.bodyParts.totalDamageReceived || {};
                const destroyed = enemy.bodyParts.destroyed || {};

                // Calculate penalty based on damage received to each part
                // More damage = more penalty (scaled by part's penalty multiplier)
                Object.keys(BODY_PART_SALVAGE.penalties).forEach(part => {
                    const partDamage = dmg[part] || 0;
                    const penalty = BODY_PART_SALVAGE.penalties[part];

                    // Destroyed parts add full penalty, damage adds proportional penalty
                    if (destroyed[part]) {
                        totalPenalty += penalty * 0.5; // 50% penalty for destroyed part
                    } else if (partDamage > 0) {
                        // Scale damage penalty (max 0.3 per part)
                        totalPenalty += Math.min(0.3, partDamage / 100) * penalty;
                    }
                });
            });

            if (enemyCount === 0) return 0.5;

            // Average penalty across enemies
            const avgPenalty = totalPenalty / enemyCount;

            // Convert to quality (0 = worst, 1 = best)
            // Penalty of 0 = quality 1, penalty of 3 (max) = quality 0
            const quality = Math.max(0, 1 - avgPenalty / 3);

            console.log(`Salvage quality: ${(quality * 100).toFixed(0)}% (penalty: ${avgPenalty.toFixed(2)})`);
            return quality;
        }

        // Generate salvage components after battle
        // enemyDamageData contains body part damage info for salvage calculation
        function generateSalvageOptions(result, enemyLevel = 1, missionDifficulty = 'Easy', enemyDamageData = null) {
            const options = [];
            const round = gameProgression.round;
            const isBoss = DIFFICULTY.isBossRound(round);

            // Calculate salvage quality based on body part damage
            const salvageQuality = calculateSalvageQuality(enemyDamageData);

            // Determine number of options based on result and boss status
            let numOptions;
            if (result === 'victory') {
                numOptions = isBoss ? SALVAGE.bossOptions : SALVAGE.normalOptions;
            } else {
                numOptions = Math.max(1, Math.floor((isBoss ? SALVAGE.bossOptions : SALVAGE.normalOptions) / 2));
            }

            // Available templates with weighted selection (reactors are rare)
            const templateWeights = {
                railgun: 3,
                laser: 3,
                missile: 3,
                machinegun: 2,          // 1Ã—2 = 2 DPR, cheap multi-hit
                minigun: 1,             // 1Ã—8 = 8 DPR, rare synergy weapon
                pulse_laser: 1,         // 1Ã—5 = 5 DPR, rare energy multi-hit
                ballistic_plating: 2,   // Damage reduction armor (weight 2)
                reactive_plating: 1,    // Better damage reduction, rarer
                armor_small: 2,         // 1 cell, 3 HP
                armor_light: 2,         // 2 cells, 7 HP
                armor_medium: 2,        // 3 cells, 11 HP
                armor_heavy: 1.5,       // 4 cells, 15 HP
                armor_reinforced: 1,    // 5 cells, 19 HP
                armor_titan: 0.5,       // 6 cells, 23 HP (rare)
                energy_shield: 1.5,     // Energy weapon defense
                reactor: 0.5,           // Much less common
                power_cell: 0.5,        // Much less common
                targeting_link: 3,      // Common - directional damage boost
                targeting_hub: 1,       // Rarer - omnidirectional damage boost
                gyro: 2,
                heat_sink: 2,
                cooling_system: 2
            };

            // Build weighted template list, filtered by minimum level
            const minLevels = getMinLevelCache();
            const weightedTemplates = [];
            for (const [key, weight] of Object.entries(templateWeights)) {
                if (ITEM_TEMPLATES[key]) {
                    // Only include templates whose minLevel <= current enemy level
                    const templateMinLevel = minLevels[key] || 1;
                    if (templateMinLevel <= enemyLevel) {
                        for (let w = 0; w < weight * 2; w++) {
                            weightedTemplates.push(key);
                        }
                    }
                }
            }

            // Fallback: if no templates available at this level, use basic templates
            if (weightedTemplates.length === 0) {
                console.warn(`No templates available for level ${enemyLevel}, using fallback`);
                for (const [key, weight] of Object.entries(templateWeights)) {
                    if (ITEM_TEMPLATES[key] && (minLevels[key] || 1) <= 3) {
                        for (let w = 0; w < weight * 2; w++) {
                            weightedTemplates.push(key);
                        }
                    }
                }
            }

            // Generate components (may become scrap based on salvage quality)
            const generatedComponents = [];

            for (let i = 0; i < numOptions; i++) {
                // Pick weighted random template
                const templateType = weightedTemplates[Math.floor(Math.random() * weightedTemplates.length)];

                // Generate rarity based on mission difficulty
                const rarity = getSalvageRarity(missionDifficulty);

                // Item level based on enemy level with some variance
                const baseLevel = Math.max(1, enemyLevel + Math.floor(Math.random() * 3) - 1);

                // Determine if item is damaged (90% chance)
                const isDamaged = Math.random() < SALVAGE.damagedChance;

                // Store original level for skip bonus calculation
                const originalLevel = baseLevel;

                // Calculate effective level (reduced for damaged items)
                let effectiveLevel = baseLevel;
                if (isDamaged) {
                    const reduction = SALVAGE.damagedLevelReduction[
                        Math.floor(Math.random() * SALVAGE.damagedLevelReduction.length)
                    ];
                    effectiveLevel = Math.max(1, baseLevel - reduction);
                }

                // Generate the component at effective level
                const component = generateComponent(templateType, effectiveLevel, rarity);
                if (component) {
                    // Mark damaged status
                    component.isDamaged = isDamaged;
                    component.originalLevel = originalLevel;

                    // Estimate component value for scrap priority
                    const estimatedValue = (component.stats.damage || 0) * 10 +
                                          (component.stats.damageReduction || 0) * 15 +
                                          (component.stats.hpBonus || 0) * 2 +
                                          (component.stats.energyShieldHP || 0) * 3 +
                                          Math.abs(component.stats.energyDraw || 0) * 20;
                    component._estimatedValue = estimatedValue;

                    // Damaged items have reduced stats (20-40% penalty) and 0 sell value
                    if (isDamaged) {
                        component.sellValue = 0;
                        const damagePenalty = 0.6 + Math.random() * 0.2;  // 60-80% of original stats

                        // Reduce primary stats
                        if (component.stats.damage) {
                            component.stats.damage = Math.max(1, Math.floor(component.stats.damage * damagePenalty));
                        }
                        if (component.stats.armorBonus) {
                            component.stats.armorBonus = Math.max(1, Math.floor(component.stats.armorBonus * damagePenalty));
                        }
                        if (component.stats.energyDraw < 0) {
                            // Energy providers give less energy when damaged
                            component.stats.energyDraw = Math.ceil(component.stats.energyDraw * damagePenalty);
                        }
                        if (component.stats.accuracyBonus) {
                            component.stats.accuracyBonus = Math.floor(component.stats.accuracyBonus * damagePenalty);
                        }
                        if (component.stats.energyReduction) {
                            component.stats.energyReduction = Math.max(1, Math.floor(component.stats.energyReduction * damagePenalty));
                        }
                    }

                    // Mark some undamaged items as high resale value
                    if (!isDamaged && Math.random() < SALVAGE.highValueChance) {
                        component.isHighValue = true;
                        component.resaleBonus = 0.5;  // 50% extra sell value
                    }

                    generatedComponents.push(component);
                }
            }

            // BODY PART SALVAGE SYSTEM: Convert some components to scrap based on salvage quality
            // Sort by value (most valuable first) - these get converted to scrap first
            generatedComponents.sort((a, b) => (b._estimatedValue || 0) - (a._estimatedValue || 0));

            // Calculate how many components become scrap
            // Base 50% scrap chance + additional based on salvage quality
            // salvageQuality 1.0 = only base 50% scrap, quality 0.0 = 100% scrap
            const scrapChance = BODY_PART_SALVAGE.baseScrapChance + (1 - salvageQuality) * 0.5;

            let scrapGold = 0;
            generatedComponents.forEach(component => {
                // Most valuable components have highest chance to become scrap when salvage quality is low
                const valueBonus = Math.min(0.2, (component._estimatedValue || 0) / 500);
                const finalScrapChance = Math.min(0.95, scrapChance + valueBonus * (1 - salvageQuality));

                if (Math.random() < finalScrapChance) {
                    // Convert to scrap - add gold instead
                    const scrapValue = Math.floor(5 + (component._estimatedValue || 10) / 5);
                    scrapGold += scrapValue;
                    console.log(`Component ${component.name} -> SCRAP (${scrapValue} gold)`);
                } else {
                    // Keep as salvage option
                    delete component._estimatedValue; // Clean up internal value
                    options.push(component);
                }
            });

            // Add scrap gold to player (will be shown in salvage screen)
            if (scrapGold > 0) {
                console.log(`Total scrap gold from body damage: ${scrapGold}`);
                playerResources.gold += scrapGold;
            }

            return options;
        }

        // Get number of salvage picks allowed
        function getSalvagePicks(result) {
            const isBoss = DIFFICULTY.isBossRound(gameProgression.round);
            if (result !== 'victory') return 1;  // Always at least 1 on defeat
            return isBoss ? SALVAGE.bossPicks : SALVAGE.normalPicks;
        }

        // Add a generated component to the ITEM_DATABASE so it can be used
        function registerGeneratedComponent(component) {
            ITEM_DATABASE[component.id] = component;
            return component.id;
        }

        // ============================================
        // ENEMY GENERATION SYSTEM
        // ============================================

        // Enemy generation constants (scaled to match player economy: 13-42 HP, 4-5 damage weapons)
        const ENEMY_GENERATION = {
            // Base budget per enemy level
            baseBudget: 20,
            budgetPerLevel: 10,

            // Budget allocation weights
            allocation: {
                health: 0.40,      // 40% to health
                damage: 0.30,      // 30% to damage
                armor: 0.15,       // 15% to armor
                weapons: 0.15      // 15% to weapon count/quality
            },

            // Conversion rates (scaled down to match player economy)
            rates: {
                healthPerBudget: 1.5,   // 1 budget = 1.5 HP
                damagePerBudget: 0.4,   // 1 budget = 0.4 damage
                armorPerBudget: 0.3,    // 1 budget = 0.3 armor
                weaponBudget: 15        // Cost per weapon slot
            },

            // Enemy chassis types
            chassisTypes: [
                { name: 'Scout Frame', weight: 'light', healthMult: 0.7, damageMult: 0.8, armorMult: 0.5 },
                { name: 'Light Frame', weight: 'light', healthMult: 0.85, damageMult: 0.9, armorMult: 0.7 },
                { name: 'Medium Frame', weight: 'medium', healthMult: 1.0, damageMult: 1.0, armorMult: 1.0 },
                { name: 'Heavy Frame', weight: 'heavy', healthMult: 1.2, damageMult: 1.1, armorMult: 1.3 },
                { name: 'Assault Frame', weight: 'heavy', healthMult: 1.4, damageMult: 1.2, armorMult: 1.5 }
            ],

            // Enemy name prefixes by level tier
            namePrefixes: {
                1: ['Rusty', 'Worn', 'Patrol', 'Scout'],
                2: ['Standard', 'Militia', 'Guard', 'Sentry'],
                3: ['Veteran', 'Battle', 'Assault', 'Strike'],
                4: ['Elite', 'Heavy', 'Siege', 'War'],
                5: ['Champion', 'Destroyer', 'Havoc', 'Titan']
            },

            // Enemy name suffixes
            nameSuffixes: ['Mech', 'Walker', 'Unit', 'Bot', 'Drone', 'Hunter', 'Striker']
        };

        // ============================================
        // DIFFICULTY SCALING SYSTEM
        // ============================================
        const DIFFICULTY = {
            // Base difficulty multiplier by round
            getMultiplier: function(round) {
                // Slow ramp for rounds 1-4 (easy intro)
                if (round <= 4) {
                    return 0.6 + (round - 1) * 0.1;  // 0.6, 0.7, 0.8, 0.9
                }
                // Spike at round 5 (first boss wave)
                if (round === 5) {
                    return 1.5;  // 1.5x difficulty spike
                }
                // Moderate ramp for rounds 6-9
                if (round <= 9) {
                    return 1.0 + (round - 5) * 0.15;  // 1.0, 1.15, 1.3, 1.45
                }
                // Big spike at round 10 (major boss)
                if (round === 10) {
                    return 2.5;  // 2.5x difficulty spike!
                }
                // Continued scaling after round 10
                return 2.0 + (round - 10) * 0.2;
            },

            // Is this round a boss round?
            isBossRound: function(round) {
                return round === 5 || round === 10 || (round > 10 && round % 5 === 0);
            },

            // Get boss type for boss rounds
            getBossType: function(round) {
                if (round === 5) return 'ELITE_COMMANDER';
                if (round === 10) return 'WARLORD';
                if (round === 15) return 'TITAN_PRIME';
                return 'BOSS_' + round;
            },

            // Boss stat multipliers (scaled for lower HP economy)
            bossMultipliers: {
                ELITE_COMMANDER: { hp: 1.5, damage: 1.3, armor: 1.3 },
                WARLORD: { hp: 2.0, damage: 1.5, armor: 1.5 },
                TITAN_PRIME: { hp: 2.5, damage: 1.8, armor: 2.0 }
            }
        };

        // ============================================
        // SALVAGE SYSTEM (Multiple Options, Limited Picks)
        // ============================================
        const SALVAGE = {
            normalOptions: 4,      // Number of salvage options after normal rounds
            bossOptions: 6,        // More options after boss rounds
            normalPicks: 1,        // Can pick 1 after normal rounds
            bossPicks: 2,          // Can pick 2 after boss rounds
            highValueChance: 0.2,  // 20% chance for high resale value item
            comboChance: 0.15,     // 15% chance for combo items (synergize)
            damagedChance: 0.9,    // 90% of salvage is damaged
            damagedLevelReduction: [1, 2],  // Damaged items lose 1-2 levels of effectiveness
            // Rarity rates by mission difficulty
            rarityRates: {
                Easy: { common: 0.75, uncommon: 0.20, rare: 0.05, epic: 0, legendary: 0 },
                Medium: { common: 0.60, uncommon: 0.30, rare: 0.08, epic: 0.02, legendary: 0 },
                Hard: { common: 0.45, uncommon: 0.35, rare: 0.12, epic: 0.06, legendary: 0.02 }
            }
        };

        // Item combos that synergize
        const ITEM_COMBOS = {
            laser_set: {
                name: 'Laser Array Set',
                items: ['laser', 'laser'],
                bonus: '+15% Laser Damage',
                effect: { type: 'damage_boost', damageType: 'laser', amount: 0.15 }
            },
            missile_barrage: {
                name: 'Missile Barrage Kit',
                items: ['missile', 'missile'],
                bonus: '+20% Knockback',
                effect: { type: 'knockback_boost', amount: 0.20 }
            },
            rapid_assault: {
                name: 'Rapid Assault Package',
                items: ['machinegun', 'machinegun'],
                bonus: '+1 Shot/Round',
                effect: { type: 'shots_boost', amount: 1 }
            },
            heavy_hitter: {
                name: 'Heavy Hitter Bundle',
                items: ['railgun', 'armor'],
                bonus: '+10% Damage, +10 Armor',
                effect: { type: 'mixed', damage: 0.10, armor: 10 }
            }
        };

        // Mission templates (base structure, enemies generated dynamically)
        // baseBudgetMult is TOTAL budget for the mission, divided among all enemies
        const MISSION_TEMPLATES = {
            patrol: {
                id: 'patrol',
                name: 'Border Patrol',
                difficulty: 'Easy',
                risk: 1,
                baseBudgetMult: 0.6,    // 60% of standard budget (1 enemy)
                enemyCount: 1,
                description: 'Light recon mission. Expect minimal resistance.',
                rewardMult: 1.0
            },
            skirmish: {
                id: 'skirmish',
                name: 'Skirmish Zone',
                difficulty: 'Easy',
                risk: 1,
                baseBudgetMult: 0.8,    // 80% total budget, split among 2 enemies
                enemyCount: 2,
                description: 'Light engagement. Two weak hostiles detected.',
                rewardMult: 1.2
            },
            convoy: {
                id: 'convoy',
                name: 'Convoy Assault',
                difficulty: 'Medium',
                risk: 2,
                baseBudgetMult: 1.0,    // 100% budget (1 enemy)
                enemyCount: 1,
                description: 'Intercept enemy supply convoy. Medium resistance expected.',
                rewardMult: 1.5
            },
            ambush: {
                id: 'ambush',
                name: 'Ambush Site',
                difficulty: 'Medium',
                risk: 2,
                baseBudgetMult: 1.4,    // 140% total budget, split among 2 enemies
                enemyCount: 2,
                description: 'Clear hostile ambush. Two medium threats detected.',
                rewardMult: 1.8
            },
            fortress: {
                id: 'fortress',
                name: 'Fortress Breach',
                difficulty: 'Hard',
                risk: 3,
                baseBudgetMult: 1.5,    // 150% budget (1 strong enemy)
                enemyCount: 1,
                description: 'Assault heavily defended position. Prepare for heavy combat.',
                rewardMult: 2.5
            },
            warzone: {
                id: 'warzone',
                name: 'Active Warzone',
                difficulty: 'Hard',
                risk: 3,
                baseBudgetMult: 2.1,    // 210% total budget, split among 3 enemies
                enemyCount: 3,
                description: 'Enter active combat zone. Three hostiles incoming.',
                rewardMult: 3.0
            }
        };

        // Game progression state (defined early for getEnemyLevel)
        let gameProgression = {
            round: 1,
            wins: 0,
            losses: 0,
            maxRound: 1
        };

        // Calculate enemy level based on currentEnemyLevel and mission difficulty
        function getEnemyLevel(missionRisk) {
            // Use new difficulty system based on round
            const round = gameProgression.round;
            const difficultyMult = DIFFICULTY.getMultiplier(round);
            const isBoss = DIFFICULTY.isBossRound(round);

            // Base level scales with difficulty multiplier
            const baseLevel = Math.max(1, Math.floor(difficultyMult * 2));

            // Add variance for non-boss rounds
            const levelVariance = isBoss ? 0 : (Math.floor(Math.random() * 2) - 1);

            // Risk affects level (1=easy, 2=medium, 3=hard)
            const riskBonus = missionRisk - 2;

            // Boss rounds get extra levels
            const bossBonus = isBoss ? 2 : 0;

            return Math.max(1, Math.min(15, baseLevel + riskBonus + levelVariance + bossBonus));
        }

        // Generate a single enemy mech
        function generateEnemy(level, budget) {
            // Select chassis based on budget and level
            const chassisIndex = Math.min(
                ENEMY_GENERATION.chassisTypes.length - 1,
                Math.floor((level - 1) / 2) + Math.floor(Math.random() * 2)
            );
            const chassis = ENEMY_GENERATION.chassisTypes[chassisIndex];

            // Allocate budget
            const healthBudget = budget * ENEMY_GENERATION.allocation.health;
            const damageBudget = budget * ENEMY_GENERATION.allocation.damage;
            const armorBudget = budget * ENEMY_GENERATION.allocation.armor;
            const weaponBudget = budget * ENEMY_GENERATION.allocation.weapons;

            // Calculate stats (scaled to match player economy: ~15-40 HP, ~3-8 damage)
            const baseHealth = 12 + Math.round(healthBudget * ENEMY_GENERATION.rates.healthPerBudget * chassis.healthMult);
            const baseDamage = 3 + Math.round(damageBudget * ENEMY_GENERATION.rates.damagePerBudget * chassis.damageMult);
            const baseArmor = Math.round(armorBudget * ENEMY_GENERATION.rates.armorPerBudget * chassis.armorMult);

            // Determine weapon count
            const weaponCount = Math.max(1, Math.min(3, Math.floor(weaponBudget / ENEMY_GENERATION.rates.weaponBudget) + 1));

            // Generate equipment using templates
            const equipment = [];
            const weaponSlots = ['rightArm', 'leftArm', 'torso'];

            // Weapon templates with their weights - filtered by minLevel
            const minLevels = getMinLevelCache();
            const allWeaponTemplates = [
                { key: 'railgun', weight: 3 },
                { key: 'laser', weight: 3 },
                { key: 'missile', weight: 2 },
                { key: 'machinegun', weight: 2 },
                { key: 'minigun', weight: 1 },
                { key: 'pulse_laser', weight: 1 }
            ];

            // Filter to templates available at this level
            const availableWeapons = allWeaponTemplates.filter(w => (minLevels[w.key] || 1) <= level);
            const weightedWeapons = [];
            for (const w of availableWeapons) {
                for (let j = 0; j < w.weight; j++) {
                    weightedWeapons.push(w.key);
                }
            }

            for (let i = 0; i < weaponCount && i < weaponSlots.length; i++) {
                const template = weightedWeapons[Math.floor(Math.random() * weightedWeapons.length)] || 'railgun';
                const weapon = generateComponent(template, level, 'common', { variantChance: 0 });
                if (weapon) {
                    weapon.id = `enemy_${template}_${Date.now()}_${i}`;
                    registerGeneratedComponent(weapon);
                    equipment.push({
                        itemId: weapon.id,
                        slot: weaponSlots[i],
                        position: { x: 0, y: 0 }
                    });
                }
            }

            // Add armor if high enough level
            if (level >= 2 && baseArmor > 20) {
                const armor = generateComponent('ballistic_plating', level, 'common', { variantChance: 0 });
                if (armor) {
                    armor.id = `enemy_armor_${Date.now()}`;
                    registerGeneratedComponent(armor);
                    equipment.push({
                        itemId: armor.id,
                        slot: 'torso',
                        position: { x: 0, y: 0 }
                    });
                }
            }

            // Add reactor for energy
            if (weaponCount >= 2) {
                const reactor = generateComponent('power_cell', level, 'common', { variantChance: 0 });
                if (reactor) {
                    reactor.id = `enemy_reactor_${Date.now()}`;
                    registerGeneratedComponent(reactor);
                    equipment.push({
                        itemId: reactor.id,
                        slot: 'torso',
                        position: { x: 2, y: 0 }
                    });
                }
            }

            // Generate name
            const tierIndex = Math.min(5, Math.ceil(level / 2));
            const prefixes = ENEMY_GENERATION.namePrefixes[tierIndex] || ENEMY_GENERATION.namePrefixes[1];
            const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
            const suffix = ENEMY_GENERATION.nameSuffixes[Math.floor(Math.random() * ENEMY_GENERATION.nameSuffixes.length)];

            return {
                name: `${prefix} ${suffix}`,
                chassis: chassis.name,
                level: level,
                maxHealth: baseHealth,
                equipment: equipment,
                stats: {
                    weight: 30 + level * 8,
                    energy: 30 + weaponCount * 15,
                    damage: baseDamage,
                    armor: baseArmor
                }
            };
        }

        // Generate enemies for a mission
        function generateMissionEnemies(missionTemplate) {
            const enemies = [];
            const enemyLevel = getEnemyLevel(missionTemplate.risk);

            // Calculate total budget for this mission
            const totalBudget = (ENEMY_GENERATION.baseBudget + ENEMY_GENERATION.budgetPerLevel * enemyLevel)
                              * missionTemplate.baseBudgetMult;

            // Divide budget among enemies (with slight variance)
            const budgetPerEnemy = totalBudget / missionTemplate.enemyCount;

            for (let i = 0; i < missionTemplate.enemyCount; i++) {
                // Add variance to individual enemy budget (+/- 15%)
                const variance = 0.85 + Math.random() * 0.3;
                const enemyBudget = budgetPerEnemy * variance;

                // Slight level variance for multi-enemy missions
                const levelVariance = missionTemplate.enemyCount > 1 ? Math.floor(Math.random() * 2) - 1 : 0;
                const individualLevel = Math.max(1, enemyLevel + levelVariance);

                enemies.push(generateEnemy(individualLevel, enemyBudget));
            }

            return enemies;
        }

        // Build dynamic missions based on current enemy level
        function buildMissions() {
            const missions = {};

            // Select 3 random mission templates for variety
            const templateEntries = Object.entries(MISSION_TEMPLATES);
            const shuffled = templateEntries.sort(() => Math.random() - 0.5);
            const selectedTemplates = shuffled.slice(0, 3);

            for (const [id, template] of selectedTemplates) {
                const enemies = generateMissionEnemies(template);
                const avgLevel = Math.round(enemies.reduce((sum, e) => sum + e.level, 0) / enemies.length);

                // Scale rewards with level
                const levelMult = 1 + (avgLevel - 1) * 0.15;
                const baseCredits = [300, 500, 800, 1200, 2000, 3500][template.risk + Math.floor(avgLevel / 2) - 1] || 500;
                const baseXP = [50, 100, 150, 250, 400, 600][template.risk + Math.floor(avgLevel / 2) - 1] || 100;

                missions[id] = {
                    ...template,
                    enemyMechs: enemies,
                    averageLevel: avgLevel,
                    reward: {
                        credits: Math.round(baseCredits * template.rewardMult * levelMult),
                        xp: Math.round(baseXP * template.rewardMult * levelMult)
                    }
                };
            }

            return missions;
        }

        // Current missions (regenerated after each battle)
        let MISSIONS = buildMissions();

        let selectedMission = null;
        let lastBattleMission = null;  // Track mission info for salvage generation

        // Background options for battle arena
        const BACKGROUND_OPTIONS = [
            { id: 'grasslands', name: 'Grasslands', description: 'Open fields with distant mountains' },
            { id: 'metal_arena', name: 'Metal Arena', description: 'Elevated metal combat platform' },
            { id: 'foggy', name: 'Foggy Wasteland', description: 'Dense fog obscures the battlefield' },
            { id: 'desert', name: 'Sand Dunes', description: 'Harsh desert environment' }
        ];
        let selectedBackground = 'grasslands';
        let userPilotingEnabled = false;  // User-controlled piloting mode

        // ============================================
        // PHYSICS BATTLE SYSTEM
        // ============================================
        let battleMechs = [];       // All mechs in battle
        let playerBattleMech = null;
        let enemyBattleMech = null;
        let projectiles = [];       // Active projectiles
        let beams = [];             // Active beam weapons
        let battleActive = false;
        let battleScene = null;     // Separate scene for battle
        let battleGround = null;
        let weaponCooldowns = {};   // Track weapon cooldowns per mech

        // Battle colors
        const BATTLE_COLORS = {
            playerPrimary: new BABYLON.Color3(0.15, 0.35, 0.2),
            playerSecondary: new BABYLON.Color3(0.25, 0.45, 0.3),
            enemyPrimary: new BABYLON.Color3(0.4, 0.12, 0.12),
            enemySecondary: new BABYLON.Color3(0.5, 0.18, 0.18),
            metal: new BABYLON.Color3(0.35, 0.35, 0.4),
            darkMetal: new BABYLON.Color3(0.12, 0.12, 0.15)
        };

        // Mech state machine
        const MechState = {
            WALKING: 'walking',
            RAGDOLL: 'ragdoll',
            RECOVERING: 'recovering'
        };

        // AI Configuration
        const AI_CONFIG = {
            idealRange: 10,
            minRange: 6,
            maxRange: 14,
            moveSpeed: 4,
            turnSpeed: 2,
            strafeChance: 0.4,
            decisionInterval: 0.3
        };

        // Arena bounds
        const ARENA_BOUNDS = {
            minX: -15,
            maxX: 15,
            minZ: -10,
            maxZ: 10
        };

        // Texture URLs
        const TEXTURE_URLS = {
            grass: 'https://i.imgur.com/c3l8U9o.png',
            rustMetal: 'https://assets.babylonjs.com/textures/rustediron2_basecolor.png'
        };

        let BATTLE_TEXTURES = {};

        // ============================================
        // BATTLE SYSTEM FUNCTIONS
        // ============================================

        // Get weapons from loadout
        function getLoadoutWeapons() {
            const weapons = [];
            loadoutState.equipment.forEach(eq => {
                const item = ITEM_DATABASE[eq.itemId];
                if (item && item.type === 'WEAPON' && item.battle) {
                    weapons.push({
                        itemId: eq.itemId,
                        slot: eq.slot,
                        name: item.name,
                        damage: item.stats.damage,
                        battle: item.battle,
                        lastFired: 0
                    });
                }
            });
            return weapons;
        }

        // Create battle scene with physics
        async function createBattleScene() {
            // Initialize Havok if not done
            if (!havokInstance) {
                havokInstance = await HavokPhysics();
            }

            battleScene = new BABYLON.Scene(engine);
            battleScene.clearColor = new BABYLON.Color3(0.5, 0.6, 0.75);

            // Enable physics
            havokPlugin = new BABYLON.HavokPlugin(true, havokInstance);
            battleScene.enablePhysics(new BABYLON.Vector3(0, -18, 0), havokPlugin);

            // Camera
            battleCamera = new BABYLON.ArcRotateCamera('battleCam', -Math.PI/2, Math.PI/3.5, 25,
                new BABYLON.Vector3(0, 2, 0), battleScene);
            battleCamera.attachControl(document.getElementById('renderCanvas'), true);
            battleCamera.lowerRadiusLimit = 10;
            battleCamera.upperRadiusLimit = 50;

            // Lighting
            const hemi = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0, 1, 0), battleScene);
            hemi.intensity = 0.5;

            const sun = new BABYLON.DirectionalLight('sun', new BABYLON.Vector3(-1, -2, -1), battleScene);
            sun.intensity = 1.2;

            // Ground
            battleGround = BABYLON.MeshBuilder.CreateGround('ground', { width: 40, height: 30 }, battleScene);
            const groundMat = new BABYLON.StandardMaterial('groundMat', battleScene);
            groundMat.diffuseColor = new BABYLON.Color3(0.3, 0.4, 0.3);
            battleGround.material = groundMat;
            battleGround.receiveShadows = true;

            // Ground physics
            const groundShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -0.5, 0),
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(40, 1, 30),
                battleScene
            );
            const groundBody = new BABYLON.PhysicsBody(battleGround, BABYLON.PhysicsMotionType.STATIC, false, battleScene);
            groundBody.shape = groundShape;

            return battleScene;
        }

        // Create a battle mech with physics and loadout weapons
        // Matches the proportions of the builder mech for consistency
        function createBattleMech(scene, xPos, zPos, isPlayer, weapons, maxHP) {
            const name = isPlayer ? 'player' : 'enemy';
            const colors = isPlayer ?
                { primary: BATTLE_COLORS.playerPrimary, secondary: BATTLE_COLORS.playerSecondary } :
                { primary: BATTLE_COLORS.enemyPrimary, secondary: BATTLE_COLORS.enemySecondary };

            // Materials - match builder holographic style but solid
            const primaryMat = new BABYLON.StandardMaterial(name + '_primary', scene);
            primaryMat.diffuseColor = colors.primary;
            primaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);

            const secondaryMat = new BABYLON.StandardMaterial(name + '_secondary', scene);
            secondaryMat.diffuseColor = colors.secondary;

            const metalMat = new BABYLON.StandardMaterial(name + '_metal', scene);
            metalMat.diffuseColor = BATTLE_COLORS.metal;
            metalMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);

            const darkMat = new BABYLON.StandardMaterial(name + '_dark', scene);
            darkMat.diffuseColor = BATTLE_COLORS.darkMetal;

            // Cockpit material (glowing)
            const cockpitMat = new BABYLON.StandardMaterial(name + '_cockpit', scene);
            cockpitMat.diffuseColor = isPlayer ? new BABYLON.Color3(0, 0.5, 0.5) : new BABYLON.Color3(0.5, 0.2, 0.2);
            cockpitMat.emissiveColor = isPlayer ? new BABYLON.Color3(0, 0.8, 0.9) : new BABYLON.Color3(0.9, 0.3, 0.2);
            cockpitMat.alpha = 0.9;

            // Pelvis (physics body) - matches builder: width: 0.9, height: 0.4, depth: 0.6
            const pelvis = BABYLON.MeshBuilder.CreateBox(name + '_pelvis', { width: 0.9, height: 0.4, depth: 0.6 }, scene);
            pelvis.position = new BABYLON.Vector3(xPos, 1.5, zPos);
            pelvis.material = darkMat;

            // Physics body - taller collision box to represent full mech
            const pelvisShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, 0.5, 0),
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(1.4, 2.5, 0.9),
                scene
            );
            const pelvisBody = new BABYLON.PhysicsBody(pelvis, BABYLON.PhysicsMotionType.ANIMATED, false, scene);
            pelvisBody.shape = pelvisShape;
            pelvisBody.setMassProperties({ mass: 50 });
            pelvisBody.setAngularDamping(5);
            pelvisBody.setLinearDamping(0.5);

            // Torso - matches builder: width: 1.2, height: 1.0, depth: 0.8
            const torso = BABYLON.MeshBuilder.CreateBox(name + '_torso', { width: 1.2, height: 1.0, depth: 0.8 }, scene);
            torso.position.y = 0.7;
            torso.parent = pelvis;
            torso.material = primaryMat;

            // Torso upper - matches builder: width: 1.4, height: 0.5, depth: 0.9
            const torsoUpper = BABYLON.MeshBuilder.CreateBox(name + '_torsoUpper', { width: 1.4, height: 0.5, depth: 0.9 }, scene);
            torsoUpper.position.y = 0.6;
            torsoUpper.parent = torso;
            torsoUpper.material = secondaryMat;

            // Head - matches builder: width: 0.5, height: 0.4, depth: 0.5
            const head = BABYLON.MeshBuilder.CreateBox(name + '_head', { width: 0.5, height: 0.4, depth: 0.5 }, scene);
            head.position.y = 0.65;
            head.parent = torsoUpper;
            head.material = primaryMat;

            // Cockpit glass - matches builder
            const cockpit = BABYLON.MeshBuilder.CreateBox(name + '_cockpit', { width: 0.4, height: 0.15, depth: 0.1 }, scene);
            cockpit.position = new BABYLON.Vector3(0, 0, 0.28);
            cockpit.parent = head;
            cockpit.material = cockpitMat;

            // Left Arm - shoulder + upper arm + lower arm
            const leftShoulder = BABYLON.MeshBuilder.CreateBox(name + '_leftShoulder', { width: 0.35, height: 0.3, depth: 0.35 }, scene);
            leftShoulder.position = new BABYLON.Vector3(-0.85, 0.35, 0);
            leftShoulder.parent = torso;
            leftShoulder.material = secondaryMat;

            const leftUpperArm = BABYLON.MeshBuilder.CreateBox(name + '_leftUpperArm', { width: 0.25, height: 0.5, depth: 0.25 }, scene);
            leftUpperArm.position.y = -0.35;
            leftUpperArm.parent = leftShoulder;
            leftUpperArm.material = metalMat;

            const leftLowerArm = BABYLON.MeshBuilder.CreateBox(name + '_leftLowerArm', { width: 0.3, height: 0.6, depth: 0.3 }, scene);
            leftLowerArm.position.y = -0.5;
            leftLowerArm.parent = leftUpperArm;
            leftLowerArm.material = primaryMat;

            // Left Weapon barrel
            const leftWeapon = BABYLON.MeshBuilder.CreateCylinder(name + '_leftWpn', { diameter: 0.15, height: 0.5 }, scene);
            leftWeapon.rotation.x = Math.PI / 2;
            leftWeapon.position = new BABYLON.Vector3(0, -0.2, 0.25);
            leftWeapon.parent = leftLowerArm;
            leftWeapon.material = darkMat;

            // Right Arm - shoulder + upper arm + lower arm
            const rightShoulder = BABYLON.MeshBuilder.CreateBox(name + '_rightShoulder', { width: 0.35, height: 0.3, depth: 0.35 }, scene);
            rightShoulder.position = new BABYLON.Vector3(0.85, 0.35, 0);
            rightShoulder.parent = torso;
            rightShoulder.material = secondaryMat;

            const rightUpperArm = BABYLON.MeshBuilder.CreateBox(name + '_rightUpperArm', { width: 0.25, height: 0.5, depth: 0.25 }, scene);
            rightUpperArm.position.y = -0.35;
            rightUpperArm.parent = rightShoulder;
            rightUpperArm.material = metalMat;

            const rightLowerArm = BABYLON.MeshBuilder.CreateBox(name + '_rightLowerArm', { width: 0.3, height: 0.6, depth: 0.3 }, scene);
            rightLowerArm.position.y = -0.5;
            rightLowerArm.parent = rightUpperArm;
            rightLowerArm.material = primaryMat;

            // Right Weapon barrel
            const rightWeapon = BABYLON.MeshBuilder.CreateCylinder(name + '_rightWpn', { diameter: 0.15, height: 0.5 }, scene);
            rightWeapon.rotation.x = Math.PI / 2;
            rightWeapon.position = new BABYLON.Vector3(0, -0.2, 0.25);
            rightWeapon.parent = rightLowerArm;
            rightWeapon.material = darkMat;

            // Legs - matching builder structure
            // Left leg
            const leftHip = BABYLON.MeshBuilder.CreateBox(name + '_leftHip', { width: 0.25, height: 0.25, depth: 0.25 }, scene);
            leftHip.position = new BABYLON.Vector3(-0.3, -0.25, 0);
            leftHip.parent = pelvis;
            leftHip.material = darkMat;

            const leftUpperLeg = BABYLON.MeshBuilder.CreateBox(name + '_leftUpperLeg', { width: 0.2, height: 0.5, depth: 0.2 }, scene);
            leftUpperLeg.position.y = -0.35;
            leftUpperLeg.parent = leftHip;
            leftUpperLeg.material = metalMat;

            const leftLowerLeg = BABYLON.MeshBuilder.CreateBox(name + '_leftLowerLeg', { width: 0.22, height: 0.55, depth: 0.22 }, scene);
            leftLowerLeg.position.y = -0.5;
            leftLowerLeg.parent = leftUpperLeg;
            leftLowerLeg.material = primaryMat;

            const leftFoot = BABYLON.MeshBuilder.CreateBox(name + '_leftFoot', { width: 0.25, height: 0.12, depth: 0.4 }, scene);
            leftFoot.position = new BABYLON.Vector3(0, -0.3, 0.08);
            leftFoot.parent = leftLowerLeg;
            leftFoot.material = darkMat;

            // Right leg
            const rightHip = BABYLON.MeshBuilder.CreateBox(name + '_rightHip', { width: 0.25, height: 0.25, depth: 0.25 }, scene);
            rightHip.position = new BABYLON.Vector3(0.3, -0.25, 0);
            rightHip.parent = pelvis;
            rightHip.material = darkMat;

            const rightUpperLeg = BABYLON.MeshBuilder.CreateBox(name + '_rightUpperLeg', { width: 0.2, height: 0.5, depth: 0.2 }, scene);
            rightUpperLeg.position.y = -0.35;
            rightUpperLeg.parent = rightHip;
            rightUpperLeg.material = metalMat;

            const rightLowerLeg = BABYLON.MeshBuilder.CreateBox(name + '_rightLowerLeg', { width: 0.22, height: 0.55, depth: 0.22 }, scene);
            rightLowerLeg.position.y = -0.5;
            rightLowerLeg.parent = rightUpperLeg;
            rightLowerLeg.material = primaryMat;

            const rightFoot = BABYLON.MeshBuilder.CreateBox(name + '_rightFoot', { width: 0.25, height: 0.12, depth: 0.4 }, scene);
            rightFoot.position = new BABYLON.Vector3(0, -0.3, 0.08);
            rightFoot.parent = rightLowerLeg;
            rightFoot.material = darkMat;

            return {
                name: name,
                pelvis: pelvis,
                pelvisBody: pelvisBody,
                torso: torso,
                head: head,
                leftArm: leftLowerArm,
                rightArm: rightLowerArm,
                leftWeapon: leftWeapon,
                rightWeapon: rightWeapon,
                leftLeg: leftLowerLeg,
                rightLeg: rightLowerLeg,
                isPlayer: isPlayer,
                maxHP: maxHP,
                currentHP: maxHP,
                weapons: weapons,
                isDestroyed: false,
                walkCycle: 0,
                walkDirection: 0,
                isWalking: false,
                torsoTwist: 0,
                lastFiredArm: 'left',
                ai: {
                    target: null,
                    decisionTimer: 0,
                    strafeAmount: 0
                }
            };
        }

        // Fire a weapon from loadout
        function fireLoadoutWeapon(mech, weaponData, target) {
            const now = performance.now();
            // Cooldown is per-burst (full 3 seconds), not per-shot
            const cooldown = 3000;
            if (now - weaponData.lastFired < cooldown) {
                return; // Still on cooldown
            }
            weaponData.lastFired = now;

            const battle = weaponData.battle;
            const shotsPerRound = battle.shotsPerRound || 1;
            const fromPos = mech.pelvis.getAbsolutePosition();
            const toPos = target.pelvis.getAbsolutePosition();
            const direction = toPos.subtract(fromPos).normalize();

            // Pick which arm fires this burst (alternate between bursts, not within burst)
            const firingArm = mech.lastFiredArm === 'left' ? mech.rightArm : mech.leftArm;

            // Fire all shots in a rapid burst with staggered timing
            for (let shotIndex = 0; shotIndex < shotsPerRound; shotIndex++) {
                // Delay between shots in burst (spread over ~400ms max for visual clarity)
                const burstDuration = Math.min(500, 60 * shotsPerRound);
                const shotDelay = shotIndex * (burstDuration / shotsPerRound);

                setTimeout(() => {
                    // Check if battle is still ongoing
                    if (!battleScene || mech.isDestroyed || target.isDestroyed) return;

                    // All shots in burst come from the same weapon/arm
                    const armPos = firingArm.getAbsolutePosition();

                    // Recalculate direction for moving targets
                    const currentTargetPos = target.pelvis.getAbsolutePosition();
                    const currentDirection = currentTargetPos.subtract(armPos).normalize();

                    // Add slight spread for visual variety (especially for high shot counts)
                    const spread = shotsPerRound > 1 ? 0.05 : 0;
                    const spreadDir = currentDirection.clone();
                    spreadDir.x += (Math.random() - 0.5) * spread;
                    spreadDir.z += (Math.random() - 0.5) * spread;
                    spreadDir.normalize();

                    if (battle.isBeam) {
                        // Create beam pulse
                        const beamLength = BABYLON.Vector3.Distance(armPos, currentTargetPos);
                        const beam = BABYLON.MeshBuilder.CreateCylinder('beam_' + Date.now() + '_' + shotIndex, {
                            diameter: 0.12 + (Math.random() * 0.06),  // Slight size variation
                            height: beamLength
                        }, battleScene);

                        const midpoint = armPos.add(currentTargetPos).scale(0.5);
                        beam.position = midpoint;
                        beam.lookAt(currentTargetPos);
                        beam.rotation.x += Math.PI / 2;

                        const beamMat = new BABYLON.StandardMaterial('beamMat_' + shotIndex, battleScene);
                        // Slight color variation per pulse
                        const colorVar = 0.9 + Math.random() * 0.1;
                        beamMat.emissiveColor = new BABYLON.Color3(
                            battle.color[0] * colorVar,
                            battle.color[1] * colorVar,
                            battle.color[2] * colorVar
                        );
                        beamMat.alpha = 0.7 + Math.random() * 0.3;
                        beam.material = beamMat;

                        beams.push({
                            mesh: beam,
                            damage: weaponData.damage,  // Each shot does weapon's damage
                            knockback: battle.knockback / shotsPerRound,  // Split knockback
                            target: target,
                            startTime: performance.now(),
                            duration: battle.beamDuration || 100,
                            applied: false
                        });
                    } else {
                        // Create projectile
                        const projectile = BABYLON.MeshBuilder.CreateSphere('proj_' + Date.now() + '_' + shotIndex, {
                            diameter: battle.projectileSize * 2
                        }, battleScene);
                        projectile.position = armPos.clone();

                        const projMat = new BABYLON.StandardMaterial('projMat_' + shotIndex, battleScene);
                        projMat.emissiveColor = new BABYLON.Color3(battle.color[0], battle.color[1], battle.color[2]);
                        projectile.material = projMat;

                        projectiles.push({
                            mesh: projectile,
                            velocity: spreadDir.scale(battle.projectileSpeed),
                            damage: weaponData.damage,  // Each projectile does weapon's damage
                            knockback: battle.knockback / shotsPerRound,  // Split knockback
                            target: target,
                            startTime: performance.now()
                        });
                    }

                    // Small recoil per shot
                    const recoilImpulse = currentDirection.scale(-battle.knockback * 0.05);
                    if (mech.pelvisBody) {
                        mech.pelvisBody.applyImpulse(recoilImpulse, fromPos);
                    }
                }, shotDelay);
            }

            // Update last fired arm after burst
            mech.lastFiredArm = mech.lastFiredArm === 'left' ? 'right' : 'left';
        }

        // Update projectiles
        function updateProjectiles(dt) {
            const toRemove = [];
            projectiles.forEach((proj, idx) => {
                proj.mesh.position.addInPlace(proj.velocity.scale(dt));

                // Check if hit target
                const dist = BABYLON.Vector3.Distance(proj.mesh.position, proj.target.pelvis.getAbsolutePosition());
                if (dist < 1.5) {
                    // Hit!
                    applyDamage(proj.target, proj.damage, proj.knockback, proj.velocity.normalize());
                    toRemove.push(idx);
                }

                // Remove if too old or out of bounds
                if (performance.now() - proj.startTime > 3000 ||
                    Math.abs(proj.mesh.position.x) > 30 ||
                    Math.abs(proj.mesh.position.z) > 30) {
                    toRemove.push(idx);
                }
            });

            // Remove hit/expired projectiles
            toRemove.reverse().forEach(idx => {
                projectiles[idx].mesh.dispose();
                projectiles.splice(idx, 1);
            });
        }

        // Update beams
        function updateBeams(dt) {
            const now = performance.now();
            const toRemove = [];

            beams.forEach((beam, idx) => {
                if (now - beam.startTime > beam.duration) {
                    toRemove.push(idx);
                } else if (!beam.applied) {
                    // Apply damage once
                    const direction = beam.target.pelvis.getAbsolutePosition().subtract(
                        beam.mesh.position
                    ).normalize();
                    applyDamage(beam.target, beam.damage, beam.knockback, direction);
                    beam.applied = true;
                }
            });

            toRemove.reverse().forEach(idx => {
                beams[idx].mesh.dispose();
                beams.splice(idx, 1);
            });
        }

        // Apply damage to mech
        function applyDamage(mech, damage, knockback, direction) {
            mech.currentHP -= damage;

            // Apply knockback
            const impulse = direction.scale(knockback);
            mech.pelvisBody.applyImpulse(impulse, mech.pelvis.getAbsolutePosition());

            // Check death
            if (mech.currentHP <= 0) {
                mech.isDestroyed = true;
                mech.currentHP = 0;
            }

            updateBattleUI();
        }

        // Update mech AI and movement
        function updateMechAI(mech, dt) {
            if (!mech || mech.isDestroyed) return;
            if (!mech.pelvis) {
                console.error('Mech pelvis is undefined:', mech.name);
                return;
            }

            const target = mech.ai.target;
            if (!target || target.isDestroyed || !target.pelvis) return;

            const myPos = mech.pelvis.getAbsolutePosition();
            const targetPos = target.pelvis.getAbsolutePosition();
            const dx = targetPos.x - myPos.x;
            const dz = targetPos.z - myPos.z;
            const distance = Math.sqrt(dx * dx + dz * dz);

            // Decision making
            mech.ai.decisionTimer -= dt;
            if (mech.ai.decisionTimer <= 0) {
                mech.ai.decisionTimer = AI_CONFIG.decisionInterval;

                // Decide to strafe
                if (Math.random() < AI_CONFIG.strafeChance) {
                    mech.ai.strafeAmount = (Math.random() - 0.5) * 2;
                } else {
                    mech.ai.strafeAmount = 0;
                }
            }

            // Movement - try to stay at ideal range
            if (distance > AI_CONFIG.maxRange) {
                mech.walkDirection = 1;  // Move forward
                mech.isWalking = true;
            } else if (distance < AI_CONFIG.minRange) {
                mech.walkDirection = -1;  // Back up
                mech.isWalking = true;
            } else {
                mech.walkDirection = 0;
                mech.isWalking = Math.abs(mech.ai.strafeAmount) > 0.3;
            }

            // Calculate facing angle
            const angleToTarget = Math.atan2(dz, dx);
            const baseAngle = Math.PI / 2;

            // Get pelvis rotation
            const body = mech.pelvisBody;
            const quat = body.transformNode.rotationQuaternion;
            let pelvisYaw = 0;
            if (quat) {
                const euler = quat.toEulerAngles();
                pelvisYaw = euler.y;
            }

            // Calculate desired yaw change
            let desiredYaw = baseAngle - angleToTarget;
            while (desiredYaw > Math.PI) desiredYaw -= Math.PI * 2;
            while (desiredYaw < -Math.PI) desiredYaw += Math.PI * 2;

            const yawError = desiredYaw - pelvisYaw;

            // Apply rotation
            const rotSpeed = AI_CONFIG.turnSpeed * dt;
            if (Math.abs(yawError) > 0.1) {
                const rot = Math.sign(yawError) * Math.min(Math.abs(yawError), rotSpeed);
                body.setAngularVelocity(new BABYLON.Vector3(0, rot * 3, 0));
            }

            // Walking animation
            if (mech.isWalking) {
                mech.walkCycle += dt * 4;
                const legSwing = Math.sin(mech.walkCycle) * 0.3;
                mech.leftLeg.rotation.x = legSwing;
                mech.rightLeg.rotation.x = -legSwing;
            }

            // Move
            if (mech.isWalking || mech.walkDirection !== 0) {
                let forwardDir = new BABYLON.Vector3(1, 0, 0);
                let rightDir = new BABYLON.Vector3(0, 0, 1);
                if (quat) {
                    const rotMatrix = new BABYLON.Matrix();
                    quat.toRotationMatrix(rotMatrix);
                    forwardDir = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(1, 0, 0), rotMatrix);
                    forwardDir.y = 0;
                    forwardDir.normalize();
                    rightDir = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(0, 0, 1), rotMatrix);
                    rightDir.y = 0;
                    rightDir.normalize();
                }

                const moveSpeed = AI_CONFIG.moveSpeed;
                let velocity = forwardDir.scale(mech.walkDirection * moveSpeed);
                velocity.addInPlace(rightDir.scale(mech.ai.strafeAmount * moveSpeed * 0.6));
                velocity.y = (2.5 - myPos.y) * 5; // Ground seeking
                body.setLinearVelocity(velocity);
            }

            // Torso twist toward target (local rotation)
            let localTorsoAngle = desiredYaw - pelvisYaw;
            while (localTorsoAngle > Math.PI) localTorsoAngle -= Math.PI * 2;
            while (localTorsoAngle < -Math.PI) localTorsoAngle += Math.PI * 2;
            localTorsoAngle = Math.max(-1.0, Math.min(1.0, localTorsoAngle));
            mech.torsoTwist = BABYLON.Scalar.Lerp(mech.torsoTwist, localTorsoAngle, dt * 5);
            mech.torso.rotation.y = mech.torsoTwist;

            // Fire weapons at target
            if (distance < 15 && mech.weapons.length > 0) {
                // Fire first available weapon
                mech.weapons.forEach(weapon => {
                    fireLoadoutWeapon(mech, weapon, target);
                });
            }
        }

        // Battle update loop
        function updateBattle(dt) {
            if (!battleActive) return;

            // Update all mechs
            battleMechs.forEach(mech => {
                updateMechAI(mech, dt);
            });

            // Update weapons
            updateProjectiles(dt);
            updateBeams(dt);

            // Check battle end
            if (playerBattleMech.isDestroyed || enemyBattleMech.isDestroyed) {
                endBattle(playerBattleMech.isDestroyed ? 'defeat' : 'victory');
            }
        }

        // Battle UI
        function updateBattleUI() {
            const playerHP = document.getElementById('playerHP');
            const enemyHP = document.getElementById('enemyHP');
            if (playerHP && playerBattleMech) {
                const pct = (playerBattleMech.currentHP / playerBattleMech.maxHP) * 100;
                playerHP.style.width = pct + '%';
            }
            if (enemyHP && enemyBattleMech) {
                const pct = (enemyBattleMech.currentHP / enemyBattleMech.maxHP) * 100;
                enemyHP.style.width = pct + '%';
            }
        }

        // End battle
        function endBattle(result) {
            battleActive = false;

            // Show result
            const overlay = document.getElementById('battleResultOverlay');
            const resultText = document.getElementById('battleResult');
            if (overlay && resultText) {
                resultText.textContent = result === 'victory' ? 'VICTORY!' : 'DEFEAT';
                resultText.style.color = result === 'victory' ? '#00ff88' : '#ff4444';
                overlay.style.display = 'flex';
            }
        }

        // Return to loadout (fallback if no rewards data)
        function returnToLoadout() {
            // Hide battle iframe
            const battleFrame = document.getElementById('battleFrame');
            battleFrame.style.display = 'none';
            battleFrame.src = '';  // Unload the iframe

            // Clear localStorage config
            localStorage.removeItem('battleConfig');

            // Show builder UI and canvas
            document.getElementById('mechBuilderUI').style.display = 'flex';
            document.getElementById('renderCanvas').style.display = 'block';

            // Switch to loadout tab (not mission)
            switchTab('loadout');

            // Switch to builder phase
            currentPhase = GamePhase.MECHBUILDER;
        }

        // Persistent bench items (no deck system - items stay on bench or mech)
        let benchItems = [];  // Array of item objects on the bench

        // Initialize with starter items (level 0, weaker than shop items)
        function initializeStarterItems() {
            benchItems = [];

            // Generate starter items from templates at level 0 (weaker than level 1)
            STARTER_ITEMS.forEach((config, index) => {
                // Generate with level 0, common rarity, no variance
                const item = generateComponent(config.template, 0, 'common', { variantChance: 0 });
                if (item) {
                    // Override name with starter name
                    item.name = config.name;
                    item.id = config.id;
                    item.instanceId = `start_${index + 1}`;
                    item.isStarter = true;  // Mark as starter item

                    // Register in database and add to bench
                    registerGeneratedComponent(item);
                    benchItems.push(item);
                }
            });
        }

        // Player resources
        let playerResources = {
            xp: 0,
            scrap: 0,
            gold: 5  // Starting gold (scaled down economy)
        };

        // ============================================
        // ECONOMY & INTEREST SYSTEM
        // ============================================
        const ECONOMY = {
            startingGold: 5,
            winBonus: 2,           // Gold for winning
            lossBonus: 1,          // Gold for losing (consolation)
            interestRate: 0.2,     // 20% interest
            interestCap: 2,        // Max 2 gold interest per round
            interestThreshold: 5,  // Need 5+ gold to earn interest
            streakBonus: 1,        // Extra gold per win streak
            maxStreak: 3,          // Cap streak bonus at 3

            // Shop costs (smaller scale: level 1 averages ~3g)
            shopRefreshCost: 1,
            mechPrices: {
                common: 3,
                uncommon: 5,
                rare: 8,
                epic: 12,
                legendary: 18
            },
            weaponPrices: {
                common: 3,       // Level 1 items cost ~3g
                uncommon: 4,
                rare: 6,
                epic: 9,
                legendary: 14
            },
            sellMultiplier: 0.33,  // Sell back for ~1g (most items)
            bargainDiscount: 0.7   // Bargain items cost 70% of normal
        };

        // Calculate interest earned
        function calculateInterest() {
            if (playerResources.gold < ECONOMY.interestThreshold) return 0;
            const interest = Math.floor(playerResources.gold * ECONOMY.interestRate);
            return Math.min(interest, ECONOMY.interestCap);
        }

        // Award end-of-round gold
        function awardRoundGold(isVictory) {
            let goldEarned = isVictory ? ECONOMY.winBonus : ECONOMY.lossBonus;

            // Win streak bonus
            if (isVictory) {
                const streak = Math.min(gameProgression.wins, ECONOMY.maxStreak);
                goldEarned += streak * ECONOMY.streakBonus;
            }

            // Interest on savings
            const interest = calculateInterest();
            goldEarned += interest;

            playerResources.gold += goldEarned;

            return {
                base: isVictory ? ECONOMY.winBonus : ECONOMY.lossBonus,
                streak: isVictory ? Math.min(gameProgression.wins, ECONOMY.maxStreak) * ECONOMY.streakBonus : 0,
                interest: interest,
                total: goldEarned
            };
        }

        // ============================================
        // MECH CHASSIS SYSTEM (Multiple Mechs)
        // ============================================
        const MECH_TEMPLATES = {
            scout: {
                id: 'scout',
                name: 'Scout Frame',
                class: 'Light',
                icon: 'ðŸƒ',
                tonnage: 35,           // Low weight capacity
                modSpace: 12,          // Grid cells available
                growthCapacity: 3,     // Max upgrades
                baseHP: 25,
                baseArmor: 0,
                baseSpeed: 1.3,
                baseAccuracy: 70,
                specialAbility: 'EVASION',  // 15% dodge chance
                specialDesc: '+15% Evasion',
                price: 0,  // Starting mech (free)
                rarity: 'common',
                slots: {
                    torso: { cols: 2, rows: 2 },
                    leftArm: { cols: 1, rows: 3 },
                    rightArm: { cols: 1, rows: 3 },
                    leftLeg: { cols: 1, rows: 2 },
                    rightLeg: { cols: 1, rows: 2 }
                }
            },
            warrior: {
                id: 'warrior',
                name: 'Warrior Frame',
                class: 'Medium',
                icon: 'âš”ï¸',
                tonnage: 55,
                modSpace: 18,
                growthCapacity: 4,
                baseHP: 35,
                baseArmor: 0,
                baseSpeed: 1.0,
                baseAccuracy: 65,
                specialAbility: 'FOCUS_FIRE',  // +10% damage to same target
                specialDesc: '+10% Damage Focus',
                price: 8,
                rarity: 'uncommon',
                slots: {
                    torso: { cols: 2, rows: 2 },
                    leftArm: { cols: 2, rows: 3 },
                    rightArm: { cols: 2, rows: 3 },
                    leftLeg: { cols: 2, rows: 2 },
                    rightLeg: { cols: 2, rows: 2 }
                }
            },
            titan: {
                id: 'titan',
                name: 'Titan Frame',
                class: 'Heavy',
                icon: 'ðŸ›¡ï¸',
                tonnage: 80,
                modSpace: 24,
                growthCapacity: 5,
                baseHP: 50,
                baseArmor: 0,
                baseSpeed: 0.7,
                baseAccuracy: 55,
                specialAbility: 'FORTIFY',  // +25% armor when stationary
                specialDesc: '+25% Armor (Stationary)',
                price: 15,
                rarity: 'rare',
                slots: {
                    torso: { cols: 3, rows: 3 },
                    leftArm: { cols: 2, rows: 4 },
                    rightArm: { cols: 2, rows: 4 },
                    leftLeg: { cols: 2, rows: 3 },
                    rightLeg: { cols: 2, rows: 3 }
                }
            },
            striker: {
                id: 'striker',
                name: 'Striker Frame',
                class: 'Medium',
                icon: 'âš¡',
                tonnage: 45,
                modSpace: 16,
                growthCapacity: 4,
                baseHP: 30,
                baseArmor: 0,
                baseSpeed: 1.2,
                baseAccuracy: 75,
                specialAbility: 'FIRST_STRIKE',  // Attack first, +20% first attack damage
                specialDesc: '+20% First Attack',
                price: 12,
                rarity: 'rare',
                slots: {
                    torso: { cols: 2, rows: 2 },
                    leftArm: { cols: 2, rows: 4 },
                    rightArm: { cols: 2, rows: 4 },
                    leftLeg: { cols: 1, rows: 2 },
                    rightLeg: { cols: 1, rows: 2 }
                }
            },
            juggernaut: {
                id: 'juggernaut',
                name: 'Juggernaut Frame',
                class: 'Assault',
                icon: 'ðŸ’€',
                tonnage: 100,
                modSpace: 30,
                growthCapacity: 6,
                baseHP: 70,
                baseArmor: 0,
                baseSpeed: 0.5,
                baseAccuracy: 50,
                specialAbility: 'UNSTOPPABLE',  // Immune to knockback, +50% knockback dealt
                specialDesc: 'Immune to KB, +50% KB',
                price: 25,
                rarity: 'epic',
                slots: {
                    torso: { cols: 4, rows: 3 },
                    leftArm: { cols: 2, rows: 5 },
                    rightArm: { cols: 2, rows: 5 },
                    leftLeg: { cols: 2, rows: 3 },
                    rightLeg: { cols: 2, rows: 3 }
                }
            },
            phantom: {
                id: 'phantom',
                name: 'Phantom Frame',
                class: 'Light',
                icon: 'ðŸ‘»',
                tonnage: 30,
                modSpace: 10,
                growthCapacity: 3,
                baseHP: 18,
                baseArmor: 0,
                baseSpeed: 1.5,
                baseAccuracy: 80,
                specialAbility: 'CLOAK',  // 30% miss chance against this mech
                specialDesc: '30% Enemy Miss Chance',
                price: 18,
                rarity: 'epic',
                slots: {
                    torso: { cols: 2, rows: 2 },
                    leftArm: { cols: 1, rows: 2 },
                    rightArm: { cols: 1, rows: 2 },
                    leftLeg: { cols: 1, rows: 2 },
                    rightLeg: { cols: 1, rows: 2 }
                }
            },
            berserker: {
                id: 'berserker',
                name: 'Berserker Frame',
                class: 'Medium',
                icon: 'ðŸ”¥',
                tonnage: 50,
                modSpace: 14,
                growthCapacity: 4,
                baseHP: 28,
                baseArmor: 0,
                baseSpeed: 1.1,
                baseAccuracy: 60,
                specialAbility: 'RAGE',  // +2% damage per 1% HP missing
                specialDesc: '+2% DMG per 1% HP Lost',
                price: 20,
                rarity: 'epic',
                slots: {
                    torso: { cols: 2, rows: 2 },
                    leftArm: { cols: 2, rows: 3 },
                    rightArm: { cols: 2, rows: 3 },
                    leftLeg: { cols: 1, rows: 2 },
                    rightLeg: { cols: 1, rows: 2 }
                }
            }
        };

        // Player's owned mechs
        let ownedMechs = ['scout'];  // Start with scout

        // Currently selected mech for battle
        let activeMechId = 'scout';

        // Get active mech template
        function getActiveMech() {
            return MECH_TEMPLATES[activeMechId] || MECH_TEMPLATES.scout;
        }

        // ============================================
        // SHOP SYSTEM
        // ============================================
        const SHOP = {
            mechSlots: 2,      // Number of mechs in shop
            weaponSlots: 4,    // Number of weapons in shop
            bargainChance: 0.15 // 15% chance for bargain
        };

        let shopInventory = {
            mechs: [],      // Array of mech IDs available
            weapons: [],    // Array of weapon objects { itemId, isBargain, price }
            refreshes: 0,   // Free refreshes used this round
            buyback: []     // Items sold this turn that can be bought back for 1g
        };

        // Generate shop inventory
        function generateShopInventory() {
            shopInventory.mechs = [];
            shopInventory.weapons = [];
            shopInventory.refreshes = 0;
            shopInventory.buyback = [];  // Clear buyback items when new turn starts

            // Generate mech offerings based on round
            const availableMechs = Object.keys(MECH_TEMPLATES).filter(id => {
                const mech = MECH_TEMPLATES[id];
                // Don't offer mechs player already owns
                if (ownedMechs.includes(id)) return false;
                // Rarer mechs appear in later rounds
                if (mech.rarity === 'epic' && gameProgression.round < 5) return false;
                if (mech.rarity === 'legendary' && gameProgression.round < 8) return false;
                return true;
            });

            // Pick random mechs for shop
            const shuffledMechs = [...availableMechs].sort(() => Math.random() - 0.5);
            shopInventory.mechs = shuffledMechs.slice(0, SHOP.mechSlots);

            // Generate equipment offerings (mix of weapons and other equipment)
            const allTemplates = Object.keys(ITEM_TEMPLATES);
            const weaponTemplates = allTemplates.filter(key => ITEM_TEMPLATES[key].type === 'WEAPON');
            const equipTemplates = allTemplates.filter(key => ITEM_TEMPLATES[key].type !== 'WEAPON');

            for (let i = 0; i < SHOP.weaponSlots; i++) {
                // 60% weapons, 40% other equipment
                const useWeapon = Math.random() < 0.6;
                const templates = useWeapon ? weaponTemplates : equipTemplates;
                const templateType = templates[Math.floor(Math.random() * templates.length)];
                const rarity = getShopWeaponRarity();
                const level = Math.max(1, Math.floor(gameProgression.round / 3) + 1);
                const item = generateComponent(templateType, level, rarity);

                if (item) {
                    registerGeneratedComponent(item);

                    const isBargain = Math.random() < SHOP.bargainChance;
                    const basePrice = ECONOMY.weaponPrices[rarity] || 5;
                    const price = isBargain ?
                        Math.floor(basePrice * ECONOMY.bargainDiscount) :
                        basePrice;

                    shopInventory.weapons.push({
                        itemId: item.id,
                        isBargain: isBargain,
                        price: price,
                        originalPrice: basePrice
                    });
                }
            }
        }

        // Get weapon rarity based on round (better items later)
        function getShopWeaponRarity() {
            const round = gameProgression.round;
            const rand = Math.random();

            // Rarity chances improve with rounds
            const legendaryChance = Math.min(0.02 + round * 0.01, 0.15);
            const epicChance = Math.min(0.05 + round * 0.02, 0.25);
            const rareChance = Math.min(0.15 + round * 0.03, 0.35);
            const uncommonChance = 0.30;

            if (rand < legendaryChance) return 'legendary';
            if (rand < legendaryChance + epicChance) return 'epic';
            if (rand < legendaryChance + epicChance + rareChance) return 'rare';
            if (rand < legendaryChance + epicChance + rareChance + uncommonChance) return 'uncommon';
            return 'common';
        }

        // Buy mech from shop
        function buyMech(mechId) {
            const mech = MECH_TEMPLATES[mechId];
            if (!mech) return { success: false, reason: 'Mech not found' };
            if (ownedMechs.includes(mechId)) return { success: false, reason: 'Already owned' };
            if (playerResources.gold < mech.price) return { success: false, reason: 'Not enough gold' };

            playerResources.gold -= mech.price;
            ownedMechs.push(mechId);

            // Remove from shop
            const idx = shopInventory.mechs.indexOf(mechId);
            if (idx > -1) shopInventory.mechs.splice(idx, 1);

            return { success: true };
        }

        // Buy weapon from shop
        function buyWeapon(shopIndex) {
            if (shopIndex < 0 || shopIndex >= shopInventory.weapons.length) {
                return { success: false, reason: 'Invalid shop index' };
            }

            const shopItem = shopInventory.weapons[shopIndex];
            if (playerResources.gold < shopItem.price) {
                return { success: false, reason: 'Not enough gold' };
            }

            // Add directly to bench
            addItemToBench(shopItem.itemId);
            playerResources.gold -= shopItem.price;

            // Remove from shop
            shopInventory.weapons.splice(shopIndex, 1);

            return { success: true };
        }

        // Refresh shop
        function refreshShop() {
            if (playerResources.gold < ECONOMY.shopRefreshCost) {
                return { success: false, reason: 'Not enough gold' };
            }
            playerResources.gold -= ECONOMY.shopRefreshCost;
            generateShopInventory();
            return { success: true };
        }

        // Loadout state (items placed on mech)
        let loadoutState = {
            mechId: MECH_CHASSIS.id,
            equipment: []  // Array of { itemId, instanceId, position: {x, y}, rotation }
        };

        // Track locked items (cannot be moved this round - e.g. heat sinks after placement)
        let lockedItems = new Set();

        // Unified grid occupation tracking (single mech-shaped grid)
        let unifiedGridOccupation = null;  // InventoryGrid instance for the unified mech grid
        let gridElements = {};  // For backwards compat - now just stores the unified grid element

        // ============================================
        // 2D GRID DATA STRUCTURE CLASS (Supports mech-shaped grids)
        // ============================================
        class MechGrid {
            constructor(cols, rows, shapeMatrix) {
                this.cols = cols;
                this.rows = rows;
                this.shapeMatrix = shapeMatrix;  // 2D array where 1=valid cell, 0=invalid
                this.cells = [];
                for (let y = 0; y < rows; y++) {
                    this.cells[y] = [];
                    for (let x = 0; x < cols; x++) {
                        // Use 'invalid' for cells outside the mech shape, null for empty valid cells
                        this.cells[y][x] = shapeMatrix[y][x] === 1 ? null : 'invalid';
                    }
                }
            }

            isValidCell(x, y) {
                if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) return false;
                return this.shapeMatrix[y][x] === 1;
            }

            canPlaceItem(item, posX, posY) {
                const shape = item.gridShape;
                const h = shape.length;
                const w = shape[0].length;

                // Check each cell of the shape
                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        if (shape[dy][dx] === 1) {
                            const cellX = posX + dx;
                            const cellY = posY + dy;
                            // Check if position is valid in mech shape
                            if (!this.isValidCell(cellX, cellY)) {
                                return false;
                            }
                            // Check if cell is occupied
                            if (this.cells[cellY][cellX] !== null) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            placeItem(item, posX, posY, instanceId) {
                const shape = item.gridShape;
                const h = shape.length;
                const w = shape[0].length;

                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        if (shape[dy][dx] === 1) {
                            this.cells[posY + dy][posX + dx] = instanceId;
                        }
                    }
                }
            }

            removeItem(instanceId) {
                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        if (this.cells[y][x] === instanceId) {
                            this.cells[y][x] = null;
                        }
                    }
                }
            }

            isCellOccupied(x, y) {
                if (!this.isValidCell(x, y)) return true;
                return this.cells[y][x] !== null;
            }
        }

        // Initialize the unified mech grid
        function initializeGrids() {
            unifiedGridOccupation = new MechGrid(
                MECH_CHASSIS.gridCols,
                MECH_CHASSIS.gridRows,
                MECH_CHASSIS.gridShape
            );
        }

        // ============================================
        // ITEM MANAGEMENT (NO DECK - PERSISTENT BENCH)
        // ============================================

        // Shuffle an array in place
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // Add an item to the bench
        function addItemToBench(itemId, instanceId = null) {
            const item = ITEM_DATABASE[itemId];
            if (!item) return null;

            const newItem = {
                ...item,
                instanceId: instanceId || `item_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
            };
            benchItems.push(newItem);
            return newItem;
        }

        // Remove an item from the bench by instanceId
        function removeItemFromBench(instanceId) {
            const idx = benchItems.findIndex(item => item.instanceId === instanceId);
            if (idx !== -1) {
                return benchItems.splice(idx, 1)[0];
            }
            return null;
        }

        // Get item from bench by instanceId
        function getBenchItem(instanceId) {
            return benchItems.find(item => item.instanceId === instanceId);
        }

        // Rotate an item's gridShape 90 degrees clockwise
        function rotateItemShape(item) {
            const shape = item.gridShape;
            const rows = shape.length;
            const cols = shape[0].length;

            // Create new rotated shape (swap dimensions)
            const newShape = [];
            for (let x = 0; x < cols; x++) {
                newShape[x] = [];
                for (let y = rows - 1; y >= 0; y--) {
                    newShape[x][rows - 1 - y] = shape[y][x];
                }
            }

            // Update item shape
            item.gridShape = newShape;
            item.gridDimensions = { w: rows, h: cols };  // Swap dimensions

            // Rotate effect direction if item has directional effects (90 degrees clockwise)
            if (item.special && item.special.effectDirection) {
                const dirRotation = { up: 'right', right: 'down', down: 'left', left: 'up' };
                item.special.effectDirection = dirRotation[item.special.effectDirection] || item.special.effectDirection;
            }

            // Re-render bench to show updated shape
            renderBench();
        }

        // Rotate an item that's already placed on the grid
        function rotateItemOnGrid(instanceId, element) {
            // Find the equipment entry
            const eqIdx = loadoutState.equipment.findIndex(eq => eq.instanceId === instanceId);
            if (eqIdx === -1) return;

            const eq = loadoutState.equipment[eqIdx];
            const item = eq.item || ITEM_DATABASE[eq.itemId];
            if (!item) return;

            const currentShape = item.gridShape;
            const currentPos = eq.position;

            // Calculate what the rotated shape would be
            const rows = currentShape.length;
            const cols = currentShape[0].length;
            const newShape = [];
            for (let x = 0; x < cols; x++) {
                newShape[x] = [];
                for (let y = rows - 1; y >= 0; y--) {
                    newShape[x][rows - 1 - y] = currentShape[y][x];
                }
            }

            // Temporarily clear this item's cells from grid occupation (without removing from loadout)
            clearGridCells(instanceId);

            // Check if all cells of the new shape are valid and unoccupied
            const newRows = newShape.length;
            const newCols = newShape[0].length;
            let canPlace = true;

            for (let dy = 0; dy < newRows && canPlace; dy++) {
                for (let dx = 0; dx < newCols && canPlace; dx++) {
                    if (newShape[dy][dx] === 1) {
                        const gx = currentPos.x + dx;
                        const gy = currentPos.y + dy;
                        // Check bounds
                        if (gx < 0 || gx >= MECH_CHASSIS.gridCols ||
                            gy < 0 || gy >= MECH_CHASSIS.gridRows) {
                            canPlace = false;
                            break;
                        }
                        // Check if cell is valid (part of mech shape)
                        if (!unifiedGridOccupation.isValidCell(gx, gy)) {
                            canPlace = false;
                            break;
                        }
                        // Check if cell is occupied by another item
                        if (unifiedGridOccupation.cells[gy][gx] !== null) {
                            canPlace = false;
                            break;
                        }
                    }
                }
            }

            if (canPlace) {
                // Apply the rotation
                item.gridShape = newShape;
                item.gridDimensions = { w: rows, h: cols };  // Swap dimensions

                // Rotate effect direction if item has directional effects
                if (item.special && item.special.effectDirection) {
                    const dirRotation = { up: 'right', right: 'down', down: 'left', left: 'up' };
                    item.special.effectDirection = dirRotation[item.special.effectDirection] || item.special.effectDirection;
                }

                // Re-add item to grid with new shape
                placeGridCells(item, currentPos.x, currentPos.y, instanceId);

                // Re-render
                renderUnifiedGridItems();
                updateStats();
            } else {
                // Flash red to indicate blocked rotation
                if (element) {
                    element.classList.add('rotation-blocked');
                    setTimeout(() => {
                        element.classList.remove('rotation-blocked');
                    }, 300);
                }

                // Re-add item to grid with original shape (restore state)
                placeGridCells(item, currentPos.x, currentPos.y, instanceId);
            }
        }

        // Clear grid cells for an item (without removing from loadoutState)
        function clearGridCells(instanceId) {
            for (let y = 0; y < MECH_CHASSIS.gridRows; y++) {
                for (let x = 0; x < MECH_CHASSIS.gridCols; x++) {
                    if (unifiedGridOccupation.cells[y][x] === instanceId) {
                        unifiedGridOccupation.cells[y][x] = null;
                    }
                }
            }
        }

        // Place grid cells for an item (without adding to loadoutState)
        function placeGridCells(item, gridX, gridY, instanceId) {
            const shape = item.gridShape;
            for (let dy = 0; dy < shape.length; dy++) {
                for (let dx = 0; dx < shape[0].length; dx++) {
                    if (shape[dy][dx] === 1) {
                        unifiedGridOccupation.cells[gridY + dy][gridX + dx] = instanceId;
                    }
                }
            }
        }

        // ============================================
        // DRAG & DROP SYSTEM
        // ============================================
        let dragState = {
            isDragging: false,
            item: null,
            sourceType: null,  // 'bench' or 'grid'
            sourceSlot: null,
            sourcePosition: null,
            startX: 0,
            startY: 0
        };

        let placedItemElements = {};  // Store references to placed item DOM elements

        function initDragAndDrop() {
            const dragGhost = document.getElementById('dragGhost');

            // Touch/Mouse event handlers
            document.addEventListener('mousedown', handleDragStart);
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);

            document.addEventListener('touchstart', handleDragStart, { passive: false });
            document.addEventListener('touchmove', handleDragMove, { passive: false });
            document.addEventListener('touchend', handleDragEnd);
        }

        function handleDragStart(e) {
            const touch = e.touches ? e.touches[0] : e;
            const target = document.elementFromPoint(touch.clientX, touch.clientY);

            // Skip if clicking on rotate button
            if (target.closest('.rotate-btn')) {
                return;  // Let the rotate button handle its own click
            }

            // Check if we clicked on a bench item (supports both old and new class names)
            const benchItem = target.closest('.bench-item-vertical') || target.closest('.bench-item');
            if (benchItem) {
                e.preventDefault();
                const instanceId = benchItem.dataset.instanceId;
                const item = benchItems.find(i => i.instanceId === instanceId);
                if (item) {
                    startDrag(item, 'bench', null, null, touch.clientX, touch.clientY);
                    benchItem.classList.add('dragging');
                }
                return;
            }

            // Check if we clicked on a placed item (unified grid)
            const placedItem = target.closest('.placed-item-unified');
            if (placedItem) {
                e.preventDefault();
                const instanceId = placedItem.dataset.instanceId;

                // Check if item is locked (e.g., heat sink after placement)
                if (lockedItems.has(instanceId)) {
                    return;  // Cannot drag locked items
                }

                const equipment = loadoutState.equipment.find(eq => eq.instanceId === instanceId);
                if (equipment) {
                    const item = equipment.item || { ...ITEM_DATABASE[equipment.itemId], instanceId };
                    startDrag(item, 'grid', null, equipment.position, touch.clientX, touch.clientY);

                    // Remove from grid temporarily
                    removeItemFromGrid(instanceId);
                    placedItem.style.opacity = '0.3';
                }
                return;
            }
        }

        function startDrag(item, sourceType, sourceSlot, sourcePosition, x, y) {
            dragState = {
                isDragging: true,
                item: item,
                sourceType: sourceType,
                sourceSlot: sourceSlot,
                sourcePosition: sourcePosition,
                startX: x,
                startY: y
            };

            // Create ghost element
            const ghost = document.getElementById('dragGhost');
            ghost.innerHTML = createGhostHTML(item);
            ghost.style.display = 'block';
            ghost.style.left = x + 'px';
            ghost.style.top = y + 'px';

            // Highlight which grids are valid for this item
            updateSlotValidity(item);
        }

        function updateSlotValidity(item) {
            // With unified grid, all valid cells can accept any item
            // No slot-specific highlighting needed
        }

        function createGhostHTML(item) {
            const shape = item.gridShape;
            const h = shape.length;
            const w = shape[0].length;

            let cellsHTML = '';
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    if (shape[y][x] === 1) {
                        cellsHTML += '<div class="ghost-cell"></div>';
                    } else {
                        // Add empty placeholder cell for proper grid layout
                        cellsHTML += '<div class="ghost-cell-empty"></div>';
                    }
                }
            }

            return `<div class="ghost-grid" style="grid-template-columns: repeat(${w}, 38px);">${cellsHTML}</div>`;
        }

        function handleDragMove(e) {
            if (!dragState.isDragging) return;
            e.preventDefault();

            const touch = e.touches ? e.touches[0] : e;
            const ghost = document.getElementById('dragGhost');
            ghost.style.left = touch.clientX + 'px';
            ghost.style.top = touch.clientY + 'px';

            // Check for valid drop target
            const dropInfo = getDropTarget(touch.clientX, touch.clientY);
            updateDropHighlight(dropInfo);

            // Check if over bench (for items from grid)
            const benchPanel = document.getElementById('benchPanel');
            let overBench = false;
            if (benchPanel) {
                const benchRect = benchPanel.getBoundingClientRect();
                overBench = dragState.sourceType === 'grid' &&
                            touch.clientX >= benchRect.left &&
                            touch.clientX <= benchRect.right &&
                            touch.clientY >= benchRect.top &&
                            touch.clientY <= benchRect.bottom;

                if (overBench) {
                    benchPanel.classList.add('drop-target');
                    ghost.classList.remove('invalid');
                } else {
                    benchPanel.classList.remove('drop-target');
                }
            }

            // Update ghost validity
            if (dropInfo && dropInfo.valid) {
                ghost.classList.remove('invalid');
            } else if (dropInfo && !overBench) {
                ghost.classList.add('invalid');
            }
        }

        function handleDragEnd(e) {
            if (!dragState.isDragging) return;

            const touch = e.changedTouches ? e.changedTouches[0] : e;
            const dropInfo = getDropTarget(touch.clientX, touch.clientY);

            // Check if dropped on bench panel area
            const benchPanel = document.getElementById('benchPanel');
            let droppedOnBench = false;
            if (benchPanel) {
                const benchRect = benchPanel.getBoundingClientRect();
                droppedOnBench = touch.clientX >= benchRect.left &&
                                 touch.clientX <= benchRect.right &&
                                 touch.clientY >= benchRect.top &&
                                 touch.clientY <= benchRect.bottom;
            }

            if (dropInfo && dropInfo.valid) {
                // Place item on grid
                placeItemOnGrid(dragState.item, dropInfo.gridX, dropInfo.gridY);

                // Remove from bench if it came from there
                if (dragState.sourceType === 'bench') {
                    removeItemFromBench(dragState.item.instanceId);
                }
            } else if (droppedOnBench && dragState.sourceType === 'grid') {
                // Return item to bench
                benchItems.push(dragState.item);
            } else if (dragState.sourceType === 'grid') {
                // Return to original position on grid
                placeItemOnGrid(
                    dragState.item,
                    dragState.sourcePosition.x,
                    dragState.sourcePosition.y
                );
            }

            // Cleanup
            cleanupDrag();
            renderBench();
            renderUnifiedGridItems();
            updateStats();
        }

        function cleanupDrag() {
            document.querySelectorAll('.bench-item-vertical.dragging').forEach(el => el.classList.remove('dragging'));
            document.querySelectorAll('.placed-item-unified').forEach(el => el.style.opacity = '1');
            document.querySelectorAll('.mech-cell').forEach(el => {
                el.classList.remove('valid-drop', 'invalid-drop');
            });
            const benchPanel = document.getElementById('benchPanel');
            if (benchPanel) benchPanel.classList.remove('drop-target');

            const ghost = document.getElementById('dragGhost');
            ghost.style.display = 'none';
            ghost.classList.remove('invalid');

            dragState = {
                isDragging: false,
                item: null,
                sourceType: null,
                sourceSlot: null,
                sourcePosition: null,
                startX: 0,
                startY: 0
            };
        }

        function getDropTarget(clientX, clientY) {
            if (!dragState.item) return null;

            // Check the unified mech grid
            const gridEl = document.getElementById('unifiedMechGrid');
            if (!gridEl) return null;

            const rect = gridEl.getBoundingClientRect();

            if (clientX >= rect.left && clientX <= rect.right &&
                clientY >= rect.top && clientY <= rect.bottom) {

                // Calculate grid cell position
                const cellSize = 47;  // 45px + 2px gap
                const padding = 10;
                const localX = clientX - rect.left - padding;
                const localY = clientY - rect.top - padding;

                const item = dragState.item;
                const shape = item.gridShape;
                const itemW = shape[0].length;
                const itemH = shape.length;

                // Calculate the cell the cursor is over
                const cursorCellX = Math.floor(localX / cellSize);
                const cursorCellY = Math.floor(localY / cellSize);

                // Calculate centered position for highlighting (same for valid and invalid)
                let highlightX = cursorCellX - Math.floor(itemW / 2);
                let highlightY = cursorCellY - Math.floor(itemH / 2);
                // Clamp to grid bounds
                highlightX = Math.max(0, Math.min(highlightX, MECH_CHASSIS.gridCols - itemW));
                highlightY = Math.max(0, Math.min(highlightY, MECH_CHASSIS.gridRows - itemH));

                // Check if this position is valid for placement
                const canPlace = unifiedGridOccupation && unifiedGridOccupation.canPlaceItem(item, highlightX, highlightY);

                return {
                    gridX: highlightX,
                    gridY: highlightY,
                    valid: canPlace
                };
            }

            return null;
        }

        function findBestPosition(grid, item, cursorX, cursorY) {
            const itemW = item.gridShape[0].length;
            const itemH = item.gridShape.length;

            // Centered position
            const centerX = cursorX - Math.floor(itemW / 2);
            const centerY = cursorY - Math.floor(itemH / 2);

            // Search in expanding rings around cursor
            const maxRadius = Math.max(MECH_CHASSIS.gridCols, MECH_CHASSIS.gridRows);
            for (let radius = 0; radius <= maxRadius; radius++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        if (radius > 0 && Math.abs(dx) !== radius && Math.abs(dy) !== radius) continue;

                        const testX = centerX + dx;
                        const testY = centerY + dy;

                        // Check bounds
                        if (testX < 0 || testY < 0 ||
                            testX + itemW > MECH_CHASSIS.gridCols ||
                            testY + itemH > MECH_CHASSIS.gridRows) continue;

                        // Check if can place
                        if (grid && grid.canPlaceItem(item, testX, testY)) {
                            return { x: testX, y: testY };
                        }
                    }
                }
            }

            return null;  // No valid position found
        }

        function updateDropHighlight(dropInfo) {
            // Clear all highlights
            document.querySelectorAll('.mech-cell').forEach(el => {
                el.classList.remove('valid-drop', 'invalid-drop');
            });

            if (!dropInfo || !dragState.item) return;

            const gridEl = document.getElementById('unifiedMechGrid');
            if (!gridEl) return;

            const item = dragState.item;
            const shape = item.gridShape;
            const cells = gridEl.querySelectorAll('.mech-cell');

            // Highlight cells that would be covered
            for (let dy = 0; dy < shape.length; dy++) {
                for (let dx = 0; dx < shape[0].length; dx++) {
                    if (shape[dy][dx] === 1) {
                        const cellX = dropInfo.gridX + dx;
                        const cellY = dropInfo.gridY + dy;

                        // Check bounds before calculating index
                        if (cellX < 0 || cellX >= MECH_CHASSIS.gridCols || cellY < 0 || cellY >= MECH_CHASSIS.gridRows) {
                            continue;  // Skip out-of-bounds cells
                        }

                        const cellIdx = cellY * MECH_CHASSIS.gridCols + cellX;

                        if (cellIdx >= 0 && cellIdx < cells.length) {
                            cells[cellIdx].classList.add(dropInfo.valid ? 'valid-drop' : 'invalid-drop');
                        }
                    }
                }
            }
        }

        function placeItemOnGrid(item, gridX, gridY) {
            const instanceId = item.instanceId;
            const itemDef = item;

            // Add to loadout state
            loadoutState.equipment.push({
                instanceId: instanceId,
                itemId: item.id || item.itemId,
                item: item,  // Store full item data
                position: { x: gridX, y: gridY },
                rotation: 0
            });

            // Mark grid cells as occupied
            unifiedGridOccupation.placeItem(item, gridX, gridY, instanceId);

            // Handle special placement effects
            if (itemDef && itemDef.special) {
                // Lock the item so it cannot be moved this round
                if (itemDef.special.locksOnPlace) {
                    lockedItems.add(instanceId);
                }
            }
        }

        function removeItemFromGrid(instanceId) {
            // Find the equipment entry
            const equipment = loadoutState.equipment.find(eq => eq.instanceId === instanceId);

            // Remove from loadout
            const idx = loadoutState.equipment.findIndex(eq => eq.instanceId === instanceId);
            if (idx !== -1) {
                loadoutState.equipment.splice(idx, 1);
            }

            // Clear grid cells
            unifiedGridOccupation.removeItem(instanceId);

            return equipment;  // Return for re-adding to bench
        }

        // Click to remove placed item
        function handlePlacedItemClick(instanceId) {
            // Check if item is locked (e.g., heat sink after placement)
            if (lockedItems.has(instanceId)) {
                return;  // Cannot remove locked items
            }

            const equipment = loadoutState.equipment.find(eq => eq.instanceId === instanceId);
            if (!equipment) return;

            const item = equipment.item || { ...ITEM_DATABASE[equipment.itemId], instanceId };

            // Remove from grid
            removeItemFromGrid(instanceId);

            // Add back to bench
            benchItems.push(item);

            renderBench();
            renderUnifiedGridItems();
            updateStats();
        }

        // ============================================
        // UI RENDERING
        // ============================================
        function renderBench() {
            const benchScroll = document.getElementById('benchScroll');
            const benchEmpty = document.getElementById('benchEmpty');
            if (!benchScroll) return;

            benchScroll.innerHTML = '';

            if (benchItems.length === 0) {
                if (benchEmpty) benchEmpty.style.display = 'block';
                return;
            }

            if (benchEmpty) benchEmpty.style.display = 'none';

            benchItems.forEach(item => {
                const el = document.createElement('div');
                el.className = `bench-item-vertical ${item.category}`;
                el.dataset.instanceId = item.instanceId;

                // Get rarity color for generated items
                const isGenerated = item.isGenerated;
                const rarityColor = isGenerated ? (COMPONENT_GENERATION.rarityColors[item.rarity] || '#00ff88') : '#00ff88';

                // Apply rarity border color
                if (isGenerated) {
                    el.style.borderColor = rarityColor;
                }

                el.innerHTML = `
                    <div class="rotate-btn" title="Rotate (R)">â†»</div>
                    <span class="item-icon">${item.icon}</span>
                    <div class="item-info">
                        <div class="item-name" style="${isGenerated ? `color: ${rarityColor};` : ''}">${item.name}</div>
                        ${buildItemStatIcons(item)}
                        <div class="item-bottom-row">
                            ${buildItemSecondaryStats(item)}
                            ${buildInlineShapePreview(item, 8)}
                        </div>
                    </div>
                `;

                // Rotate button click
                const rotateBtn = el.querySelector('.rotate-btn');
                rotateBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    rotateItemShape(item);
                });

                // Add hover tooltip
                el.addEventListener('mouseenter', (e) => showItemTooltip(item, e));
                el.addEventListener('mousemove', moveItemTooltip);
                el.addEventListener('mouseleave', hideItemTooltip);

                // Make draggable
                el.addEventListener('mousedown', (e) => handleDragStart(e, item, 'bench'));
                el.addEventListener('touchstart', (e) => handleDragStart(e, item, 'bench'), { passive: false });

                benchScroll.appendChild(el);
            });
        }

        // Render the unified mech-shaped grid
        function renderUnifiedMechGrid() {
            const container = document.getElementById('unifiedMechGrid');
            if (!container) return;

            container.innerHTML = '';
            container.style.gridTemplateColumns = `repeat(${MECH_CHASSIS.gridCols}, 45px)`;

            // Create cells for the mech grid
            for (let y = 0; y < MECH_CHASSIS.gridRows; y++) {
                for (let x = 0; x < MECH_CHASSIS.gridCols; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'mech-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;

                    // Mark invalid cells (not part of mech shape)
                    if (MECH_CHASSIS.gridShape[y][x] === 0) {
                        cell.classList.add('invalid');
                    }

                    container.appendChild(cell);
                }
            }

            // Store reference
            gridElements.unified = container;
        }

        // Render placed items on the unified grid
        function renderUnifiedGridItems() {
            // Remove old placed items
            document.querySelectorAll('.placed-item-unified').forEach(el => el.remove());

            const container = document.getElementById('unifiedMechGrid');
            if (!container || !unifiedGridOccupation) return;

            const cellSize = 45;
            const gap = 2;

            // Update cell states (occupied highlighting)
            const cells = container.querySelectorAll('.mech-cell');
            cells.forEach(cell => {
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                if (unifiedGridOccupation.isValidCell(x, y)) {
                    cell.classList.toggle('occupied', unifiedGridOccupation.cells[y][x] !== null);
                }
            });

            // Calculate adjacency bonuses for visual display
            const adjacencyBonuses = calculateAdjacencyBonuses();

            // Render placed items
            loadoutState.equipment.forEach(eq => {
                const item = eq.item || ITEM_DATABASE[eq.itemId];
                if (!item) return;

                const shape = item.gridShape;
                const w = shape[0].length;
                const h = shape.length;

                // Get adjacency bonus for this item (if it's a weapon)
                const adjBonus = adjacencyBonuses[eq.instanceId] || 0;

                // Create a container for the item that spans the bounding box
                const placedEl = document.createElement('div');
                placedEl.className = `placed-item-unified ${item.category}`;
                placedEl.dataset.instanceId = eq.instanceId;

                // Position based on grid cell
                placedEl.style.position = 'absolute';
                placedEl.style.left = `${10 + eq.position.x * (cellSize + gap)}px`;
                placedEl.style.top = `${10 + eq.position.y * (cellSize + gap)}px`;
                placedEl.style.width = `${w * cellSize + (w - 1) * gap}px`;
                placedEl.style.height = `${h * cellSize + (h - 1) * gap}px`;
                placedEl.style.background = 'transparent';
                placedEl.style.border = 'none';

                // Add glow effect if receiving adjacency bonus
                if (adjBonus > 0) {
                    placedEl.style.filter = 'drop-shadow(0 0 6px #ffcc00)';
                }

                // Build the shape cells
                let shapeCellsHtml = '';
                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        if (shape[dy][dx] === 1) {
                            const cellLeft = dx * (cellSize + gap);
                            const cellTop = dy * (cellSize + gap);
                            // Add golden border if receiving bonus
                            const bonusBorder = adjBonus > 0 ? 'box-shadow: 0 0 8px #ffcc00, inset 0 0 4px rgba(255,204,0,0.3);' : '';
                            shapeCellsHtml += `<div class="item-shape-cell" style="
                                position: absolute;
                                left: ${cellLeft}px;
                                top: ${cellTop}px;
                                width: ${cellSize}px;
                                height: ${cellSize}px;
                                background: var(--item-bg);
                                border: 2px solid var(--item-border);
                                border-radius: 4px;
                                box-sizing: border-box;
                                ${bonusBorder}
                            "></div>`;
                        }
                    }
                }

                // Find center cell for icon placement
                let centerX = 0, centerY = 0, cellCount = 0;
                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        if (shape[dy][dx] === 1) {
                            centerX += dx;
                            centerY += dy;
                            cellCount++;
                        }
                    }
                }
                centerX = Math.floor(centerX / cellCount);
                centerY = Math.floor(centerY / cellCount);

                const iconLeft = centerX * (cellSize + gap) + cellSize / 2;
                const iconTop = centerY * (cellSize + gap) + cellSize / 2;

                // Build tooltip HTML with adjacency bonus info
                const tooltipHtml = buildItemTooltipHtmlWithBonus(item, adjBonus);

                // Build direction indicator for directional damage items
                let directionHtml = '';
                if (item.stats?.directionalDamageBonus && item.special?.effectDirection) {
                    const dir = item.special.effectDirection;
                    const dirArrow = { up: 'â†‘', down: 'â†“', left: 'â†', right: 'â†’' }[dir] || 'â†‘';
                    // Position arrow based on direction
                    const arrowOffsets = {
                        up: { left: iconLeft, top: iconTop - 18 },
                        down: { left: iconLeft, top: iconTop + 18 },
                        left: { left: iconLeft - 18, top: iconTop },
                        right: { left: iconLeft + 18, top: iconTop }
                    };
                    const offset = arrowOffsets[dir] || arrowOffsets.up;
                    directionHtml = `<div class="direction-arrow" style="
                        position: absolute;
                        left: ${offset.left}px;
                        top: ${offset.top}px;
                        transform: translate(-50%, -50%);
                        font-size: 16px;
                        font-weight: bold;
                        color: #ff8844;
                        text-shadow: 0 0 4px #ff4400;
                        z-index: 3;
                        pointer-events: none;
                    ">${dirArrow}</div>`;
                }

                // Show bonus indicator badge
                let bonusBadgeHtml = '';
                if (adjBonus > 0) {
                    bonusBadgeHtml = `<div style="
                        position: absolute;
                        top: -8px;
                        right: -8px;
                        background: #ffcc00;
                        color: #000;
                        font-size: 10px;
                        font-weight: bold;
                        padding: 2px 4px;
                        border-radius: 4px;
                        z-index: 25;
                        pointer-events: none;
                    ">+${adjBonus}</div>`;
                }

                placedEl.innerHTML = `
                    ${shapeCellsHtml}
                    <div class="item-icon-overlay" style="
                        position: absolute;
                        left: ${iconLeft}px;
                        top: ${iconTop}px;
                        transform: translate(-50%, -50%);
                        font-size: 24px;
                        z-index: 2;
                        pointer-events: none;
                    ">${item.icon}</div>
                    ${directionHtml}
                    ${bonusBadgeHtml}
                    ${tooltipHtml}
                `;

                // Click to rotate (if not dragging)
                let clickStartTime = 0;
                let clickStartPos = { x: 0, y: 0 };
                placedEl.addEventListener('mousedown', (e) => {
                    clickStartTime = Date.now();
                    clickStartPos = { x: e.clientX, y: e.clientY };
                    handleDragStart(e, { ...item, instanceId: eq.instanceId }, 'grid');
                });
                placedEl.addEventListener('mouseup', (e) => {
                    const elapsed = Date.now() - clickStartTime;
                    const moved = Math.abs(e.clientX - clickStartPos.x) + Math.abs(e.clientY - clickStartPos.y);
                    // If it was a quick click without much movement, rotate
                    if (elapsed < 200 && moved < 10) {
                        rotateItemOnGrid(eq.instanceId, placedEl);
                    }
                });
                placedEl.addEventListener('touchstart', (e) => {
                    clickStartTime = Date.now();
                    const touch = e.touches[0];
                    clickStartPos = { x: touch.clientX, y: touch.clientY };
                    handleDragStart(e, { ...item, instanceId: eq.instanceId }, 'grid');
                }, { passive: false });
                placedEl.addEventListener('touchend', (e) => {
                    const elapsed = Date.now() - clickStartTime;
                    // For touch, we can't easily get end position from touchend, so just check time
                    if (elapsed < 200 && !dragState.isDragging) {
                        rotateItemOnGrid(eq.instanceId, placedEl);
                    }
                });

                container.appendChild(placedEl);
            });
        }

        // Build compact stat icons row for item cards
        function buildItemStatIcons(item) {
            const stats = item.stats || {};
            const battle = item.battle || {};

            let html = '<div class="item-stat-row">';

            // Damage (with xN for multi-shot) - using flame icon
            if (stats.damage) {
                const shotsPerRound = battle.shotsPerRound || 1;
                if (shotsPerRound > 1) {
                    html += `<span class="item-stat damage"><span class="item-stat-icon">ðŸ’¥</span><span class="item-stat-value">${stats.damage}x${shotsPerRound}</span></span>`;
                } else {
                    html += `<span class="item-stat damage"><span class="item-stat-icon">ðŸ’¥</span><span class="item-stat-value">${stats.damage}</span></span>`;
                }
            }

            // Armor (old style - legacy support)
            if (stats.armorBonus) {
                html += `<span class="item-stat armor"><span class="item-stat-icon">ðŸ›¡</span><span class="item-stat-value">+${stats.armorBonus}</span></span>`;
            }

            // Damage Reduction (reduces ballistic/missile damage)
            if (stats.damageReduction) {
                html += `<span class="item-stat" style="color: #888;"><span class="item-stat-icon">ðŸ›¡ï¸</span><span class="item-stat-value">-${stats.damageReduction} dmg</span></span>`;
            }

            // HP Bonus (adds to max HP)
            if (stats.hpBonus) {
                html += `<span class="item-stat" style="color: #ff4466;"><span class="item-stat-icon">â¤ï¸</span><span class="item-stat-value">+${stats.hpBonus}</span></span>`;
            }

            // Energy Shield HP (absorbs energy weapon damage)
            if (stats.energyShieldHP) {
                html += `<span class="item-stat" style="color: #44aaff;"><span class="item-stat-icon">ðŸ”µ</span><span class="item-stat-value">${stats.energyShieldHP}</span></span>`;
            }

            // Energy generation (negative energyDraw means provides energy)
            if (stats.energyDraw < 0) {
                html += `<span class="item-stat" style="color: #4488ff;"><span class="item-stat-icon">âš¡</span><span class="item-stat-value">+${Math.abs(stats.energyDraw)}</span></span>`;
            }

            // Adjacent weapon damage bonus
            if (stats.adjacentDamageBonus) {
                html += `<span class="item-stat" style="color: #ff8844;"><span class="item-stat-icon">âš”ï¸</span><span class="item-stat-value">+${stats.adjacentDamageBonus} adj</span></span>`;
            }

            // Adjacent armor bonus
            if (stats.adjacentArmorBonus) {
                html += `<span class="item-stat" style="color: #88ccff;"><span class="item-stat-icon">ðŸ›¡ï¸</span><span class="item-stat-value">+${stats.adjacentArmorBonus} adj</span></span>`;
            }

            // Adjacent energy bonus
            if (stats.adjacentEnergyBonus) {
                html += `<span class="item-stat" style="color: #ffcc44;"><span class="item-stat-icon">âš¡</span><span class="item-stat-value">+${stats.adjacentEnergyBonus} adj</span></span>`;
            }

            // Energy reduction (cooling)
            if (stats.energyReduction) {
                html += `<span class="item-stat" style="color: #44ddff;"><span class="item-stat-icon">â„ï¸</span><span class="item-stat-value">-${stats.energyReduction}</span></span>`;
            }

            // Directional damage bonus (targeting links - one direction only)
            if (stats.directionalDamageBonus) {
                // Get direction from special property or default to 'up'
                const dir = item.special?.effectDirection || 'up';
                const dirArrow = { up: 'â†‘', down: 'â†“', left: 'â†', right: 'â†’' }[dir] || 'â†‘';
                html += `<span class="item-stat" style="color: #ff8844;"><span class="item-stat-icon">ðŸŽ¯</span><span class="item-stat-value">+${stats.directionalDamageBonus}${dirArrow}</span></span>`;
            }

            // Accuracy bonus
            if (stats.accuracyBonus) {
                html += `<span class="item-stat" style="color: #44ff88;"><span class="item-stat-icon">ðŸŽ¯</span><span class="item-stat-value">+${stats.accuracyBonus}%</span></span>`;
            }

            // Evasion bonus
            if (stats.evasionBonus) {
                html += `<span class="item-stat" style="color: #aaaaff;"><span class="item-stat-icon">ðŸ’¨</span><span class="item-stat-value">+${stats.evasionBonus}%</span></span>`;
            }

            html += '</div>';
            return html;
        }

        // Build secondary stat icons (energy, weight) for bottom left display
        function buildItemSecondaryStats(item) {
            const stats = item.stats || {};

            let html = '<div class="item-secondary-stats">';

            // Energy (negative = provides, positive = uses)
            if (stats.energyDraw !== undefined && stats.energyDraw !== 0) {
                if (stats.energyDraw < 0) {
                    html += `<span class="item-stat energy"><span class="item-stat-icon">âš¡</span><span class="item-stat-value">+${-stats.energyDraw}</span></span>`;
                } else {
                    html += `<span class="item-stat energy"><span class="item-stat-icon">âš¡</span><span class="item-stat-value">${stats.energyDraw}</span></span>`;
                }
            }

            // Weight
            if (stats.weight) {
                html += `<span class="item-stat weight"><span class="item-stat-icon">âš–</span><span class="item-stat-value">${stats.weight}</span></span>`;
            }

            html += '</div>';
            return html;
        }

        // Build shape preview HTML for hover display
        function buildItemShapePreview(item) {
            const shape = item.gridShape || [[1]];
            const rarityColor = (item.isGenerated && COMPONENT_GENERATION) ?
                (COMPONENT_GENERATION.rarityColors[item.rarity] || '#00aa66') : '#00aa66';

            const cols = shape[0].length;
            let html = `<div class="item-shape-preview">`;
            html += `<div class="shape-grid" style="grid-template-columns: repeat(${cols}, 10px);">`;

            for (let row of shape) {
                for (let cell of row) {
                    if (cell === 1) {
                        html += `<div class="shape-cell filled" style="background: ${rarityColor};"></div>`;
                    } else {
                        html += `<div class="shape-cell empty"></div>`;
                    }
                }
            }

            html += '</div></div>';
            return html;
        }

        // Build inline shape preview (always visible, not a tooltip)
        // Colors match the slot colors used on the mech grid
        const SLOT_TYPE_COLORS = {
            weapon: '#ff6644',
            armor: '#888888',
            reactor: '#44ddff',
            system: '#aa44ff',
            cooling: '#44ddff'
        };

        function buildInlineShapePreview(item, cellSize = 8) {
            const shape = item.gridShape || [[1]];
            const slotColor = SLOT_TYPE_COLORS[item.category] || '#00aa66';

            const cols = shape[0].length;
            let html = `<div style="display: inline-grid; gap: 2px; grid-template-columns: repeat(${cols}, ${cellSize}px);">`;
            for (let row of shape) {
                for (let cell of row) {
                    if (cell === 1) {
                        html += `<div style="width: ${cellSize}px; height: ${cellSize}px; background: ${slotColor}; border: 1px solid rgba(255,255,255,0.3); border-radius: 1px;"></div>`;
                    } else {
                        html += `<div style="width: ${cellSize}px; height: ${cellSize}px;"></div>`;
                    }
                }
            }
            html += '</div>';
            return html;
        }

        // Build tooltip HTML for an item
        function buildItemTooltipHtml(item) {
            const stats = item.stats || {};
            const battle = item.battle || {};
            let statsHtml = '';

            // Show damage with xN if fires multiple times per round - HIGHLIGHT MULTI-HIT!
            if (stats.damage) {
                const shotsPerRound = battle.shotsPerRound || 1;
                if (shotsPerRound > 1) {
                    const totalDmg = stats.damage * shotsPerRound;
                    // Calculate what damage would be with a +2 flat bonus to show synergy potential
                    const withBonus = (stats.damage + 2) * shotsPerRound;
                    statsHtml += `<div style="color: #ff8844; font-weight: bold;">ðŸ’¥ ${stats.damage} Ã— ${shotsPerRound} = ${totalDmg} dmg/round</div>`;
                    statsHtml += `<div style="color: #ffcc00; font-size: 10px;">â†³ With +2 bonus: ${stats.damage + 2} Ã— ${shotsPerRound} = ${withBonus} (+${withBonus - totalDmg}!)</div>`;
                } else {
                    statsHtml += `<div>ðŸ’¥ Damage: ${stats.damage}</div>`;
                }
            }
            if (stats.accuracy) statsHtml += `<div>ðŸŽ¯ Accuracy: ${stats.accuracy}%</div>`;
            if (stats.armorBonus) statsHtml += `<div>ðŸ›¡ï¸ Armor: +${stats.armorBonus}</div>`;
            if (stats.damageReduction) statsHtml += `<div>ðŸ›¡ï¸ Damage Reduction: -${stats.damageReduction} <span style="color: #888; font-size: 10px;">(highest only)</span></div>`;
            if (stats.hpBonus) statsHtml += `<div>â¤ï¸ HP: +${stats.hpBonus}</div>`;
            if (stats.energyShieldHP) statsHtml += `<div>ðŸ”µ Energy Shield: ${stats.energyShieldHP} HP</div>`;
            if (stats.energyDraw < 0) statsHtml += `<div>âš¡ Energy: +${-stats.energyDraw}</div>`;
            if (stats.energyDraw > 0) statsHtml += `<div>âš¡ Energy: ${stats.energyDraw}</div>`;
            if (stats.weight) statsHtml += `<div>âš–ï¸ Weight: ${stats.weight}</div>`;
            if (stats.heatCapacity) statsHtml += `<div>ðŸŒ¡ï¸ Heat Cap: +${stats.heatCapacity}</div>`;

            // Show adjacency bonus effects - KEY SYNERGY INFO
            if (stats.adjacentDamageBonus) {
                statsHtml += `<div style="color: #ff8844;">ðŸŽ¯ +${stats.adjacentDamageBonus} dmg to adjacent weapons</div>`;
                statsHtml += `<div style="color: #ffcc00; font-size: 10px;">â†³ MULTIPLIER: Chain Gun gets +${stats.adjacentDamageBonus * 8} total!</div>`;
            }
            if (stats.directionalDamageBonus) {
                // Check for multiple directions (rarity bonus)
                const directions = stats.effectDirections || [item.special?.effectDirection || 'up'];
                const arrows = directions.map(d => ({up: 'â†‘', down: 'â†“', left: 'â†', right: 'â†’'}[d])).join('');
                const dirCount = directions.length;
                if (dirCount > 1) {
                    statsHtml += `<div style="color: #ff8844;">ðŸŽ¯ +${stats.directionalDamageBonus} dmg in ${dirCount} directions ${arrows}</div>`;
                } else {
                    statsHtml += `<div style="color: #ff8844;">ðŸŽ¯ +${stats.directionalDamageBonus} dmg ${arrows} direction</div>`;
                }
            }

            // Show rarity bonuses if any
            if (stats.rarityBonuses && stats.rarityBonuses.length > 0) {
                const rarityColor = item.isGenerated && COMPONENT_GENERATION ?
                    (COMPONENT_GENERATION.rarityColors[item.rarity] || '#00ff88') : '#00ff88';
                statsHtml += `<div style="color: ${rarityColor}; font-size: 10px; margin-top: 4px; border-top: 1px solid ${rarityColor}33; padding-top: 4px;">`;
                statsHtml += `âœ¨ Rarity bonus: ${stats.rarityBonuses.join(', ')}</div>`;
            }

            let specialHtml = '';
            if (item.special) {
                if (item.special.damageBoost) specialHtml += `+${Math.round((item.special.damageBoost - 1) * 100)}% damage to adjacent weapons<br>`;
                if (item.special.adjacentArmorBoost) specialHtml += `+${item.special.adjacentArmorBoost} armor to adjacent items<br>`;
                if (item.special.energyPerAdjacentWeapon) specialHtml += `+${item.special.energyPerAdjacentWeapon} energy per adjacent weapon<br>`;
            }
            if (item.description) {
                specialHtml += item.description;
            }

            // Show synergy tags
            let synergyHtml = '';
            if (item.synergies && item.synergies.length > 0) {
                const tagColors = {
                    'multi-hit': '#ff8844',
                    'multi-hit-synergy': '#ffcc00',
                    'kinetic': '#888',
                    'energy': '#4488ff',
                    'explosive': '#ff4444',
                    'precision': '#44ff88',
                    'alpha-strike': '#ff44ff',
                    'amplifier': '#ffcc00',
                    'shredder': '#ff6600'
                };
                synergyHtml = '<div style="margin-top: 4px; display: flex; flex-wrap: wrap; gap: 3px;">';
                item.synergies.forEach(tag => {
                    const color = tagColors[tag] || '#666';
                    synergyHtml += `<span style="background: ${color}33; color: ${color}; padding: 1px 4px; border-radius: 3px; font-size: 9px; border: 1px solid ${color};">${tag}</span>`;
                });
                synergyHtml += '</div>';
            }

            // Show synergy description
            let synergyDescHtml = '';
            if (item.synergyDescription) {
                synergyDescHtml = `<div style="margin-top: 4px; color: #ffcc00; font-size: 10px; font-style: italic; border-left: 2px solid #ffcc00; padding-left: 6px;">${item.synergyDescription}</div>`;
            }

            const rarityColor = item.isGenerated && COMPONENT_GENERATION ?
                (COMPONENT_GENERATION.rarityColors[item.rarity] || '#00ff88') : '#00ff88';

            // Build inline shape preview for tooltip
            const shape = item.gridShape || [[1]];
            const cols = shape[0].length;
            let shapeHtml = `<div style="display: inline-grid; gap: 2px; grid-template-columns: repeat(${cols}, 12px); margin-top: 6px;">`;
            for (let row of shape) {
                for (let cell of row) {
                    if (cell === 1) {
                        shapeHtml += `<div style="width: 12px; height: 12px; background: ${rarityColor}; border: 1px solid rgba(255,255,255,0.3); border-radius: 2px;"></div>`;
                    } else {
                        shapeHtml += `<div style="width: 12px; height: 12px;"></div>`;
                    }
                }
            }
            shapeHtml += '</div>';

            return `
                <div class="item-tooltip">
                    <div class="tooltip-name" style="color: ${rarityColor};">${item.name}</div>
                    <div class="tooltip-stats">${statsHtml}</div>
                    ${specialHtml ? `<div class="tooltip-special">${specialHtml}</div>` : ''}
                    ${synergyHtml}
                    ${synergyDescHtml}
                    <div class="tooltip-shape" style="margin-top: 4px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 6px;">
                        <span style="font-size: 9px; color: #888;">Shape:</span>
                        ${shapeHtml}
                    </div>
                </div>
            `;
        }

        // Build tooltip HTML with adjacency bonus displayed
        function buildItemTooltipHtmlWithBonus(item, adjBonus = 0) {
            const stats = item.stats || {};
            const battle = item.battle || {};
            let statsHtml = '';

            // Show damage with adjacency bonus if applicable
            if (stats.damage) {
                const shotsPerRound = battle.shotsPerRound || 1;
                const baseDamage = stats.damage;
                const totalDamage = baseDamage + adjBonus;

                if (shotsPerRound > 1) {
                    const baseTotalDmg = baseDamage * shotsPerRound;
                    const boostedTotalDmg = totalDamage * shotsPerRound;

                    if (adjBonus > 0) {
                        // Show boosted damage prominently
                        statsHtml += `<div style="color: #ffcc00; font-weight: bold; font-size: 12px;">ðŸ’¥ ${baseDamage}+${adjBonus} Ã— ${shotsPerRound} = ${boostedTotalDmg} dmg</div>`;
                        statsHtml += `<div style="color: #888; font-size: 10px; text-decoration: line-through;">Base: ${baseDamage} Ã— ${shotsPerRound} = ${baseTotalDmg}</div>`;
                        statsHtml += `<div style="color: #00ff88; font-size: 10px;">ðŸŽ¯ SYNERGY ACTIVE: +${adjBonus * shotsPerRound} total damage!</div>`;
                    } else {
                        // Show potential synergy
                        const withBonus = (baseDamage + 2) * shotsPerRound;
                        statsHtml += `<div style="color: #ff8844; font-weight: bold;">ðŸ’¥ ${baseDamage} Ã— ${shotsPerRound} = ${baseTotalDmg} dmg/round</div>`;
                        statsHtml += `<div style="color: #666; font-size: 10px;">â†³ With +2 bonus: ${baseDamage + 2} Ã— ${shotsPerRound} = ${withBonus} (+${withBonus - baseTotalDmg}!)</div>`;
                    }
                } else {
                    if (adjBonus > 0) {
                        statsHtml += `<div style="color: #ffcc00; font-weight: bold;">ðŸ’¥ ${baseDamage}+${adjBonus} = ${totalDamage} damage</div>`;
                        statsHtml += `<div style="color: #00ff88; font-size: 10px;">ðŸŽ¯ SYNERGY ACTIVE!</div>`;
                    } else {
                        statsHtml += `<div>ðŸ’¥ Damage: ${baseDamage}</div>`;
                    }
                }
            }

            if (stats.accuracy) statsHtml += `<div>ðŸŽ¯ Accuracy: ${stats.accuracy}%</div>`;
            if (stats.armorBonus) statsHtml += `<div>ðŸ›¡ï¸ Armor: +${stats.armorBonus}</div>`;
            if (stats.damageReduction) statsHtml += `<div>ðŸ›¡ï¸ Damage Reduction: -${stats.damageReduction} <span style="color: #888; font-size: 10px;">(highest only)</span></div>`;
            if (stats.hpBonus) statsHtml += `<div>â¤ï¸ HP: +${stats.hpBonus}</div>`;
            if (stats.energyShieldHP) statsHtml += `<div>ðŸ”µ Energy Shield: ${stats.energyShieldHP} HP</div>`;
            if (stats.energyDraw < 0) statsHtml += `<div>âš¡ Energy: +${-stats.energyDraw}</div>`;
            if (stats.energyDraw > 0) statsHtml += `<div>âš¡ Energy: ${stats.energyDraw}</div>`;
            if (stats.weight) statsHtml += `<div>âš–ï¸ Weight: ${stats.weight}</div>`;
            if (stats.heatCapacity) statsHtml += `<div>ðŸŒ¡ï¸ Heat Cap: +${stats.heatCapacity}</div>`;

            // Show adjacency bonus effects
            if (stats.adjacentDamageBonus) {
                statsHtml += `<div style="color: #ff8844;">ðŸŽ¯ +${stats.adjacentDamageBonus} dmg to adjacent weapons</div>`;
            }
            if (stats.directionalDamageBonus) {
                const dir = item.special?.effectDirection || 'up';
                const arrow = {up: 'â†‘', down: 'â†“', left: 'â†', right: 'â†’'}[dir];
                statsHtml += `<div style="color: #ff8844;">ðŸŽ¯ +${stats.directionalDamageBonus} dmg ${arrow} direction</div>`;
            }

            // Show synergy tags
            let synergyHtml = '';
            if (item.synergies && item.synergies.length > 0) {
                const tagColors = {
                    'multi-hit': '#ff8844',
                    'multi-hit-synergy': '#ffcc00',
                    'kinetic': '#888',
                    'energy': '#4488ff',
                    'explosive': '#ff4444',
                    'precision': '#44ff88',
                    'alpha-strike': '#ff44ff',
                    'amplifier': '#ffcc00',
                    'shredder': '#ff6600'
                };
                synergyHtml = '<div style="margin-top: 4px; display: flex; flex-wrap: wrap; gap: 3px;">';
                item.synergies.forEach(tag => {
                    const color = tagColors[tag] || '#666';
                    synergyHtml += `<span style="background: ${color}33; color: ${color}; padding: 1px 4px; border-radius: 3px; font-size: 9px; border: 1px solid ${color};">${tag}</span>`;
                });
                synergyHtml += '</div>';
            }

            const rarityColor = item.isGenerated && COMPONENT_GENERATION ?
                (COMPONENT_GENERATION.rarityColors[item.rarity] || '#00ff88') : '#00ff88';

            return `
                <div class="item-tooltip">
                    <div class="tooltip-name" style="color: ${rarityColor};">${item.name}${adjBonus > 0 ? ' <span style="color: #ffcc00;">â˜…</span>' : ''}</div>
                    <div class="tooltip-stats">${statsHtml}</div>
                    ${synergyHtml}
                </div>
            `;
        }

        // ============================================
        // GLOBAL TOOLTIP SYSTEM
        // ============================================
        function showItemTooltip(item, event) {
            const tooltip = document.getElementById('itemTooltip');
            if (!tooltip || !item) return;

            tooltip.innerHTML = buildItemTooltipHtml(item);
            tooltip.style.display = 'block';

            // Position near cursor
            const x = event.clientX + 15;
            const y = event.clientY + 15;

            // Keep on screen
            const rect = tooltip.getBoundingClientRect();
            const maxX = window.innerWidth - 300;
            const maxY = window.innerHeight - 200;

            tooltip.style.left = Math.min(x, maxX) + 'px';
            tooltip.style.top = Math.min(y, maxY) + 'px';
        }

        function hideItemTooltip() {
            const tooltip = document.getElementById('itemTooltip');
            if (tooltip) tooltip.style.display = 'none';
        }

        function moveItemTooltip(event) {
            const tooltip = document.getElementById('itemTooltip');
            if (!tooltip || tooltip.style.display === 'none') return;

            const x = event.clientX + 15;
            const y = event.clientY + 15;
            const maxX = window.innerWidth - 300;
            const maxY = window.innerHeight - 200;

            tooltip.style.left = Math.min(x, maxX) + 'px';
            tooltip.style.top = Math.min(y, maxY) + 'px';
        }

        // Build synergy tags HTML for compact display
        function buildSynergyTags(item) {
            if (!item.synergies || item.synergies.length === 0) return '';

            const tagColors = {
                'multi-hit': '#ff8844',
                'multi-hit-synergy': '#ffcc00',
                'kinetic': '#888',
                'energy': '#4488ff',
                'explosive': '#ff4444',
                'precision': '#44ff88',
                'alpha-strike': '#ff44ff',
                'amplifier': '#ffcc00',
                'shredder': '#ff6600',
                'knockback': '#aa88ff',
                'sustained': '#88ff88'
            };

            let html = '<div style="display: flex; flex-wrap: wrap; gap: 2px; margin-top: 4px;">';
            item.synergies.forEach(tag => {
                const color = tagColors[tag] || '#666';
                html += `<span style="background: ${color}33; color: ${color}; padding: 1px 3px; border-radius: 2px; font-size: 8px; border: 1px solid ${color};">${tag}</span>`;
            });
            html += '</div>';
            return html;
        }

        // ============================================
        // TAB SWITCHING & MOBILE LAYOUT
        // ============================================
        let currentTab = 'loadout';
        let isMobileLayout = false;

        function switchTab(tabName) {
            currentTab = tabName;

            // Update header title
            const gameTitle = document.getElementById('gameTitle');
            const goToMissionsBtn = document.getElementById('goToMissionsBtn');
            const goToShopBtn = document.getElementById('goToShopBtn');

            // Hide all nav buttons in header by default
            const headerBtns = [goToMissionsBtn, goToShopBtn];

            if (tabName === 'loadout') {
                gameTitle.textContent = 'Loadout';
                headerBtns.forEach(btn => { if (btn) btn.style.display = ''; });
            } else if (tabName === 'mission') {
                gameTitle.textContent = 'Missions';
                headerBtns.forEach(btn => { if (btn) btn.style.display = 'none'; });
            } else if (tabName === 'shop') {
                gameTitle.textContent = 'Shop';
                headerBtns.forEach(btn => { if (btn) btn.style.display = 'none'; });
            }

            // Update tab content visibility
            const loadoutTab = document.getElementById('loadoutTab');
            const missionTab = document.getElementById('missionTab');
            const shopTab = document.getElementById('shopTab');

            const allTabs = [loadoutTab, missionTab, shopTab];
            allTabs.forEach(tab => { if (tab) tab.classList.remove('active'); });

            if (tabName === 'loadout' && loadoutTab) {
                loadoutTab.classList.add('active');
                updateHeaderDisplay();
            } else if (tabName === 'mission' && missionTab) {
                missionTab.classList.add('active');
                renderMissionTab();
            } else if (tabName === 'shop' && shopTab) {
                shopTab.classList.add('active');
                renderShop();
            }
        }

        function checkMobileLayout() {
            // Layout is now consistent across all screen sizes
            // This function is kept for resize handling
            isMobileLayout = window.innerWidth <= 768;
        }

        function startBattleFromMission() {
            if (selectedMission) {
                startBattle();
            }
        }

        // Render missions for mobile tab
        function renderMissionTab() {
            const missionTabList = document.getElementById('missionTabList');
            if (!missionTabList) return;

            missionTabList.innerHTML = '';

            // Sort missions by difficulty: Easy < Medium < Hard
            const difficultyOrder = { 'Easy': 1, 'Medium': 2, 'Hard': 3 };
            const sortedMissions = Object.values(MISSIONS).sort((a, b) =>
                difficultyOrder[a.difficulty] - difficultyOrder[b.difficulty]
            );

            for (const mission of sortedMissions) {
                const card = document.createElement('div');
                card.className = `mission-card ${mission.difficulty.toLowerCase()}`;
                card.dataset.missionId = mission.id;

                if (selectedMission === mission.id) {
                    card.classList.add('selected');
                }

                const enemyCount = mission.enemyMechs.length;
                const totalHP = mission.enemyMechs.reduce((sum, e) => sum + e.maxHealth, 0);
                const totalDMG = mission.enemyMechs.reduce((sum, e) => sum + e.stats.damage, 0);

                // Build enemy list HTML
                let enemiesHTML = '';
                mission.enemyMechs.forEach((enemy, i) => {
                    enemiesHTML += `<div style="margin: 2px 0;">âš ï¸ ${enemy.name} - HP: ${enemy.maxHealth} | DMG: ${enemy.stats.damage}</div>`;
                });

                // Build salvage rarity rates display for mobile
                const rates = SALVAGE.rarityRates[mission.difficulty] || SALVAGE.rarityRates.Easy;
                const salvageRatesHTML = Object.entries(rates)
                    .filter(([rarity, chance]) => chance > 0)
                    .map(([rarity, chance]) => {
                        const rarityColor = COMPONENT_GENERATION.rarityColors[rarity] || '#aaa';
                        return `<span style="color: ${rarityColor};">${Math.round(chance * 100)}% ${rarity}</span>`;
                    })
                    .join(' â€¢ ');

                card.innerHTML = `
                    <div class="mission-card-header">
                        <span class="mission-name">${mission.name}</span>
                        <span class="mission-difficulty ${mission.difficulty.toLowerCase()}">${mission.difficulty}</span>
                    </div>
                    <div class="mission-desc">${mission.description}</div>
                    <div class="mission-details">
                        <div class="mission-reward">
                            <span>ðŸ’° ${mission.reward.credits} Credits</span>
                            <span>â­ ${mission.reward.xp} XP</span>
                        </div>
                        <div class="mission-enemy">
                            <div style="font-weight: bold; color: #ff6644; margin-bottom: 4px;">
                                ${enemyCount > 1 ? `ðŸ‘¥ ${enemyCount} ENEMIES` : 'ðŸ‘¤ 1 ENEMY'}
                                ${enemyCount > 1 ? ` (Total: HP ${totalHP} | DMG ${totalDMG})` : ''}
                            </div>
                            ${enemiesHTML}
                        </div>
                        <div class="mission-salvage" style="margin-top: 6px; font-size: 9px; color: #888;">
                            ðŸ“¦ ${salvageRatesHTML}
                        </div>
                    </div>
                `;

                card.addEventListener('click', () => {
                    selectMission(mission.id);
                    renderMissionTab();
                });
                missionTabList.appendChild(card);
            }

            // Update continue button state
            const continueBtn = document.getElementById('missionContinueBtn');
            if (continueBtn) {
                continueBtn.disabled = !selectedMission || loadoutState.equipment.length === 0;
            }

            // Render background options
            renderBackgroundOptions();

            // Update piloting toggle state
            updatePilotingToggle();
        }

        function renderBackgroundOptions() {
            const container = document.getElementById('backgroundOptions');
            if (!container) return;

            container.innerHTML = '';

            BACKGROUND_OPTIONS.forEach(bg => {
                const option = document.createElement('div');
                option.className = `background-option${selectedBackground === bg.id ? ' selected' : ''}`;
                option.innerHTML = `
                    <div class="background-option-name">${bg.name}</div>
                    <div class="background-option-desc">${bg.description}</div>
                `;
                option.addEventListener('click', () => {
                    selectedBackground = bg.id;
                    renderBackgroundOptions();
                });
                container.appendChild(option);
            });
        }

        function togglePilotingMode() {
            userPilotingEnabled = !userPilotingEnabled;
            updatePilotingToggle();
        }

        function updatePilotingToggle() {
            const toggle = document.getElementById('pilotingToggle');
            if (!toggle) return;

            if (userPilotingEnabled) {
                toggle.classList.add('active');
            } else {
                toggle.classList.remove('active');
            }
        }

        function renderMissions() {
            const missionList = document.getElementById('missionList');
            if (!missionList) return;  // Mission list may not exist in new layout
            missionList.innerHTML = '';

            // Sort missions by difficulty: Easy < Medium < Hard
            const difficultyOrder = { 'Easy': 1, 'Medium': 2, 'Hard': 3 };
            const sortedMissions = Object.values(MISSIONS).sort((a, b) =>
                difficultyOrder[a.difficulty] - difficultyOrder[b.difficulty]
            );

            for (const mission of sortedMissions) {
                const card = document.createElement('div');
                card.className = `mission-card ${mission.difficulty.toLowerCase()}`;
                card.dataset.missionId = mission.id;

                if (selectedMission === mission.id) {
                    card.classList.add('selected');
                }

                // Build enemies info for display
                const enemyCount = mission.enemyMechs.length;
                const avgLevel = mission.averageLevel || mission.enemyMechs[0].level || 1;

                // Build enemy summary for card
                let enemySummary = '';
                if (enemyCount === 1) {
                    const enemy = mission.enemyMechs[0];
                    enemySummary = `<span style="color: #ff6666;">âš”ï¸ Lv.${enemy.level} ${enemy.name}</span>`;
                } else {
                    const levels = mission.enemyMechs.map(e => e.level);
                    const minLv = Math.min(...levels);
                    const maxLv = Math.max(...levels);
                    const lvRange = minLv === maxLv ? `Lv.${minLv}` : `Lv.${minLv}-${maxLv}`;
                    enemySummary = `<span style="color: #ff6666;">âš”ï¸ ${enemyCount}x Enemies (${lvRange})</span>`;
                }

                // Build detailed enemy tooltip
                let enemiesHTML = '';
                mission.enemyMechs.forEach((enemy, idx) => {
                    let equipmentHTML = '';
                    enemy.equipment.forEach(eq => {
                        const item = ITEM_DATABASE[eq.itemId];
                        if (item) {
                            equipmentHTML += `<div style="font-size: 10px; color: #888;">${item.icon} ${item.name}</div>`;
                        }
                    });

                    // Level color based on level
                    const levelColor = enemy.level <= 2 ? '#88ff88' : enemy.level <= 4 ? '#ffff88' : enemy.level <= 6 ? '#ffaa44' : '#ff6666';

                    enemiesHTML += `
                        <div style="margin-bottom: ${idx < enemyCount - 1 ? '12px' : '0'}; padding-bottom: ${idx < enemyCount - 1 ? '12px' : '0'}; border-bottom: ${idx < enemyCount - 1 ? '1px solid #333' : 'none'};">
                            <div class="enemy-name" style="display: flex; justify-content: space-between; align-items: center;">
                                <span>âš ï¸ ${enemy.name}</span>
                                <span style="background: ${levelColor}; color: #000; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: bold;">Lv.${enemy.level}</span>
                            </div>
                            <div class="enemy-chassis" style="font-size: 11px; color: #666; margin: 3px 0;">${enemy.chassis}</div>
                            <div class="enemy-stats" style="display: grid; grid-template-columns: 1fr 1fr; gap: 2px; font-size: 11px;">
                                <div>â¤ï¸ ${enemy.maxHealth} HP</div>
                                <div>ðŸ’¥ ${enemy.stats.damage} DMG</div>
                                <div>ðŸ›¡ï¸ ${enemy.stats.armor} ARM</div>
                                <div>âš¡ ${enemy.stats.energy} EN</div>
                            </div>
                            <div class="enemy-equipment" style="margin-top: 5px;">
                                ${equipmentHTML}
                            </div>
                        </div>
                    `;
                });

                // Build salvage rarity rates display
                const rates = SALVAGE.rarityRates[mission.difficulty] || SALVAGE.rarityRates.Easy;
                const salvageRatesHTML = Object.entries(rates)
                    .filter(([rarity, chance]) => chance > 0)
                    .map(([rarity, chance]) => {
                        const rarityColor = COMPONENT_GENERATION.rarityColors[rarity] || '#aaa';
                        return `<span style="color: ${rarityColor}; font-size: 9px;">${Math.round(chance * 100)}% ${rarity}</span>`;
                    })
                    .join(' â€¢ ');

                card.innerHTML = `
                    <div class="mission-header">
                        <span class="mission-name">${mission.name}</span>
                        <span class="mission-difficulty ${mission.difficulty.toLowerCase()}">${mission.difficulty}</span>
                    </div>
                    <div class="mission-desc">${mission.description}</div>
                    <div class="mission-enemies" style="margin: 8px 0; font-size: 12px;">
                        ${enemySummary}
                    </div>
                    <div class="mission-reward">
                        <span>ðŸ’° ${mission.reward.credits}</span>
                        <span>â­ ${mission.reward.xp} XP</span>
                    </div>
                    <div class="mission-salvage" style="margin-top: 6px; font-size: 9px; color: #888;">
                        ðŸ“¦ Salvage: ${salvageRatesHTML}
                    </div>
                    <div class="enemy-tooltip">
                        <div style="font-size: 12px; color: #00aa66; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;">
                            ${enemyCount > 1 ? `${enemyCount} Hostiles Detected` : 'Hostile Detected'}
                        </div>
                        ${enemiesHTML}
                    </div>
                `;

                card.addEventListener('click', () => selectMission(mission.id));
                missionList.appendChild(card);
            }

            // Also update mobile tab if visible
            if (currentTab === 'mission') {
                renderMissionTab();
            }
        }

        function selectMission(missionId) {
            selectedMission = missionId;
            renderMissions();
            updateStats();  // Re-check battle ready state
        }

        // ============================================
        // SHOP RENDERING
        // ============================================
        function renderShop() {
            // Update gold display
            const goldDisplay = document.getElementById('shopGoldDisplay');
            if (goldDisplay) goldDisplay.textContent = playerResources.gold;

            // Render mechs for sale
            const mechsContainer = document.getElementById('shopMechsContainer');
            if (mechsContainer) {
                mechsContainer.innerHTML = '';
                if (shopInventory.mechs.length === 0) {
                    mechsContainer.innerHTML = '<div style="color: #666; font-style: italic;">No mechs available</div>';
                } else {
                    shopInventory.mechs.forEach(mechId => {
                        const mech = MECH_TEMPLATES[mechId];
                        if (!mech) return;
                        const rarityColor = COMPONENT_GENERATION.rarityColors[mech.rarity] || '#aaa';
                        const canAfford = playerResources.gold >= mech.price;

                        const card = document.createElement('div');
                        card.className = 'shop-mech-card';
                        card.style.cssText = `
                            background: rgba(0, 0, 0, 0.5);
                            border: 2px solid ${rarityColor};
                            border-radius: 8px;
                            padding: 15px;
                            width: 200px;
                            cursor: ${canAfford ? 'pointer' : 'not-allowed'};
                            opacity: ${canAfford ? '1' : '0.6'};
                            transition: all 0.2s;
                        `;
                        card.innerHTML = `
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <span style="font-size: 28px;">${mech.icon}</span>
                                <span style="color: #ffcc00; font-weight: bold;">${mech.price}g</span>
                            </div>
                            <div style="font-size: 14px; color: ${rarityColor}; font-weight: bold;">${mech.name}</div>
                            <div style="font-size: 10px; color: #888; text-transform: uppercase; margin: 4px 0;">${mech.class} CLASS</div>
                            <div style="font-size: 11px; color: #aaa; margin-top: 8px;">
                                <div>â¤ï¸ ${mech.baseHP} HP | ðŸ›¡ï¸ ${mech.baseArmor} ARM</div>
                                <div>âš–ï¸ ${mech.tonnage}t | ðŸ“¦ ${mech.modSpace} slots</div>
                                <div style="color: #00ff88; margin-top: 5px;">${mech.specialDesc}</div>
                            </div>
                        `;

                        if (canAfford) {
                            card.addEventListener('click', () => handleBuyMech(mechId));
                            card.addEventListener('mouseenter', () => { card.style.transform = 'scale(1.02)'; });
                            card.addEventListener('mouseleave', () => { card.style.transform = 'scale(1)'; });
                        }

                        mechsContainer.appendChild(card);
                    });
                }
            }

            // Render weapons for sale
            const weaponsContainer = document.getElementById('shopWeaponsContainer');
            if (weaponsContainer) {
                weaponsContainer.innerHTML = '';
                if (shopInventory.weapons.length === 0) {
                    weaponsContainer.innerHTML = '<div style="color: #666; font-style: italic;">No weapons available</div>';
                } else {
                    shopInventory.weapons.forEach((shopItem, index) => {
                        const item = ITEM_DATABASE[shopItem.itemId];
                        if (!item) return;
                        const rarityColor = COMPONENT_GENERATION.rarityColors[item.rarity] || '#aaa';
                        const canAfford = playerResources.gold >= shopItem.price;

                        const card = document.createElement('div');
                        card.className = 'shop-weapon-card';
                        card.style.cssText = `
                            background: rgba(0, 0, 0, 0.5);
                            border: 2px solid ${rarityColor};
                            border-radius: 8px;
                            padding: 12px;
                            width: 160px;
                            cursor: ${canAfford ? 'pointer' : 'not-allowed'};
                            opacity: ${canAfford ? '1' : '0.6'};
                            position: relative;
                            transition: all 0.2s;
                        `;

                        const bargainBadge = shopItem.isBargain ?
                            `<div style="position: absolute; top: -8px; left: -8px; background: #ff6600; color: #fff; font-size: 9px; padding: 2px 6px; border-radius: 3px; font-weight: bold;">BARGAIN!</div>` : '';

                        card.innerHTML = `
                            ${bargainBadge}
                            <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                <span style="font-size: 22px;">${item.icon}</span>
                                <div style="text-align: right;">
                                    ${shopItem.isBargain ? `<div style="font-size: 9px; color: #666; text-decoration: line-through;">${shopItem.originalPrice}g</div>` : ''}
                                    <div style="color: #ffcc00; font-weight: bold; font-size: 14px;">${shopItem.price}g</div>
                                </div>
                            </div>
                            <div style="font-size: 11px; color: ${rarityColor}; font-weight: bold; margin: 6px 0;">${item.name}</div>
                            ${buildItemStatIcons(item)}
                            <div class="item-bottom-row">
                                ${buildItemSecondaryStats(item)}
                                ${buildInlineShapePreview(item, 8)}
                            </div>
                        `;

                        // Add hover tooltip
                        card.addEventListener('mouseenter', (e) => {
                            showItemTooltip(item, e);
                            if (canAfford) card.style.transform = 'scale(1.02)';
                        });
                        card.addEventListener('mousemove', moveItemTooltip);
                        card.addEventListener('mouseleave', () => {
                            hideItemTooltip();
                            card.style.transform = 'scale(1)';
                        });

                        if (canAfford) {
                            card.addEventListener('click', () => handleBuyWeapon(index));
                        }

                        weaponsContainer.appendChild(card);
                    });
                }
            }

            // Render owned mechs
            const ownedContainer = document.getElementById('ownedMechsContainer');
            if (ownedContainer) {
                ownedContainer.innerHTML = '';
                ownedMechs.forEach(mechId => {
                    const mech = MECH_TEMPLATES[mechId];
                    if (!mech) return;
                    const isActive = mechId === activeMechId;
                    const rarityColor = COMPONENT_GENERATION.rarityColors[mech.rarity] || '#aaa';

                    const card = document.createElement('div');
                    card.className = 'owned-mech-card';
                    card.style.cssText = `
                        background: rgba(0, 0, 0, 0.5);
                        border: 2px solid ${isActive ? '#00ff88' : rarityColor};
                        border-radius: 8px;
                        padding: 12px;
                        width: 150px;
                        cursor: pointer;
                        transition: all 0.2s;
                        ${isActive ? 'box-shadow: 0 0 15px rgba(0, 255, 136, 0.4);' : ''}
                    `;
                    card.innerHTML = `
                        <div style="text-align: center;">
                            <div style="font-size: 24px;">${mech.icon}</div>
                            <div style="font-size: 12px; color: ${isActive ? '#00ff88' : rarityColor}; font-weight: bold; margin-top: 5px;">${mech.name}</div>
                            <div style="font-size: 10px; color: #888;">${mech.class}</div>
                            ${isActive ? '<div style="font-size: 10px; color: #00ff88; margin-top: 5px;">âœ“ ACTIVE</div>' : '<div style="font-size: 10px; color: #666; margin-top: 5px;">Click to select</div>'}
                        </div>
                    `;

                    if (!isActive) {
                        card.addEventListener('click', () => {
                            activeMechId = mechId;
                            renderShop();
                            updateHeaderDisplay();
                        });
                    }

                    ownedContainer.appendChild(card);
                });
            }

            // Render player's equipped items (for selling)
            renderShopInventory();
        }

        // Render player's inventory in the shop (for selling)
        function renderShopInventory() {
            const equippedContainer = document.getElementById('shopEquippedItems');
            const benchContainer = document.getElementById('shopBenchItems');

            // Render equipped items
            if (equippedContainer) {
                equippedContainer.innerHTML = '';
                if (loadoutState.equipment.length === 0) {
                    equippedContainer.innerHTML = '<div class="shop-empty-msg">No items equipped</div>';
                } else {
                    loadoutState.equipment.forEach(eq => {
                        const item = eq.item || ITEM_DATABASE[eq.itemId];
                        if (!item) return;
                        const sellPrice = calculateSellPrice(item);
                        const el = createShopSellItem(item, eq.instanceId, sellPrice, 'equipped');
                        equippedContainer.appendChild(el);
                    });
                }
            }

            // Render bench items
            if (benchContainer) {
                benchContainer.innerHTML = '';
                if (benchItems.length === 0) {
                    benchContainer.innerHTML = '<div class="shop-empty-msg">No items on bench</div>';
                } else {
                    benchItems.forEach(item => {
                        const sellPrice = calculateSellPrice(item);
                        const el = createShopSellItem(item, item.instanceId, sellPrice, 'bench');
                        benchContainer.appendChild(el);
                    });
                }
            }

            // Render buyback items
            const buybackContainer = document.getElementById('shopBuybackItems');
            if (buybackContainer) {
                buybackContainer.innerHTML = '';
                if (shopInventory.buyback.length === 0) {
                    buybackContainer.innerHTML = '<div class="shop-empty-msg">No items to buy back</div>';
                } else {
                    shopInventory.buyback.forEach((buybackItem, index) => {
                        const item = buybackItem.item || ITEM_DATABASE[buybackItem.itemId];
                        if (!item) return;
                        const rarityColor = item.isGenerated && COMPONENT_GENERATION ?
                            (COMPONENT_GENERATION.rarityColors[item.rarity] || '#00ff88') : '#00ff88';

                        const el = document.createElement('div');
                        el.className = `shop-sell-item ${item.category}`;
                        el.style.borderColor = '#ffaa00';
                        el.innerHTML = `
                            <span class="item-icon">${item.icon}</span>
                            <div class="item-info">
                                <div class="item-name" style="color: ${rarityColor};">${item.name}</div>
                                ${buildItemStatIcons(item)}
                                <div style="margin-top: 4px; color: #ffaa00; font-size: 10px;">ðŸ”„ Buyback: 1g</div>
                            </div>
                        `;
                        el.addEventListener('click', () => handleBuyback(index));
                        buybackContainer.appendChild(el);
                    });
                }
            }
        }

        // Create a sellable item element for the shop
        function createShopSellItem(item, instanceId, sellPrice, source) {
            const el = document.createElement('div');
            el.className = `shop-sell-item ${item.category}`;
            el.dataset.instanceId = instanceId;
            el.dataset.source = source;

            const rarityColor = item.isGenerated && COMPONENT_GENERATION ?
                (COMPONENT_GENERATION.rarityColors[item.rarity] || '#00ff88') : '#00ff88';

            el.innerHTML = `
                ${buildItemShapePreview(item)}
                <span class="item-icon">${item.icon}</span>
                <div class="item-info">
                    <div class="item-name" style="color: ${rarityColor};">${item.name}</div>
                    ${buildItemStatIcons(item)}
                    <div class="item-sell-price" style="margin-top: 4px;">ðŸ’° Sell: ${sellPrice}g</div>
                </div>
            `;

            el.addEventListener('click', () => handleSellItem(instanceId, source, sellPrice, item.name, item.id));
            return el;
        }

        // Calculate sell price (most items sell for 1g, rare+ sell for more)
        function calculateSellPrice(item) {
            // Base sell price by rarity (scaled down economy)
            const rarityPrices = {
                common: 1,
                uncommon: 1,
                rare: 2,
                epic: 3,
                legendary: 5
            };
            return rarityPrices[item.rarity] || 1;
        }

        // Handle selling an item (no confirmation - can buyback for 1g this turn)
        function handleSellItem(instanceId, source, sellPrice, itemName, itemId) {
            let soldItem = null;

            if (source === 'equipped') {
                // Remove from equipment and grid
                soldItem = removeItemFromGrid(instanceId);
            } else if (source === 'bench') {
                // Remove from bench
                soldItem = removeItemFromBench(instanceId);
            }

            // Add gold
            playerResources.gold += sellPrice;

            // Add to buyback list (can repurchase for 1g this turn)
            if (soldItem || itemId) {
                shopInventory.buyback.push({
                    item: soldItem || { ...ITEM_DATABASE[itemId], instanceId },
                    itemId: soldItem ? soldItem.id : itemId,
                    name: itemName
                });
            }

            // Re-render everything
            renderShop();
            renderBench();
            renderUnifiedGridItems();
            updateStats();
        }

        // Handle buying back a sold item
        function handleBuyback(buybackIndex) {
            if (buybackIndex < 0 || buybackIndex >= shopInventory.buyback.length) return;
            if (playerResources.gold < 1) return;

            const buybackItem = shopInventory.buyback[buybackIndex];

            // Deduct gold and add to bench
            playerResources.gold -= 1;
            addItemToBench(buybackItem.itemId);

            // Remove from buyback permanently
            shopInventory.buyback.splice(buybackIndex, 1);

            // Re-render
            renderShop();
            renderBench();
            updateHeaderDisplay();
        }

        // ============================================
        // HEADER DISPLAY UPDATE
        // ============================================
        function updateHeaderDisplay() {
            const roundNum = document.getElementById('roundNum');
            const goldAmount = document.getElementById('goldAmount');

            if (roundNum) roundNum.textContent = gameProgression.round;
            if (goldAmount) goldAmount.textContent = playerResources.gold;
        }

        // ============================================
        // SHOP HANDLERS
        // ============================================
        function handleBuyMech(mechId) {
            const result = buyMech(mechId);
            if (result.success) {
                renderShop();
                updateHeaderDisplay();
            } else {
                console.log('Failed to buy mech:', result.reason);
            }
        }

        function handleBuyWeapon(shopIndex) {
            const result = buyWeapon(shopIndex);
            if (result.success) {
                renderShop();
                renderBench();
                updateHeaderDisplay();
            } else {
                console.log('Failed to buy weapon:', result.reason);
            }
        }

        function handleRefreshShop() {
            const result = refreshShop();
            if (result.success) {
                renderShop();
                updateHeaderDisplay();
            } else {
                console.log('Failed to refresh shop:', result.reason);
            }
        }

        function renderGridOverlays() {
            // Legacy function - gridOverlayContainer no longer exists in new layout
            const container = document.getElementById('gridOverlayContainer');
            if (!container) return;  // Use renderUnifiedMechGrid instead
            container.innerHTML = '';
            gridElements = {};

            // Create legs container for centered leg grids
            const legsContainer = document.createElement('div');
            legsContainer.id = 'legsContainer';
            container.appendChild(legsContainer);

            // Get cell size based on screen width
            let cellSize = 40;
            if (window.innerWidth <= 480) {
                cellSize = 28;
            } else if (window.innerWidth <= 768) {
                cellSize = 32;
            }

            for (const [slotName, slotDef] of Object.entries(MECH_CHASSIS.slots)) {
                const gridEl = document.createElement('div');
                gridEl.className = 'mech-grid-overlay';
                gridEl.dataset.slot = slotName;
                gridEl.style.gridTemplateColumns = `repeat(${slotDef.cols}, ${cellSize}px)`;

                // Add label
                const label = document.createElement('span');
                label.className = 'grid-label';
                label.textContent = slotName.replace(/([A-Z])/g, ' $1').trim();
                gridEl.appendChild(label);

                // Create grid cells
                for (let y = 0; y < slotDef.rows; y++) {
                    for (let x = 0; x < slotDef.cols; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.x = x;
                        cell.dataset.y = y;
                        gridEl.appendChild(cell);
                    }
                }

                // Append legs to legsContainer, others to main container
                if (slotName === 'leftLeg' || slotName === 'rightLeg') {
                    legsContainer.appendChild(gridEl);
                } else {
                    container.appendChild(gridEl);
                }
                gridElements[slotName] = gridEl;
            }
        }

        // Check if two items are adjacent (share an edge) in the unified grid
        function areItemsAdjacent(eq1, eq2) {
            // With unified grid, all items are in the same grid space

            const item1 = ITEM_DATABASE[eq1.itemId];
            const item2 = ITEM_DATABASE[eq2.itemId];
            if (!item1 || !item2) return false;

            // Get all cells occupied by each item
            const cells1 = [];
            const cells2 = [];

            const shape1 = item1.gridShape;
            for (let dy = 0; dy < shape1.length; dy++) {
                for (let dx = 0; dx < shape1[0].length; dx++) {
                    if (shape1[dy][dx] === 1) {
                        cells1.push({ x: eq1.position.x + dx, y: eq1.position.y + dy });
                    }
                }
            }

            const shape2 = item2.gridShape;
            for (let dy = 0; dy < shape2.length; dy++) {
                for (let dx = 0; dx < shape2[0].length; dx++) {
                    if (shape2[dy][dx] === 1) {
                        cells2.push({ x: eq2.position.x + dx, y: eq2.position.y + dy });
                    }
                }
            }

            // Check if any cell from item1 is adjacent to any cell from item2
            for (const c1 of cells1) {
                for (const c2 of cells2) {
                    const dx = Math.abs(c1.x - c2.x);
                    const dy = Math.abs(c1.y - c2.y);
                    // Adjacent means sharing an edge (not diagonal)
                    if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Calculate energy reduction from heat sinks for adjacent items
        function calculateHeatSinkReduction() {
            let totalReduction = 0;
            const heatSinks = loadoutState.equipment.filter(eq => {
                const item = ITEM_DATABASE[eq.itemId];
                return item && item.stats && item.stats.energyReduction;
            });

            // Track remaining energy that can be reduced for each item (to cap at 0)
            const remainingEnergy = new Map();  // instanceId -> remaining energy to reduce

            // For each heat sink, find adjacent items and apply reduction
            for (const heatSink of heatSinks) {
                const heatSinkItem = ITEM_DATABASE[heatSink.itemId];
                const reduction = heatSinkItem.stats.energyReduction || 0;

                for (const eq of loadoutState.equipment) {
                    if (eq.instanceId === heatSink.instanceId) continue;

                    const item = ITEM_DATABASE[eq.itemId];
                    if (!item || !item.stats || !item.stats.energyDraw || item.stats.energyDraw <= 0) continue;

                    if (areItemsAdjacent(heatSink, eq)) {
                        // Initialize remaining energy if not tracked yet
                        if (!remainingEnergy.has(eq.instanceId)) {
                            remainingEnergy.set(eq.instanceId, item.stats.energyDraw);
                        }

                        // Apply reduction up to remaining energy (can't go below 0)
                        const remaining = remainingEnergy.get(eq.instanceId);
                        const actualReduction = Math.min(reduction, remaining);
                        totalReduction += actualReduction;
                        remainingEnergy.set(eq.instanceId, remaining - actualReduction);
                    }
                }
            }
            return totalReduction;
        }

        function updateStats() {
            let totalWeight = 0;
            let energyUsed = 0;      // Positive energyDraw = consumes energy
            let energyProvided = 0;  // Negative energyDraw = provides energy (reactors)
            let totalArmor = 0;
            let accuracyBonus = 0;
            let hpBonus = 0;
            let damageReduction = 0;  // Takes highest value, doesn't stack
            let energyShieldHP = 0;

            loadoutState.equipment.forEach(eq => {
                const item = ITEM_DATABASE[eq.itemId];
                if (item && item.stats) {
                    totalWeight += item.stats.weight || 0;
                    totalArmor += item.stats.armorBonus || 0;
                    accuracyBonus += item.stats.accuracyBonus || 0;
                    hpBonus += item.stats.hpBonus || 0;
                    damageReduction = Math.max(damageReduction, item.stats.damageReduction || 0);  // Highest only
                    energyShieldHP += item.stats.energyShieldHP || 0;
                    const draw = item.stats.energyDraw || 0;
                    if (draw > 0) {
                        energyUsed += draw;
                    } else {
                        energyProvided += Math.abs(draw);
                    }
                }
            });

            // Apply heat sink energy reduction
            const heatSinkReduction = calculateHeatSinkReduction();
            energyUsed = Math.max(0, energyUsed - heatSinkReduction);

            const maxWeight = MECH_CHASSIS.maxWeight;
            const maxEnergy = MECH_CHASSIS.baseEnergy + energyProvided;  // Reactors increase max energy

            // Calculate HP from mech's baseHP + hpBonus from armor
            const mech = getActiveMech();
            const baseHealth = mech.baseHP || 25;
            const totalHP = baseHealth + hpBonus;

            // Store combat stats for battle (accessible globally)
            loadoutState.combatStats = {
                maxHP: totalHP,
                damageReduction: damageReduction,
                energyShieldHP: energyShieldHP
            };

            // Update HP bar
            const hpFill = document.getElementById('hpFill');
            const hpText = document.getElementById('hpText');
            hpFill.style.width = '100%';  // Always full (shows max HP)
            hpText.textContent = totalHP;

            // Update armor display (only show if armor > 0)
            const armorStatItem = document.getElementById('armorStatItem');
            const armorFill = document.getElementById('armorFill');
            const armorText = document.getElementById('armorText');
            if (totalArmor > 0) {
                armorStatItem.style.display = '';
                armorFill.style.width = '100%';
                armorText.textContent = `+${totalArmor}`;
            } else {
                armorStatItem.style.display = 'none';
            }

            // Update accuracy bar (base 60% + bonuses)
            const baseAccuracy = 60;
            const totalAccuracy = Math.min(100, baseAccuracy + accuracyBonus);
            const accuracyFill = document.getElementById('accuracyFill');
            const accuracyText = document.getElementById('accuracyText');
            accuracyFill.style.width = totalAccuracy + '%';
            accuracyText.textContent = `${totalAccuracy}%`;

            // Update weight bar
            const weightFill = document.getElementById('weightFill');
            const weightText = document.getElementById('weightText');
            const weightPercent = Math.min((totalWeight / maxWeight) * 100, 100);
            weightFill.style.width = weightPercent + '%';
            weightText.textContent = `${totalWeight} / ${maxWeight}`;
            weightFill.classList.toggle('over-limit', totalWeight > maxWeight);

            // Update energy bar (energy used vs available energy)
            const energyFill = document.getElementById('energyFill');
            const energyText = document.getElementById('energyText');
            const energyPercent = Math.min((energyUsed / maxEnergy) * 100, 100);
            energyFill.style.width = energyPercent + '%';
            energyText.textContent = `${energyUsed} / ${maxEnergy}`;
            energyFill.classList.toggle('over-limit', energyUsed > maxEnergy);

            // Update pile counts
            updatePileCounts();

            // Check button states
            const hasEquipment = loadoutState.equipment.length > 0;
            const withinLimits = totalWeight <= maxWeight && energyUsed <= maxEnergy;
            const isValid = withinLimits && hasEquipment && selectedMission !== null;

            // Update "Go to Missions" button on loadout screen
            const goToMissionsBtn = document.getElementById('goToMissionsBtn');
            if (goToMissionsBtn) {
                if (!withinLimits) {
                    goToMissionsBtn.textContent = 'Over Limit!';
                    goToMissionsBtn.disabled = true;
                    goToMissionsBtn.classList.add('warning');
                } else {
                    goToMissionsBtn.textContent = 'Go to Missions â†’';
                    goToMissionsBtn.disabled = !hasEquipment;
                    goToMissionsBtn.classList.remove('warning');
                }
            }

            // Update "Continue to Battle" button on mission screen
            const continueBtn = document.getElementById('missionContinueBtn');
            if (continueBtn) {
                if (!withinLimits) {
                    continueBtn.textContent = 'Over Limit!';
                    continueBtn.disabled = true;
                    continueBtn.classList.add('warning');
                } else {
                    continueBtn.textContent = 'Continue to Battle â†’';
                    continueBtn.disabled = !isValid;
                    continueBtn.classList.remove('warning');
                }
            }
        }

        // Update pile count displays (no longer used - no deck system)
        function updatePileCounts() {
            // No deck piles to update
        }

        // Show pile viewer modal (no longer used - no deck system)
        function showPileViewer(pileType) {
            // No deck viewer needed
            return;
            const viewer = document.getElementById('pileViewer');
            if (!viewer) return;
            const title = document.getElementById('pileViewerTitle');
            const cardsContainer = document.getElementById('pileViewerCards');

            const pile = [];
            console.log('[PILE] pile contents:', pile.length, 'cards');
            title.textContent = pileType === 'draw' ? `Draw Pile (${pile.length} cards)` : `Discard Pile (${pile.length} cards)`;

            // Count occurrences of each card
            const cardCounts = {};
            pile.forEach(itemId => {
                cardCounts[itemId] = (cardCounts[itemId] || 0) + 1;
            });

            // Build cards HTML
            cardsContainer.innerHTML = '';
            for (const [itemId, count] of Object.entries(cardCounts)) {
                const item = ITEM_DATABASE[itemId];
                if (!item) continue;

                // Get rarity styling for generated items
                const isGenerated = item.isGenerated;
                const rarityColor = isGenerated ? (COMPONENT_GENERATION.rarityColors[item.rarity] || '#00ff88') : '#00ff88';
                const rarityName = isGenerated ? (item.rarity.charAt(0).toUpperCase() + item.rarity.slice(1)) : '';

                const cardEl = document.createElement('div');
                cardEl.className = 'pile-card';
                if (isGenerated) {
                    cardEl.style.borderColor = rarityColor;
                    cardEl.style.boxShadow = `0 0 8px ${rarityColor}40`;
                }
                cardEl.innerHTML = `
                    <div class="card-icon">${item.icon}</div>
                    <div class="card-name" style="${isGenerated ? `color: ${rarityColor};` : ''}">${item.name}</div>
                    ${isGenerated ? `<div style="font-size: 9px; color: ${rarityColor};">${rarityName} L${item.level}</div>` : ''}
                    ${count > 1 ? `<div class="card-count" style="font-size: 11px; color: #ffcc00;">Ã—${count}</div>` : ''}
                `;
                cardsContainer.appendChild(cardEl);
            }

            if (pile.length === 0) {
                cardsContainer.innerHTML = '<div style="color: #666; font-size: 14px;">Empty</div>';
            }

            viewer.classList.add('active');
            console.log('[PILE] Added active class, viewer display:', window.getComputedStyle(viewer).display);
        }

        // Close pile viewer modal
        function closePileViewer() {
            console.log('[PILE] closePileViewer called');
            const viewer = document.getElementById('pileViewer');
            viewer.classList.remove('active');
        }

        // ============================================
        // 3D SCENE - MECHBUILDER VIEW
        // ============================================
        let builderMech = null;
        let outlineMaterial = null;

        function createBuilderScene() {
            // Create orthographic camera for blueprint view
            const aspectRatio = engine.getRenderWidth() / engine.getRenderHeight();
            const orthoSize = 4;

            builderCamera = new BABYLON.ArcRotateCamera('builderCam',
                -Math.PI/2, Math.PI/2.5, 10,
                new BABYLON.Vector3(0, 1.5, 0), scene);
            builderCamera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
            builderCamera.orthoLeft = -orthoSize * aspectRatio;
            builderCamera.orthoRight = orthoSize * aspectRatio;
            builderCamera.orthoTop = orthoSize;
            builderCamera.orthoBottom = -orthoSize;

            // Only attach camera controls on desktop - mobile needs that area for scrolling
            const isMobile = window.innerWidth <= 768 || 'ontouchstart' in window;
            if (!isMobile) {
                builderCamera.attachControl(document.getElementById('renderCanvas'), true);
            }

            // Ambient lighting for builder
            const hemi = new BABYLON.HemisphericLight('builderHemi', new BABYLON.Vector3(0, 1, 0), scene);
            hemi.intensity = 0.8;
            hemi.groundColor = new BABYLON.Color3(0.1, 0.2, 0.15);

            // Create outline/holographic material
            outlineMaterial = new BABYLON.StandardMaterial('outlineMat', scene);
            outlineMaterial.diffuseColor = new BABYLON.Color3(0, 0.4, 0.3);
            outlineMaterial.emissiveColor = new BABYLON.Color3(0, 0.8, 0.5);
            outlineMaterial.specularColor = new BABYLON.Color3(0, 1, 0.7);
            outlineMaterial.alpha = 0.7;
            outlineMaterial.wireframe = false;

            // Create dark background plane
            const bgPlane = BABYLON.MeshBuilder.CreatePlane('bgPlane', { size: 50 }, scene);
            bgPlane.position.z = 5;
            const bgMat = new BABYLON.StandardMaterial('bgMat', scene);
            bgMat.diffuseColor = new BABYLON.Color3(0.02, 0.04, 0.03);
            bgMat.emissiveColor = new BABYLON.Color3(0.01, 0.02, 0.015);
            bgPlane.material = bgMat;

            // Create grid floor for reference
            const gridSize = 10;
            const gridLines = [];
            for (let i = -gridSize; i <= gridSize; i++) {
                gridLines.push([new BABYLON.Vector3(i, 0, -gridSize), new BABYLON.Vector3(i, 0, gridSize)]);
                gridLines.push([new BABYLON.Vector3(-gridSize, 0, i), new BABYLON.Vector3(gridSize, 0, i)]);
            }
            const gridMesh = BABYLON.MeshBuilder.CreateLineSystem('grid', { lines: gridLines }, scene);
            gridMesh.color = new BABYLON.Color3(0, 0.3, 0.2);
            gridMesh.alpha = 0.3;

            // Create the mech model for builder view
            builderMech = createBuilderMechModel();

            scene.activeCamera = builderCamera;
        }

        function createBuilderMechModel() {
            // Create a simplified mech silhouette for the builder
            const mech = new BABYLON.TransformNode('builderMech', scene);

            // Torso (main body)
            const torso = BABYLON.MeshBuilder.CreateBox('torso', {
                width: 1.2, height: 1.0, depth: 0.8
            }, scene);
            torso.position.y = 2.2;
            torso.parent = mech;
            torso.material = outlineMaterial;

            // Torso upper
            const torsoUpper = BABYLON.MeshBuilder.CreateBox('torsoUpper', {
                width: 1.4, height: 0.5, depth: 0.9
            }, scene);
            torsoUpper.position.y = 0.6;
            torsoUpper.parent = torso;
            torsoUpper.material = outlineMaterial;

            // Head/cockpit
            const head = BABYLON.MeshBuilder.CreateBox('head', {
                width: 0.5, height: 0.4, depth: 0.5
            }, scene);
            head.position.y = 0.9;
            head.parent = torso;
            head.material = outlineMaterial;

            // Cockpit glass
            const cockpit = BABYLON.MeshBuilder.CreateBox('cockpit', {
                width: 0.4, height: 0.15, depth: 0.1
            }, scene);
            cockpit.position = new BABYLON.Vector3(0, 0, 0.28);
            cockpit.parent = head;
            const cockpitMat = new BABYLON.StandardMaterial('cockpitMat', scene);
            cockpitMat.diffuseColor = new BABYLON.Color3(0, 0.5, 0.5);
            cockpitMat.emissiveColor = new BABYLON.Color3(0, 0.8, 0.9);
            cockpitMat.alpha = 0.9;
            cockpit.material = cockpitMat;

            // Left Arm
            const leftArm = createBuilderArm('left', -0.9, torso);

            // Right Arm
            const rightArm = createBuilderArm('right', 0.9, torso);

            // Pelvis
            const pelvis = BABYLON.MeshBuilder.CreateBox('pelvis', {
                width: 0.9, height: 0.4, depth: 0.6
            }, scene);
            pelvis.position.y = 1.5;
            pelvis.parent = mech;
            pelvis.material = outlineMaterial;

            // Left Leg
            const leftLeg = createBuilderLeg('left', -0.4, pelvis);

            // Right Leg
            const rightLeg = createBuilderLeg('right', 0.4, pelvis);

            // Add edge rendering for holographic effect
            addEdgeRendering(mech);

            return mech;
        }

        function createBuilderArm(side, xOffset, parent) {
            const arm = new BABYLON.TransformNode(side + 'Arm', scene);
            arm.position.x = xOffset;
            arm.position.y = 0.3;
            arm.parent = parent;

            // Shoulder
            const shoulder = BABYLON.MeshBuilder.CreateSphere(side + 'Shoulder', {
                diameter: 0.4
            }, scene);
            shoulder.parent = arm;
            shoulder.material = outlineMaterial;

            // Upper arm
            const upperArm = BABYLON.MeshBuilder.CreateBox(side + 'UpperArm', {
                width: 0.25, height: 0.6, depth: 0.25
            }, scene);
            upperArm.position.y = -0.4;
            upperArm.parent = arm;
            upperArm.material = outlineMaterial;

            // Lower arm / weapon housing
            const lowerArm = BABYLON.MeshBuilder.CreateBox(side + 'LowerArm', {
                width: 0.35, height: 0.8, depth: 0.4
            }, scene);
            lowerArm.position.y = -1.0;
            lowerArm.parent = arm;
            lowerArm.material = outlineMaterial;

            return arm;
        }

        function createBuilderLeg(side, xOffset, parent) {
            const leg = new BABYLON.TransformNode(side + 'Leg', scene);
            leg.position.x = xOffset;
            leg.position.y = -0.2;
            leg.parent = parent;

            // Hip joint
            const hip = BABYLON.MeshBuilder.CreateSphere(side + 'Hip', {
                diameter: 0.3
            }, scene);
            hip.parent = leg;
            hip.material = outlineMaterial;

            // Upper leg (thigh)
            const upperLeg = BABYLON.MeshBuilder.CreateBox(side + 'UpperLeg', {
                width: 0.25, height: 0.5, depth: 0.3
            }, scene);
            upperLeg.position.y = -0.35;
            upperLeg.rotation.x = 0.3;
            upperLeg.parent = leg;
            upperLeg.material = outlineMaterial;

            // Knee
            const knee = BABYLON.MeshBuilder.CreateSphere(side + 'Knee', {
                diameter: 0.25
            }, scene);
            knee.position.y = -0.6;
            knee.position.z = 0.15;
            knee.parent = leg;
            knee.material = outlineMaterial;

            // Lower leg (shin)
            const lowerLeg = BABYLON.MeshBuilder.CreateBox(side + 'LowerLeg', {
                width: 0.3, height: 0.7, depth: 0.35
            }, scene);
            lowerLeg.position.y = -1.0;
            lowerLeg.position.z = 0.05;
            lowerLeg.rotation.x = -0.2;
            lowerLeg.parent = leg;
            lowerLeg.material = outlineMaterial;

            // Foot
            const foot = BABYLON.MeshBuilder.CreateBox(side + 'Foot', {
                width: 0.35, height: 0.15, depth: 0.5
            }, scene);
            foot.position.y = -1.45;
            foot.position.z = 0.1;
            foot.parent = leg;
            foot.material = outlineMaterial;

            return leg;
        }

        function addEdgeRendering(rootNode) {
            // Add edge rendering to all meshes
            const meshes = rootNode.getChildMeshes();
            meshes.forEach(mesh => {
                mesh.enableEdgesRendering();
                mesh.edgesWidth = 2.0;
                mesh.edgesColor = new BABYLON.Color4(0, 1, 0.6, 1);
            });
        }

        // ============================================
        // PLAYER STATS CALCULATION
        // ============================================

        // Calculate adjacency damage bonuses for weapons
        // This is the KEY SYNERGY system - flat damage bonuses MULTIPLY with multi-hit weapons!
        function calculateAdjacencyBonuses() {
            const bonusMap = {};  // instanceId -> bonus damage

            if (!unifiedGridOccupation || !unifiedGridOccupation.cells) return bonusMap;

            // First, collect all items with adjacency effects and their positions
            const bonusSources = [];  // Items that provide adjacency bonuses
            const weaponPositions = {};  // instanceId -> Set of {x, y} positions

            loadoutState.equipment.forEach(eq => {
                const item = ITEM_DATABASE[eq.itemId];
                if (!item || !eq.position) return;

                // Collect positions occupied by this item
                const positions = new Set();
                const shape = item.gridShape;
                if (shape) {
                    for (let dy = 0; dy < shape.length; dy++) {
                        for (let dx = 0; dx < shape[0].length; dx++) {
                            if (shape[dy][dx] === 1) {
                                positions.add(`${eq.position.x + dx},${eq.position.y + dy}`);
                            }
                        }
                    }
                }

                if (item.type === 'WEAPON') {
                    weaponPositions[eq.instanceId] = positions;
                    bonusMap[eq.instanceId] = 0;
                }

                // Check if this item provides adjacency bonuses
                if (item.stats?.adjacentDamageBonus) {
                    bonusSources.push({
                        eq,
                        item,
                        positions,
                        bonus: item.stats.adjacentDamageBonus,
                        isDirectional: false
                    });
                }
                if (item.stats?.directionalDamageBonus && item.special?.effectDirection) {
                    bonusSources.push({
                        eq,
                        item,
                        positions,
                        bonus: item.stats.directionalDamageBonus,
                        isDirectional: true,
                        direction: item.special.effectDirection
                    });
                }
            });

            // For each bonus source, find adjacent weapons and apply bonuses
            bonusSources.forEach(source => {
                if (source.isDirectional) {
                    // Directional bonus - only applies in one direction
                    const dirOffsets = {
                        up: [{dx: 0, dy: -1}],
                        down: [{dx: 0, dy: 1}],
                        left: [{dx: -1, dy: 0}],
                        right: [{dx: 1, dy: 0}]
                    };
                    const offsets = dirOffsets[source.direction] || dirOffsets.up;

                    // Check cells in the specified direction from each cell of this item
                    source.positions.forEach(posStr => {
                        const [x, y] = posStr.split(',').map(Number);
                        offsets.forEach(({dx, dy}) => {
                            const adjX = x + dx;
                            const adjY = y + dy;
                            if (adjX >= 0 && adjX < MECH_CHASSIS.gridCols &&
                                adjY >= 0 && adjY < MECH_CHASSIS.gridRows) {
                                const adjInstanceId = unifiedGridOccupation.cells[adjY]?.[adjX];
                                if (adjInstanceId && bonusMap.hasOwnProperty(adjInstanceId)) {
                                    bonusMap[adjInstanceId] += source.bonus;
                                }
                            }
                        });
                    });
                } else {
                    // Omni-directional bonus - applies to all adjacent cells
                    const offsets = [
                        {dx: 0, dy: -1}, {dx: 0, dy: 1},
                        {dx: -1, dy: 0}, {dx: 1, dy: 0}
                    ];

                    // Track which weapons already got bonus from this source (avoid double-counting)
                    const bonusedWeapons = new Set();

                    source.positions.forEach(posStr => {
                        const [x, y] = posStr.split(',').map(Number);
                        offsets.forEach(({dx, dy}) => {
                            const adjX = x + dx;
                            const adjY = y + dy;
                            if (adjX >= 0 && adjX < MECH_CHASSIS.gridCols &&
                                adjY >= 0 && adjY < MECH_CHASSIS.gridRows) {
                                const adjInstanceId = unifiedGridOccupation.cells[adjY]?.[adjX];
                                if (adjInstanceId && bonusMap.hasOwnProperty(adjInstanceId) &&
                                    !bonusedWeapons.has(adjInstanceId)) {
                                    bonusMap[adjInstanceId] += source.bonus;
                                    bonusedWeapons.add(adjInstanceId);
                                }
                            }
                        });
                    });
                }
            });

            return bonusMap;
        }

        // ============================================
        // POSITIONAL MODIFIER CALCULATION
        // Evaluates positional bonuses for items with special modifiers
        // ============================================
        function calculatePositionalBonuses() {
            const bonuses = {};  // instanceId -> { damage: 0, hp: 0, energy: 0 }

            if (!unifiedGridOccupation || !unifiedGridOccupation.cells) return bonuses;

            // Build a map of all occupied cells and their item types
            const cellMap = {};  // "x,y" -> { instanceId, type, category }
            const itemPositions = {};  // instanceId -> [{x, y}, ...]

            loadoutState.equipment.forEach(eq => {
                const item = ITEM_DATABASE[eq.itemId];
                if (!item || !eq.position) return;

                itemPositions[eq.instanceId] = [];
                const shape = item.gridShape;
                if (shape) {
                    for (let dy = 0; dy < shape.length; dy++) {
                        for (let dx = 0; dx < shape[0].length; dx++) {
                            if (shape[dy][dx] === 1) {
                                const x = eq.position.x + dx;
                                const y = eq.position.y + dy;
                                const key = `${x},${y}`;
                                cellMap[key] = {
                                    instanceId: eq.instanceId,
                                    type: item.type,
                                    category: item.category
                                };
                                itemPositions[eq.instanceId].push({ x, y });
                            }
                        }
                    }
                }

                // Initialize bonus tracking
                bonuses[eq.instanceId] = { damage: 0, hp: 0, energy: 0 };
            });

            // Helper functions for position checks
            const isInTopRow = (positions) => positions.some(p => p.y === 0);
            const isInBottomRow = (positions) => positions.some(p => p.y === MECH_CHASSIS.gridRows - 1);
            const isOnLeftEdge = (positions) => positions.some(p => p.x === 0);
            const isOnRightEdge = (positions) => positions.some(p => p.x === MECH_CHASSIS.gridCols - 1);
            const isOnEdge = (positions) => isOnLeftEdge(positions) || isOnRightEdge(positions);
            const isInCorner = (positions) => positions.some(p =>
                (p.x === 0 || p.x === MECH_CHASSIS.gridCols - 1) &&
                (p.y === 0 || p.y === MECH_CHASSIS.gridRows - 1)
            );
            const isCentral = (positions) => !positions.some(p =>
                p.x === 0 || p.x === MECH_CHASSIS.gridCols - 1 ||
                p.y === 0 || p.y === MECH_CHASSIS.gridRows - 1
            );

            // Count adjacent items of a specific type
            const countAdjacentOfType = (positions, targetType, excludeInstanceId) => {
                const offsets = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];
                const counted = new Set();
                positions.forEach(p => {
                    offsets.forEach(({dx, dy}) => {
                        const key = `${p.x + dx},${p.y + dy}`;
                        if (cellMap[key] && cellMap[key].type === targetType &&
                            cellMap[key].instanceId !== excludeInstanceId) {
                            counted.add(cellMap[key].instanceId);
                        }
                    });
                });
                return counted.size;
            };

            // Check if item is isolated (no adjacent items)
            const isIsolated = (positions, instanceId) => {
                const offsets = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];
                for (const p of positions) {
                    for (const {dx, dy} of offsets) {
                        const key = `${p.x + dx},${p.y + dy}`;
                        if (cellMap[key] && cellMap[key].instanceId !== instanceId) {
                            return false;
                        }
                    }
                }
                return true;
            };

            // Calculate longest chain of connected items of same type
            const getLongestChain = (startInstanceId, targetType) => {
                const visited = new Set();
                const queue = [startInstanceId];
                visited.add(startInstanceId);

                while (queue.length > 0) {
                    const currentId = queue.shift();
                    const positions = itemPositions[currentId] || [];
                    const offsets = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];

                    positions.forEach(p => {
                        offsets.forEach(({dx, dy}) => {
                            const key = `${p.x + dx},${p.y + dy}`;
                            if (cellMap[key] && cellMap[key].type === targetType &&
                                !visited.has(cellMap[key].instanceId)) {
                                visited.add(cellMap[key].instanceId);
                                queue.push(cellMap[key].instanceId);
                            }
                        });
                    });
                }
                return visited.size;
            };

            // Check if any row is completely filled
            const hasCompleteRow = () => {
                for (let y = 0; y < MECH_CHASSIS.gridRows; y++) {
                    let rowFilled = true;
                    for (let x = 0; x < MECH_CHASSIS.gridCols; x++) {
                        // Only check valid cells in the mech shape
                        if (MECH_CHASSIS.gridShape[y]?.[x] === 1 && !cellMap[`${x},${y}`]) {
                            rowFilled = false;
                            break;
                        }
                    }
                    // Count valid cells in row
                    const validCells = MECH_CHASSIS.gridShape[y]?.filter(c => c === 1).length || 0;
                    if (validCells > 0 && rowFilled) return true;
                }
                return false;
            };

            // Check if any column is completely filled
            const hasCompleteColumn = () => {
                for (let x = 0; x < MECH_CHASSIS.gridCols; x++) {
                    let colFilled = true;
                    let validCells = 0;
                    for (let y = 0; y < MECH_CHASSIS.gridRows; y++) {
                        if (MECH_CHASSIS.gridShape[y]?.[x] === 1) {
                            validCells++;
                            if (!cellMap[`${x},${y}`]) {
                                colFilled = false;
                            }
                        }
                    }
                    if (validCells > 0 && colFilled) return true;
                }
                return false;
            };

            // Now evaluate each item's modifiers
            loadoutState.equipment.forEach(eq => {
                const item = ITEM_DATABASE[eq.itemId];
                if (!item || !eq.position) return;

                const positions = itemPositions[eq.instanceId];
                const modifier = item.modifier;
                if (!modifier || !modifier.effect) return;

                const effect = modifier.effect;

                // Position-based bonuses (Cost 1)
                if (effect.topRowDamageBonus && isInTopRow(positions)) {
                    bonuses[eq.instanceId].damage += effect.topRowDamageBonus;
                }
                if (effect.bottomRowHPBonus && isInBottomRow(positions)) {
                    bonuses[eq.instanceId].hp += effect.bottomRowHPBonus;
                }
                if (effect.edgeDamageBonus && isOnEdge(positions)) {
                    bonuses[eq.instanceId].damage += effect.edgeDamageBonus;
                }
                if (effect.centralEnergyBonus && isCentral(positions)) {
                    bonuses[eq.instanceId].energy += effect.centralEnergyBonus;
                }

                // Adjacency count bonuses (Cost 2)
                if (effect.damagePerAdjacentWeapon) {
                    const count = countAdjacentOfType(positions, 'WEAPON', eq.instanceId);
                    bonuses[eq.instanceId].damage += effect.damagePerAdjacentWeapon * count;
                }
                if (effect.hpPerAdjacentArmor) {
                    const count = countAdjacentOfType(positions, 'ARMOR', eq.instanceId);
                    bonuses[eq.instanceId].hp += effect.hpPerAdjacentArmor * count;
                }
                if (effect.energyPerAdjacentReactor) {
                    const count = countAdjacentOfType(positions, 'REACTOR', eq.instanceId);
                    bonuses[eq.instanceId].energy += effect.energyPerAdjacentReactor * count;
                }

                // Isolation bonuses (Cost 2)
                if (effect.isolationDamageBonus && isIsolated(positions, eq.instanceId)) {
                    bonuses[eq.instanceId].damage += effect.isolationDamageBonus;
                }
                if (effect.isolationHPBonus && isIsolated(positions, eq.instanceId)) {
                    bonuses[eq.instanceId].hp += effect.isolationHPBonus;
                }

                // Corner bonus (Cost 2)
                if (effect.cornerDamageBonus && isInCorner(positions)) {
                    bonuses[eq.instanceId].damage += effect.cornerDamageBonus;
                }

                // Chain bonuses (Cost 3)
                if (effect.damagePerChainWeapon) {
                    const chainLength = getLongestChain(eq.instanceId, 'WEAPON');
                    bonuses[eq.instanceId].damage += effect.damagePerChainWeapon * (chainLength - 1);  // -1 to not count self
                }
                if (effect.hpPerChainArmor) {
                    const chainLength = getLongestChain(eq.instanceId, 'ARMOR');
                    bonuses[eq.instanceId].hp += effect.hpPerChainArmor * (chainLength - 1);
                }

                // Row/Column completion bonuses (Cost 3)
                if (effect.rowCompleteDamageBonus && hasCompleteRow()) {
                    bonuses[eq.instanceId].damage += effect.rowCompleteDamageBonus;
                }
                if (effect.columnCompleteHPBonus && hasCompleteColumn()) {
                    bonuses[eq.instanceId].hp += effect.columnCompleteHPBonus;
                }
            });

            return bonuses;
        }

        function calculatePlayerStats() {
            let totalDamage = 0;
            let totalArmor = 0;
            let totalWeight = 0;
            let hpBonus = 0;
            let damageReduction = 0;  // Takes highest value, doesn't stack
            let energyShieldHP = 0;
            let weapons = [];

            // Calculate adjacency bonuses and positional bonuses
            const adjacencyBonuses = calculateAdjacencyBonuses();
            const positionalBonuses = calculatePositionalBonuses();

            loadoutState.equipment.forEach(eq => {
                const item = ITEM_DATABASE[eq.itemId];
                if (item && item.stats) {
                    totalWeight += item.stats.weight || 0;
                    totalDamage += item.stats.damage || 0;
                    totalArmor += item.stats.armorBonus || 0;
                    hpBonus += item.stats.hpBonus || 0;
                    damageReduction = Math.max(damageReduction, item.stats.damageReduction || 0);  // Highest only
                    energyShieldHP += item.stats.energyShieldHP || 0;

                    // Add positional HP bonus if present
                    const posBonuses = positionalBonuses[eq.instanceId] || { damage: 0, hp: 0, energy: 0 };
                    hpBonus += posBonuses.hp;

                    if (item.type === 'WEAPON') {
                        // Get adjacency bonus for this weapon
                        const adjBonus = adjacencyBonuses[eq.instanceId] || 0;
                        const baseDamage = item.stats.damage || 0;
                        // Include positional damage bonus
                        const totalWeaponDamage = baseDamage + adjBonus + posBonuses.damage;

                        // Pass full weapon info for battle simulation
                        weapons.push({
                            itemId: eq.itemId,
                            instanceId: eq.instanceId,
                            slot: eq.slot,
                            name: item.name,
                            damage: totalWeaponDamage,  // Base + adjacency + positional!
                            baseDamage: baseDamage,
                            adjacencyBonus: adjBonus,
                            positionalBonus: posBonuses.damage,
                            battle: item.battle || {},
                            synergies: item.synergies || [],
                            synergyDescription: item.synergyDescription || ''
                        });

                        // Log synergy activation
                        const totalBonus = adjBonus + posBonuses.damage;
                        if (totalBonus > 0) {
                            const shots = item.battle?.shotsPerRound || 1;
                            console.log(`ðŸŽ¯ BONUS! ${item.name}: ${baseDamage}+${totalBonus}=${totalWeaponDamage} damage x${shots} shots = ${totalWeaponDamage * shots} total`);
                        }
                    }
                }
            });

            // Use mech's base HP + hpBonus from armor
            // Player gets 2x health advantage
            const mech = getActiveMech();
            const baseHealth = mech.baseHP || 25;
            const totalHealth = (baseHealth + hpBonus) * 2;

            return {
                maxHealth: totalHealth,
                currentHealth: totalHealth,
                damage: Math.max(5, totalDamage),  // Minimum 5 damage
                armor: totalArmor,
                damageReduction: damageReduction,  // -X damage from ballistic/missile
                energyShieldHP: energyShieldHP,    // Absorbs energy weapon damage
                weapons: weapons
            };
        }

        // Create battle arena
        function createBattleArena(scene) {
            // Ground
            const ground = BABYLON.MeshBuilder.CreateGround('battleGround', { width: 40, height: 25 }, scene);
            const groundMat = new BABYLON.StandardMaterial('groundMat', scene);
            groundMat.diffuseColor = new BABYLON.Color3(0.25, 0.3, 0.2);
            groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            ground.material = groundMat;
            ground.receiveShadows = true;
            battleGround = ground;

            // Battle lighting
            const battleLight = new BABYLON.DirectionalLight('battleLight', new BABYLON.Vector3(-1, -2, -1), scene);
            battleLight.intensity = 1.2;
            battleLight.position = new BABYLON.Vector3(10, 20, 10);

            const ambientLight = new BABYLON.HemisphericLight('battleAmbient', new BABYLON.Vector3(0, 1, 0), scene);
            ambientLight.intensity = 0.4;

            return ground;
        }

        // Build weapons list from equipment array using ITEM_DATABASE
        function buildWeaponsFromEquipment(equipment) {
            const weapons = [];
            if (!equipment) return weapons;

            equipment.forEach(eq => {
                const item = ITEM_DATABASE[eq.itemId];
                if (item && item.type === 'WEAPON') {
                    weapons.push({
                        itemId: eq.itemId,
                        slot: eq.slot,
                        name: item.name,
                        damage: item.stats.damage || 0,
                        battle: item.battle || {}
                    });
                }
            });
            return weapons;
        }

        function startBattle() {
            if (loadoutState.equipment.length === 0 || !selectedMission) {
                return;
            }

            const mission = MISSIONS[selectedMission];
            const playerStats = calculatePlayerStats();

            // Save mission info for salvage generation
            lastBattleMission = {
                ...mission,
                averageLevel: mission.averageLevel || Math.round(mission.enemyMechs.reduce((sum, e) => sum + e.level, 0) / mission.enemyMechs.length)
            };

            // Build ALL enemies with their weapons from ITEM_DATABASE
            const enemies = mission.enemyMechs.map(enemy => ({
                ...enemy,
                weapons: buildWeaponsFromEquipment(enemy.equipment)
            }));

            // Build battle config for the original physics simulation
            const battleConfig = {
                player: {
                    name: MECH_CHASSIS.name,
                    loadout: loadoutState,
                    stats: playerStats
                },
                mission: mission,
                // Pass ALL enemies for multi-enemy battles
                enemies: enemies,
                // Also pass first enemy as 'enemy' for backwards compatibility
                enemy: enemies[0],
                // Pass ITEM_DATABASE for future use (special properties, etc.)
                itemDatabase: ITEM_DATABASE
            };

            // Save to localStorage (battle-arena.html reads this)
            localStorage.setItem('battleConfig', JSON.stringify(battleConfig));

            // Hide builder UI and canvas
            document.getElementById('mechBuilderUI').style.display = 'none';
            document.getElementById('renderCanvas').style.display = 'none';

            // Show and load the battle iframe with the physics simulation
            const battleFrame = document.getElementById('battleFrame');
            battleFrame.style.display = 'block';
            // Add cache-busting parameter and background parameter
            battleFrame.src = `battle-arena.html?t=${Date.now()}&bg=${selectedBackground}&piloting=${userPilotingEnabled ? '1' : '0'}`;

            currentPhase = GamePhase.BATTLE;
        }

        // Listen for messages from battle iframe
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'battleEnd') {
                const result = event.data.result || 'victory';
                const rewards = event.data.rewards || { xp: 0, scrap: 0, components: [] };
                const enemyDamageData = event.data.enemyDamageData || null;
                showSalvageScreen(result, rewards, enemyDamageData);
            }
        });

        // Show salvage screen with rewards
        // Build HTML for component stats display
        function buildComponentStatsHTML(component) {
            const stats = component.stats || {};
            const battle = component.battle || {};
            let statsLines = [];

            // Format stat values - show damage with xN if fires multiple times
            if (stats.damage) {
                const shotsPerRound = battle.shotsPerRound || 1;
                if (shotsPerRound > 1) {
                    statsLines.push(`DMG: ${stats.damage} x${shotsPerRound}`);
                } else {
                    statsLines.push(`DMG: ${stats.damage}`);
                }
            }
            if (stats.armorBonus) statsLines.push(`ARM: +${stats.armorBonus}`);
            if (stats.accuracyBonus) statsLines.push(`ACC: +${stats.accuracyBonus}%`);
            if (stats.evasionBonus) statsLines.push(`EVA: +${stats.evasionBonus}%`);
            if (stats.energyDraw > 0) statsLines.push(`EN: ${stats.energyDraw}`);
            if (stats.energyDraw < 0) statsLines.push(`âš¡ +${Math.abs(stats.energyDraw)}`);
            if (stats.energyReduction) statsLines.push(`COOL: -${stats.energyReduction}`);
            if (stats.adjacentDamageBonus) statsLines.push(`âš”ï¸ +${stats.adjacentDamageBonus} adj wpn`);
            if (stats.adjacentArmorBonus) statsLines.push(`ðŸ›¡ï¸ +${stats.adjacentArmorBonus} adj arm`);
            if (stats.adjacentEnergyBonus) statsLines.push(`âš¡ +${stats.adjacentEnergyBonus} adj pwr`);
            if (stats.heatCapacity) statsLines.push(`HEAT: ${stats.heatCapacity}`);
            if (battle.knockback) statsLines.push(`KB: ${battle.knockback}`);

            return statsLines.join(' | ');
        }

        // Build shape preview HTML for component
        function buildShapePreviewHTML(component) {
            const shape = component.gridShape;
            const rarityColor = COMPONENT_GENERATION.rarityColors[component.rarity] || '#aaa';
            let html = '<div style="display: inline-grid; gap: 1px; margin-top: 5px;">';

            for (let row of shape) {
                html += '<div style="display: flex; gap: 1px;">';
                for (let cell of row) {
                    if (cell === 1) {
                        html += `<div style="width: 12px; height: 12px; background: ${rarityColor}; border: 1px solid rgba(255,255,255,0.3);"></div>`;
                    } else {
                        html += '<div style="width: 12px; height: 12px;"></div>';
                    }
                }
                html += '</div>';
            }
            html += '</div>';
            return html;
        }

        function showSalvageScreen(result, rewards, enemyDamageData) {
            // Hide battle iframe
            const battleFrame = document.getElementById('battleFrame');
            battleFrame.style.display = 'none';
            battleFrame.src = '';

            // Get enemy level and difficulty from the mission we just fought
            const missionEnemyLevel = lastBattleMission ? lastBattleMission.averageLevel : Math.floor(currentEnemyLevel);
            const missionDifficulty = lastBattleMission ? lastBattleMission.difficulty : 'Easy';

            // Generate salvage options using the mission's enemy level and difficulty
            // Pass enemy damage data for body-part-based salvage calculation
            const salvageOptions = generateSalvageOptions(result, missionEnemyLevel, missionDifficulty, enemyDamageData);

            // Calculate skip salvage gold bonus (highest original level of salvage)
            const skipGoldBonus = salvageOptions.length > 0 ?
                Math.max(...salvageOptions.map(opt => opt.originalLevel || opt.level || 1)) : 0;

            // Get max picks allowed
            const maxPicks = getSalvagePicks(result);

            // Track selected components (multiple selection support)
            let selectedComponents = [];

            // Award gold for the round
            const goldReward = awardRoundGold(result === 'victory');

            // Update game progression
            if (result === 'victory') {
                gameProgression.wins++;
                gameProgression.round++;
                gameProgression.maxRound = Math.max(gameProgression.maxRound, gameProgression.round);
            } else {
                gameProgression.losses++;
            }

            const isBoss = DIFFICULTY.isBossRound(gameProgression.round - 1);  // Check previous round

            // Create salvage overlay
            const overlay = document.createElement('div');
            overlay.id = 'salvageOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0, 20, 10, 0.95);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-start;
                z-index: 1000;
                font-family: 'Courier New', monospace;
                overflow-y: auto;
                padding: 20px;
            `;

            const resultColor = result === 'victory' ? '#00ff88' : '#ff4444';
            const resultText = result === 'victory' ?
                (isBoss ? 'BOSS DEFEATED!' : 'MISSION COMPLETE') :
                'MISSION FAILED';

            // Calculate sell prices for each salvage option
            function getSellPrice(comp) {
                // Damaged items have 0 sell value
                if (comp.isDamaged) return 0;
                const basePrice = ECONOMY.weaponPrices[comp.rarity || 'common'] || 2;
                const bonus = comp.isHighValue ? (1 + comp.resaleBonus) : 1;
                return Math.floor(basePrice * ECONOMY.sellMultiplier * bonus);
            }

            // Build salvage options HTML
            let salvageHTML = '';
            if (salvageOptions.length > 0) {
                salvageHTML = `
                    <div style="margin-top: 25px; width: 100%; max-width: 1000px;">
                        <div style="font-size: 16px; color: #00aa66; margin-bottom: 15px; text-align: center; letter-spacing: 2px;">
                            SALVAGEABLE COMPONENTS <span id="pickCounter">(Select up to ${maxPicks})</span>
                        </div>
                        <div id="salvageOptionsContainer" style="display: flex; flex-wrap: wrap; gap: 12px; justify-content: center;">
                            ${salvageOptions.map((comp, index) => {
                                const rarityColor = COMPONENT_GENERATION.rarityColors[comp.rarity] || '#aaa';
                                const rarityName = comp.rarity.charAt(0).toUpperCase() + comp.rarity.slice(1);
                                const sellPrice = getSellPrice(comp);

                                // Show appropriate badge
                                let badgeHTML = '';
                                if (comp.isDamaged) {
                                    badgeHTML = `<div style="position: absolute; top: -8px; left: -8px; background: #ff6644; color: #fff; font-size: 9px; padding: 2px 5px; border-radius: 3px; font-weight: bold;">âš ï¸ DAMAGED</div>`;
                                } else if (comp.isHighValue) {
                                    badgeHTML = `<div style="position: absolute; top: -8px; left: -8px; background: #ffcc00; color: #000; font-size: 9px; padding: 2px 5px; border-radius: 3px; font-weight: bold;">ðŸ’° HIGH VALUE</div>`;
                                } else {
                                    // Undamaged but not high value - show pristine badge
                                    badgeHTML = `<div style="position: absolute; top: -8px; left: -8px; background: #44ff88; color: #000; font-size: 9px; padding: 2px 5px; border-radius: 3px; font-weight: bold;">âœ¨ PRISTINE</div>`;
                                }

                                // Border style for damaged items
                                const borderStyle = comp.isDamaged ? 'dashed' : 'solid';

                                return `
                                    <div class="salvage-option" data-index="${index}" style="
                                        background: rgba(0, 0, 0, 0.5);
                                        border: 2px ${borderStyle} ${rarityColor};
                                        border-radius: 8px;
                                        padding: 12px;
                                        width: 160px;
                                        cursor: pointer;
                                        transition: all 0.2s;
                                        position: relative;
                                        ${comp.isDamaged ? 'opacity: 0.85;' : ''}
                                    ">
                                        ${badgeHTML}
                                        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                            <div style="font-size: 22px;">${comp.icon}</div>
                                            <div style="text-align: right;">
                                                <div style="font-size: 9px; color: ${rarityColor}; text-transform: uppercase; letter-spacing: 1px;">${rarityName}</div>
                                                <div style="font-size: 9px; color: #666;">Lv.${comp.level}${comp.isDamaged ? ` <span style="color: #ff6644;">(â†“)</span>` : ''}</div>
                                            </div>
                                        </div>
                                        <div style="font-size: 11px; color: ${rarityColor}; margin: 6px 0; font-weight: bold; line-height: 1.2;">
                                            ${comp.name}
                                        </div>
                                        ${buildItemStatIcons(comp)}
                                        <div class="item-bottom-row" style="display: flex; justify-content: space-between; align-items: center; margin-top: 6px;">
                                            ${buildItemSecondaryStats(comp)}
                                            ${buildInlineShapePreview(comp, 8)}
                                        </div>
                                        <div style="text-align: right; margin-top: 4px; padding-top: 4px; border-top: 1px solid #333;">
                                            <div style="font-size: 10px; color: ${sellPrice > 0 ? '#ffcc00' : '#666'};">${sellPrice > 0 ? `Sell: ${sellPrice}g` : 'No value'}</div>
                                        </div>
                                        <div class="selection-indicator" style="
                                            position: absolute;
                                            top: -8px; right: -8px;
                                            width: 24px; height: 24px;
                                            background: #00ff88;
                                            border-radius: 50%;
                                            display: none;
                                            align-items: center;
                                            justify-content: center;
                                            font-size: 14px;
                                            color: #000;
                                            font-weight: bold;
                                        ">âœ“</div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            } else {
                salvageHTML = `
                    <div style="margin-top: 25px; color: #666; font-style: italic;">
                        No salvageable components found.
                    </div>
                `;
            }

            overlay.innerHTML = `
                <div style="font-size: 14px; color: #666; letter-spacing: 4px; margin-bottom: 8px;">ROUND ${gameProgression.round - (result === 'victory' ? 1 : 0)} ${isBoss ? '- BOSS' : ''}</div>
                <div style="font-size: 32px; font-weight: bold; color: ${resultColor}; text-shadow: 0 0 20px ${resultColor}; margin-bottom: 15px;">
                    ${resultText}
                </div>
                <div style="background: rgba(0, 0, 0, 0.3); padding: 20px 30px; border-radius: 12px; text-align: center;">
                    <div style="font-size: 16px; color: #aaa; margin-bottom: 12px;">Rewards Collected:</div>
                    <div style="display: flex; gap: 25px; justify-content: center; flex-wrap: wrap;">
                        <div style="text-align: center;">
                            <div style="font-size: 28px; color: #ffcc00;">+${goldReward.total}</div>
                            <div style="font-size: 10px; color: #888;">GOLD</div>
                            <div style="font-size: 9px; color: #666; margin-top: 2px;">
                                ${goldReward.base} base ${goldReward.streak > 0 ? `+ ${goldReward.streak} streak` : ''} ${goldReward.interest > 0 ? `+ ${goldReward.interest} interest` : ''}
                            </div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 28px; color: #ffcc00;">${playerResources.gold}</div>
                            <div style="font-size: 10px; color: #888;">TOTAL GOLD</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 28px; color: #88aaff;">+${rewards.xp}</div>
                            <div style="font-size: 10px; color: #888;">EXPERIENCE</div>
                        </div>
                    </div>
                </div>
                ${salvageHTML}
                <div style="display: flex; gap: 15px; margin-top: 25px; margin-bottom: 20px;">
                    <button id="skipSalvageBtn" style="
                        padding: 10px 25px;
                        font-size: 13px;
                        background: rgba(255, 200, 0, 0.15);
                        border: 2px solid #aa8800;
                        color: #ffcc00;
                        cursor: pointer;
                        border-radius: 6px;
                        font-family: 'Courier New', monospace;
                        text-transform: uppercase;
                        letter-spacing: 1px;
                    ">Skip Salvage (+${skipGoldBonus}g)</button>
                    <button id="confirmSalvageBtn" style="
                        padding: 10px 25px;
                        font-size: 13px;
                        background: rgba(0, 255, 136, 0.2);
                        border: 2px solid #00ff88;
                        color: #00ff88;
                        cursor: pointer;
                        border-radius: 6px;
                        font-family: 'Courier New', monospace;
                        text-transform: uppercase;
                        letter-spacing: 1px;
                        opacity: 0.5;
                    " disabled>Take Selected (0/${maxPicks})</button>
                </div>
            `;

            document.body.appendChild(overlay);

            // Update pick counter and button
            function updatePickUI() {
                const counter = document.getElementById('pickCounter');
                const btn = document.getElementById('confirmSalvageBtn');
                if (counter) {
                    counter.textContent = `(${selectedComponents.length}/${maxPicks} selected)`;
                }
                if (btn) {
                    btn.textContent = `Take Selected (${selectedComponents.length}/${maxPicks})`;
                    btn.disabled = selectedComponents.length === 0;
                    btn.style.opacity = selectedComponents.length > 0 ? '1' : '0.5';
                }
            }

            // Handle salvage option selection (multiple)
            const optionElements = overlay.querySelectorAll('.salvage-option');
            optionElements.forEach((el, index) => {
                el.addEventListener('click', () => {
                    const comp = salvageOptions[index];
                    const existingIndex = selectedComponents.indexOf(comp);

                    if (existingIndex > -1) {
                        // Deselect
                        selectedComponents.splice(existingIndex, 1);
                        el.style.transform = 'scale(1)';
                        el.style.boxShadow = 'none';
                        el.querySelector('.selection-indicator').style.display = 'none';
                    } else if (selectedComponents.length < maxPicks) {
                        // Select
                        selectedComponents.push(comp);
                        el.style.transform = 'scale(1.05)';
                        el.style.boxShadow = `0 0 20px ${COMPONENT_GENERATION.rarityColors[comp.rarity]}`;
                        el.querySelector('.selection-indicator').style.display = 'flex';
                    }
                    // If at max picks and clicking unselected, do nothing

                    updatePickUI();
                });

                // Hover effect with tooltip
                el.addEventListener('mouseenter', (e) => {
                    showItemTooltip(salvageOptions[index], e);
                    if (!selectedComponents.includes(salvageOptions[index])) {
                        el.style.transform = 'scale(1.02)';
                    }
                });
                el.addEventListener('mousemove', moveItemTooltip);
                el.addEventListener('mouseleave', () => {
                    hideItemTooltip();
                    if (!selectedComponents.includes(salvageOptions[index])) {
                        el.style.transform = 'scale(1)';
                    }
                });
            });

            // Handle skip button
            document.getElementById('skipSalvageBtn').addEventListener('click', () => {
                // Award skip gold bonus
                playerResources.gold += skipGoldBonus;
                finishSalvage([], rewards, overlay, result, skipGoldBonus);
            });

            // Handle confirm button
            document.getElementById('confirmSalvageBtn').addEventListener('click', () => {
                finishSalvage(selectedComponents, rewards, overlay, result, 0);
            });
        }

        // Complete the salvage process
        function finishSalvage(selectedComponents, rewards, overlay, result, skipGoldBonus = 0) {
            // Apply XP and scrap rewards
            playerResources.xp += rewards.xp;
            playerResources.scrap += rewards.scrap;

            // Handle array of selected components (or empty array)
            const components = Array.isArray(selectedComponents) ? selectedComponents : (selectedComponents ? [selectedComponents] : []);

            // Add each selected component to bench
            components.forEach(comp => {
                // Register in ITEM_DATABASE so it can be used in gameplay
                registerGeneratedComponent(comp);

                // Add to bench so it's immediately available
                addItemToBench(comp.id);
                console.log(`Salvaged: ${comp.name} (${comp.rarity} Lv.${comp.level})`);
            });

            // Increase enemy level for progression based on round (using new difficulty system)
            const isVictory = result === 'victory';
            const round = gameProgression.round;

            // Enemy level scales with difficulty multiplier
            currentEnemyLevel = Math.max(1, DIFFICULTY.getMultiplier(round) * 2);

            console.log(`Round ${round}, Difficulty: ${DIFFICULTY.getMultiplier(round).toFixed(2)}, Enemy Level: ${currentEnemyLevel.toFixed(2)}`);

            // Generate new shop inventory for next round
            generateShopInventory();

            // Remove overlay
            overlay.remove();

            // Handle post-battle cleanup
            handlePostBattle();
        }

        // Handle post-battle cleanup
        function handlePostBattle() {
            // Clear localStorage
            localStorage.removeItem('battleConfig');

            // Keep equipped items on mech - don't return to bench
            // Equipment persists between battles

            // Clear mission selection
            selectedMission = null;

            // Regenerate missions with new enemy levels (progression!)
            MISSIONS = buildMissions();

            // Show builder UI
            document.getElementById('mechBuilderUI').style.display = 'flex';
            document.getElementById('renderCanvas').style.display = 'block';

            // Switch to loadout tab (not mission)
            switchTab('loadout');

            // Re-render everything
            renderBench();
            renderMissions();
            renderUnifiedMechGrid();
            renderUnifiedGridItems();
            updateStats();

            currentPhase = GamePhase.MECHBUILDER;
        }

        // ============================================
        // ENGINE INITIALIZATION
        // ============================================
        async function initEngine() {
            const canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, {
                preserveDrawingBuffer: true,
                stencil: true,
                antialias: true
            });

            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.02, 0.04, 0.03, 1);

            // Initialize MechBuilder
            createBuilderScene();
            initializeGrids();

            // Initialize starter items on bench (no deck system)
            initializeStarterItems();

            // Render UI
            renderBench();
            renderMissions();
            renderUnifiedMechGrid();
            renderUnifiedGridItems();
            updateStats();

            // Initialize drag and drop
            initDragAndDrop();

            // Go to Missions button
            document.getElementById('goToMissionsBtn').addEventListener('click', function() {
                switchTab('mission');
            });

            // Shop button
            document.getElementById('goToShopBtn').addEventListener('click', function() {
                switchTab('shop');
            });

            // Initialize shop inventory
            generateShopInventory();
            updateHeaderDisplay();

            // (Deck pile viewers removed - no deck system)

            // Main render loop with delta time for battle updates
            let lastFrameTime = performance.now();
            engine.runRenderLoop(() => {
                const now = performance.now();
                const dt = (now - lastFrameTime) / 1000;
                lastFrameTime = now;

                // Render appropriate scene based on phase
                if (currentPhase === GamePhase.BATTLE && battleScene) {
                    // Update battle mechanics
                    if (battleActive) {
                        updateBattle(dt);
                    }
                    battleScene.render();
                } else if (scene) {
                    scene.render();
                }
            });

            // Handle window resize
            window.addEventListener('resize', () => {
                engine.resize();
                // Check mobile layout and re-render grid on resize
                if (currentPhase === GamePhase.MECHBUILDER) {
                    setTimeout(() => {
                        checkMobileLayout();
                        renderUnifiedMechGrid();
                        renderUnifiedGridItems();
                    }, 100);
                }
            });

            // Handle orientation change for mobile
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    checkMobileLayout();
                    if (currentPhase === GamePhase.MECHBUILDER) {
                        renderUnifiedMechGrid();
                        renderUnifiedGridItems();
                    }
                }, 200);
            });

            // Initial mobile layout check
            checkMobileLayout();

            console.log('MechBuilder initialized!');
        }

        // ============================================
        // TEST FUNCTIONS (call from browser console)
        // ============================================
        function testComponentGeneration() {
            console.log('=== COMPONENT GENERATION TESTS ===\n');
            let passed = 0;
            let failed = 0;

            function assert(condition, testName, details = '') {
                if (condition) {
                    console.log(`âœ“ ${testName}`);
                    passed++;
                } else {
                    console.error(`âœ— ${testName}`, details);
                    failed++;
                }
            }

            // Test 1: Level 1 Common should have prototype stats
            console.log('\n--- Test 1: Level 1 Common = Prototype Stats ---');
            const laser1 = generateComponent('laser', 1, 'common');
            assert(laser1.stats.damage === 4, 'Laser L1 damage = 4 (prototype)', `Got: ${laser1.stats.damage}`);
            assert(laser1.stats.energyDraw === 2, 'Laser L1 energy = 2 (prototype)', `Got: ${laser1.stats.energyDraw}`);
            assert(laser1.stats.weight === 1, 'Laser L1 weight = 1 (prototype)', `Got: ${laser1.stats.weight}`);
            assert(laser1.budgetInfo.levelBudget === 0, 'Level budget = 0 at L1', `Got: ${laser1.budgetInfo.levelBudget}`);
            assert(laser1.budgetInfo.rarityBudget === 0, 'Rarity budget = 0 for common', `Got: ${laser1.budgetInfo.rarityBudget}`);
            assert(laser1.modifier === null, 'No modifier on common item', `Got: ${laser1.modifier}`);

            // Test 2: Level 5 should have +4 budget
            console.log('\n--- Test 2: Level 5 Common = +4 Budget ---');
            const laser5 = generateComponent('laser', 5, 'common');
            assert(laser5.budgetInfo.levelBudget === 4, 'Level budget = 4 at L5', `Got: ${laser5.budgetInfo.levelBudget}`);
            assert(laser5.stats.damage >= 4, 'Laser L5 damage >= 4', `Got: ${laser5.stats.damage}`);
            // Damage should increase (most of budget goes to damage since it's 50% of prototype spend)
            assert(laser5.stats.damage > laser1.stats.damage, 'Laser L5 damage > L1 damage', `L5: ${laser5.stats.damage}, L1: ${laser1.stats.damage}`);

            // Test 3: Multi-hit weapons should NOT scale damage
            console.log('\n--- Test 3: Multi-Hit Weapons = Fixed Damage ---');
            const minigun1 = generateComponent('minigun', 1, 'common');
            const minigun10 = generateComponent('minigun', 10, 'common');
            assert(minigun1.stats.damage === 1, 'Minigun L1 damage = 1 (fixed)', `Got: ${minigun1.stats.damage}`);
            assert(minigun10.stats.damage === 1, 'Minigun L10 damage = 1 (still fixed!)', `Got: ${minigun10.stats.damage}`);
            assert(minigun1.battle.shotsPerRound === 8, 'Minigun shots = 8', `Got: ${minigun1.battle.shotsPerRound}`);

            const pulseLaser1 = generateComponent('pulse_laser', 1, 'common');
            const pulseLaser10 = generateComponent('pulse_laser', 10, 'common');
            assert(pulseLaser1.stats.damage === 1, 'Pulse Laser L1 damage = 1 (fixed)', `Got: ${pulseLaser1.stats.damage}`);
            assert(pulseLaser10.stats.damage === 1, 'Pulse Laser L10 damage = 1 (still fixed!)', `Got: ${pulseLaser10.stats.damage}`);

            // Test 4: Rarity budget scales with level range
            console.log('\n--- Test 4: Rarity Budget Scaling ---');
            const rareLv3 = generateComponent('laser', 3, 'rare');
            const rareLv8 = generateComponent('laser', 8, 'rare');
            const rareLv12 = generateComponent('laser', 12, 'rare');
            assert(rareLv3.budgetInfo.rarityBudget === 2, 'Rare L3: rarity budget = 2 (tier 2 Ã— 1)', `Got: ${rareLv3.budgetInfo.rarityBudget}`);
            assert(rareLv8.budgetInfo.rarityBudget === 4, 'Rare L8: rarity budget = 4 (tier 2 Ã— 2)', `Got: ${rareLv8.budgetInfo.rarityBudget}`);
            assert(rareLv12.budgetInfo.rarityBudget === 6, 'Rare L12: rarity budget = 6 (tier 2 Ã— 3)', `Got: ${rareLv12.budgetInfo.rarityBudget}`);

            const legendaryLv5 = generateComponent('laser', 5, 'legendary');
            const legendaryLv10 = generateComponent('laser', 10, 'legendary');
            assert(legendaryLv5.budgetInfo.rarityBudget === 4, 'Legendary L5: rarity budget = 4 (tier 4 Ã— 1)', `Got: ${legendaryLv5.budgetInfo.rarityBudget}`);
            assert(legendaryLv10.budgetInfo.rarityBudget === 8, 'Legendary L10: rarity budget = 8 (tier 4 Ã— 2)', `Got: ${legendaryLv10.budgetInfo.rarityBudget}`);

            // Test 5: Weight/energy reduction max -1
            console.log('\n--- Test 5: Weight/Energy Reduction Capped at -1 ---');
            // Generate many items to check that reductions never exceed -1
            let maxWeightReduction = 0;
            let maxEnergyReduction = 0;
            for (let i = 0; i < 100; i++) {
                const item = generateComponent('laser', 10, 'legendary');
                maxWeightReduction = Math.max(maxWeightReduction, item.budgetInfo.weightReduced);
                maxEnergyReduction = Math.max(maxEnergyReduction, item.budgetInfo.energyReduced);
            }
            assert(maxWeightReduction <= 1, 'Weight reduction never exceeds 1', `Max seen: ${maxWeightReduction}`);
            assert(maxEnergyReduction <= 1, 'Energy reduction never exceeds 1', `Max seen: ${maxEnergyReduction}`);

            // Test 6: Only uncommon+ gets modifiers
            console.log('\n--- Test 6: Modifiers Only on Uncommon+ ---');
            let commonModCount = 0;
            let uncommonModCount = 0;
            for (let i = 0; i < 100; i++) {
                const common = generateComponent('laser', 15, 'common');
                const uncommon = generateComponent('laser', 15, 'uncommon');
                if (common.modifier) commonModCount++;
                if (uncommon.modifier) uncommonModCount++;
            }
            assert(commonModCount === 0, 'Common items never get modifiers', `Got ${commonModCount} modifiers in 100 items`);
            assert(uncommonModCount > 0, 'Uncommon items can get modifiers', `Got ${uncommonModCount} modifiers in 100 items`);

            // Test 7: Higher rarity = access to higher cost modifiers
            console.log('\n--- Test 7: Modifier Budget by Rarity ---');
            let uncommonMaxCost = 0;
            let rareMaxCost = 0;
            let epicMaxCost = 0;
            for (let i = 0; i < 200; i++) {
                const uncommon = generateComponent('laser', 15, 'uncommon');
                const rare = generateComponent('laser', 15, 'rare');
                const epic = generateComponent('laser', 15, 'epic');
                if (uncommon.modifier) {
                    const cost = Object.keys(COMPONENT_GENERATION.modifiers).find(c =>
                        COMPONENT_GENERATION.modifiers[c].some(m => m.id === uncommon.modifier.id)
                    );
                    uncommonMaxCost = Math.max(uncommonMaxCost, parseInt(cost) || 0);
                }
                if (rare.modifier) {
                    const cost = Object.keys(COMPONENT_GENERATION.modifiers).find(c =>
                        COMPONENT_GENERATION.modifiers[c].some(m => m.id === rare.modifier.id)
                    );
                    rareMaxCost = Math.max(rareMaxCost, parseInt(cost) || 0);
                }
                if (epic.modifier) {
                    const cost = Object.keys(COMPONENT_GENERATION.modifiers).find(c =>
                        COMPONENT_GENERATION.modifiers[c].some(m => m.id === epic.modifier.id)
                    );
                    epicMaxCost = Math.max(epicMaxCost, parseInt(cost) || 0);
                }
            }
            assert(uncommonMaxCost <= 1, 'Uncommon max modifier cost = 1', `Got: ${uncommonMaxCost}`);
            assert(rareMaxCost <= 2, 'Rare max modifier cost = 2', `Got: ${rareMaxCost}`);
            assert(epicMaxCost <= 3, 'Epic max modifier cost = 3', `Got: ${epicMaxCost}`);

            // Test 8: Armor HP scaling
            console.log('\n--- Test 8: Armor HP Scaling ---');
            const armor1 = generateComponent('armor_medium', 1, 'common');
            const armor5 = generateComponent('armor_medium', 5, 'common');
            assert(armor1.stats.hpBonus === 11, 'Medium Armor L1 HP = 11 (prototype)', `Got: ${armor1.stats.hpBonus}`);
            assert(armor5.stats.hpBonus > armor1.stats.hpBonus, 'Medium Armor L5 HP > L1 HP', `L5: ${armor5.stats.hpBonus}, L1: ${armor1.stats.hpBonus}`);

            // Test 9: Minimum Level System
            console.log('\n--- Test 9: Minimum Level Calculation ---');
            const minLevels = getMinLevelCache();

            // Minigun: 4 cells + 2 weight + 2 energy = 8 earned
            //          8 damage (1Ã—8) + 3.5 multi-hit = 11.5 spent
            //          Net: 8 - 11.5 = -3.5, minLevel = ceil(3.5) + 1 = 5
            const minigunMinLevel = minLevels['minigun'];
            assert(minigunMinLevel >= 4, 'Minigun minLevel >= 4 (overpowered at L1)', `Got: ${minigunMinLevel}`);

            // Laser: 2 cells + 1 weight + 4 energy = 7 earned
            //        4 damage = 4 spent
            //        Net: 7 - 4 = +3, minLevel = 1 (underpowered)
            const laserMinLevel = minLevels['laser'];
            assert(laserMinLevel === 1, 'Laser minLevel = 1 (balanced/underpowered)', `Got: ${laserMinLevel}`);

            // Machinegun: 3 cells + 1 weight + 0 energy = 4 earned
            //             2 damage (1Ã—2) + 0.5 multi-hit = 2.5 spent
            //             Net: 4 - 2.5 = +1.5, minLevel = 1
            const machinegunMinLevel = minLevels['machinegun'];
            assert(machinegunMinLevel === 1, 'Machinegun minLevel = 1 (underpowered)', `Got: ${machinegunMinLevel}`);

            // Test 10: Budget Balance Sanity Check
            console.log('\n--- Test 10: Budget Balance Values ---');
            const templates = ['railgun', 'laser', 'missile', 'machinegun', 'minigun', 'pulse_laser',
                              'ballistic_plating', 'armor_medium', 'reactor', 'targeting_hub'];
            for (const key of templates) {
                if (ITEM_TEMPLATES[key]) {
                    const balance = calculateTemplateBudgetBalance(ITEM_TEMPLATES[key]);
                    const minLevel = minLevels[key];
                    console.log(`  ${key}: earned=${balance.budgetEarned.toFixed(1)}, spent=${balance.budgetSpent.toFixed(1)}, net=${balance.netBalance.toFixed(1)}, minLevel=${minLevel}`);
                }
            }
            // Just verify the function runs without error
            assert(Object.keys(minLevels).length > 0, 'MinLevel cache populated', `Keys: ${Object.keys(minLevels).length}`);

            // Summary
            console.log('\n=== TEST SUMMARY ===');
            console.log(`Passed: ${passed}`);
            console.log(`Failed: ${failed}`);
            console.log(`Total: ${passed + failed}`);

            return { passed, failed };
        }

        // Quick item generation diagnostic
        function showItemStats(templateType, level = 1, rarity = 'common') {
            const item = generateComponent(templateType, level, rarity);
            console.log(`\n=== ${item.name} (${templateType} L${level} ${rarity}) ===`);
            console.log('Stats:', item.stats);
            console.log('Battle:', item.battle || 'N/A');
            console.log('Budget Info:', item.budgetInfo);
            if (item.modifier) {
                console.log('Modifier:', item.modifier.name, '-', item.modifier.description);
            }
            return item;
        }

        // Generate comparison table
        function compareItemLevels(templateType, levels = [1, 5, 10], rarities = ['common', 'rare', 'legendary']) {
            console.log(`\n=== ${templateType} Level/Rarity Comparison ===`);
            const results = [];
            for (const rarity of rarities) {
                for (const level of levels) {
                    const item = generateComponent(templateType, level, rarity);
                    results.push({
                        level,
                        rarity,
                        damage: item.stats.damage || '-',
                        energy: item.stats.energyDraw || '-',
                        weight: item.stats.weight || '-',
                        hp: item.stats.hpBonus || '-',
                        dr: item.stats.damageReduction || '-',
                        levelBudget: item.budgetInfo.levelBudget,
                        rarityBudget: item.budgetInfo.rarityBudget,
                        modifier: item.modifier ? item.modifier.name : '-'
                    });
                }
            }
            console.table(results);
            return results;
        }

        // Show budget balance for all templates
        function showAllTemplateBudgets() {
            console.log('\n=== TEMPLATE BUDGET BALANCE REPORT ===');
            const results = [];
            const minLevels = getMinLevelCache();

            for (const [key, template] of Object.entries(ITEM_TEMPLATES)) {
                const balance = calculateTemplateBudgetBalance(template);
                results.push({
                    template: key,
                    type: template.type,
                    cells: balance.cells,
                    shots: balance.shots,
                    earned: balance.budgetEarned.toFixed(1),
                    spent: balance.budgetSpent.toFixed(1),
                    net: balance.netBalance.toFixed(1),
                    minLevel: minLevels[key]
                });
            }

            // Sort by minLevel descending (most restricted first)
            results.sort((a, b) => b.minLevel - a.minLevel);
            console.table(results);

            // Summary
            const overpowered = results.filter(r => r.minLevel > 1);
            console.log(`\nOverpowered templates (need higher level):`);
            for (const r of overpowered) {
                console.log(`  ${r.template}: minLevel ${r.minLevel} (net ${r.net})`);
            }

            return results;
        }

        // Expose test functions globally
        window.testComponentGeneration = testComponentGeneration;
        window.showItemStats = showItemStats;
        window.compareItemLevels = compareItemLevels;
        window.showAllTemplateBudgets = showAllTemplateBudgets;
        window.getMinLevelCache = getMinLevelCache;
        window.calculateTemplateBudgetBalance = calculateTemplateBudgetBalance;

        // Start the game
        initEngine();
    </script>
</body>
</html>
