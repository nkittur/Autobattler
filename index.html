<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mech Autobattler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            background-attachment: fixed;
            color: #eee;
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 10px;
        }

        header {
            background: rgba(0, 0, 0, 0.5);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 2px solid #00ff88;
        }

        h1 {
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin-bottom: 8px;
            font-size: 20px;
        }

        h2 {
            font-size: 18px;
            margin-bottom: 10px;
        }

        h3 {
            font-size: 16px;
        }

        .stats-bar {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 11px;
        }

        .stat {
            font-size: 11px;
        }

        .stat strong {
            color: #00ff88;
        }

        .screen {
            display: none;
        }

        .screen.active {
            display: block;
        }

        /* Battle Screen - MOBILE OPTIMIZED */
        .battle-area {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 15px;
        }

        .combatant {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #444;
        }

        .combatant h2 {
            font-size: 14px;
            margin-bottom: 8px;
        }

        .combatant.player {
            border-color: #00ff88;
        }

        .combatant.monster {
            border-color: #ff4444;
        }

        .abilities-display {
            margin-top: 12px;
            padding: 8px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 6px;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .abilities-display h4 {
            font-size: 11px;
            color: #00ff88;
            margin-bottom: 6px;
        }

        .ability-tag {
            display: inline-block;
            padding: 3px 6px;
            margin: 2px;
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            border-radius: 3px;
            font-size: 9px;
            color: #00ff88;
        }

        .trait-tag {
            display: inline-block;
            padding: 3px 6px;
            margin: 2px;
            background: rgba(255, 170, 0, 0.2);
            border: 1px solid #ffaa00;
            border-radius: 3px;
            font-size: 9px;
            color: #ffaa00;
        }

        .status-effects {
            margin-top: 8px;
            padding: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-size: 10px;
            min-height: 24px;
        }

        .status-effect {
            display: inline-block;
            padding: 2px 5px;
            margin: 2px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            font-size: 9px;
        }

        .status-shield {
            background: rgba(0, 204, 255, 0.3);
            border: 1px solid #00ccff;
            color: #00ccff;
        }

        .status-burn {
            background: rgba(255, 136, 0, 0.3);
            border: 1px solid #ff8800;
            color: #ff8800;
        }

        .status-bleed {
            background: rgba(255, 0, 100, 0.3);
            border: 1px solid #ff0064;
            color: #ff0064;
        }

        .mech-display {
            text-align: center;
        }

        .mech-display h3 {
            font-size: 14px;
        }

        .mech-visual {
            font-size: 40px;
            margin: 8px 0;
        }

        .health-bar {
            background: #333;
            height: 24px;
            border-radius: 12px;
            overflow: hidden;
            margin: 8px 0;
            border: 1px solid #555;
        }

        .health-fill {
            background: linear-gradient(90deg, #ff4444, #ff8844);
            height: 100%;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
        }

        .health-fill.player {
            background: linear-gradient(90deg, #00ff88, #00ccff);
        }

        .combat-log {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #444;
            height: 250px;
            overflow-y: auto;
            font-size: 12px;
        }

        .log-entry {
            padding: 6px;
            margin: 3px 0;
            border-left: 3px solid #444;
            padding-left: 8px;
            animation: slideIn 0.3s ease;
            line-height: 1.4;
        }

        .log-entry.player {
            border-left-color: #00ff88;
        }

        .log-entry.monster {
            border-left-color: #ff4444;
        }

        .log-entry.system {
            border-left-color: #00ccff;
            color: #00ccff;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Salvage Screen - MOBILE OPTIMIZED */
        .salvage-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 15px 0;
        }

        .salvage-card, .mech-card {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #444;
            cursor: pointer;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .salvage-card:active, .mech-card:active {
            border-color: #00ff88;
            transform: scale(0.98);
            box-shadow: 0 3px 15px rgba(0, 255, 136, 0.3);
        }

        .component-name {
            color: #00ff88;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .component-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin: 10px 0;
            font-size: 11px;
        }

        .stat-item {
            padding: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            text-align: center;
        }

        /* Loadout Screen - MOBILE OPTIMIZED */
        .loadout-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .mech-panel {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00ff88;
        }

        .mech-panel h3 {
            font-size: 14px;
        }

        .mech-slots {
            margin-top: 15px;
        }

        .slot {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            margin: 8px 0;
            border-radius: 6px;
            border: 2px dashed #444;
            min-height: 55px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .slot.filled {
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
        }

        .slot:active {
            background: rgba(0, 255, 136, 0.2);
        }

        .slot-header {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .inventory-panel {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #444;
            max-height: 500px;
            overflow-y: auto;
        }

        .inventory-panel h3 {
            font-size: 16px;
        }

        .inventory-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 12px;
        }

        .inventory-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 6px;
            border: 2px solid #444;
            cursor: pointer;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .inventory-item:active {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.15);
            transform: scale(0.98);
        }

        .inventory-item.selected {
            border-color: #00ccff;
            background: rgba(0, 204, 255, 0.2);
        }

        /* Buttons - MOBILE OPTIMIZED */
        .btn {
            background: linear-gradient(135deg, #00ff88, #00ccff);
            color: #000;
            border: none;
            padding: 16px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 8px 0;
            width: 100%;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .btn:active {
            transform: scale(0.97);
            box-shadow: 0 3px 15px rgba(0, 255, 136, 0.5);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: scale(1);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #666, #888);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff4444, #ff8844);
        }

        /* Resource bars */
        .resource-bars {
            margin: 12px 0;
        }

        .resource-bar {
            margin: 10px 0;
        }

        .resource-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 11px;
        }

        .resource-fill-container {
            background: #333;
            height: 12px;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #555;
        }

        .resource-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .resource-fill.tier {
            background: linear-gradient(90deg, #ff4444, #ff8844);
        }

        .resource-fill.weight {
            background: linear-gradient(90deg, #00ccff, #0088ff);
        }

        .tier-indicator {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 5px;
        }

        .tier-1 { background: #888; }
        .tier-2 { background: #00ff88; color: #000; }
        .tier-3 { background: #00ccff; color: #000; }
        .tier-4 { background: #ff00ff; color: #fff; }
        .tier-5 { background: #ffaa00; color: #000; }

        /* Debug Panel - MOBILE OPTIMIZED */
        .debug-panel {
            position: fixed;
            top: 50px;
            right: 10px;
            background: rgba(0, 0, 0, 0.95);
            padding: 12px;
            border-radius: 6px;
            border: 2px solid #ff00ff;
            font-size: 10px;
            max-width: 250px;
            z-index: 1000;
            max-height: 80vh;
            overflow-y: auto;
        }

        .debug-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #ff00ff;
            color: #000;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 999;
            font-size: 11px;
            font-weight: bold;
            -webkit-tap-highlight-color: transparent;
        }

        /* Scrollbar styling - MOBILE */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        ::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00ccff;
        }

        .warning {
            color: #ff8844;
            font-weight: bold;
        }

        .success {
            color: #00ff88;
            font-weight: bold;
        }

        /* Tablet and larger screens */
        @media (min-width: 768px) {
            .container {
                max-width: 1400px;
                padding: 20px;
            }

            h1 {
                font-size: 28px;
            }

            h2 {
                font-size: 22px;
            }

            .stats-bar {
                display: flex;
                gap: 30px;
            }

            .stat {
                font-size: 14px;
            }

            .battle-area {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 20px;
            }

            .salvage-options {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 20px;
            }

            .loadout-container {
                display: grid;
                grid-template-columns: 400px 1fr;
                gap: 20px;
            }

            .inventory-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            }

            .btn {
                width: auto;
            }

            .btn:hover {
                transform: scale(1.05);
            }

            .salvage-card:hover, .mech-card:hover {
                border-color: #00ff88;
                transform: translateY(-5px);
            }

            .inventory-item:hover {
                border-color: #00ff88;
                background: rgba(0, 255, 136, 0.1);
            }

            .slot:hover {
                background: rgba(0, 255, 136, 0.15);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚öîÔ∏è MECH AUTOBATTLER ‚öîÔ∏è</h1>
            <div class="stats-bar">
                <div class="stat"><strong>Round:</strong> <span id="round-num">1</span></div>
                <div class="stat"><strong>Victories:</strong> <span id="victories">0</span></div>
                <div class="stat"><strong>Current Mech:</strong> <span id="current-mech-name">None</span></div>
                <div class="stat"><strong>Inventory:</strong> <span id="inventory-count">0/10</span></div>
            </div>
        </header>

        <!-- Battle Screen -->
        <div id="battle-screen" class="screen">
            <div class="battle-area">
                <div class="combatant player">
                    <h2>ü§ñ YOUR MECH</h2>
                    <div class="mech-display">
                        <div class="mech-visual" id="player-visual">ü§ñ</div>
                        <h3 id="player-name">Loading...</h3>
                        <div class="health-bar">
                            <div class="health-fill player" id="player-health">
                                <span id="player-health-text">100/100</span>
                            </div>
                        </div>
                        <div class="status-effects" id="player-status-effects">
                            <span style="color: #666; font-size: 9px;">No active effects</span>
                        </div>
                        <div id="player-stats" style="font-size: 12px; margin-top: 10px;"></div>
                        <div class="abilities-display" id="player-abilities-display" style="display: none;"></div>
                    </div>
                </div>

                <div class="combatant monster">
                    <h2>üëæ ENEMY</h2>
                    <div class="mech-display">
                        <div class="mech-visual" id="monster-visual">üëæ</div>
                        <h3 id="monster-name">Loading...</h3>
                        <div class="health-bar">
                            <div class="health-fill" id="monster-health">
                                <span id="monster-health-text">100/100</span>
                            </div>
                        </div>
                        <div class="status-effects" id="monster-status-effects">
                            <span style="color: #666; font-size: 9px;">No active effects</span>
                        </div>
                        <div id="monster-stats" style="font-size: 12px; margin-top: 10px;"></div>
                    </div>
                </div>
            </div>

            <div class="combat-log" id="combat-log"></div>

            <div style="text-align: center; margin-top: 20px;">
                <button class="btn" id="start-battle-btn">START BATTLE</button>
            </div>
        </div>

        <!-- Salvage Screen -->
        <div id="salvage-screen" class="screen">
            <h2>üîß SALVAGE SELECTION</h2>
            <p style="margin: 15px 0;">Choose one component to salvage from the battlefield:</p>
            <div class="salvage-options" id="salvage-options"></div>
        </div>

        <!-- Trait Selection Screen -->
        <div id="trait-select-screen" class="screen">
            <h2>‚≠ê MECH UPGRADE AVAILABLE ‚≠ê</h2>
            <p style="margin: 15px 0;">Your mech has proven itself in battle! Choose a permanent trait upgrade:</p>
            <div class="salvage-options" id="trait-options"></div>
        </div>

        <!-- Loadout Screen -->
        <div id="loadout-screen" class="screen active">
            <h2>‚öôÔ∏è LOADOUT MANAGEMENT</h2>
            <div class="loadout-container">
                <div class="mech-panel">
                    <h3 id="loadout-mech-name">Select a Mech</h3>
                    <div class="mech-visual" style="text-align: center; font-size: 64px; margin: 20px 0;" id="loadout-mech-visual">ü§ñ</div>

                    <div class="resource-bars">
                        <div class="resource-bar">
                            <div class="resource-label">
                                <span>Tier Points:</span>
                                <span id="tier-usage">0/0</span>
                            </div>
                            <div class="resource-fill-container">
                                <div class="resource-fill tier" id="tier-bar"></div>
                            </div>
                        </div>
                        <div class="resource-bar">
                            <div class="resource-label">
                                <span>Weight:</span>
                                <span id="weight-usage">0/0</span>
                            </div>
                            <div class="resource-fill-container">
                                <div class="resource-fill weight" id="weight-bar"></div>
                            </div>
                        </div>
                    </div>

                    <div class="mech-slots" id="mech-slots"></div>

                    <button class="btn" id="ready-battle-btn" style="width: 100%; margin-top: 20px;">READY FOR BATTLE</button>
                </div>

                <div class="inventory-panel">
                    <h3>üì¶ Inventory</h3>
                    <button class="btn btn-secondary" id="toggle-abilities-guide" style="width: 100%; margin-bottom: 10px; padding: 8px; font-size: 12px;">
                        üìñ ABILITIES GUIDE
                    </button>
                    <div id="abilities-guide" style="display: none; background: rgba(0, 255, 136, 0.1); border: 2px solid #00ff88; border-radius: 8px; padding: 12px; margin-bottom: 15px; max-height: 300px; overflow-y: auto;">
                        <h4 style="color: #00ff88; margin-bottom: 10px; font-size: 14px;">‚ö° ABILITY REFERENCE</h4>
                        <div id="abilities-reference"></div>
                    </div>
                    <div class="inventory-grid" id="inventory-grid"></div>
                </div>
            </div>
        </div>
    </div>

    <button class="debug-toggle" id="debug-toggle">DEBUG</button>
    <div class="debug-panel" id="debug-panel" style="display: none;"></div>

    <script>
        // ============================================================================
        // GAME DATA STRUCTURES
        // ============================================================================

        const SLOT_TYPES = {
            HEAD: 'head',
            TORSO: 'torso',
            LEFT_ARM: 'leftArm',
            RIGHT_ARM: 'rightArm',
            LEFT_SHOULDER: 'leftShoulder',
            RIGHT_SHOULDER: 'rightShoulder',
            LEGS: 'legs'
        };

        const COMPONENT_TYPES = {
            WEAPON: 'weapon',
            ARMOR: 'armor',
            SYSTEM: 'system'
        };

        const MECH_CLASSES = {
            LIGHT: 'Light',
            MEDIUM: 'Medium',
            HEAVY: 'Heavy'
        };

        const DAMAGE_TYPES = {
            ENERGY: 'energy',
            KINETIC: 'kinetic',
            EXPLOSIVE: 'explosive',
            NONE: 'none'
        };

        const ABILITIES = {
            // Damage abilities
            CRITICAL_STRIKE: { name: 'Critical Strike', desc: '25% crit chance (2x dmg)', tier: 2 },
            VAMPIRIC: { name: 'Vampiric', desc: 'Heal 25% of damage dealt', tier: 4 },
            ARMOR_PIERCING: { name: 'Armor Piercing', desc: 'Ignore 50% enemy armor', tier: 3 },
            BURN: { name: 'Plasma Burn', desc: 'Deal 5 dmg/turn for 3 turns', tier: 2 },
            BLEED: { name: 'Hemorrhage', desc: 'Crits cause 15 bleed over 5 turns', tier: 3 },

            // Defense abilities
            SHIELD_GEN: { name: 'Energy Shield', desc: 'Start with 50 shield HP', tier: 3 },
            REGENERATION: { name: 'Regeneration', desc: 'Heal 5 HP per turn', tier: 3 },
            REACTIVE: { name: 'Reactive Armor', desc: 'Reflect 25% damage taken', tier: 3 },
            DODGE: { name: 'Dodge Matrix', desc: '20% chance to avoid damage', tier: 3 },

            // Speed abilities
            LIGHTWEIGHT: { name: 'Lightweight Frame', desc: 'Weight doesn\'t affect speed', tier: 2 },
            OVERDRIVE: { name: 'Overdrive', desc: '+50 speed, -20% armor', tier: 3 },
            QUICK_DEPLOY: { name: 'Quick Deploy', desc: 'Always attack first on turn 1', tier: 2 },

            // Special abilities
            EFFICIENT: { name: 'Efficient Design', desc: 'Component costs -1 tier', tier: 3 },
            BERSERKER: { name: 'Berserker', desc: '+1% dmg per 1% HP missing', tier: 3 },
            EXECUTIONER: { name: 'Executioner', desc: '+100% dmg vs enemies <30% HP', tier: 3 },
            DOUBLE_STRIKE: { name: 'Multi-Strike', desc: 'Attack twice at 60% dmg each', tier: 4 },
            OVERCHARGE: { name: 'Overcharge', desc: '+100% dmg, take 10% max HP/attack', tier: 5 }
        };

        const MECH_TRAITS = {
            BERSERKER: {
                name: 'BERSERKER',
                desc: 'Gain +3% damage per 1% HP missing',
                tier: 4,
                icon: 'üí¢'
            },
            CRITICAL_CORE: {
                name: 'CRITICAL CORE',
                desc: 'All attacks have +30% crit chance, crits deal 3x damage',
                tier: 3,
                icon: 'üí•'
            },
            FORTRESS: {
                name: 'FORTRESS',
                desc: 'Armor increased by 100%, speed reduced by 50%',
                tier: 4,
                icon: 'üõ°Ô∏è'
            },
            REGENERATOR: {
                name: 'REGENERATOR',
                desc: 'Regenerate 8% max HP per turn',
                tier: 4,
                icon: 'üíö'
            },
            VAMPIRE: {
                name: 'VAMPIRE',
                desc: 'Heal for 40% of damage dealt, -30% armor',
                tier: 5,
                icon: 'ü©∏'
            },
            LIGHTNING_FAST: {
                name: 'LIGHTNING FAST',
                desc: 'Weight doesn\'t affect speed, +50 base speed',
                tier: 4,
                icon: '‚ö°'
            },
            EFFICIENT: {
                name: 'EFFICIENT',
                desc: 'All components cost -2 tier points (min 1)',
                tier: 5,
                icon: '‚öôÔ∏è'
            },
            SALVAGER: {
                name: 'SALVAGER',
                desc: 'Choose 2 salvage items instead of 1',
                tier: 4,
                icon: 'üîß'
            },
            ENERGY_MASTER: {
                name: 'ENERGY MASTER',
                desc: 'All Energy damage +100%, Energy components cost -1 tier',
                tier: 4,
                icon: '‚öõÔ∏è'
            },
            KINETIC_MASTER: {
                name: 'KINETIC MASTER',
                desc: 'All Kinetic damage +100%, ignore 50% armor',
                tier: 4,
                icon: 'üéØ'
            },
            EXPLOSIVE_MASTER: {
                name: 'EXPLOSIVE MASTER',
                desc: 'All Explosive damage +100%, apply burn effect',
                tier: 4,
                icon: 'üí£'
            },
            OVERCHARGED: {
                name: 'OVERCHARGED',
                desc: '+100% damage, lose 8% max HP per turn',
                tier: 5,
                icon: 'üî•'
            }
        };

        // Relics - Permanent upgrades that stack
        const RELICS = {
            // Damage Type Scaling
            ENERGY_CONDUIT: {
                name: 'Energy Conduit',
                desc: 'Energy damage +50% (stacks!)',
                icon: 'üîã',
                category: 'damage'
            },
            KINETIC_AMPLIFIER: {
                name: 'Kinetic Amplifier',
                desc: 'Kinetic damage +50%, ignore 25% armor',
                icon: 'üéØ',
                category: 'damage'
            },
            EXPLOSIVE_CATALYST: {
                name: 'Explosive Catalyst',
                desc: 'Explosive damage +50%, burns spread faster',
                icon: 'üí£',
                category: 'damage'
            },
            CRITICAL_MASS: {
                name: 'Critical Mass',
                desc: 'Critical chance +10%, crits +50% damage',
                icon: 'üí•',
                category: 'damage'
            },

            // Conversion Mechanics
            MOMENTUM_DRIVE: {
                name: 'Momentum Drive',
                desc: 'Each tier point spent = +2 damage',
                icon: '‚ö°',
                category: 'conversion'
            },
            BLOOD_PACT: {
                name: 'Blood Pact',
                desc: 'Max HP -20%, heal 50% of damage dealt',
                icon: 'ü©∏',
                category: 'conversion'
            },

            // Investment/Snowball
            HUNTERS_MARK: {
                name: "Hunter's Mark",
                desc: 'Each kill grants +3 permanent damage',
                icon: 'üíÄ',
                category: 'investment'
            },

            // Game Changers
            PERFECT_AEGIS: {
                name: 'Perfect Aegis',
                desc: 'Shields are 3x more effective',
                icon: 'üõ°Ô∏è',
                category: 'gameChanger'
            },
            CONTAGION: {
                name: 'Contagion',
                desc: 'DoTs deal 2x damage and last 2x longer',
                icon: 'üî•',
                category: 'gameChanger'
            },
            GLASS_CANNON_CORE: {
                name: 'Glass Cannon Core',
                desc: 'All damage 2x, max HP -50%',
                icon: 'üíé',
                category: 'gameChanger'
            },
            FORTRESS_PROTOCOL: {
                name: 'Fortress Protocol',
                desc: 'Armor doubled, immune to one-shots',
                icon: 'üè∞',
                category: 'gameChanger'
            },
            VAMPIRIC_ASCENSION: {
                name: 'Vampiric Ascension',
                desc: 'Lifesteal from all damage (25%)',
                icon: 'üßõ',
                category: 'gameChanger'
            },

            // Build-Arounds
            ALL_IN: {
                name: 'All-In',
                desc: 'Abilities trigger twice, cost double tier',
                icon: 'üé≤',
                category: 'buildAround'
            },
            LAST_STAND: {
                name: 'Last Stand',
                desc: 'Below 30% HP: +200% damage, +50 armor',
                icon: '‚è±Ô∏è',
                category: 'buildAround'
            },
            SCAVENGER: {
                name: 'Scavenger',
                desc: '+3 inventory slots, always salvage 2',
                icon: 'üîß',
                category: 'buildAround'
            }
        };

        // Mech Templates
        const MECH_TEMPLATES = {
            SCOUT: {
                name: 'Scout',
                class: MECH_CLASSES.LIGHT,
                tierCapacity: 25,
                baseHP: 80,
                baseArmor: 5,
                visual: 'üèÉ',
                slots: [SLOT_TYPES.HEAD, SLOT_TYPES.TORSO, SLOT_TYPES.LEFT_ARM, SLOT_TYPES.RIGHT_ARM, SLOT_TYPES.LEFT_SHOULDER, SLOT_TYPES.RIGHT_SHOULDER, SLOT_TYPES.LEGS]
            },
            WARRIOR: {
                name: 'Warrior',
                class: MECH_CLASSES.MEDIUM,
                tierCapacity: 38,
                baseHP: 120,
                baseArmor: 10,
                visual: 'ü§ñ',
                slots: [SLOT_TYPES.HEAD, SLOT_TYPES.TORSO, SLOT_TYPES.LEFT_ARM, SLOT_TYPES.RIGHT_ARM, SLOT_TYPES.LEFT_SHOULDER, SLOT_TYPES.RIGHT_SHOULDER, SLOT_TYPES.LEGS]
            },
            TITAN: {
                name: 'Titan',
                class: MECH_CLASSES.HEAVY,
                tierCapacity: 50,
                baseHP: 180,
                baseArmor: 15,
                visual: 'üèãÔ∏è',
                slots: [SLOT_TYPES.HEAD, SLOT_TYPES.TORSO, SLOT_TYPES.LEFT_ARM, SLOT_TYPES.RIGHT_ARM, SLOT_TYPES.LEFT_SHOULDER, SLOT_TYPES.RIGHT_SHOULDER, SLOT_TYPES.LEGS]
            }
        };

        // Component Templates (simplified - no weight/size/conflicts)
        const COMPONENT_TEMPLATES = [
            // ENERGY WEAPONS
            { name: 'Laser Cannon', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_ARM, damage: 25, armor: 0, tier: 2, damageType: DAMAGE_TYPES.ENERGY, abilities: ['CRITICAL_STRIKE'] },
            { name: 'Plasma Rifle', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_ARM, damage: 30, armor: 0, tier: 3, damageType: DAMAGE_TYPES.ENERGY, abilities: ['BURN'] },
            { name: 'Ion Beam', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.LEFT_ARM, damage: 22, armor: 0, tier: 3, damageType: DAMAGE_TYPES.ENERGY, abilities: ['ARMOR_PIERCING'] },

            // KINETIC WEAPONS
            { name: 'Rail Gun', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_ARM, damage: 40, armor: -10, tier: 4, damageType: DAMAGE_TYPES.KINETIC, abilities: ['ARMOR_PIERCING'] },
            { name: 'Machine Gun', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.LEFT_ARM, damage: 15, armor: 0, tier: 1, damageType: DAMAGE_TYPES.KINETIC, abilities: [] },
            { name: 'Autocannon', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_ARM, damage: 28, armor: -5, tier: 3, damageType: DAMAGE_TYPES.KINETIC, abilities: ['BLEED'] },

            // EXPLOSIVE WEAPONS
            { name: 'Missile Pod', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.LEFT_SHOULDER, damage: 35, armor: -3, tier: 3, damageType: DAMAGE_TYPES.EXPLOSIVE, abilities: ['BURN'] },
            { name: 'Rocket Launcher', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_SHOULDER, damage: 45, armor: -8, tier: 4, damageType: DAMAGE_TYPES.EXPLOSIVE, abilities: ['EXECUTIONER'] },
            { name: 'Grenade Launcher', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.LEFT_SHOULDER, damage: 30, armor: 0, tier: 2, damageType: DAMAGE_TYPES.EXPLOSIVE, abilities: [] },

            // ARMOR
            { name: 'Light Plating', type: COMPONENT_TYPES.ARMOR, slot: SLOT_TYPES.TORSO, damage: 0, armor: 10, tier: 1, damageType: DAMAGE_TYPES.NONE, abilities: [] },
            { name: 'Heavy Plating', type: COMPONENT_TYPES.ARMOR, slot: SLOT_TYPES.TORSO, damage: 0, armor: 20, tier: 2, damageType: DAMAGE_TYPES.NONE, abilities: [] },
            { name: 'Composite Armor', type: COMPONENT_TYPES.ARMOR, slot: SLOT_TYPES.TORSO, damage: 0, armor: 35, tier: 4, damageType: DAMAGE_TYPES.NONE, abilities: ['REACTIVE'] },
            { name: 'Reactive Armor', type: COMPONENT_TYPES.ARMOR, slot: SLOT_TYPES.TORSO, damage: 0, armor: 25, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['REACTIVE'] },

            // SYSTEMS - Head
            { name: 'Targeting System', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.HEAD, damage: 10, armor: 5, tier: 2, damageType: DAMAGE_TYPES.NONE, abilities: ['CRITICAL_STRIKE'] },
            { name: 'Advanced Sensors', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.HEAD, damage: 15, armor: 10, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['EXECUTIONER'] },

            // SYSTEMS - Legs
            { name: 'Boost System', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.LEGS, damage: 5, armor: 0, tier: 2, damageType: DAMAGE_TYPES.NONE, abilities: [] },
            { name: 'Overdrive Boosters', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.LEGS, damage: 8, armor: -5, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: [] },
            { name: 'Heavy Servos', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.LEGS, damage: 0, armor: 15, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: [] },

            // SYSTEMS - Special
            { name: 'Shield Generator', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 0, armor: 25, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['SHIELD_GEN'] },
            { name: 'Repair Nanobots', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 0, armor: 15, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['REGENERATION'] },
            { name: 'Power Core', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 10, armor: 10, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['EFFICIENT'] },
            { name: 'Vampiric Core', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 15, armor: -10, tier: 4, damageType: DAMAGE_TYPES.NONE, abilities: ['VAMPIRIC'] },
            { name: 'Berserker Chip', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.HEAD, damage: 20, armor: -15, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['BERSERKER'] },
            { name: 'Overcharge Module', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 25, armor: -20, tier: 5, damageType: DAMAGE_TYPES.NONE, abilities: ['OVERCHARGE'] }
        ];

        // ============================================================================
        // GAME STATE
        // ============================================================================

        class GameState {
            constructor() {
                this.round = 1;
                this.victories = 0;
                this.currentMech = null;
                this.inventory = [];
                this.currentMonster = null;
                this.battleInProgress = false;
                this.maxInventorySize = 10;
                this.relics = []; // Array of acquired relic keys
                this.permanentDamageBonus = 0; // From Hunter's Mark
                this.componentBattleCount = {}; // Track battles per component ID for Evolution Chamber
            }

            save() {
                localStorage.setItem('mechAutobattler', JSON.stringify({
                    round: this.round,
                    victories: this.victories,
                    currentMech: this.currentMech,
                    inventory: this.inventory,
                    relics: this.relics,
                    permanentDamageBonus: this.permanentDamageBonus,
                    componentBattleCount: this.componentBattleCount
                }));
            }

            load() {
                const saved = localStorage.getItem('mechAutobattler');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.round = data.round || 1;
                    this.victories = data.victories || 0;
                    this.currentMech = data.currentMech;
                    this.inventory = data.inventory || [];
                    this.relics = data.relics || [];
                    this.permanentDamageBonus = data.permanentDamageBonus || 0;
                    this.componentBattleCount = data.componentBattleCount || {};
                    return true;
                }
                return false;
            }

            reset() {
                this.round = 1;
                this.victories = 0;
                this.currentMech = null;
                this.inventory = [];
                localStorage.removeItem('mechAutobattler'); // Clear saved game
            }
        }

        const game = new GameState();

        // ============================================================================
        // COMPONENT & MECH MANAGEMENT
        // ============================================================================

        function createMech(template, tier = 1) {
            const loadout = {};
            template.slots.forEach(slot => {
                loadout[slot] = null;
            });

            return {
                name: template.name,
                class: template.class,
                tierCapacity: template.tierCapacity,
                baseHP: template.baseHP,
                baseArmor: template.baseArmor,
                visual: template.visual,
                slots: template.slots,
                tier: tier,
                loadout: loadout,
                currentHP: template.baseHP,
                maxHP: template.baseHP,
                traits: []  // Array of acquired traits
            };
        }

        function createComponent(template, tier = 1) {
            const comp = {
                name: template.name,
                type: template.type,
                slot: template.slot,
                damage: template.damage,
                armor: template.armor,
                tier: tier,
                damageType: template.damageType || DAMAGE_TYPES.NONE,
                abilities: template.abilities ? [...template.abilities] : [],
                id: Math.random().toString(36).substr(2, 9)
            };

            // Scale stats with tier
            const tierMultiplier = 1 + ((tier - 1) * 0.3);
            comp.damage = Math.floor(comp.damage * tierMultiplier);
            comp.armor = Math.floor(comp.armor * tierMultiplier);

            return comp;
        }

        function generateRandomComponents(count, minTier, maxTier) {
            const components = [];
            for (let i = 0; i < count; i++) {
                const template = COMPONENT_TEMPLATES[Math.floor(Math.random() * COMPONENT_TEMPLATES.length)];
                const tier = Math.floor(Math.random() * (maxTier - minTier + 1)) + minTier;
                components.push(createComponent(template, tier));
            }
            return components;
        }

        function generateRandomMechs(count, tier) {
            const mechs = [];
            const templates = Object.values(MECH_TEMPLATES);
            for (let i = 0; i < count; i++) {
                const template = templates[Math.floor(Math.random() * templates.length)];
                mechs.push(createMech(template, tier));
            }
            return mechs;
        }

        function calculateMechStats(mech) {
            let totalDamage = 0;
            let totalArmor = mech.baseArmor;
            let totalTier = 0;

            const traits = mech.traits || [];

            Object.values(mech.loadout).forEach(component => {
                if (component) {
                    totalDamage += component.damage;
                    totalArmor += component.armor;

                    // Apply EFFICIENT trait/ability - reduce tier cost
                    let compTier = component.tier;
                    if (traits.some(t => t.name === 'EFFICIENT')) {
                        compTier = Math.max(1, compTier - 2);
                    } else if (component.abilities && component.abilities.includes('EFFICIENT')) {
                        compTier = Math.max(1, compTier - 1);
                    }

                    // Apply ALL_IN relic - abilities cost double tier
                    if (game.relics && game.relics.includes('ALL_IN') && component.abilities) {
                        component.abilities.forEach(abilityKey => {
                            const ability = ABILITIES[abilityKey];
                            if (ability && abilityKey !== 'EFFICIENT') {
                                compTier += ability.tier; // Adds double (once here, once below)
                            }
                        });
                    }

                    totalTier += compTier;

                    // Add ability tier costs
                    if (component.abilities) {
                        component.abilities.forEach(abilityKey => {
                            const ability = ABILITIES[abilityKey];
                            if (ability && abilityKey !== 'EFFICIENT') {
                                totalTier += ability.tier;
                            }
                        });
                    }
                }
            });

            // Apply FORTRESS trait - double armor
            if (traits.some(t => t.name === 'FORTRESS')) {
                totalArmor *= 2;
            }

            // Apply VAMPIRE trait - reduce armor
            if (traits.some(t => t.name === 'VAMPIRE')) {
                totalArmor = Math.floor(totalArmor * 0.7);
            }

            // Apply FORTRESS_PROTOCOL relic - double armor
            if (game.relics && game.relics.includes('FORTRESS_PROTOCOL')) {
                totalArmor *= 2;
            }

            // Apply MOMENTUM_DRIVE relic - tier ‚Üí damage
            if (game.relics && game.relics.includes('MOMENTUM_DRIVE')) {
                totalDamage += totalTier * 2;
            }

            // Add permanent damage bonus from Hunter's Mark
            if (game.permanentDamageBonus) {
                totalDamage += game.permanentDamageBonus;
            }

            return {
                damage: totalDamage,
                armor: totalArmor,
                tierUsed: totalTier
            };
        }

        function canAttachComponent(mech, component, slotName) {
            // Check slot type matches
            if (component.slot !== slotName) return false;

            // Calculate if adding this would exceed tier limit
            const currentStats = calculateMechStats(mech);
            let newTier = currentStats.tierUsed + component.tier;

            // Add ability tier costs for new component
            if (component.abilities) {
                component.abilities.forEach(abilityKey => {
                    const ability = ABILITIES[abilityKey];
                    if (ability && abilityKey !== 'EFFICIENT') {
                        newTier += ability.tier;
                    }
                });
            }

            // If slot is filled, subtract the old component's contribution
            if (mech.loadout[slotName]) {
                const oldComp = mech.loadout[slotName];
                let oldTier = oldComp.tier;
                if (oldComp.abilities) {
                    oldComp.abilities.forEach(abilityKey => {
                        const ability = ABILITIES[abilityKey];
                        if (ability && abilityKey !== 'EFFICIENT') {
                            oldTier += ability.tier;
                        }
                    });
                }
                newTier -= oldTier;
            }

            // Apply SCAVENGER relic - +3 inventory slots
            let tierCap = mech.tierCapacity;
            if (game.relics && game.relics.includes('SCAVENGER')) {
                tierCap += 10; // Extra tier budget
            }

            if (newTier > tierCap) return false;

            return true;
        }

        function attachComponent(mech, component, slotName) {
            if (!canAttachComponent(mech, component, slotName)) {
                return false;
            }

            // Remove from old slot if it's already attached
            Object.keys(mech.loadout).forEach(key => {
                if (mech.loadout[key]?.id === component.id) {
                    delete mech.loadout[key];
                }
            });

            // Remove old component from slot and return it to inventory
            if (mech.loadout[slotName]) {
                const oldComp = mech.loadout[slotName];
                game.inventory.push(oldComp);
            }

            // Attach new component
            mech.loadout[slotName] = component;

            // Remove from inventory
            const invIndex = game.inventory.findIndex(c => c.id === component.id);
            if (invIndex !== -1) {
                game.inventory.splice(invIndex, 1);
            }

            game.save();
            return true;
        }

        function detachComponent(mech, slotName) {
            if (mech.loadout[slotName]) {
                const component = mech.loadout[slotName];
                game.inventory.push(component);
                delete mech.loadout[slotName];
                game.save();
                return true;
            }
            return false;
        }

        // ============================================================================
        // MONSTER GENERATION
        // ============================================================================

        function generateMonster(round) {
            const difficultyMultiplier = 1 + ((round - 1) * 0.2);
            const isBoss = round % 5 === 0;

            if (isBoss) {
                // Boss fight every 5 rounds
                const bossTypes = [
                    {
                        name: 'FORTRESS TITAN',
                        visual: 'üè∞',
                        hp: 200,
                        damage: 20,
                        armor: 40,
                        special: 'ARMORED',
                        desc: 'Massive armor - Energy weapons recommended!'
                    },
                    {
                        name: 'PLASMA STORM',
                        visual: '‚ö°',
                        hp: 120,
                        damage: 45,
                        armor: 5,
                        special: 'SHIELD_IGNORE',
                        desc: 'Ignores shields and armor!'
                    },
                    {
                        name: 'BERSERKER PRIME',
                        visual: 'üòà',
                        hp: 150,
                        damage: 25,
                        armor: 10,
                        special: 'RAGE',
                        desc: 'Gains damage as HP drops!'
                    },
                    {
                        name: 'MIRROR WRAITH',
                        visual: 'üëª',
                        hp: 100,
                        damage: 30,
                        armor: 10,
                        special: 'REFLECT',
                        desc: 'Reflects 50% of damage taken!'
                    }
                ];

                const boss = bossTypes[Math.floor(Math.random() * bossTypes.length)];
                return {
                    name: boss.name,
                    visual: boss.visual,
                    maxHP: Math.floor(boss.hp * difficultyMultiplier),
                    currentHP: Math.floor(boss.hp * difficultyMultiplier),
                    damage: Math.floor(boss.damage * difficultyMultiplier),
                    armor: Math.floor(boss.armor * difficultyMultiplier),
                    speed: 50 + Math.floor(Math.random() * 30),
                    special: boss.special,
                    isBoss: true,
                    description: boss.desc
                };
            } else {
                // Regular enemies with variety
                const monsterTypes = [
                    { name: 'Scrap Bot', visual: 'ü§ñ', hp: 60, damage: 15, armor: 5, special: null },
                    { name: 'War Drone', visual: 'üëæ', hp: 80, damage: 20, armor: 8, special: 'FAST' },
                    { name: 'Battle Mech', visual: 'ü¶æ', hp: 100, damage: 25, armor: 10, special: null },
                    { name: 'Tank Unit', visual: 'üöõ', hp: 120, damage: 18, armor: 15, special: 'ARMORED' },
                    { name: 'Hunter Killer', visual: 'üíÄ', hp: 70, damage: 35, armor: 5, special: 'CRITICAL' },
                    { name: 'Shield Bot', visual: 'üõ°Ô∏è', hp: 90, damage: 18, armor: 8, special: 'SHIELD' }
                ];

                const baseMonster = monsterTypes[Math.floor(Math.random() * monsterTypes.length)];

                return {
                    name: `${baseMonster.name} Mk.${Math.ceil(round / 2)}`,
                    visual: baseMonster.visual,
                    maxHP: Math.floor(baseMonster.hp * difficultyMultiplier),
                    currentHP: Math.floor(baseMonster.hp * difficultyMultiplier),
                    damage: Math.floor(baseMonster.damage * difficultyMultiplier),
                    armor: Math.floor(baseMonster.armor * difficultyMultiplier),
                    speed: 50 + Math.floor(Math.random() * 30),
                    special: baseMonster.special,
                    isBoss: false
                };
            }
        }

        // ============================================================================
        // BATTLE SYSTEM
        // ============================================================================

        class BattleSystem {
            constructor(playerMech, monster) {
                this.playerMech = JSON.parse(JSON.stringify(playerMech));
                this.monster = JSON.parse(JSON.stringify(monster));
                this.log = [];
                this.turn = 0;

                // Initialize battle state
                this.playerShield = 0;
                this.monsterShield = 0;
                this.playerDots = []; // {type, damage, duration}
                this.monsterDots = [];

                // Collect all player abilities
                this.playerAbilities = this.collectAbilities(this.playerMech);
                this.playerTraits = this.playerMech.traits || [];

                // Apply start-of-battle abilities
                this.applyStartOfBattleAbilities();

                // Apply monster special abilities
                this.applyMonsterSpecialInit();
            }

            collectAbilities(mech) {
                const abilities = [];
                Object.values(mech.loadout || {}).forEach(comp => {
                    if (comp && comp.abilities) {
                        comp.abilities.forEach(abilityKey => {
                            if (ABILITIES[abilityKey]) {
                                abilities.push(abilityKey);
                            }
                        });
                    }
                });
                return abilities;
            }

            applyStartOfBattleAbilities() {
                // Shield Generator
                if (this.playerAbilities.includes('SHIELD_GEN')) {
                    this.playerShield = 50;
                    this.addLog('üõ°Ô∏è ENERGY SHIELD: Activated with 50 shield HP', 'player');
                }
            }

            applyMonsterSpecialInit() {
                if (this.monster.special === 'SHIELD') {
                    this.monsterShield = 40;
                    this.addLog('üõ°Ô∏è Enemy activated energy shield! (40 shield)', 'monster');
                }

                if (this.monster.isBoss && this.monster.description) {
                    this.addLog(`‚ö†Ô∏è BOSS: ${this.monster.description}`, 'system');
                }
            }

            addLog(message, actor = 'system') {
                this.log.push({ message, actor, turn: this.turn });
            }

            hasAbility(abilityKey) {
                return this.playerAbilities.includes(abilityKey);
            }

            hasTrait(traitName) {
                return this.playerTraits.some(t => t.name === traitName);
            }

            calculateDamage(isPlayer, targetArmor) {
                const stats = calculateMechStats(this.playerMech);
                let baseDamage = isPlayer ? stats.damage : this.monster.damage;
                const currentArmor = targetArmor;

                // Enemy special abilities
                if (!isPlayer) {
                    // RAGE - gains damage as HP drops (like Berserker)
                    if (this.monster.special === 'RAGE') {
                        const hpLostPercent = ((this.monster.maxHP - this.monster.currentHP) / this.monster.maxHP) * 100;
                        const bonus = Math.floor(baseDamage * (hpLostPercent * 0.02));
                        if (bonus > 0) {
                            baseDamage += bonus;
                            this.addLog(`üòà RAGE: Enemy gains +${bonus} damage from low HP!`, 'monster');
                        }
                    }
                }

                if (isPlayer) {
                    // Apply trait bonuses
                    if (this.hasTrait('BERSERKER')) {
                        const hpLostPercent = ((this.playerMech.maxHP - this.playerMech.currentHP) / this.playerMech.maxHP) * 100;
                        const bonus = Math.floor(baseDamage * (hpLostPercent * 0.03));
                        if (bonus > 0) {
                            baseDamage += bonus;
                            this.addLog(`üí¢ BERSERKER TRAIT: +${bonus} damage (+3% per 1% HP lost)`, 'player');
                        }
                    }

                    if (this.hasTrait('OVERCHARGED')) {
                        baseDamage *= 2;
                    }

                    // Apply ability bonuses
                    if (this.hasAbility('BERSERKER')) {
                        const hpLostPercent = ((this.playerMech.maxHP - this.playerMech.currentHP) / this.playerMech.maxHP) * 100;
                        const bonus = Math.floor(baseDamage * (hpLostPercent * 0.01));
                        if (bonus > 0) {
                            baseDamage += bonus;
                            this.addLog(`üí¢ Berserker Chip: +${bonus} damage (+1% per 1% HP lost)`, 'player');
                        }
                    }

                    if (this.hasAbility('OVERCHARGE')) {
                        baseDamage *= 2;
                        const selfDamage = Math.floor(this.playerMech.maxHP * 0.1);
                        this.playerMech.currentHP -= selfDamage;
                        this.addLog(`‚ö° OVERCHARGE: Double damage! Cost: ${selfDamage} HP`, 'player');
                    }
                }

                // Critical strike
                let isCrit = false;
                if (isPlayer && (this.hasAbility('CRITICAL_STRIKE') || this.hasTrait('CRITICAL_CORE'))) {
                    const critChance = this.hasTrait('CRITICAL_CORE') ? 0.30 : 0.25;
                    const critMultiplier = this.hasTrait('CRITICAL_CORE') ? 3 : 2;

                    if (Math.random() < critChance) {
                        baseDamage *= critMultiplier;
                        isCrit = true;
                    }
                } else if (!isPlayer && this.monster.special === 'CRITICAL') {
                    // Enemy crit ability
                    if (Math.random() < 0.30) {
                        baseDamage *= 2;
                        isCrit = true;
                    }
                }

                // Armor reduction
                let armorToUse = currentArmor;
                if (isPlayer && this.hasAbility('ARMOR_PIERCING')) {
                    armorToUse *= 0.5;
                    this.addLog(`üéØ ARMOR PIERCING: Ignoring 50% of enemy armor`, 'player');
                }

                const damageReduction = Math.min(armorToUse * 0.5, baseDamage * 0.7);
                let finalDamage = Math.max(1, Math.floor(baseDamage - damageReduction));

                // Executioner
                if (isPlayer && this.hasAbility('EXECUTIONER') && this.monster.currentHP < this.monster.maxHP * 0.3) {
                    finalDamage *= 2;
                    this.addLog(`üéØ EXECUTIONER: Target below 30% HP - DOUBLE DAMAGE!`, 'player');
                }

                return { damage: finalDamage, isCrit };
            }

            applyDoTs(target, isPlayer) {
                const dots = isPlayer ? this.playerDots : this.monsterDots;
                let totalDotDamage = 0;

                for (let i = dots.length - 1; i >= 0; i--) {
                    const dot = dots[i];
                    if (target === 'player') {
                        this.playerMech.currentHP -= dot.damage;
                    } else {
                        this.monster.currentHP -= dot.damage;
                    }
                    totalDotDamage += dot.damage;

                    dot.duration--;
                    if (dot.duration <= 0) {
                        dots.splice(i, 1);
                    }
                }

                if (totalDotDamage > 0) {
                    const actor = target === 'player' ? 'monster' : 'player';
                    this.addLog(`üî• DoT damage: ${totalDotDamage}`, actor);
                }
            }

            applyRegeneration() {
                // Regeneration ability
                if (this.hasAbility('REGENERATION')) {
                    const heal = 5;
                    this.playerMech.currentHP = Math.min(this.playerMech.maxHP, this.playerMech.currentHP + heal);
                    this.addLog(`üíö REGENERATION: Healed ${heal} HP`, 'player');
                }

                // Regenerator trait
                if (this.hasTrait('REGENERATOR')) {
                    const heal = Math.floor(this.playerMech.maxHP * 0.08);
                    this.playerMech.currentHP = Math.min(this.playerMech.maxHP, this.playerMech.currentHP + heal);
                    this.addLog(`üíö REGENERATOR TRAIT: Restored ${heal} HP (8% of max HP)`, 'player');
                }
            }

            performAttack(isPlayer) {
                let targetArmor = isPlayer ? this.monster.armor : calculateMechStats(this.playerMech).armor;

                // ARMORED enemy - double effective armor
                if (!isPlayer && this.monster.special === 'ARMORED') {
                    targetArmor *= 2;
                }

                const { damage, isCrit } = this.calculateDamage(isPlayer, targetArmor);

                let actualDamage = damage;

                if (isPlayer) {
                    // Player attacking monster - check monster shield first
                    if (this.monsterShield > 0) {
                        if (this.monsterShield >= actualDamage) {
                            this.monsterShield -= actualDamage;
                            this.addLog(`üõ°Ô∏è Enemy shield absorbed ${actualDamage} damage! (${this.monsterShield} shield left)`, 'player');
                            actualDamage = 0;
                        } else {
                            const overflow = actualDamage - this.monsterShield;
                            this.addLog(`üõ°Ô∏è Enemy shield absorbed ${this.monsterShield} damage, ${overflow} passed through!`, 'player');
                            this.monsterShield = 0;
                            actualDamage = overflow;
                        }
                    }

                    // Apply remaining damage to monster HP
                    if (actualDamage > 0) {
                        this.monster.currentHP -= actualDamage;
                        const critText = isCrit ? ' üí• CRITICAL HIT!' : '';
                        this.addLog(`‚öîÔ∏è Your mech deals ${actualDamage} damage!${critText} (Enemy: ${Math.max(0, this.monster.currentHP)}/${this.monster.maxHP} HP)`, 'player');

                        // REFLECT - Monster reflects damage back
                        if (this.monster.special === 'REFLECT') {
                            const reflected = Math.floor(actualDamage * 0.5);
                            this.playerMech.currentHP -= reflected;
                            this.addLog(`üëª MIRROR WRAITH: Reflected ${reflected} damage back!`, 'monster');
                        }
                    }

                    // Vampiric healing
                    if (this.hasAbility('VAMPIRIC') || this.hasTrait('VAMPIRE')) {
                        const healPercent = this.hasTrait('VAMPIRE') ? 0.4 : 0.25;
                        const heal = Math.floor(actualDamage * healPercent);
                        this.playerMech.currentHP = Math.min(this.playerMech.maxHP, this.playerMech.currentHP + heal);
                        const source = this.hasTrait('VAMPIRE') ? 'ü©∏ VAMPIRE TRAIT' : 'ü©∏ Vampiric';
                        this.addLog(`${source}: Healed ${heal} HP from damage dealt`, 'player');
                    }

                    // Apply DoTs
                    if (this.hasAbility('BURN')) {
                        this.monsterDots.push({ type: 'burn', damage: 5, duration: 3 });
                        this.addLog(`üî• PLASMA BURN: Inflicted burn (5 dmg/turn for 3 turns)`, 'player');
                    }

                    if (isCrit && this.hasAbility('BLEED')) {
                        this.monsterDots.push({ type: 'bleed', damage: 3, duration: 5 });
                        this.addLog(`ü©∏ HEMORRHAGE: Critical hit causes bleeding (3 dmg/turn for 5 turns)`, 'player');
                    }
                } else {
                    // Monster attacks player
                    const ignoresShield = this.monster.special === 'SHIELD_IGNORE';

                    // Check shield first (unless SHIELD_IGNORE)
                    if (!ignoresShield && this.playerShield > 0) {
                        if (this.playerShield >= actualDamage) {
                            this.playerShield -= actualDamage;
                            this.addLog(`üõ°Ô∏è Shield absorbed ${actualDamage} damage! (${this.playerShield} shield left)`, 'monster');
                            actualDamage = 0;
                        } else {
                            const overflow = actualDamage - this.playerShield;
                            this.addLog(`üõ°Ô∏è Shield absorbed ${this.playerShield} damage, ${overflow} passed through!`, 'monster');
                            this.playerShield = 0;
                            actualDamage = overflow;
                        }
                    } else if (ignoresShield && this.playerShield > 0) {
                        this.addLog(`‚ö° PLASMA STORM: Shields and armor ignored!`, 'monster');
                    }

                    // Apply remaining damage to HP
                    if (actualDamage > 0) {
                        const critText = isCrit ? ' üí• CRIT!' : '';
                        this.playerMech.currentHP -= actualDamage;
                        this.addLog(`üí• ${this.monster.name} deals ${actualDamage} damage!${critText} (${Math.max(0, this.playerMech.currentHP)}/${this.playerMech.maxHP} HP)`, 'monster');

                        // Reactive armor
                        if (this.hasAbility('REACTIVE')) {
                            const reflected = Math.floor(actualDamage * 0.25);
                            this.monster.currentHP -= reflected;
                            this.addLog(`‚ö° REACTIVE ARMOR: Reflected ${reflected} damage (25% of damage taken)`, 'player');
                        }
                    }
                }

                return actualDamage;
            }

            executeTurn() {
                this.turn++;

                // Apply Overcharged trait damage
                if (this.hasTrait('OVERCHARGED')) {
                    const damage = Math.floor(this.playerMech.maxHP * 0.08);
                    this.playerMech.currentHP -= damage;
                    this.addLog(`üî• OVERCHARGED TRAIT: Losing ${damage} HP (8% max HP per turn)`, 'player');
                }

                // Apply regeneration
                this.applyRegeneration();

                // Apply DoTs
                this.applyDoTs('player', true);
                this.applyDoTs('monster', false);

                // Check for deaths from DoTs
                if (this.playerMech.currentHP <= 0) {
                    this.addLog('üíÄ YOUR MECH IS DESTROYED! DEFEAT! üíÄ', 'monster');
                    return 'defeat';
                }
                if (this.monster.currentHP <= 0) {
                    this.addLog('üí• ENEMY DESTROYED! VICTORY! üí•', 'player');
                    return 'victory';
                }

                const playerStats = calculateMechStats(this.playerMech);
                let playerSpeed = playerStats.speed;

                // Apply speed traits
                if (this.hasTrait('LIGHTNING_FAST')) {
                    playerSpeed = 100 + 50;
                }
                if (this.hasTrait('FORTRESS')) {
                    playerSpeed = Math.floor(playerSpeed * 0.5);
                }

                // Determine turn order
                const playerGoesFirst = playerSpeed >= this.monster.speed;

                if (playerGoesFirst) {
                    this.performAttack(true);
                    if (this.monster.currentHP <= 0) {
                        this.addLog('üí• ENEMY DESTROYED! VICTORY! üí•', 'player');
                        return 'victory';
                    }
                    this.performAttack(false);
                    if (this.playerMech.currentHP <= 0) {
                        this.addLog('üíÄ YOUR MECH IS DESTROYED! DEFEAT! üíÄ', 'monster');
                        return 'defeat';
                    }
                } else {
                    this.performAttack(false);
                    if (this.playerMech.currentHP <= 0) {
                        this.addLog('üíÄ YOUR MECH IS DESTROYED! DEFEAT! üíÄ', 'monster');
                        return 'defeat';
                    }
                    this.performAttack(true);
                    if (this.monster.currentHP <= 0) {
                        this.addLog('üí• ENEMY DESTROYED! VICTORY! üí•', 'player');
                        return 'victory';
                    }
                }

                return 'continue';
            }

            getState() {
                return {
                    playerMech: this.playerMech,
                    monster: this.monster,
                    log: this.log,
                    playerShield: this.playerShield
                };
            }
        }

        // ============================================================================
        // UI MANAGEMENT
        // ============================================================================

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        function updateHeader() {
            document.getElementById('round-num').textContent = game.round;
            document.getElementById('victories').textContent = game.victories;
            document.getElementById('current-mech-name').textContent =
                game.currentMech ? `${game.currentMech.name} (T${game.currentMech.tier})` : 'None';

            const invCount = game.inventory.length;
            // Apply SCAVENGER relic +3 inventory
            let invMax = game.maxInventorySize;
            if (game.relics && game.relics.includes('SCAVENGER')) {
                invMax += 3;
            }
            const invText = `${invCount}/${invMax}`;
            const invElement = document.getElementById('inventory-count');
            invElement.textContent = invText;

            // Color code inventory status
            if (invCount >= invMax) {
                invElement.style.color = '#ff4444';
                invElement.style.fontWeight = 'bold';
            } else if (invCount >= invMax - 2) {
                invElement.style.color = '#ffaa00';
            } else {
                invElement.style.color = '';
                invElement.style.fontWeight = '';
            }
        }

        function renderLoadoutScreen() {
            if (!game.currentMech) {
                document.getElementById('loadout-mech-name').textContent = 'No Mech Selected';
                document.getElementById('mech-slots').innerHTML = '<p class="warning">Please select a mech to continue.</p>';
                return;
            }

            const mech = game.currentMech;
            const stats = calculateMechStats(mech);

            // Display mech name with traits
            const traitIcons = (mech.traits || []).map(t => t.icon).join(' ');
            document.getElementById('loadout-mech-name').textContent =
                `${mech.name} (${mech.class}) - Tier ${mech.tier} ${traitIcons}`;
            document.getElementById('loadout-mech-visual').textContent = mech.visual;

            // Update resource bars
            const tierPercent = (stats.tierUsed / mech.tierCapacity) * 100;
            const weightPercent = (stats.weightUsed / mech.weightCapacity) * 100;

            document.getElementById('tier-usage').textContent =
                `${stats.tierUsed}/${mech.tierCapacity}`;
            document.getElementById('tier-bar').style.width = `${Math.min(100, tierPercent)}%`;

            document.getElementById('weight-usage').textContent =
                `${stats.weightUsed}/${mech.weightCapacity}`;
            document.getElementById('weight-bar').style.width = `${Math.min(100, weightPercent)}%`;

            // Render slots
            const slotsHTML = Object.entries(SLOT_TYPES).map(([key, slotName]) => {
                const slot = mech.slots[slotName];
                const component = mech.loadout[slotName];
                const slotLabel = key.replace(/_/g, ' ');

                if (component) {
                    const damageTypeIcon = component.damageType === DAMAGE_TYPES.ENERGY ? '‚öõÔ∏è' :
                                           component.damageType === DAMAGE_TYPES.KINETIC ? 'üéØ' :
                                           component.damageType === DAMAGE_TYPES.EXPLOSIVE ? 'üí£' : '';
                    const abilities = component.abilities || [];
                    const abilityText = abilities.map(abilityKey => {
                        const ability = ABILITIES[abilityKey];
                        return ability ? `
                            <div style="font-size: 9px; color: #00ff88; margin-top: 3px; padding: 3px; background: rgba(0, 255, 136, 0.1); border-radius: 2px;">
                                <strong>‚ú® ${ability.name}</strong><br>
                                <span style="color: #aaa; font-size: 8px;">${ability.desc}</span>
                            </div>
                        ` : '';
                    }).join('');

                    return `
                        <div class="slot filled" onclick="handleSlotClick('${slotName}')">
                            <div class="slot-header">
                                <span>${slotLabel}</span>
                                <span class="tier-indicator tier-${component.tier}">T${component.tier}</span>
                            </div>
                            <div class="component-name">${damageTypeIcon} ${component.name}</div>
                            <div style="font-size: 11px; margin-top: 5px;">
                                ‚öîÔ∏è${component.damage} üõ°Ô∏è${component.armor}
                            </div>
                            ${abilityText}
                        </div>
                    `;
                } else {
                    return `
                        <div class="slot" onclick="handleSlotClick('${slotName}')">
                            <div class="slot-header">
                                <span>${slotLabel}</span>
                                <span style="color: #666;">Empty</span>
                            </div>
                            <div style="font-size: 11px; color: #666;">Click to attach component</div>
                        </div>
                    `;
                }
            }).join('');

            document.getElementById('mech-slots').innerHTML = slotsHTML;

            // Render inventory
            renderInventory();
        }

        let selectedInventoryItem = null;

        function renderInventory() {
            const inventoryGrid = document.getElementById('inventory-grid');

            if (game.inventory.length === 0) {
                inventoryGrid.innerHTML = '<p style="color: #666;">No components in inventory. Win battles to collect salvage!</p>';
                return;
            }

            inventoryGrid.innerHTML = game.inventory.map(comp => {
                const damageTypeIcon = comp.damageType === DAMAGE_TYPES.ENERGY ? '‚öõÔ∏è' :
                                       comp.damageType === DAMAGE_TYPES.KINETIC ? 'üéØ' :
                                       comp.damageType === DAMAGE_TYPES.EXPLOSIVE ? 'üí£' : '';
                const abilities = comp.abilities || [];
                const abilityText = abilities.map(abilityKey => {
                    const ability = ABILITIES[abilityKey];
                    return ability ? `
                        <div style="font-size: 10px; color: #00ff88; margin-top: 5px; padding: 4px; background: rgba(0, 255, 136, 0.1); border-radius: 3px; border-left: 2px solid #00ff88;">
                            <strong>‚ú® ${ability.name}</strong><br>
                            <span style="color: #ccc; font-size: 9px;">${ability.desc}</span>
                        </div>
                    ` : '';
                }).join('');

                return `
                    <div class="inventory-item ${selectedInventoryItem?.id === comp.id ? 'selected' : ''}"
                         onclick="selectInventoryItem('${comp.id}')">
                        <div class="component-name" style="font-size: 14px;">
                            ${damageTypeIcon} ${comp.name}
                            <span class="tier-indicator tier-${comp.tier}">T${comp.tier}</span>
                        </div>
                        <div class="component-stats">
                            <div class="stat-item">‚öîÔ∏è DMG: ${comp.damage}</div>
                            <div class="stat-item">üõ°Ô∏è ARM: ${comp.armor}</div>
                        </div>
                        <div style="font-size: 10px; color: #888; margin-top: 5px;">
                            Slot: ${comp.slot.replace(/([A-Z])/g, ' $1').trim()}
                        </div>
                        ${abilityText}
                    </div>
                `;
            }).join('');
        }

        function selectInventoryItem(componentId) {
            const component = game.inventory.find(c => c.id === componentId);
            if (component) {
                selectedInventoryItem = component;
                renderInventory();
            }
        }

        function handleSlotClick(slotName) {
            if (!game.currentMech) return;

            const currentComponent = game.currentMech.loadout[slotName];

            // If slot is filled, detach
            if (currentComponent) {
                if (confirm(`Detach ${currentComponent.name}?`)) {
                    detachComponent(game.currentMech, slotName);
                    selectedInventoryItem = null;
                    renderLoadoutScreen();
                }
                return;
            }

            // If slot is empty and we have a selected item, try to attach
            if (selectedInventoryItem) {
                if (canAttachComponent(game.currentMech, selectedInventoryItem, slotName)) {
                    attachComponent(game.currentMech, selectedInventoryItem, slotName);
                    selectedInventoryItem = null;
                    renderLoadoutScreen();
                } else {
                    alert('Cannot attach this component here. Check slot type, size, tier points, and weight limits.');
                }
            } else {
                alert('Please select a component from inventory first.');
            }
        }

        function renderBattleScreen() {
            if (!game.currentMech) {
                alert('No mech selected!');
                return;
            }

            // Reset mech HP
            game.currentMech.currentHP = game.currentMech.maxHP;

            // Generate monster
            game.currentMonster = generateMonster(game.round);

            const stats = calculateMechStats(game.currentMech);

            // Update player display
            document.getElementById('player-visual').textContent = game.currentMech.visual;
            document.getElementById('player-name').textContent = game.currentMech.name;
            document.getElementById('player-stats').innerHTML =
                `‚öîÔ∏è Damage: ${stats.damage} | üõ°Ô∏è Armor: ${stats.armor} | ‚ö° Speed: ${stats.speed}`;
            updateHealthBar('player', game.currentMech.currentHP, game.currentMech.maxHP);

            // Update monster display
            document.getElementById('monster-visual').textContent = game.currentMonster.visual;
            document.getElementById('monster-name').textContent = game.currentMonster.name;
            document.getElementById('monster-stats').innerHTML =
                `‚öîÔ∏è Damage: ${game.currentMonster.damage} | üõ°Ô∏è Armor: ${game.currentMonster.armor} | ‚ö° Speed: ${game.currentMonster.speed}`;
            updateHealthBar('monster', game.currentMonster.currentHP, game.currentMonster.maxHP);

            // Display active abilities and traits
            displayActiveAbilities();

            // Clear status effects
            document.getElementById('player-status-effects').innerHTML = '<span style="color: #666; font-size: 9px;">No active effects</span>';
            document.getElementById('monster-status-effects').innerHTML = '<span style="color: #666; font-size: 9px;">No active effects</span>';

            // Clear combat log
            document.getElementById('combat-log').innerHTML = '';

            showScreen('battle-screen');
        }

        function displayActiveAbilities() {
            const abilitiesDiv = document.getElementById('player-abilities-display');

            // Collect all abilities
            const abilities = [];
            Object.values(game.currentMech.loadout || {}).forEach(comp => {
                if (comp && comp.abilities) {
                    comp.abilities.forEach(abilityKey => {
                        if (ABILITIES[abilityKey] && !abilities.includes(abilityKey)) {
                            abilities.push(abilityKey);
                        }
                    });
                }
            });

            // Collect traits
            const traits = game.currentMech.traits || [];

            if (abilities.length === 0 && traits.length === 0) {
                abilitiesDiv.style.display = 'none';
                return;
            }

            let html = '<h4>‚ö° ACTIVE EFFECTS</h4>';

            if (traits.length > 0) {
                html += '<div style="margin-bottom: 5px;">';
                traits.forEach(trait => {
                    html += `<span class="trait-tag" title="${trait.desc}">${trait.icon} ${trait.name}</span>`;
                });
                html += '</div>';
            }

            if (abilities.length > 0) {
                html += '<div>';
                abilities.forEach(abilityKey => {
                    const ability = ABILITIES[abilityKey];
                    html += `<span class="ability-tag" title="${ability.desc}">‚ú® ${ability.name}</span>`;
                });
                html += '</div>';
            }

            abilitiesDiv.innerHTML = html;
            abilitiesDiv.style.display = 'block';
        }

        function updateStatusEffects(playerShield, playerDots, monsterDots) {
            // Update player status effects
            const playerStatusDiv = document.getElementById('player-status-effects');
            let playerEffects = [];

            if (playerShield > 0) {
                playerEffects.push(`<span class="status-effect status-shield">üõ°Ô∏è Shield: ${playerShield}</span>`);
            }

            if (playerEffects.length === 0) {
                playerStatusDiv.innerHTML = '<span style="color: #666; font-size: 9px;">No active effects</span>';
            } else {
                playerStatusDiv.innerHTML = playerEffects.join('');
            }

            // Update monster status effects
            const monsterStatusDiv = document.getElementById('monster-status-effects');
            let monsterEffects = [];

            monsterDots.forEach(dot => {
                if (dot.type === 'burn') {
                    monsterEffects.push(`<span class="status-effect status-burn">üî• Burn: ${dot.damage}x${dot.duration}</span>`);
                } else if (dot.type === 'bleed') {
                    monsterEffects.push(`<span class="status-effect status-bleed">ü©∏ Bleed: ${dot.damage}x${dot.duration}</span>`);
                }
            });

            if (monsterEffects.length === 0) {
                monsterStatusDiv.innerHTML = '<span style="color: #666; font-size: 9px;">No active effects</span>';
            } else {
                monsterStatusDiv.innerHTML = monsterEffects.join('');
            }
        }

        function updateHealthBar(actor, current, max) {
            const percent = (current / max) * 100;
            const fill = document.getElementById(`${actor}-health`);
            const text = document.getElementById(`${actor}-health-text`);

            fill.style.width = `${Math.max(0, percent)}%`;
            text.textContent = `${Math.max(0, current)}/${max}`;
        }

        function addCombatLog(message, actor) {
            const log = document.getElementById('combat-log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${actor}`;
            entry.textContent = message;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        async function startBattle() {
            if (!game.currentMech || !game.currentMonster) return;

            document.getElementById('start-battle-btn').disabled = true;

            const battle = new BattleSystem(game.currentMech, game.currentMonster);

            addCombatLog('‚öîÔ∏è BATTLE START! ‚öîÔ∏è', 'system');

            // Show initial status effects (e.g., shield)
            updateStatusEffects(battle.playerShield, battle.playerDots, battle.monsterDots);

            let result = 'continue';

            while (result === 'continue') {
                await new Promise(resolve => setTimeout(resolve, 1000));

                result = battle.executeTurn();
                const state = battle.getState();

                // Update displays
                updateHealthBar('player', state.playerMech.currentHP, state.playerMech.maxHP);
                updateHealthBar('monster', state.monster.currentHP, state.monster.maxHP);

                // Update status effects display
                updateStatusEffects(state.playerShield, battle.playerDots, battle.monsterDots);

                // Add latest log entries
                if (battle.log.length > 0) {
                    const latestLog = battle.log[battle.log.length - 1];
                    addCombatLog(latestLog.message, latestLog.actor);

                    if (battle.log.length > 1 && battle.log[battle.log.length - 2].turn === battle.turn) {
                        const secondLog = battle.log[battle.log.length - 2];
                        addCombatLog(secondLog.message, secondLog.actor);
                    }
                }
            }

            await new Promise(resolve => setTimeout(resolve, 1500));

            if (result === 'victory') {
                game.victories++;
                game.round++;
                game.save();

                // Check if round 5, 10, 15, etc. - Show trait selection
                if ((game.round - 1) % 5 === 0 && game.round > 1) {
                    showTraitSelectionScreen();
                } else {
                    showSalvageScreen();
                }
            } else {
                // Defeat - game over
                addCombatLog('', 'system');
                addCombatLog('GAME OVER! Starting new game...', 'system');
                await new Promise(resolve => setTimeout(resolve, 3000));
                game.reset();
                initializeGame();
            }

            document.getElementById('start-battle-btn').disabled = false;
            updateHeader();
        }

        function showSalvageScreen() {
            const tierLevel = Math.floor(game.round / 5) + 1;
            const salvageOptions = generateRandomComponents(3, tierLevel, tierLevel + 1);

            // Check if player has SALVAGER trait
            const hasSalvager = game.currentMech && game.currentMech.traits &&
                                game.currentMech.traits.some(t => t.name === 'SALVAGER');

            const titleText = hasSalvager ?
                'Choose TWO components to salvage (SALVAGER trait active!):' :
                'Choose one component to salvage from the battlefield:';

            document.querySelector('#salvage-screen p').textContent = titleText;

            const optionsHTML = salvageOptions.map((comp, index) => {
                const damageTypeIcon = comp.damageType === DAMAGE_TYPES.ENERGY ? '‚öõÔ∏è' :
                                       comp.damageType === DAMAGE_TYPES.KINETIC ? 'üéØ' :
                                       comp.damageType === DAMAGE_TYPES.EXPLOSIVE ? 'üí£' : '';
                const abilities = comp.abilities || [];
                const abilityText = abilities.map(abilityKey => {
                    const ability = ABILITIES[abilityKey];
                    return ability ? `
                        <div style="font-size: 10px; color: #00ff88; margin-top: 5px; padding: 4px; background: rgba(0, 255, 136, 0.1); border-radius: 3px; border-left: 2px solid #00ff88;">
                            <strong>‚ú® ${ability.name}</strong><br>
                            <span style="color: #ccc; font-size: 9px;">${ability.desc}</span>
                        </div>
                    ` : '';
                }).join('');

                return `
                    <div class="salvage-card" onclick="selectSalvage(${index})">
                        <div class="component-name">
                            ${damageTypeIcon} ${comp.name}
                            <span class="tier-indicator tier-${comp.tier}">Tier ${comp.tier}</span>
                        </div>
                        <div style="margin: 10px 0; color: #888;">${comp.type.toUpperCase()}</div>
                        <div class="component-stats">
                            <div class="stat-item">‚öîÔ∏è Damage: ${comp.damage}</div>
                            <div class="stat-item">üõ°Ô∏è Armor: ${comp.armor}</div>
                            <div class="stat-item" style="grid-column: 1 / -1;">
                                üìç Slot: ${comp.slot.replace(/([A-Z])/g, ' $1').trim()}
                            </div>
                        </div>
                        ${abilityText}
                    </div>
                `;
            }).join('');

            document.getElementById('salvage-options').innerHTML = optionsHTML;

            // Store options temporarily
            window.currentSalvageOptions = salvageOptions;
            window.salvageSelections = [];
            window.salvageLimit = hasSalvager ? 2 : 1;

            showScreen('salvage-screen');
        }

        function selectSalvage(index) {
            const component = window.currentSalvageOptions[index];
            window.salvageSelections = window.salvageSelections || [];

            if (window.salvageSelections.includes(index)) {
                // Already selected, deselect
                window.salvageSelections = window.salvageSelections.filter(i => i !== index);
            } else {
                window.salvageSelections.push(index);
            }

            // Visual feedback - highlight selected
            document.querySelectorAll('#salvage-options .salvage-card').forEach((card, i) => {
                if (window.salvageSelections.includes(i)) {
                    card.style.borderColor = '#00ff88';
                    card.style.transform = 'scale(0.95)';
                } else {
                    card.style.borderColor = '#444';
                    card.style.transform = 'scale(1)';
                }
            });

            // If reached limit, auto-confirm
            if (window.salvageSelections.length >= window.salvageLimit) {
                setTimeout(() => {
                    // Check if inventory is full
                    const selectedComponents = window.salvageSelections.map(idx => window.currentSalvageOptions[idx]);

                    if (game.inventory.length + selectedComponents.length > game.maxInventorySize) {
                        // Inventory would overflow - need to drop items
                        const overflow = (game.inventory.length + selectedComponents.length) - game.maxInventorySize;
                        showInventoryManagementScreen(selectedComponents, overflow);
                    } else {
                        // Inventory has space
                        selectedComponents.forEach(comp => game.inventory.push(comp));
                        game.save();
                        updateHeader();
                        renderLoadoutScreen();
                        showScreen('loadout-screen');
                    }
                }, 300);
            }
        }

        function showInventoryManagementScreen(newComponents, mustDrop) {
            const message = `‚ö†Ô∏è INVENTORY FULL! (${game.inventory.length + newComponents.length}/${game.maxInventorySize})\n\nYou must DROP ${mustDrop} component(s) to make room for your salvage.`;

            if (!confirm(message + '\n\nOK = Choose what to drop\nCancel = Skip salvage')) {
                // Skip salvage
                updateHeader();
                renderLoadoutScreen();
                showScreen('loadout-screen');
                return;
            }

            // Show inventory management UI
            window.pendingNewComponents = newComponents;
            window.mustDropCount = mustDrop;
            window.selectedForDrop = [];

            alert('Select ' + mustDrop + ' component(s) from your inventory to drop, then proceed to loadout screen.');

            // Add new components to temporary holding
            game.inventory.push(...newComponents);
            game.save();
            updateHeader();
            renderLoadoutScreen();
            showScreen('loadout-screen');

            // Add drop mode UI hint
            const inventoryPanel = document.querySelector('.inventory-panel h3');
            if (inventoryPanel) {
                inventoryPanel.innerHTML = `üì¶ Inventory <span style="color: #ff4444; font-size: 12px;">(MUST DROP ${mustDrop} ITEMS - Click to drop)</span>`;
            }
        }

        function showTraitSelectionScreen() {
            // Generate 3 random trait options
            const allTraits = Object.values(MECH_TRAITS);
            const availableTraits = allTraits.filter(trait =>
                !game.currentMech.traits.some(t => t.name === trait.name)
            );

            const traitOptions = [];
            for (let i = 0; i < 3 && availableTraits.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * availableTraits.length);
                traitOptions.push(availableTraits.splice(randomIndex, 1)[0]);
            }

            const traitsHTML = traitOptions.map((trait, index) => `
                <div class="mech-card" onclick="selectTrait(${index})" style="border-color: #ffaa00;">
                    <div style="font-size: 48px; text-align: center; margin: 15px 0;">${trait.icon}</div>
                    <div class="component-name" style="color: #ffaa00;">
                        ${trait.name}
                        <span class="tier-indicator tier-${trait.tier}">T${trait.tier}</span>
                    </div>
                    <div style="margin: 15px 0; color: #ccc; font-size: 13px; line-height: 1.5;">
                        ${trait.desc}
                    </div>
                    <div style="margin-top: 15px; padding: 10px; background: rgba(255,170,0,0.2); border-radius: 5px; font-size: 11px;">
                        This trait is permanent and will transform your playstyle!
                    </div>
                </div>
            `).join('');

            document.getElementById('trait-options').innerHTML = traitsHTML;
            window.currentTraitOptions = traitOptions;

            showScreen('trait-select-screen');
        }

        function selectTrait(index) {
            const trait = window.currentTraitOptions[index];

            if (!game.currentMech.traits) {
                game.currentMech.traits = [];
            }

            game.currentMech.traits.push(trait);
            game.save();

            alert(`${trait.icon} Trait Acquired: ${trait.name}!\n\n${trait.desc}`);

            updateHeader();
            renderLoadoutScreen();
            showScreen('loadout-screen');
        }

        // ============================================================================
        // INITIALIZATION
        // ============================================================================

        function initializeGame() {
            // Try to load saved game
            if (!game.load()) {
                // New game - choose starting mech
                const startingMechs = [
                    createMech(MECH_TEMPLATES.SCOUT, 1),
                    createMech(MECH_TEMPLATES.WARRIOR, 1),
                    createMech(MECH_TEMPLATES.TITAN, 1)
                ];

                // Add some starter components
                game.inventory = generateRandomComponents(6, 1, 2);

                const choice = confirm('Welcome to Mech Autobattler!\n\nChoose your starting mech:\n\nOK = Scout (Fast, Light)\nCancel = Warrior (Balanced)\n\n(Heavy Titan also available)');

                if (choice) {
                    game.currentMech = startingMechs[0];
                } else {
                    const choice2 = confirm('Warrior (Balanced) or Titan (Heavy)?\n\nOK = Warrior\nCancel = Titan');
                    game.currentMech = choice2 ? startingMechs[1] : startingMechs[2];
                }

                game.save();
            }

            updateHeader();
            renderLoadoutScreen();
        }

        // ============================================================================
        // EVENT LISTENERS
        // ============================================================================

        document.getElementById('ready-battle-btn').addEventListener('click', () => {
            if (!game.currentMech) {
                alert('No mech selected!');
                return;
            }
            renderBattleScreen();
        });

        document.getElementById('start-battle-btn').addEventListener('click', startBattle);

        // Abilities guide toggle
        document.getElementById('toggle-abilities-guide').addEventListener('click', () => {
            const guide = document.getElementById('abilities-guide');
            if (guide.style.display === 'none') {
                guide.style.display = 'block';
                populateAbilitiesGuide();
            } else {
                guide.style.display = 'none';
            }
        });

        function populateAbilitiesGuide() {
            const referenceDiv = document.getElementById('abilities-reference');

            let html = '<div style="font-size: 11px; line-height: 1.6;">';

            // Group abilities by category
            const damageAbilities = ['CRITICAL_STRIKE', 'ARMOR_PIERCING', 'BURN', 'BLEED', 'EXECUTIONER', 'DOUBLE_STRIKE', 'OVERCHARGE'];
            const defenseAbilities = ['SHIELD_GEN', 'REGENERATION', 'REACTIVE', 'DODGE'];
            const utilityAbilities = ['VAMPIRIC', 'BERSERKER', 'LIGHTWEIGHT', 'OVERDRIVE', 'QUICK_DEPLOY', 'EFFICIENT'];

            html += '<div style="margin-bottom: 12px;"><strong style="color: #ff8844; font-size: 12px;">‚öîÔ∏è DAMAGE ABILITIES</strong></div>';
            damageAbilities.forEach(key => {
                const ability = ABILITIES[key];
                if (ability) {
                    html += `
                        <div style="margin-bottom: 8px; padding: 6px; background: rgba(255, 136, 68, 0.1); border-left: 3px solid #ff8844; border-radius: 3px;">
                            <strong style="color: #ff8844;">${ability.name}</strong> <span style="color: #666; font-size: 9px;">(Tier ${ability.tier})</span><br>
                            <span style="color: #ccc; font-size: 10px;">${ability.desc}</span>
                        </div>
                    `;
                }
            });

            html += '<div style="margin: 12px 0;"><strong style="color: #00ccff; font-size: 12px;">üõ°Ô∏è DEFENSE ABILITIES</strong></div>';
            defenseAbilities.forEach(key => {
                const ability = ABILITIES[key];
                if (ability) {
                    html += `
                        <div style="margin-bottom: 8px; padding: 6px; background: rgba(0, 204, 255, 0.1); border-left: 3px solid #00ccff; border-radius: 3px;">
                            <strong style="color: #00ccff;">${ability.name}</strong> <span style="color: #666; font-size: 9px;">(Tier ${ability.tier})</span><br>
                            <span style="color: #ccc; font-size: 10px;">${ability.desc}</span>
                        </div>
                    `;
                }
            });

            html += '<div style="margin: 12px 0;"><strong style="color: #ffaa00; font-size: 12px;">‚ö° UTILITY ABILITIES</strong></div>';
            utilityAbilities.forEach(key => {
                const ability = ABILITIES[key];
                if (ability) {
                    html += `
                        <div style="margin-bottom: 8px; padding: 6px; background: rgba(255, 170, 0, 0.1); border-left: 3px solid #ffaa00; border-radius: 3px;">
                            <strong style="color: #ffaa00;">${ability.name}</strong> <span style="color: #666; font-size: 9px;">(Tier ${ability.tier})</span><br>
                            <span style="color: #ccc; font-size: 10px;">${ability.desc}</span>
                        </div>
                    `;
                }
            });

            html += '</div>';
            referenceDiv.innerHTML = html;
        }

        // Debug panel
        document.getElementById('debug-toggle').addEventListener('click', () => {
            const panel = document.getElementById('debug-panel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        });

        function updateDebugPanel() {
            const panel = document.getElementById('debug-panel');
            const stats = game.currentMech ? calculateMechStats(game.currentMech) : null;

            panel.innerHTML = `
                <h4 style="color: #ff00ff;">DEBUG INFO</h4>
                <div style="margin-bottom: 10px; padding: 5px; background: rgba(255,0,255,0.2); border-radius: 4px; font-size: 10px;">
                    <strong>Version:</strong> 3.1.0-WIP - RELICS & SIMPLIFICATION
                </div>
                <div style="margin: 10px 0;">
                    <strong>Round:</strong> ${game.round}<br>
                    <strong>Victories:</strong> ${game.victories}<br>
                    <strong>Inventory:</strong> ${game.inventory.length} items<br>
                    ${stats ? `
                        <strong>Mech Stats:</strong><br>
                        - Damage: ${stats.damage}<br>
                        - Armor: ${stats.armor}<br>
                        - Speed: ${stats.speed}<br>
                        - Tier: ${stats.tierUsed}/${game.currentMech.tierCapacity}<br>
                        - Weight: ${stats.weightUsed}/${game.currentMech.weightCapacity}
                    ` : '<em>No mech selected</em>'}
                </div>
                <button class="btn btn-danger" onclick="if(confirm('Reset game?')) { game.reset(); initializeGame(); }" style="width: 100%; padding: 8px; font-size: 12px;">
                    RESET GAME
                </button>
            `;
        }

        // Update debug panel every second
        setInterval(updateDebugPanel, 1000);

        // ============================================================================
        // START GAME
        // ============================================================================

        initializeGame();
    </script>
</body>
</html>
