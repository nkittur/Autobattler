<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BattleTech Arena - AI Combat</title>
    <style>
        body {
            margin: 0;
            padding: 15px;
            background: #1a1a2e;
            font-family: monospace;
            color: #00ff88;
            overflow-x: hidden;
        }
        #renderCanvas {
            width: 100%;
            max-width: 1000px;
            height: 55vh;
            max-height: 450px;
            display: block;
            margin: 0 auto;
            border: 3px solid #00ff88;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            touch-action: none;
        }
        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin: 8px 0;
            font-size: 1.3em;
        }
        #status {
            max-width: 1000px;
            margin: 10px auto;
            padding: 8px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #00ff88;
            border-radius: 8px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        #logs {
            flex: 1;
            min-width: 200px;
            max-height: 100px;
            overflow-y: auto;
            font-size: 10px;
        }
        #mechStatus {
            flex: 1;
            min-width: 280px;
            display: flex;
            gap: 10px;
        }
        .mech-info {
            flex: 1;
            padding: 5px;
            border: 1px solid #00ff88;
            border-radius: 4px;
            font-size: 11px;
        }
        .mech-info.enemy { border-color: #ff4444; }
        .log { margin: 1px 0; padding: 1px 3px; }
        .log.info { color: #00ff88; }
        .log.warn { color: #ffaa00; }
        .log.error { color: #ff4444; }
        #controls {
            text-align: center;
            margin: 8px 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 4px;
        }
        button {
            padding: 6px 12px;
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            border-radius: 5px;
            font-family: monospace;
            font-size: 11px;
        }
        button:hover, button:active {
            background: rgba(0, 255, 136, 0.4);
        }
        button.red {
            border-color: #ff4444;
            color: #ff4444;
            background: rgba(255, 68, 68, 0.2);
        }
        .hp-bar {
            height: 10px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin: 2px 0;
        }
        .hp-fill {
            height: 100%;
            transition: width 0.3s;
        }
        .hp-fill.player { background: linear-gradient(90deg, #00aa55, #00ff88); }
        .hp-fill.enemy { background: linear-gradient(90deg, #aa2222, #ff4444); }
        #polyCount {
            text-align: center;
            font-size: 10px;
            color: #888;
            margin-top: 5px;
        }
        #debugPanel {
            max-width: 1000px;
            margin: 10px auto;
            padding: 8px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #ff8800;
            border-radius: 8px;
            font-size: 10px;
        }
        #debugPanel .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        #debugPanel .title { color: #ff8800; font-weight: bold; }
        #debugLogs {
            max-height: 150px;
            overflow-y: auto;
            font-family: monospace;
            white-space: pre;
            color: #aaa;
            line-height: 1.3;
        }
        #debugLogs .dbg-ai { color: #88ff88; }
        #debugLogs .dbg-phys { color: #88ffff; }
        #debugLogs .dbg-torso { color: #ff88ff; }
        #debugLogs .dbg-err { color: #ff4444; }
        #debugLogs .dbg-warn { color: #ffaa00; }
        .copy-btn {
            padding: 3px 8px;
            font-size: 10px;
            background: rgba(255, 136, 0, 0.3);
            border: 1px solid #ff8800;
            color: #ff8800;
            cursor: pointer;
            border-radius: 3px;
        }
        .copy-btn:hover { background: rgba(255, 136, 0, 0.5); }
    </style>
</head>
<body>
    <h1>BattleTech Arena <span id="version" style="font-size: 0.6em; color: #888;">v9.7</span></h1>
    <div id="controls">
        <button id="autoFireBtn" onclick="toggleAutoFire()" style="background: rgba(255, 200, 0, 0.3); border-color: #ffcc00; color: #ffcc00;">AI Battle: OFF</button>
        <button onclick="resetScene()">Reset</button>
    </div>
    <canvas id="renderCanvas"></canvas>
    <div id="polyCount">Triangles: <span id="triCount">0</span></div>
    <div id="status">
        <div id="logs"></div>
        <div id="mechStatus">
            <div class="mech-info player">
                <strong style="color: #00ff88;">TIMBER WOLF (Mad Cat)</strong>
                <div class="hp-bar"><div class="hp-fill player" id="playerHP" style="width: 100%"></div></div>
                <div id="playerHPText">HP: 150/150</div>
                <div id="playerState">Idle</div>
            </div>
            <div class="mech-info enemy">
                <strong style="color: #ff4444;">DIRE WOLF (Daishi)</strong>
                <div class="hp-bar"><div class="hp-fill enemy" id="enemyHP" style="width: 100%"></div></div>
                <div id="enemyHPText">HP: 200/200</div>
                <div id="enemyState">Idle</div>
            </div>
        </div>
    </div>

    <div id="debugPanel">
        <div class="header">
            <span class="title">DIAGNOSTIC LOGS</span>
            <button class="copy-btn" onclick="copyDebugLogs()">Copy Logs</button>
        </div>
        <div id="debugLogs"></div>
    </div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>

    <script>
        // Logging
        const logs = [];
        function log(msg, type = 'info') {
            console.log(msg);
            logs.push({ msg, type });
            const logsDiv = document.getElementById('logs');
            if (logsDiv) {
                logsDiv.innerHTML = logs.slice(-10).map(l =>
                    `<div class="log ${l.type}">${l.msg}</div>`
                ).join('');
            }
        }

        // Debug logging system
        const debugLogs = [];
        let lastDebugTime = 0;
        const DEBUG_INTERVAL = 0.5; // Log every 0.5 seconds to avoid spam

        function dbg(msg, category = '') {
            const ts = gameTime.toFixed(2);
            const entry = `[${ts}] ${msg}`;
            debugLogs.push({ msg: entry, cat: category });
            if (debugLogs.length > 100) debugLogs.shift(); // Keep last 100 entries
            updateDebugPanel();
        }

        function updateDebugPanel() {
            const el = document.getElementById('debugLogs');
            if (el) {
                el.innerHTML = debugLogs.slice(-30).map(l => {
                    const cls = l.cat ? `dbg-${l.cat}` : '';
                    return `<span class="${cls}">${l.msg}</span>`;
                }).join('\n');
                el.scrollTop = el.scrollHeight;
            }
        }

        function copyDebugLogs() {
            const text = debugLogs.map(l => l.msg).join('\n');
            navigator.clipboard.writeText(text).then(() => {
                log('Logs copied to clipboard!', 'info');
            }).catch(err => {
                // Fallback for browsers without clipboard API
                const ta = document.createElement('textarea');
                ta.value = text;
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                document.body.removeChild(ta);
                log('Logs copied!', 'info');
            });
        }

        log('Initializing Mad Cat Physics Test...');

        // Globals
        let engine, scene, camera, havokInstance, havokPlugin;
        let playerMechs = [];  // Array of player team mechs
        let enemyMechs = [];   // Array of enemy team mechs
        let allMechs = [];     // Combined array for iteration
        let projectiles = [];
        let beams = [];
        let gameTime = 0;
        let autoFireEnabled = false;
        let autoFireInterval = null;
        let battleEnded = false;  // Flag to stop AI loops when battle is over

        // Weapon cooldowns per mech (keyed by mech name)
        const mechCooldowns = {};
        const COOLDOWN_TIMES = { erlaser: 2000, lrm: 3500, ac: 1500 };

        // Helper to get alive mechs
        function getAliveMechs(team) {
            const mechs = team === 'player' ? playerMechs : enemyMechs;
            return mechs.filter(m => m && m.currentHP > 0 && !m.isDestroyed);
        }

        // Helper to find a new target for a mech
        function findNewTarget(mech) {
            const enemies = mech.isPlayer ? enemyMechs : playerMechs;
            const aliveEnemies = enemies.filter(e => e && e.currentHP > 0 && !e.isDestroyed);
            if (aliveEnemies.length === 0) return null;
            // Find closest enemy
            const myPos = mech.pelvis.getAbsolutePosition();
            let closest = null;
            let closestDist = Infinity;
            for (const enemy of aliveEnemies) {
                const dist = BABYLON.Vector3.Distance(myPos, enemy.pelvis.getAbsolutePosition());
                if (dist < closestDist) {
                    closestDist = dist;
                    closest = enemy;
                }
            }
            return closest;
        }

        // AI Configuration
        const AI_CONFIG = {
            idealRange: 10,         // Optimal combat distance
            minRange: 6,            // Too close - back up
            maxRange: 13,           // Too far - close in (slightly less than starting distance)
            edgeBoundary: 16,       // X position to start avoiding edges
            edgeForce: 45,          // Force to push away from edges
            moveForce: 150,         // Normal movement force (increased significantly)
            strafeForce: 60,        // Lateral movement force (increased significantly)
            decisionInterval: 0.2,  // How often AI makes decisions (faster for responsiveness)
            strafeChance: 0.6,      // Higher chance to strafe at optimal range for more dynamic combat
            strafeDuration: 1.5     // How long to strafe before reconsidering
        };

        // Weapons
        const WEAPONS = {
            erlaser: {
                name: 'ER Large Laser',
                damage: 20,
                knockback: 10,
                recoil: 0.2,
                isBeam: true,
                beamDuration: 180,
                color: new BABYLON.Color3(0.2, 1, 0.3)
            },
            lrm: {
                name: 'LRM-20',
                damage: 25,
                knockback: 15,
                recoil: 0.15,
                projectileSpeed: 38,  // Faster missiles
                isCluster: true,
                clusterCount: 8,
                color: new BABYLON.Color3(1, 0.5, 0.1)
            },
            ac: {
                name: 'UAC/5',
                damage: 18,
                knockback: 28,  // Much more impact
                recoil: 0.12,
                projectileSpeed: 45,  // Faster rounds
                projectileSize: 0.1,
                color: new BABYLON.Color3(1, 0.9, 0.3)
            }
        };

        // Colors
        const COLORS = {
            playerPrimary: new BABYLON.Color3(0.15, 0.35, 0.2),
            playerSecondary: new BABYLON.Color3(0.25, 0.45, 0.3),
            playerAccent: new BABYLON.Color3(0.7, 0.6, 0.1),
            enemyPrimary: new BABYLON.Color3(0.4, 0.12, 0.12),
            enemySecondary: new BABYLON.Color3(0.5, 0.18, 0.18),
            enemyAccent: new BABYLON.Color3(0.25, 0.25, 0.3),
            metal: new BABYLON.Color3(0.35, 0.35, 0.4),
            darkMetal: new BABYLON.Color3(0.12, 0.12, 0.15),
            chrome: new BABYLON.Color3(0.6, 0.6, 0.65),
            cockpit: new BABYLON.Color3(0.1, 0.9, 0.95),
            thruster: new BABYLON.Color3(1, 0.4, 0.1),
            ground: new BABYLON.Color3(0.22, 0.2, 0.18)
        };

        // Texture URLs from Babylon.js assets
        const TEXTURE_URLS = {
            // Ground textures
            grass: 'https://playground.babylonjs.com/textures/grass.png',
            grassNormal: 'https://playground.babylonjs.com/textures/grassn.png',
            rock: 'https://playground.babylonjs.com/textures/rock.png',
            rockNormal: 'https://playground.babylonjs.com/textures/rockn.png',
            // Metal textures
            metal: 'https://playground.babylonjs.com/textures/floor.png',
            metalNormal: 'https://playground.babylonjs.com/textures/floorNormal.png',
            rustMetal: 'https://assets.babylonjs.com/textures/rustediron2_basecolor.png',
            rustMetalNormal: 'https://assets.babylonjs.com/textures/rustediron2_normal.png',
            // Detail textures
            crate: 'https://playground.babylonjs.com/textures/crate.png',
            wood: 'https://playground.babylonjs.com/textures/wood.jpg',
            // Misc
            distortion: 'https://playground.babylonjs.com/textures/distortion.png'
        };

        // Global texture cache
        let TEXTURES = {};

        async function initEngine() {
            const canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

            try {
                havokInstance = await HavokPhysics();
                log('Havok initialized');
            } catch (e) {
                log('Havok failed: ' + e.message, 'error');
                return;
            }

            scene = createScene();

            let lastTime = performance.now();
            let frameCount = 0;
            engine.runRenderLoop(() => {
                if (scene) {
                    try {
                        const now = performance.now();
                        const dt = (now - lastTime) / 1000;
                        lastTime = now;
                        gameTime += dt;
                        frameCount++;

                        // Log frame start occasionally
                        if (frameCount % 60 === 0) {
                            console.log(`[FRAME ${frameCount}] t=${gameTime.toFixed(2)}`);
                        }

                        // Always update projectiles and beams (so they don't freeze)
                        updateProjectiles(dt);
                        updateBeams();

                        // Only run AI/mech logic if battle hasn't ended
                        if (!battleEnded) {
                            updateMechs(dt);
                            checkBattleEnd();
                        } else {
                            // Still update destroyed mech physics during death animation
                            allMechs.forEach(mech => {
                                if (mech && mech.isDestroyed) {
                                    // Keep feet horizontal even when falling
                                    const body = mech.pelvisAggregate.body;
                                    const quat = body.transformNode.rotationQuaternion;
                                    if (quat && mech.leftLeg.footGroup) {
                                        const euler = quat.toEulerAngles();
                                        mech.leftLeg.footGroup.rotation.x = -euler.x;
                                        mech.rightLeg.footGroup.rotation.x = -euler.x;
                                        mech.leftLeg.footGroup.rotation.z = -euler.z * 0.5;
                                        mech.rightLeg.footGroup.rotation.z = -euler.z * 0.5;
                                    }
                                }
                            });
                        }
                        updateUI();

                        // Update debug timer AFTER all subsystems have had a chance to log
                        if (gameTime - lastDebugTime > DEBUG_INTERVAL) {
                            lastDebugTime = gameTime;
                        }
                        scene.render();
                    } catch (e) {
                        console.error('[RENDER LOOP ERROR]', e);
                        log(`[RENDER ERROR] ${e.message}`, 'error');
                    }
                }
            });

            window.addEventListener('resize', () => engine.resize());
            log('Scene ready!');

            // Log initial mech state for debugging
            setTimeout(() => {
                const motionTypes = ['STATIC', 'ANIMATED', 'DYNAMIC'];
                dbg(`Created ${playerMechs.length} player mechs and ${enemyMechs.length} enemy mechs`, 'ai');
                allMechs.forEach(mech => {
                    if (!mech) return;
                    const pos = mech.pelvis.getAbsolutePosition();
                    const body = mech.pelvisAggregate.body;
                    const side = mech.isPlayer ? 'P' : 'E';
                    dbg(`${side} ${mech.name}: pos=(${pos.x.toFixed(1)},${pos.y.toFixed(1)},${pos.z.toFixed(1)}) HP=${mech.maxHP}`, 'ai');
                });
                dbg('Click "AI Battle: OFF" to start battle', 'warn');
            }, 500);
        }

        function createScene() {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.06, 0.06, 0.1);

            havokPlugin = new BABYLON.HavokPlugin(true, havokInstance);
            scene.enablePhysics(new BABYLON.Vector3(0, -18, 0), havokPlugin);

            // Load textures
            TEXTURES.grass = new BABYLON.Texture(TEXTURE_URLS.grass, scene);
            TEXTURES.grass.uScale = 8;
            TEXTURES.grass.vScale = 4;
            TEXTURES.grassNormal = new BABYLON.Texture(TEXTURE_URLS.grassNormal, scene);
            TEXTURES.grassNormal.uScale = 8;
            TEXTURES.grassNormal.vScale = 4;

            TEXTURES.rock = new BABYLON.Texture(TEXTURE_URLS.rock, scene);
            TEXTURES.rock.uScale = 2;
            TEXTURES.rock.vScale = 2;
            TEXTURES.rockNormal = new BABYLON.Texture(TEXTURE_URLS.rockNormal, scene);
            TEXTURES.rockNormal.uScale = 2;
            TEXTURES.rockNormal.vScale = 2;

            TEXTURES.metal = new BABYLON.Texture(TEXTURE_URLS.metal, scene);
            TEXTURES.metal.uScale = 4;
            TEXTURES.metal.vScale = 4;

            TEXTURES.rustMetal = new BABYLON.Texture(TEXTURE_URLS.rustMetal, scene);
            TEXTURES.rustMetal.uScale = 2;
            TEXTURES.rustMetal.vScale = 2;
            TEXTURES.rustMetalNormal = new BABYLON.Texture(TEXTURE_URLS.rustMetalNormal, scene);
            TEXTURES.rustMetalNormal.uScale = 2;
            TEXTURES.rustMetalNormal.vScale = 2;

            // Camera
            camera = new BABYLON.ArcRotateCamera('cam', -Math.PI/2, Math.PI/3.2, 24,
                new BABYLON.Vector3(0, 3, 0), scene);
            camera.attachControl(document.getElementById('renderCanvas'), true);
            camera.lowerRadiusLimit = 10;
            camera.upperRadiusLimit = 50;
            camera.wheelPrecision = 30;

            // Lighting - multiple sources for better illumination
            // Main ambient light from above
            const hemi = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0, 1, 0), scene);
            hemi.intensity = 0.7;
            hemi.groundColor = new BABYLON.Color3(0.2, 0.18, 0.15);

            // Primary directional (sun) light
            const dir = new BABYLON.DirectionalLight('dir', new BABYLON.Vector3(-1, -2.5, 1), scene);
            dir.intensity = 1.0;
            dir.diffuse = new BABYLON.Color3(1, 0.95, 0.85);

            // Secondary fill light from opposite side
            const fillLight = new BABYLON.DirectionalLight('fill', new BABYLON.Vector3(1, -1, -0.5), scene);
            fillLight.intensity = 0.4;
            fillLight.diffuse = new BABYLON.Color3(0.7, 0.8, 1.0);  // Slight blue tint

            // Rim/back light for mech silhouettes
            const rimLight = new BABYLON.DirectionalLight('rim', new BABYLON.Vector3(0, -0.5, -1), scene);
            rimLight.intensity = 0.3;
            rimLight.diffuse = new BABYLON.Color3(1, 0.9, 0.7);

            // Point lights on each side of arena for extra fill
            const leftPoint = new BABYLON.PointLight('leftPoint', new BABYLON.Vector3(-12, 6, 0), scene);
            leftPoint.intensity = 0.5;
            leftPoint.diffuse = new BABYLON.Color3(0.9, 0.95, 1.0);
            leftPoint.range = 25;

            const rightPoint = new BABYLON.PointLight('rightPoint', new BABYLON.Vector3(12, 6, 0), scene);
            rightPoint.intensity = 0.5;
            rightPoint.diffuse = new BABYLON.Color3(1.0, 0.9, 0.85);
            rightPoint.range = 25;

            // Fog
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
            scene.fogDensity = 0.008;
            scene.fogColor = new BABYLON.Color3(0.08, 0.08, 0.12);

            createGround(scene);
            createWalls(scene);

            // Create teams of mechs - 3 per side at different Z positions
            // Player team (left side, x = -7 to -10)
            playerMechs = [
                createMadCatMech(scene, -7, 0, true),      // Center - heavy
                createCatapultMech(scene, -9, 3, true),    // Back left - support
                createCommandoMech(scene, -9, -3, true)   // Back right - scout
            ];

            // Enemy team (right side, x = 7 to 10)
            enemyMechs = [
                createDireWolfMech(scene, 7, 0, false),    // Center - assault
                createCatapultMech(scene, 9, 3, false),    // Back left - support
                createCommandoMech(scene, 9, -3, false)   // Back right - scout
            ];

            // Combined list for easy iteration
            allMechs = [...playerMechs, ...enemyMechs];

            // Initialize cooldowns for each mech
            allMechs.forEach(mech => {
                mechCooldowns[mech.name + '_' + (mech.isPlayer ? 'p' : 'e')] = { erlaser: 0, lrm: 0, ac: 0 };
            });

            return scene;
        }

        function createGround(scene) {
            const ground = BABYLON.MeshBuilder.CreateGround('ground', { width: 40, height: 20 }, scene);
            const mat = new BABYLON.StandardMaterial('groundMat', scene);
            // Use grass texture with tint
            mat.diffuseTexture = TEXTURES.grass;
            mat.diffuseColor = new BABYLON.Color3(0.7, 0.75, 0.6);  // Slight tint
            mat.bumpTexture = TEXTURES.grassNormal;
            mat.bumpTexture.level = 0.8;
            mat.specularColor = new BABYLON.Color3(0.08, 0.08, 0.06);
            mat.specularPower = 16;
            ground.material = mat;
            new BABYLON.PhysicsAggregate(ground, BABYLON.PhysicsShapeType.BOX,
                { mass: 0, friction: 1.0, restitution: 0.05 }, scene);

            // Rock material with texture
            const rockMat = new BABYLON.StandardMaterial('rockMat', scene);
            rockMat.diffuseTexture = TEXTURES.rock;
            rockMat.bumpTexture = TEXTURES.rockNormal;
            rockMat.bumpTexture.level = 1.0;
            rockMat.diffuseColor = new BABYLON.Color3(0.6, 0.55, 0.5);
            rockMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            // Terrain details - rocks with texture
            for (let i = 0; i < 6; i++) {
                const rock = BABYLON.MeshBuilder.CreateBox('rock' + i, {
                    width: 0.6 + Math.random() * 0.8,
                    height: 0.2 + Math.random() * 0.4,
                    depth: 0.6 + Math.random() * 0.8
                }, scene);
                rock.position = new BABYLON.Vector3((Math.random() - 0.5) * 25, 0.15, (Math.random() - 0.5) * 10);
                rock.rotation.y = Math.random() * Math.PI;
                rock.material = rockMat;
                new BABYLON.PhysicsAggregate(rock, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);
            }
        }

        function createWalls(scene) {
            // Invisible walls - physics only, no rendering
            const walls = [
                { p: [-20, 5, 0], s: [1, 10, 20] },
                { p: [20, 5, 0], s: [1, 10, 20] },
                { p: [0, 5, 10], s: [40, 10, 1] },
                { p: [0, 5, -10], s: [40, 10, 1] }
            ];
            walls.forEach((w, i) => {
                const wall = BABYLON.MeshBuilder.CreateBox('wall' + i, { width: w.s[0], height: w.s[1], depth: w.s[2] }, scene);
                wall.position = new BABYLON.Vector3(...w.p);
                wall.isVisible = false;  // Invisible but still has physics
                new BABYLON.PhysicsAggregate(wall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);
            });
        }

        // ============================================
        // MAD CAT (Timber Wolf) - Highly Detailed
        // ============================================
        function createMadCatMech(scene, xPos, zPos, isPlayer) {
            const name = isPlayer ? 'player' : 'enemy';
            const primary = isPlayer ? COLORS.playerPrimary : COLORS.enemyPrimary;
            const secondary = isPlayer ? COLORS.playerSecondary : COLORS.enemySecondary;
            const accent = isPlayer ? COLORS.playerAccent : COLORS.enemyAccent;

            // Materials with textures
            const primaryMat = new BABYLON.StandardMaterial(name + '_primary', scene);
            primaryMat.diffuseTexture = TEXTURES.rustMetal.clone();
            primaryMat.diffuseTexture.uScale = 3;
            primaryMat.diffuseTexture.vScale = 3;
            primaryMat.diffuseColor = primary.scale(1.5);  // Tint the texture
            primaryMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            primaryMat.bumpTexture.uScale = 3;
            primaryMat.bumpTexture.vScale = 3;
            primaryMat.bumpTexture.level = 0.6;
            primaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            primaryMat.specularPower = 32;

            const secondaryMat = new BABYLON.StandardMaterial(name + '_secondary', scene);
            secondaryMat.diffuseTexture = TEXTURES.metal.clone();
            secondaryMat.diffuseTexture.uScale = 2;
            secondaryMat.diffuseTexture.vScale = 2;
            secondaryMat.diffuseColor = secondary.scale(1.3);
            secondaryMat.specularColor = new BABYLON.Color3(0.15, 0.15, 0.15);

            const accentMat = new BABYLON.StandardMaterial(name + '_accent', scene);
            accentMat.diffuseColor = accent;
            accentMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.3);
            accentMat.specularPower = 48;

            const metalMat = new BABYLON.StandardMaterial(name + '_metal', scene);
            metalMat.diffuseTexture = TEXTURES.rustMetal.clone();
            metalMat.diffuseTexture.uScale = 4;
            metalMat.diffuseTexture.vScale = 4;
            metalMat.diffuseColor = COLORS.metal.scale(1.2);
            metalMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            metalMat.bumpTexture.uScale = 4;
            metalMat.bumpTexture.vScale = 4;
            metalMat.bumpTexture.level = 0.5;
            metalMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            metalMat.specularPower = 64;

            const darkMat = new BABYLON.StandardMaterial(name + '_dark', scene);
            darkMat.diffuseColor = COLORS.darkMetal;
            darkMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            const cockpitMat = new BABYLON.StandardMaterial(name + '_cockpit', scene);
            cockpitMat.diffuseColor = COLORS.cockpit;
            cockpitMat.emissiveColor = COLORS.cockpit.scale(0.6);
            cockpitMat.alpha = 0.8;

            const chromeMat = new BABYLON.StandardMaterial(name + '_chrome', scene);
            chromeMat.diffuseColor = COLORS.chrome;
            chromeMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.9);
            chromeMat.specularPower = 128;

            // === PELVIS / CENTER (Physics body) - Wide stance for stability ===
            const pelvis = BABYLON.MeshBuilder.CreateBox(name + '_pelvis', {
                width: 1.8, height: 0.5, depth: 0.9  // Wider pelvis
            }, scene);
            pelvis.position = new BABYLON.Vector3(xPos, 3.5, zPos);  // Spawn height
            pelvis.material = darkMat;

            // Create a taller collision shape to represent the full mech standing height
            // The visual legs extend ~3 units below pelvis, so we use a tall box offset downward
            const pelvisShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -1.5, 0),  // Center offset (shift down to cover legs)
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(1.8, 3.5, 0.9),  // Full standing height (wider)
                scene
            );
            const pelvisBody = new BABYLON.PhysicsBody(pelvis, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
            pelvisBody.shape = pelvisShape;
            pelvisBody.setMassProperties({ mass: 75 });
            pelvisBody.setAngularDamping(0.92);
            pelvisBody.setLinearDamping(0.25);

            // Set friction and restitution on the shape
            // Low friction (0.1) allows movement - friction 1.0 was blocking all forces
            pelvisShape.material = { friction: 0.1, restitution: 0.05 };

            const pelvisAgg = { body: pelvisBody, shape: pelvisShape };  // Compatibility wrapper

            // === TORSO - Mad Cat Style with Conical Front ===
            const torsoCore = BABYLON.MeshBuilder.CreateBox(name + '_torsoCore', {
                width: 1.6, height: 1.2, depth: 1.1
            }, scene);
            torsoCore.position.y = 0.75;
            torsoCore.parent = pelvis;
            torsoCore.material = primaryMat;

            // Torso upper section (wider for missile racks)
            const torsoUpper = BABYLON.MeshBuilder.CreateBox(name + '_torsoUpper', {
                width: 1.8, height: 0.55, depth: 0.95
            }, scene);
            torsoUpper.position.y = 0.8;
            torsoUpper.parent = torsoCore;
            torsoUpper.material = secondaryMat;

            // === DISTINCTIVE CONICAL FRONT (Mad Cat "Bird Beak") ===
            // Main nose cone pointing forward
            const noseCone = BABYLON.MeshBuilder.CreateCylinder(name + '_noseCone', {
                height: 0.9, diameterTop: 0.15, diameterBottom: 0.7, tessellation: 8
            }, scene);
            noseCone.rotation.x = Math.PI / 2;
            noseCone.position = new BABYLON.Vector3(0, 0.15, 0.75);
            noseCone.parent = torsoCore;
            noseCone.material = primaryMat;

            // Nose cone tip (darker)
            const noseTip = BABYLON.MeshBuilder.CreateCylinder(name + '_noseTip', {
                height: 0.25, diameterTop: 0.08, diameterBottom: 0.18, tessellation: 8
            }, scene);
            noseTip.rotation.x = Math.PI / 2;
            noseTip.position = new BABYLON.Vector3(0, 0.15, 1.15);
            noseTip.parent = torsoCore;
            noseTip.material = darkMat;

            // Laser ports on nose (glowing)
            for (let i = 0; i < 2; i++) {
                const laserPort = BABYLON.MeshBuilder.CreateCylinder(name + '_laserPort' + i, {
                    height: 0.15, diameter: 0.12, tessellation: 12
                }, scene);
                laserPort.rotation.x = Math.PI / 2;
                laserPort.position = new BABYLON.Vector3((i - 0.5) * 0.25, 0.15, 1.22);
                laserPort.parent = torsoCore;
                const laserMat = new BABYLON.StandardMaterial(name + '_laserMat' + i, scene);
                laserMat.emissiveColor = isPlayer ? new BABYLON.Color3(0, 0.8, 1) : new BABYLON.Color3(1, 0.3, 0.1);
                laserPort.material = laserMat;
            }

            // Side chest plates (angled to form the cone shape)
            const chestLeft = BABYLON.MeshBuilder.CreateBox(name + '_chestL', {
                width: 0.5, height: 0.85, depth: 0.55
            }, scene);
            chestLeft.position = new BABYLON.Vector3(-0.5, 0.1, 0.4);
            chestLeft.rotation.x = -0.15;
            chestLeft.rotation.y = 0.35;
            chestLeft.parent = torsoCore;
            chestLeft.material = primaryMat;

            const chestRight = chestLeft.clone(name + '_chestR');
            chestRight.position.x = 0.5;
            chestRight.rotation.y = -0.35;
            chestRight.parent = torsoCore;

            // Side intake vents (decorative)
            for (let side = -1; side <= 1; side += 2) {
                const intake = BABYLON.MeshBuilder.CreateBox(name + '_intake' + side, {
                    width: 0.08, height: 0.4, depth: 0.35
                }, scene);
                intake.position = new BABYLON.Vector3(side * 0.65, 0.2, 0.25);
                intake.parent = torsoCore;
                intake.material = darkMat;

                // Vent slats
                for (let j = 0; j < 4; j++) {
                    const slat = BABYLON.MeshBuilder.CreateBox(name + '_slat' + side + j, {
                        width: 0.1, height: 0.03, depth: 0.3
                    }, scene);
                    slat.position = new BABYLON.Vector3(side * 0.02, (j - 1.5) * 0.09, 0);
                    slat.parent = intake;
                    slat.material = metalMat;
                }
            }

            // Center chest armor ridge
            const chestRidge = BABYLON.MeshBuilder.CreateBox(name + '_chestRidge', {
                width: 0.15, height: 0.7, depth: 0.5
            }, scene);
            chestRidge.position = new BABYLON.Vector3(0, 0.15, 0.35);
            chestRidge.parent = torsoCore;
            chestRidge.material = accentMat;

            // Lower chest detail
            const chestLower = BABYLON.MeshBuilder.CreateBox(name + '_chestLower', {
                width: 0.8, height: 0.25, depth: 0.4
            }, scene);
            chestLower.position = new BABYLON.Vector3(0, -0.35, 0.45);
            chestLower.parent = torsoCore;
            chestLower.material = secondaryMat;

            // Reactor housing (back) - larger
            const reactor = BABYLON.MeshBuilder.CreateBox(name + '_reactor', {
                width: 1.1, height: 0.9, depth: 0.6
            }, scene);
            reactor.position = new BABYLON.Vector3(0, 0.25, -0.7);
            reactor.parent = torsoCore;
            reactor.material = darkMat;

            // Heat sink fins (more prominent)
            for (let i = 0; i < 5; i++) {
                const fin = BABYLON.MeshBuilder.CreateBox(name + '_fin' + i, {
                    width: 0.06, height: 0.6, depth: 0.45
                }, scene);
                fin.position = new BABYLON.Vector3((i - 2) * 0.2, 0.05, 0.15);
                fin.parent = reactor;
                fin.material = metalMat;
            }

            // Exhaust vents (glowing)
            for (let i = 0; i < 3; i++) {
                const vent = BABYLON.MeshBuilder.CreateCylinder(name + '_vent' + i, {
                    height: 0.18, diameter: 0.2, tessellation: 12
                }, scene);
                vent.position = new BABYLON.Vector3((i - 1) * 0.32, -0.32, 0.32);
                vent.rotation.x = Math.PI / 2;
                vent.parent = reactor;
                const ventMat = new BABYLON.StandardMaterial(name + '_ventMat' + i, scene);
                ventMat.emissiveColor = COLORS.thruster.scale(0.5);
                vent.material = ventMat;
            }

            // === COCKPIT / HEAD - Detailed ===
            const headBase = BABYLON.MeshBuilder.CreateBox(name + '_headBase', {
                width: 0.6, height: 0.35, depth: 0.5
            }, scene);
            headBase.position = new BABYLON.Vector3(0, 0.55, 0.25);
            headBase.parent = torsoUpper;
            headBase.material = primaryMat;

            // Cockpit canopy (angled)
            const canopy = BABYLON.MeshBuilder.CreateBox(name + '_canopy', {
                width: 0.45, height: 0.25, depth: 0.35
            }, scene);
            canopy.position = new BABYLON.Vector3(0, 0.15, 0.15);
            canopy.rotation.x = -0.4;
            canopy.parent = headBase;
            canopy.material = cockpitMat;

            // Cockpit frame
            const frame1 = BABYLON.MeshBuilder.CreateBox(name + '_frame1', {
                width: 0.5, height: 0.04, depth: 0.3
            }, scene);
            frame1.position = new BABYLON.Vector3(0, 0.28, 0.1);
            frame1.rotation.x = -0.4;
            frame1.parent = headBase;
            frame1.material = darkMat;

            // Sensor pod on top
            const sensor = BABYLON.MeshBuilder.CreateCylinder(name + '_sensor', {
                height: 0.15, diameter: 0.12
            }, scene);
            sensor.position = new BABYLON.Vector3(0, 0.3, -0.1);
            sensor.parent = headBase;
            sensor.material = chromeMat;

            // Antenna
            const antenna = BABYLON.MeshBuilder.CreateCylinder(name + '_antenna', {
                height: 0.35, diameter: 0.04
            }, scene);
            antenna.position = new BABYLON.Vector3(0.2, 0.35, -0.1);
            antenna.parent = headBase;
            antenna.material = metalMat;

            // Chin sensor
            const chin = BABYLON.MeshBuilder.CreateBox(name + '_chin', {
                width: 0.2, height: 0.12, depth: 0.15
            }, scene);
            chin.position = new BABYLON.Vector3(0, -0.15, 0.25);
            chin.parent = headBase;
            chin.material = darkMat;

            // === GIANT SHOULDER MISSILE RACKS (LRM-20 Style) ===
            function createMissilePod(side) {
                const xOff = side === 'left' ? -1 : 1;
                const pod = new BABYLON.TransformNode(name + '_' + side + 'Pod', scene);
                pod.parent = torsoUpper;
                pod.position = new BABYLON.Vector3(xOff * 1.1, 0.5, -0.15);
                // Angle pods slightly outward for intimidating look
                pod.rotation.z = xOff * -0.15;

                // Main pod housing (much larger)
                const podBase = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodBase', {
                    width: 0.75, height: 0.85, depth: 1.0
                }, scene);
                podBase.parent = pod;
                podBase.material = primaryMat;

                // Angled front face plate
                const podFront = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodFront', {
                    width: 0.7, height: 0.8, depth: 0.15
                }, scene);
                podFront.position = new BABYLON.Vector3(0, 0, 0.5);
                podFront.rotation.x = -0.1;
                podFront.parent = podBase;
                podFront.material = secondaryMat;

                // Missile tubes (5x4 grid = 20 missiles per rack)
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 5; col++) {
                        const tube = BABYLON.MeshBuilder.CreateCylinder(name + '_tube_' + side + row + col, {
                            height: 0.2, diameter: 0.11, tessellation: 8
                        }, scene);
                        tube.rotation.x = Math.PI / 2;
                        tube.position = new BABYLON.Vector3(
                            (col - 2) * 0.13,
                            (row - 1.5) * 0.16,
                            0.55
                        );
                        tube.parent = podBase;
                        tube.material = darkMat;

                        // Missile tip visible in each tube
                        const missileTip = BABYLON.MeshBuilder.CreateCylinder(name + '_missile_' + side + row + col, {
                            height: 0.08, diameterTop: 0.02, diameterBottom: 0.07, tessellation: 6
                        }, scene);
                        missileTip.rotation.x = Math.PI / 2;
                        missileTip.position = new BABYLON.Vector3(
                            (col - 2) * 0.13,
                            (row - 1.5) * 0.16,
                            0.62
                        );
                        missileTip.parent = podBase;
                        missileTip.material = metalMat;
                    }
                }

                // Armored top with angular shape
                const podTop = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodTop', {
                    width: 0.72, height: 0.15, depth: 0.95
                }, scene);
                podTop.position.y = 0.48;
                podTop.parent = podBase;
                podTop.material = secondaryMat;

                // Top ridge
                const topRidge = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'TopRidge', {
                    width: 0.2, height: 0.12, depth: 0.85
                }, scene);
                topRidge.position = new BABYLON.Vector3(0, 0.58, 0);
                topRidge.parent = podBase;
                topRidge.material = accentMat;

                // Outer side armor panel
                const podSideOuter = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodSideO', {
                    width: 0.12, height: 0.75, depth: 0.9
                }, scene);
                podSideOuter.position.x = xOff * 0.4;
                podSideOuter.parent = podBase;
                podSideOuter.material = primaryMat;

                // Inner side armor panel
                const podSideInner = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodSideI', {
                    width: 0.1, height: 0.6, depth: 0.8
                }, scene);
                podSideInner.position.x = xOff * -0.38;
                podSideInner.parent = podBase;
                podSideInner.material = secondaryMat;

                // Bottom armor
                const podBottom = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodBottom', {
                    width: 0.65, height: 0.1, depth: 0.85
                }, scene);
                podBottom.position.y = -0.45;
                podBottom.parent = podBase;
                podBottom.material = darkMat;

                // Mounting strut connecting to torso
                const strut = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Strut', {
                    width: 0.2, height: 0.35, depth: 0.3
                }, scene);
                strut.position = new BABYLON.Vector3(xOff * -0.35, -0.25, 0);
                strut.parent = podBase;
                strut.material = metalMat;

                // Hydraulic actuator
                const actuator = BABYLON.MeshBuilder.CreateCylinder(name + '_' + side + 'Actuator', {
                    height: 0.4, diameter: 0.1, tessellation: 8
                }, scene);
                actuator.position = new BABYLON.Vector3(xOff * -0.28, -0.15, -0.25);
                actuator.rotation.x = 0.3;
                actuator.parent = podBase;
                actuator.material = chromeMat;

                // Warning stripes on side
                for (let i = 0; i < 3; i++) {
                    const stripe = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Stripe' + i, {
                        width: 0.13, height: 0.08, depth: 0.25
                    }, scene);
                    stripe.position = new BABYLON.Vector3(xOff * 0.405, 0.2 - i * 0.25, 0.2);
                    stripe.parent = podBase;
                    const stripeMat = new BABYLON.StandardMaterial(name + '_stripeMat' + side + i, scene);
                    stripeMat.diffuseColor = i % 2 === 0 ?
                        new BABYLON.Color3(0.9, 0.7, 0) : new BABYLON.Color3(0.1, 0.1, 0.1);
                    stripe.material = stripeMat;
                }

                return pod;
            }

            const leftPod = createMissilePod('left');
            const rightPod = createMissilePod('right');

            // === ARMS (Large Laser Pods) ===
            function createArm(side) {
                const xOff = side === 'left' ? -1 : 1;
                const armGroup = new BABYLON.TransformNode(name + '_' + side + 'Arm', scene);
                armGroup.parent = torsoCore;
                armGroup.position = new BABYLON.Vector3(xOff * 0.95, 0.1, 0);

                // Shoulder joint
                const shoulderJoint = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'ShoulderJ', {
                    diameter: 0.32
                }, scene);
                shoulderJoint.parent = armGroup;
                shoulderJoint.material = chromeMat;

                // Upper arm
                const upperArm = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'UpperArm', {
                    width: 0.28, height: 0.55, depth: 0.28
                }, scene);
                upperArm.position = new BABYLON.Vector3(xOff * 0.15, -0.35, 0);
                upperArm.parent = armGroup;
                upperArm.material = primaryMat;

                // Upper arm detail
                const upperDetail = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'UpperDetail', {
                    width: 0.32, height: 0.2, depth: 0.15
                }, scene);
                upperDetail.position = new BABYLON.Vector3(xOff * 0.05, 0, 0.15);
                upperDetail.parent = upperArm;
                upperDetail.material = secondaryMat;

                // Elbow
                const elbow = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Elbow', {
                    diameter: 0.22
                }, scene);
                elbow.position = new BABYLON.Vector3(0, -0.35, 0);
                elbow.parent = upperArm;
                elbow.material = metalMat;

                // Lower arm / weapon pod
                const weaponPod = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'WeaponPod', {
                    width: 0.45, height: 0.75, depth: 0.4
                }, scene);
                weaponPod.position = new BABYLON.Vector3(0, -0.75, 0);
                weaponPod.parent = upperArm;
                weaponPod.material = primaryMat;

                // Weapon pod front plate
                const podFront = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodFront', {
                    width: 0.4, height: 0.5, depth: 0.1
                }, scene);
                podFront.position.z = 0.22;
                podFront.parent = weaponPod;
                podFront.material = secondaryMat;

                // ER Large Laser barrels (2 per arm)
                for (let i = 0; i < 2; i++) {
                    const laserBarrel = BABYLON.MeshBuilder.CreateCylinder(name + '_laser_' + side + i, {
                        height: 0.7, diameter: 0.12
                    }, scene);
                    laserBarrel.rotation.x = Math.PI / 2;
                    laserBarrel.position = new BABYLON.Vector3((i - 0.5) * 0.15, -0.1, 0.5);
                    laserBarrel.parent = weaponPod;
                    laserBarrel.material = chromeMat;

                    // Barrel tip
                    const tip = BABYLON.MeshBuilder.CreateCylinder(name + '_laserTip_' + side + i, {
                        height: 0.08, diameter: 0.15
                    }, scene);
                    tip.rotation.x = Math.PI / 2;
                    tip.position.z = 0.38;
                    tip.parent = laserBarrel;
                    tip.material = darkMat;
                }

                // Weapon pod side detail
                const podSideL = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodSideL', {
                    width: 0.08, height: 0.5, depth: 0.3
                }, scene);
                podSideL.position = new BABYLON.Vector3(-0.22, 0, 0);
                podSideL.parent = weaponPod;
                podSideL.material = accentMat;

                const podSideR = podSideL.clone(name + '_' + side + 'PodSideR');
                podSideR.position.x = 0.22;
                podSideR.parent = weaponPod;

                return { armGroup, upperArm, weaponPod };
            }

            const leftArm = createArm('left');
            const rightArm = createArm('right');

            // === LEGS (Chicken Walker / Mad Cat Style - More Stable) ===
            // These legs have a pronounced backward knee bend for stability
            function createLeg(side) {
                const xOff = side === 'left' ? -1 : 1;

                // Hip joint - moved slightly back for better balance
                const hip = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Hip', {
                    diameter: 0.42
                }, scene);
                hip.position = new BABYLON.Vector3(xOff * 0.8, -0.3, -0.1);  // Wider stance
                hip.parent = pelvis;
                hip.material = chromeMat;

                // Leg group for rotation (parent of all leg parts below hip)
                const legGroup = new BABYLON.TransformNode(name + '_' + side + 'LegGroup', scene);
                legGroup.position = new BABYLON.Vector3(xOff * 0.8, -0.3, -0.1);  // Match hip
                legGroup.parent = pelvis;

                // Upper leg (thigh) - angled forward significantly for chicken-walk stance
                const upperLeg = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'UpperLeg', {
                    width: 0.4, height: 1.0, depth: 0.4
                }, scene);
                upperLeg.position = new BABYLON.Vector3(0, -0.55, 0.35);
                upperLeg.rotation.x = 0.5;  // Angled forward
                upperLeg.parent = legGroup;
                upperLeg.material = primaryMat;

                // Thigh armor (front)
                const thighFront = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ThighFront', {
                    width: 0.44, height: 0.7, depth: 0.14
                }, scene);
                thighFront.position = new BABYLON.Vector3(0, 0.05, 0.24);
                thighFront.parent = upperLeg;
                thighFront.material = secondaryMat;

                // Thigh armor (side)
                const thighSide = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ThighSide', {
                    width: 0.12, height: 0.6, depth: 0.35
                }, scene);
                thighSide.position = new BABYLON.Vector3(xOff * 0.24, 0, 0);
                thighSide.parent = upperLeg;
                thighSide.material = accentMat;

                // Knee (large, detailed) - the backward-pointing joint
                const knee = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Knee', {
                    diameter: 0.4
                }, scene);
                knee.position = new BABYLON.Vector3(0, -0.55, 0);
                knee.parent = upperLeg;
                knee.material = metalMat;

                // Knee armor cap (pointing backward)
                const kneeCap = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'KneeCap', {
                    width: 0.28, height: 0.25, depth: 0.2
                }, scene);
                kneeCap.position = new BABYLON.Vector3(0, 0, -0.22);
                kneeCap.parent = knee;
                kneeCap.material = primaryMat;

                // Lower leg (shin) - angled backward for chicken-walker stance
                const lowerLeg = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'LowerLeg', {
                    width: 0.34, height: 1.1, depth: 0.34
                }, scene);
                lowerLeg.position = new BABYLON.Vector3(0, -0.75, -0.3);
                lowerLeg.rotation.x = -0.65;  // Strong backward angle
                lowerLeg.parent = knee;
                lowerLeg.material = primaryMat;

                // Shin armor (front)
                const shinFront = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ShinFront', {
                    width: 0.38, height: 0.8, depth: 0.14
                }, scene);
                shinFront.position = new BABYLON.Vector3(0, 0.05, 0.22);
                shinFront.parent = lowerLeg;
                shinFront.material = secondaryMat;

                // Shin detail lines
                for (let i = 0; i < 3; i++) {
                    const line = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ShinLine' + i, {
                        width: 0.32, height: 0.035, depth: 0.025
                    }, scene);
                    line.position = new BABYLON.Vector3(0, 0.25 - i * 0.22, 0.29);
                    line.parent = lowerLeg;
                    line.material = darkMat;
                }

                // Ankle - positioned for digitigrade stance
                const ankle = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Ankle', {
                    diameter: 0.28
                }, scene);
                ankle.position = new BABYLON.Vector3(0, -0.6, 0);
                ankle.parent = lowerLeg;
                ankle.material = metalMat;

                // Foot group for independent rotation
                const footGroup = new BABYLON.TransformNode(name + '_' + side + 'FootGroup', scene);
                footGroup.position = new BABYLON.Vector3(0, -0.12, 0);
                footGroup.parent = ankle;

                // === MAD CAT STYLE FOOT - Y-Fork Design ===
                // Main foot body (centered under ankle for balance)
                const foot = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Foot', {
                    width: 0.5, height: 0.18, depth: 0.4
                }, scene);
                foot.position = new BABYLON.Vector3(0, 0, 0);  // Centered under ankle
                foot.parent = footGroup;
                foot.material = darkMat;

                // Foot armor top
                const footTop = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'FootTop', {
                    width: 0.45, height: 0.1, depth: 0.35
                }, scene);
                footTop.position = new BABYLON.Vector3(0, 0.1, 0);
                footTop.parent = foot;
                footTop.material = primaryMat;

                // === FRONT Y-FORK ===
                // Y-fork stem (center piece going forward)
                const forkStem = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ForkStem', {
                    width: 0.18, height: 0.12, depth: 0.45
                }, scene);
                forkStem.position = new BABYLON.Vector3(0, -0.03, 0.35);
                forkStem.rotation.x = -0.08;
                forkStem.parent = foot;
                forkStem.material = primaryMat;

                // Y-fork left prong
                const forkProngL = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ForkProngL', {
                    width: 0.12, height: 0.1, depth: 0.5
                }, scene);
                forkProngL.position = new BABYLON.Vector3(-0.18, -0.02, 0.35);
                forkProngL.rotation.x = -0.1;
                forkProngL.rotation.y = 0.35;  // Angled outward for Y shape
                forkProngL.parent = forkStem;
                forkProngL.material = primaryMat;

                // Left prong tip
                const prongTipL = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ProngTipL', {
                    width: 0.08, height: 0.06, depth: 0.18
                }, scene);
                prongTipL.position = new BABYLON.Vector3(0, -0.02, 0.28);
                prongTipL.rotation.x = -0.15;
                prongTipL.parent = forkProngL;
                prongTipL.material = metalMat;

                // Y-fork right prong
                const forkProngR = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ForkProngR', {
                    width: 0.12, height: 0.1, depth: 0.5
                }, scene);
                forkProngR.position = new BABYLON.Vector3(0.18, -0.02, 0.35);
                forkProngR.rotation.x = -0.1;
                forkProngR.rotation.y = -0.35;  // Angled outward for Y shape
                forkProngR.parent = forkStem;
                forkProngR.material = primaryMat;

                // Right prong tip
                const prongTipR = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ProngTipR', {
                    width: 0.08, height: 0.06, depth: 0.18
                }, scene);
                prongTipR.position = new BABYLON.Vector3(0, -0.02, 0.28);
                prongTipR.rotation.x = -0.15;
                prongTipR.parent = forkProngR;
                prongTipR.material = metalMat;

                // === REAR Y-FORK (Mirror of front for balance) ===
                // Rear Y-fork stem
                const rearForkStem = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'RearForkStem', {
                    width: 0.16, height: 0.1, depth: 0.4
                }, scene);
                rearForkStem.position = new BABYLON.Vector3(0, -0.04, -0.35);
                rearForkStem.rotation.x = 0.1;
                rearForkStem.parent = foot;
                rearForkStem.material = primaryMat;

                // Rear left prong
                const rearProngL = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'RearProngL', {
                    width: 0.1, height: 0.08, depth: 0.4
                }, scene);
                rearProngL.position = new BABYLON.Vector3(-0.15, -0.01, -0.3);
                rearProngL.rotation.x = 0.12;
                rearProngL.rotation.y = -0.3;  // Angled outward
                rearProngL.parent = rearForkStem;
                rearProngL.material = primaryMat;

                // Rear left tip
                const rearTipL = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'RearTipL', {
                    width: 0.06, height: 0.05, depth: 0.15
                }, scene);
                rearTipL.position = new BABYLON.Vector3(0, -0.01, -0.22);
                rearTipL.rotation.x = 0.15;
                rearTipL.parent = rearProngL;
                rearTipL.material = metalMat;

                // Rear right prong
                const rearProngR = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'RearProngR', {
                    width: 0.1, height: 0.08, depth: 0.4
                }, scene);
                rearProngR.position = new BABYLON.Vector3(0.15, -0.01, -0.3);
                rearProngR.rotation.x = 0.12;
                rearProngR.rotation.y = 0.3;  // Angled outward
                rearProngR.parent = rearForkStem;
                rearProngR.material = primaryMat;

                // Rear right tip
                const rearTipR = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'RearTipR', {
                    width: 0.06, height: 0.05, depth: 0.15
                }, scene);
                rearTipR.position = new BABYLON.Vector3(0, -0.01, -0.22);
                rearTipR.rotation.x = 0.15;
                rearTipR.parent = rearProngR;
                rearTipR.material = metalMat;

                return { hip, upperLeg, knee, lowerLeg, ankle, foot, legGroup, footGroup };
            }

            const leftLeg = createLeg('left');
            const rightLeg = createLeg('right');

            // Build mech data
            return {
                name: 'TIMBER WOLF',
                pelvis, pelvisAggregate: pelvisAgg,
                torso: torsoCore, head: headBase, cockpit: canopy,
                leftArm, rightArm, leftLeg, rightLeg,
                leftPod, rightPod,
                isPlayer, scale: 1.0,
                stats: { maxHP: 150, mass: 75 },
                currentHP: 150, maxHP: 150,
                isWalking: false, walkCycle: 0, walkSpeed: 2.8,
                walkDirection: isPlayer ? 1 : -1,
                impactRecovery: 0, impactDirection: new BABYLON.Vector3(0,0,0),
                staggerTime: 0, recoilRecovery: 0, lastFiredArm: 'right',
                torsoTwist: 0, targetTorsoTwist: 0,
                // AI state
                ai: {
                    enabled: false,
                    state: 'idle',        // idle, advancing, retreating, optimal, strafing
                    target: null,         // Current target mech
                    lastDecision: 0,
                    strafeDir: 0,         // -1 left, 0 none, 1 right
                    strafeEndTime: 0
                }
            };
        }

        // ============================================
        // DIRE WOLF (Daishi) - Even More Detailed, Heavier
        // ============================================
        function createDireWolfMech(scene, xPos, zPos, isPlayer) {
            const name = isPlayer ? 'player' : 'enemy';
            const primary = isPlayer ? COLORS.playerPrimary : COLORS.enemyPrimary;
            const secondary = isPlayer ? COLORS.playerSecondary : COLORS.enemySecondary;
            const accent = isPlayer ? COLORS.playerAccent : COLORS.enemyAccent;

            // Materials with textures
            const primaryMat = new BABYLON.StandardMaterial(name + '_primary', scene);
            primaryMat.diffuseTexture = TEXTURES.rustMetal.clone();
            primaryMat.diffuseTexture.uScale = 3;
            primaryMat.diffuseTexture.vScale = 3;
            primaryMat.diffuseColor = primary.scale(1.5);
            primaryMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            primaryMat.bumpTexture.uScale = 3;
            primaryMat.bumpTexture.vScale = 3;
            primaryMat.bumpTexture.level = 0.6;
            primaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            primaryMat.specularPower = 32;

            const secondaryMat = new BABYLON.StandardMaterial(name + '_secondary', scene);
            secondaryMat.diffuseTexture = TEXTURES.metal.clone();
            secondaryMat.diffuseTexture.uScale = 2;
            secondaryMat.diffuseTexture.vScale = 2;
            secondaryMat.diffuseColor = secondary.scale(1.3);
            secondaryMat.specularColor = new BABYLON.Color3(0.15, 0.15, 0.15);

            const accentMat = new BABYLON.StandardMaterial(name + '_accent', scene);
            accentMat.diffuseColor = accent;
            accentMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.3);
            accentMat.specularPower = 48;

            const metalMat = new BABYLON.StandardMaterial(name + '_metal', scene);
            metalMat.diffuseTexture = TEXTURES.rustMetal.clone();
            metalMat.diffuseTexture.uScale = 4;
            metalMat.diffuseTexture.vScale = 4;
            metalMat.diffuseColor = COLORS.metal.scale(1.2);
            metalMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            metalMat.bumpTexture.uScale = 4;
            metalMat.bumpTexture.vScale = 4;
            metalMat.bumpTexture.level = 0.5;
            metalMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            metalMat.specularPower = 64;

            const darkMat = new BABYLON.StandardMaterial(name + '_dark', scene);
            darkMat.diffuseColor = COLORS.darkMetal;
            darkMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            const cockpitMat = new BABYLON.StandardMaterial(name + '_cockpit', scene);
            cockpitMat.diffuseColor = COLORS.cockpit;
            cockpitMat.emissiveColor = COLORS.cockpit.scale(0.5);
            cockpitMat.alpha = 0.8;

            const chromeMat = new BABYLON.StandardMaterial(name + '_chrome', scene);
            chromeMat.diffuseColor = COLORS.chrome;
            chromeMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.9);
            chromeMat.specularPower = 128;

            const scale = 1.15; // Bigger mech

            // === PELVIS - Wide stance for stability ===
            const pelvis = BABYLON.MeshBuilder.CreateBox(name + '_pelvis', {
                width: 2.0 * scale, height: 0.55 * scale, depth: 1.0 * scale  // Wider pelvis
            }, scene);
            pelvis.position = new BABYLON.Vector3(xPos, 3.8, zPos);  // Spawn height
            pelvis.material = darkMat;

            // Create a taller collision shape to represent the full mech standing height
            // Dire Wolf is bigger (scale 1.15), legs extend ~3.5 units below pelvis
            const pelvisShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -1.7 * scale, 0),  // Center offset (shift down to cover legs)
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(2.0 * scale, 4.0 * scale, 1.0 * scale),  // Full standing height (wider)
                scene
            );
            const pelvisBody = new BABYLON.PhysicsBody(pelvis, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
            pelvisBody.shape = pelvisShape;
            pelvisBody.setMassProperties({ mass: 100 });
            pelvisBody.setAngularDamping(0.93);
            pelvisBody.setLinearDamping(0.3);

            // Set friction and restitution on the shape
            // Low friction (0.1) allows movement - friction 1.0 was blocking all forces
            pelvisShape.material = { friction: 0.1, restitution: 0.05 };

            const pelvisAgg = { body: pelvisBody, shape: pelvisShape };  // Compatibility wrapper

            // === MASSIVE TORSO - Dire Wolf Style with Angular Front ===
            const torsoCore = BABYLON.MeshBuilder.CreateBox(name + '_torsoCore', {
                width: 1.9 * scale, height: 1.4 * scale, depth: 1.3 * scale
            }, scene);
            torsoCore.position.y = 0.85 * scale;
            torsoCore.parent = pelvis;
            torsoCore.material = primaryMat;

            // Upper torso (wider for weapon pods)
            const torsoUpper = BABYLON.MeshBuilder.CreateBox(name + '_torsoUpper', {
                width: 2.0 * scale, height: 0.65 * scale, depth: 1.1 * scale
            }, scene);
            torsoUpper.position.y = 0.9 * scale;
            torsoUpper.parent = torsoCore;
            torsoUpper.material = secondaryMat;

            // === DISTINCTIVE ANGULAR FRONT (Dire Wolf "Fortress" style) ===
            // Main angular nose section
            const noseCone = BABYLON.MeshBuilder.CreateCylinder(name + '_noseCone', {
                height: 1.1 * scale, diameterTop: 0.2 * scale, diameterBottom: 0.85 * scale, tessellation: 6
            }, scene);
            noseCone.rotation.x = Math.PI / 2;
            noseCone.position = new BABYLON.Vector3(0, 0.1 * scale, 0.85 * scale);
            noseCone.parent = torsoCore;
            noseCone.material = primaryMat;

            // Nose armor tip
            const noseTip = BABYLON.MeshBuilder.CreateCylinder(name + '_noseTip', {
                height: 0.3 * scale, diameterTop: 0.1 * scale, diameterBottom: 0.25 * scale, tessellation: 6
            }, scene);
            noseTip.rotation.x = Math.PI / 2;
            noseTip.position = new BABYLON.Vector3(0, 0.1 * scale, 1.35 * scale);
            noseTip.parent = torsoCore;
            noseTip.material = darkMat;

            // Heavy laser array on nose (4 barrels)
            for (let i = 0; i < 4; i++) {
                const laserBarrel = BABYLON.MeshBuilder.CreateCylinder(name + '_laserBarrel' + i, {
                    height: 0.25 * scale, diameter: 0.1 * scale, tessellation: 12
                }, scene);
                laserBarrel.rotation.x = Math.PI / 2;
                const angle = (i / 4) * Math.PI * 2;
                laserBarrel.position = new BABYLON.Vector3(
                    Math.cos(angle) * 0.18 * scale,
                    0.1 * scale + Math.sin(angle) * 0.18 * scale,
                    1.45 * scale
                );
                laserBarrel.parent = torsoCore;
                const barrelMat = new BABYLON.StandardMaterial(name + '_barrelMat' + i, scene);
                barrelMat.emissiveColor = isPlayer ? new BABYLON.Color3(0, 0.8, 1) : new BABYLON.Color3(1, 0.2, 0.1);
                laserBarrel.material = barrelMat;
            }

            // Side chest plates (angled for angular look)
            for (let side = -1; side <= 1; side += 2) {
                const chestPlate = BABYLON.MeshBuilder.CreateBox(name + '_chestPlate' + side, {
                    width: 0.6 * scale, height: 0.95 * scale, depth: 0.6 * scale
                }, scene);
                chestPlate.position = new BABYLON.Vector3(side * 0.6 * scale, 0.05 * scale, 0.45 * scale);
                chestPlate.rotation.y = side * 0.4;
                chestPlate.parent = torsoCore;
                chestPlate.material = primaryMat;

                // Armor detail on chest plates
                const plateDetail = BABYLON.MeshBuilder.CreateBox(name + '_plateDetail' + side, {
                    width: 0.5 * scale, height: 0.6 * scale, depth: 0.12 * scale
                }, scene);
                plateDetail.position = new BABYLON.Vector3(0, 0, 0.32 * scale);
                plateDetail.parent = chestPlate;
                plateDetail.material = secondaryMat;
            }

            // Side torso panels (larger)
            for (let side = -1; side <= 1; side += 2) {
                const sidePanel = BABYLON.MeshBuilder.CreateBox(name + '_sidePanel' + side, {
                    width: 0.18 * scale, height: 1.0 * scale, depth: 0.9 * scale
                }, scene);
                sidePanel.position = new BABYLON.Vector3(side * 0.95 * scale, 0.15 * scale, 0);
                sidePanel.parent = torsoCore;
                sidePanel.material = secondaryMat;

                // Vent grilles
                for (let j = 0; j < 3; j++) {
                    const grille = BABYLON.MeshBuilder.CreateBox(name + '_grille' + side + j, {
                        width: 0.2 * scale, height: 0.05 * scale, depth: 0.4 * scale
                    }, scene);
                    grille.position = new BABYLON.Vector3(side * 0.02, (j - 1) * 0.2 * scale, 0.1 * scale);
                    grille.parent = sidePanel;
                    grille.material = darkMat;
                }
            }

            // Center chest ridge
            const chestRidge = BABYLON.MeshBuilder.CreateBox(name + '_chestRidge', {
                width: 0.2 * scale, height: 0.8 * scale, depth: 0.55 * scale
            }, scene);
            chestRidge.position = new BABYLON.Vector3(0, 0.1 * scale, 0.4 * scale);
            chestRidge.parent = torsoCore;
            chestRidge.material = accentMat;

            // Large reactor (back)
            const reactor = BABYLON.MeshBuilder.CreateBox(name + '_reactor', {
                width: 1.3 * scale, height: 1.1 * scale, depth: 0.7 * scale
            }, scene);
            reactor.position = new BABYLON.Vector3(0, 0.3 * scale, -0.85 * scale);
            reactor.parent = torsoCore;
            reactor.material = darkMat;

            // Reactor pipes
            for (let i = 0; i < 4; i++) {
                const pipe = BABYLON.MeshBuilder.CreateCylinder(name + '_pipe' + i, {
                    height: 0.9 * scale, diameter: 0.14 * scale
                }, scene);
                pipe.position = new BABYLON.Vector3((i - 1.5) * 0.28 * scale, 0.15 * scale, 0);
                pipe.rotation.x = 0.15;
                pipe.parent = reactor;
                pipe.material = chromeMat;
            }

            // Exhaust array (larger)
            for (let i = 0; i < 4; i++) {
                const exhaust = BABYLON.MeshBuilder.CreateCylinder(name + '_exhaust' + i, {
                    height: 0.22 * scale, diameter: 0.18 * scale, tessellation: 12
                }, scene);
                exhaust.rotation.x = Math.PI / 2;
                exhaust.position = new BABYLON.Vector3((i - 1.5) * 0.28 * scale, -0.4 * scale, 0.38 * scale);
                exhaust.parent = reactor;
                const exMat = new BABYLON.StandardMaterial(name + '_exMat' + i, scene);
                exMat.emissiveColor = COLORS.thruster.scale(0.4);
                exhaust.material = exMat;
            }

            // === HEAD (Smaller, bunker-style) ===
            const headBase = BABYLON.MeshBuilder.CreateBox(name + '_headBase', {
                width: 0.55 * scale, height: 0.35 * scale, depth: 0.45 * scale
            }, scene);
            headBase.position = new BABYLON.Vector3(0, 0.55 * scale, 0.2 * scale);
            headBase.parent = torsoUpper;
            headBase.material = primaryMat;

            const canopy = BABYLON.MeshBuilder.CreateBox(name + '_canopy', {
                width: 0.4 * scale, height: 0.18 * scale, depth: 0.25 * scale
            }, scene);
            canopy.position = new BABYLON.Vector3(0, 0.1 * scale, 0.15 * scale);
            canopy.rotation.x = -0.35;
            canopy.parent = headBase;
            canopy.material = cockpitMat;

            // Sensor array
            for (let i = 0; i < 2; i++) {
                const sens = BABYLON.MeshBuilder.CreateCylinder(name + '_sens' + i, {
                    height: 0.12 * scale, diameter: 0.08 * scale
                }, scene);
                sens.position = new BABYLON.Vector3((i - 0.5) * 0.2 * scale, 0.22 * scale, 0);
                sens.parent = headBase;
                sens.material = chromeMat;
            }

            // === MASSIVE SHOULDER WEAPON PODS ===
            function createWeaponPod(side) {
                const xOff = side === 'left' ? -1 : 1;
                const pod = new BABYLON.TransformNode(name + '_' + side + 'WeaponPod', scene);
                pod.parent = torsoUpper;
                pod.position = new BABYLON.Vector3(xOff * 1.1 * scale, 0.2 * scale, 0);

                // Main pod body
                const podBody = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodBody', {
                    width: 0.7 * scale, height: 0.65 * scale, depth: 0.9 * scale
                }, scene);
                podBody.parent = pod;
                podBody.material = primaryMat;

                // Pod top armor
                const podTop = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodTop', {
                    width: 0.65 * scale, height: 0.15 * scale, depth: 0.85 * scale
                }, scene);
                podTop.position.y = 0.38 * scale;
                podTop.parent = podBody;
                podTop.material = secondaryMat;

                // Missile tubes (5x4)
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 5; c++) {
                        const tube = BABYLON.MeshBuilder.CreateCylinder(name + '_mtube' + side + r + c, {
                            height: 0.1 * scale, diameter: 0.07 * scale
                        }, scene);
                        tube.rotation.x = Math.PI / 2;
                        tube.position = new BABYLON.Vector3(
                            (c - 2) * 0.11 * scale,
                            (r - 1.5) * 0.11 * scale,
                            0.48 * scale
                        );
                        tube.parent = podBody;
                        tube.material = darkMat;
                    }
                }

                // Side weapon (autocannon or laser)
                const sideGun = BABYLON.MeshBuilder.CreateCylinder(name + '_' + side + 'SideGun', {
                    height: 0.8 * scale, diameter: 0.15 * scale
                }, scene);
                sideGun.rotation.x = Math.PI / 2;
                sideGun.position = new BABYLON.Vector3(xOff * 0.32 * scale, -0.15 * scale, 0.55 * scale);
                sideGun.parent = podBody;
                sideGun.material = chromeMat;

                return pod;
            }

            const leftPod = createWeaponPod('left');
            const rightPod = createWeaponPod('right');

            // === ARMS (Heavy weapon mounts) ===
            function createArm(side) {
                const xOff = side === 'left' ? -1 : 1;
                const armGroup = new BABYLON.TransformNode(name + '_' + side + 'Arm', scene);
                armGroup.parent = torsoCore;
                armGroup.position = new BABYLON.Vector3(xOff * 1.1 * scale, 0, 0);

                const shoulder = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Shoulder', {
                    diameter: 0.35 * scale
                }, scene);
                shoulder.parent = armGroup;
                shoulder.material = chromeMat;

                const upperArm = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'UpperArm', {
                    width: 0.32 * scale, height: 0.6 * scale, depth: 0.32 * scale
                }, scene);
                upperArm.position = new BABYLON.Vector3(xOff * 0.12 * scale, -0.38 * scale, 0);
                upperArm.parent = armGroup;
                upperArm.material = primaryMat;

                const elbow = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Elbow', {
                    diameter: 0.25 * scale
                }, scene);
                elbow.position.y = -0.38 * scale;
                elbow.parent = upperArm;
                elbow.material = metalMat;

                // Massive weapon pod
                const weaponPod = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ArmWeapon', {
                    width: 0.5 * scale, height: 0.85 * scale, depth: 0.45 * scale
                }, scene);
                weaponPod.position = new BABYLON.Vector3(0, -0.8 * scale, 0);
                weaponPod.parent = upperArm;
                weaponPod.material = primaryMat;

                // Quad laser barrels
                for (let r = 0; r < 2; r++) {
                    for (let c = 0; c < 2; c++) {
                        const barrel = BABYLON.MeshBuilder.CreateCylinder(name + '_barrel' + side + r + c, {
                            height: 0.75 * scale, diameter: 0.1 * scale
                        }, scene);
                        barrel.rotation.x = Math.PI / 2;
                        barrel.position = new BABYLON.Vector3(
                            (c - 0.5) * 0.15 * scale,
                            -0.15 * scale + r * 0.2 * scale,
                            0.55 * scale
                        );
                        barrel.parent = weaponPod;
                        barrel.material = chromeMat;
                    }
                }

                return { armGroup, upperArm, weaponPod };
            }

            const leftArm = createArm('left');
            const rightArm = createArm('right');

            // === LEGS (Heavy Chicken Walker / Mad Cat Style - More Stable) ===
            function createLeg(side) {
                const xOff = side === 'left' ? -1 : 1;

                // Hip joint - wider stance for stability
                const hip = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Hip', {
                    diameter: 0.46 * scale
                }, scene);
                hip.position = new BABYLON.Vector3(xOff * 0.9 * scale, -0.32 * scale, -0.1 * scale);  // Wider stance
                hip.parent = pelvis;
                hip.material = chromeMat;

                // Leg group for rotation (parent of all leg parts below hip)
                const legGroup = new BABYLON.TransformNode(name + '_' + side + 'LegGroup', scene);
                legGroup.position = new BABYLON.Vector3(xOff * 0.9 * scale, -0.32 * scale, -0.1 * scale);  // Match hip
                legGroup.parent = pelvis;

                // Upper leg (thigh) - angled forward for chicken-walk stance
                const upperLeg = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'UpperLeg', {
                    width: 0.44 * scale, height: 1.1 * scale, depth: 0.44 * scale
                }, scene);
                upperLeg.position = new BABYLON.Vector3(0, -0.6 * scale, 0.4 * scale);
                upperLeg.rotation.x = 0.5;  // Angled forward
                upperLeg.parent = legGroup;
                upperLeg.material = primaryMat;

                // Thigh armor layers
                const thighArmor = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ThighArmor', {
                    width: 0.5 * scale, height: 0.8 * scale, depth: 0.16 * scale
                }, scene);
                thighArmor.position = new BABYLON.Vector3(0, 0.05 * scale, 0.28 * scale);
                thighArmor.parent = upperLeg;
                thighArmor.material = secondaryMat;

                // Knee (backward-pointing joint)
                const knee = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Knee', {
                    diameter: 0.44 * scale
                }, scene);
                knee.position = new BABYLON.Vector3(0, -0.6 * scale, 0);
                knee.parent = upperLeg;
                knee.material = metalMat;

                // Knee armor cap (pointing backward)
                const kneeCap = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'KneeCap', {
                    width: 0.32 * scale, height: 0.28 * scale, depth: 0.22 * scale
                }, scene);
                kneeCap.position = new BABYLON.Vector3(0, 0, -0.25 * scale);
                kneeCap.parent = knee;
                kneeCap.material = accentMat;

                // Lower leg (shin) - angled backward for chicken-walker stance
                const lowerLeg = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'LowerLeg', {
                    width: 0.4 * scale, height: 1.2 * scale, depth: 0.4 * scale
                }, scene);
                lowerLeg.position = new BABYLON.Vector3(0, -0.8 * scale, -0.35 * scale);
                lowerLeg.rotation.x = -0.65;  // Strong backward angle
                lowerLeg.parent = knee;
                lowerLeg.material = primaryMat;

                // Shin armor
                const shinArmor = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ShinArmor', {
                    width: 0.44 * scale, height: 0.9 * scale, depth: 0.14 * scale
                }, scene);
                shinArmor.position = new BABYLON.Vector3(0, 0, 0.24 * scale);
                shinArmor.parent = lowerLeg;
                shinArmor.material = secondaryMat;

                // Ankle
                const ankle = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Ankle', {
                    diameter: 0.32 * scale
                }, scene);
                ankle.position = new BABYLON.Vector3(0, -0.65 * scale, 0);
                ankle.parent = lowerLeg;
                ankle.material = metalMat;

                // Foot group for independent rotation
                const footGroup = new BABYLON.TransformNode(name + '_' + side + 'FootGroup', scene);
                footGroup.position = new BABYLON.Vector3(0, -0.14 * scale, 0);
                footGroup.parent = ankle;

                // === DIRE WOLF STYLE FOOT - Y-Fork Design (heavier than Mad Cat) ===
                // Main foot body (centered under ankle for balance)
                const foot = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Foot', {
                    width: 0.6 * scale, height: 0.2 * scale, depth: 0.5 * scale
                }, scene);
                foot.position = new BABYLON.Vector3(0, 0, 0);  // Centered under ankle
                foot.parent = footGroup;
                foot.material = darkMat;

                // Foot armor top
                const footArmor = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'FootArmor', {
                    width: 0.55 * scale, height: 0.12 * scale, depth: 0.45 * scale
                }, scene);
                footArmor.position = new BABYLON.Vector3(0, 0.12 * scale, 0);
                footArmor.parent = foot;
                footArmor.material = primaryMat;

                // === FRONT Y-FORK (Heavy) ===
                // Y-fork stem (center piece going forward)
                const forkStem = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ForkStem', {
                    width: 0.2 * scale, height: 0.14 * scale, depth: 0.5 * scale
                }, scene);
                forkStem.position = new BABYLON.Vector3(0, -0.03 * scale, 0.4 * scale);
                forkStem.rotation.x = -0.08;
                forkStem.parent = foot;
                forkStem.material = primaryMat;

                // Y-fork left prong
                const forkProngL = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ForkProngL', {
                    width: 0.14 * scale, height: 0.12 * scale, depth: 0.55 * scale
                }, scene);
                forkProngL.position = new BABYLON.Vector3(-0.2 * scale, -0.02 * scale, 0.38 * scale);
                forkProngL.rotation.x = -0.1;
                forkProngL.rotation.y = 0.35;  // Angled outward for Y shape
                forkProngL.parent = forkStem;
                forkProngL.material = primaryMat;

                // Left prong tip
                const prongTipL = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ProngTipL', {
                    width: 0.1 * scale, height: 0.08 * scale, depth: 0.2 * scale
                }, scene);
                prongTipL.position = new BABYLON.Vector3(0, -0.02 * scale, 0.32 * scale);
                prongTipL.rotation.x = -0.15;
                prongTipL.parent = forkProngL;
                prongTipL.material = metalMat;

                // Y-fork right prong
                const forkProngR = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ForkProngR', {
                    width: 0.14 * scale, height: 0.12 * scale, depth: 0.55 * scale
                }, scene);
                forkProngR.position = new BABYLON.Vector3(0.2 * scale, -0.02 * scale, 0.38 * scale);
                forkProngR.rotation.x = -0.1;
                forkProngR.rotation.y = -0.35;  // Angled outward for Y shape
                forkProngR.parent = forkStem;
                forkProngR.material = primaryMat;

                // Right prong tip
                const prongTipR = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ProngTipR', {
                    width: 0.1 * scale, height: 0.08 * scale, depth: 0.2 * scale
                }, scene);
                prongTipR.position = new BABYLON.Vector3(0, -0.02 * scale, 0.32 * scale);
                prongTipR.rotation.x = -0.15;
                prongTipR.parent = forkProngR;
                prongTipR.material = metalMat;

                // === REAR Y-FORK (Mirror of front for balance) ===
                // Rear Y-fork stem
                const rearForkStem = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'RearForkStem', {
                    width: 0.18 * scale, height: 0.12 * scale, depth: 0.45 * scale
                }, scene);
                rearForkStem.position = new BABYLON.Vector3(0, -0.04 * scale, -0.4 * scale);
                rearForkStem.rotation.x = 0.1;
                rearForkStem.parent = foot;
                rearForkStem.material = primaryMat;

                // Rear left prong
                const rearProngL = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'RearProngL', {
                    width: 0.12 * scale, height: 0.1 * scale, depth: 0.45 * scale
                }, scene);
                rearProngL.position = new BABYLON.Vector3(-0.17 * scale, -0.01 * scale, -0.32 * scale);
                rearProngL.rotation.x = 0.12;
                rearProngL.rotation.y = -0.3;  // Angled outward
                rearProngL.parent = rearForkStem;
                rearProngL.material = primaryMat;

                // Rear left tip
                const rearTipL = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'RearTipL', {
                    width: 0.08 * scale, height: 0.06 * scale, depth: 0.18 * scale
                }, scene);
                rearTipL.position = new BABYLON.Vector3(0, -0.01 * scale, -0.25 * scale);
                rearTipL.rotation.x = 0.15;
                rearTipL.parent = rearProngL;
                rearTipL.material = metalMat;

                // Rear right prong
                const rearProngR = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'RearProngR', {
                    width: 0.12 * scale, height: 0.1 * scale, depth: 0.45 * scale
                }, scene);
                rearProngR.position = new BABYLON.Vector3(0.17 * scale, -0.01 * scale, -0.32 * scale);
                rearProngR.rotation.x = 0.12;
                rearProngR.rotation.y = 0.3;  // Angled outward
                rearProngR.parent = rearForkStem;
                rearProngR.material = primaryMat;

                // Rear right tip
                const rearTipR = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'RearTipR', {
                    width: 0.08 * scale, height: 0.06 * scale, depth: 0.18 * scale
                }, scene);
                rearTipR.position = new BABYLON.Vector3(0, -0.01 * scale, -0.25 * scale);
                rearTipR.rotation.x = 0.15;
                rearTipR.parent = rearProngR;
                rearTipR.material = metalMat;

                return { hip, upperLeg, knee, lowerLeg, ankle, foot, legGroup, footGroup };
            }

            const leftLeg = createLeg('left');
            const rightLeg = createLeg('right');

            return {
                name: 'DIRE WOLF',
                pelvis, pelvisAggregate: pelvisAgg,
                torso: torsoCore, head: headBase, cockpit: canopy,
                leftArm, rightArm, leftLeg, rightLeg,
                leftPod, rightPod,
                isPlayer, scale,
                stats: { maxHP: 200, mass: 100 },
                currentHP: 200, maxHP: 200,
                isWalking: false, walkCycle: 0, walkSpeed: 2.2,
                walkDirection: isPlayer ? 1 : -1,
                impactRecovery: 0, impactDirection: new BABYLON.Vector3(0,0,0),
                staggerTime: 0, recoilRecovery: 0, lastFiredArm: 'right',
                torsoTwist: 0, targetTorsoTwist: 0,
                // AI state
                ai: {
                    enabled: false,
                    state: 'idle',        // idle, advancing, retreating, optimal, strafing
                    target: null,         // Current target mech
                    lastDecision: 0,
                    strafeDir: 0,         // -1 left, 0 none, 1 right
                    strafeEndTime: 0
                }
            };
        }

        // ============================================
        // COMMANDO - Light Scout Mech
        // ============================================
        function createCommandoMech(scene, xPos, zPos, isPlayer) {
            const name = (isPlayer ? 'player' : 'enemy') + '_commando_' + Math.random().toString(36).substr(2, 4);
            const primary = isPlayer ? COLORS.playerPrimary : COLORS.enemyPrimary;
            const secondary = isPlayer ? COLORS.playerSecondary : COLORS.enemySecondary;
            const scale = 0.7;  // Smaller mech

            // Materials with textures
            const primaryMat = new BABYLON.StandardMaterial(name + '_primary', scene);
            primaryMat.diffuseTexture = TEXTURES.rustMetal.clone();
            primaryMat.diffuseTexture.uScale = 2;
            primaryMat.diffuseTexture.vScale = 2;
            primaryMat.diffuseColor = primary.scale(1.4);
            primaryMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            primaryMat.bumpTexture.uScale = 2;
            primaryMat.bumpTexture.vScale = 2;
            primaryMat.bumpTexture.level = 0.5;
            primaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            primaryMat.specularPower = 32;

            const secondaryMat = new BABYLON.StandardMaterial(name + '_secondary', scene);
            secondaryMat.diffuseTexture = TEXTURES.metal.clone();
            secondaryMat.diffuseTexture.uScale = 2;
            secondaryMat.diffuseTexture.vScale = 2;
            secondaryMat.diffuseColor = secondary.scale(1.2);
            secondaryMat.specularColor = new BABYLON.Color3(0.15, 0.15, 0.15);

            const darkMat = new BABYLON.StandardMaterial(name + '_dark', scene);
            darkMat.diffuseColor = COLORS.darkMetal;
            darkMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            const metalMat = new BABYLON.StandardMaterial(name + '_metal', scene);
            metalMat.diffuseTexture = TEXTURES.rustMetal.clone();
            metalMat.diffuseTexture.uScale = 3;
            metalMat.diffuseTexture.vScale = 3;
            metalMat.diffuseColor = COLORS.metal.scale(1.2);
            metalMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            metalMat.bumpTexture.uScale = 3;
            metalMat.bumpTexture.vScale = 3;
            metalMat.bumpTexture.level = 0.4;
            metalMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
            metalMat.specularPower = 48;

            // Pelvis - smaller
            const pelvis = BABYLON.MeshBuilder.CreateBox(name + '_pelvis', {
                width: 1.2 * scale, height: 0.4 * scale, depth: 0.7 * scale
            }, scene);
            pelvis.position = new BABYLON.Vector3(xPos, 3.0, zPos);
            pelvis.material = darkMat;

            const pelvisShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -1.2, 0),
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(1.2 * scale, 2.8, 0.7 * scale),
                scene
            );
            const pelvisBody = new BABYLON.PhysicsBody(pelvis, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
            pelvisBody.shape = pelvisShape;
            pelvisBody.setMassProperties({ mass: 40 });
            pelvisBody.setAngularDamping(0.90);
            pelvisBody.setLinearDamping(0.20);
            pelvisShape.material = { friction: 0.1, restitution: 0.05 };
            const pelvisAgg = { body: pelvisBody, shape: pelvisShape };

            // Torso - compact, angular
            const torsoCore = BABYLON.MeshBuilder.CreateBox(name + '_torso', {
                width: 1.0 * scale, height: 1.2 * scale, depth: 0.8 * scale
            }, scene);
            torsoCore.position.y = 0.8 * scale;
            torsoCore.parent = pelvis;
            torsoCore.material = primaryMat;

            // Head - small sensor dome
            const headBase = BABYLON.MeshBuilder.CreateCylinder(name + '_head', {
                diameter: 0.5 * scale, height: 0.4 * scale
            }, scene);
            headBase.position.y = 0.9 * scale;
            headBase.parent = torsoCore;
            headBase.material = secondaryMat;

            const canopy = BABYLON.MeshBuilder.CreateSphere(name + '_canopy', {
                diameter: 0.35 * scale
            }, scene);
            canopy.position.y = 0.15 * scale;
            canopy.parent = headBase;
            canopy.material = new BABYLON.StandardMaterial(name + '_cockpit', scene);
            canopy.material.diffuseColor = COLORS.cockpit;
            canopy.material.emissiveColor = COLORS.cockpit.scale(0.5);
            canopy.material.alpha = 0.8;

            // Arms - simple laser mounts
            function createArm(side) {
                const sign = side === 'left' ? -1 : 1;
                const shoulder = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Shoulder', {
                    width: 0.25 * scale, height: 0.3 * scale, depth: 0.25 * scale
                }, scene);
                shoulder.position = new BABYLON.Vector3(sign * 0.55 * scale, 0.5 * scale, 0);
                shoulder.parent = torsoCore;
                shoulder.material = secondaryMat;

                const arm = BABYLON.MeshBuilder.CreateCylinder(name + '_' + side + 'Arm', {
                    diameter: 0.18 * scale, height: 0.8 * scale
                }, scene);
                arm.rotation.z = sign * 0.2;
                arm.position = new BABYLON.Vector3(sign * 0.15 * scale, -0.4 * scale, 0);
                arm.parent = shoulder;
                arm.material = metalMat;

                // Weapon pod at end of arm (required for firing)
                const weaponPod = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'WeaponPod', {
                    width: 0.12 * scale, height: 0.2 * scale, depth: 0.15 * scale
                }, scene);
                weaponPod.position = new BABYLON.Vector3(0, -0.45 * scale, 0);
                weaponPod.parent = arm;
                weaponPod.material = darkMat;

                return { shoulder, arm, weaponPod };
            }

            const leftArm = createArm('left');
            const rightArm = createArm('right');

            // Simple missile pod on shoulder
            const leftPod = BABYLON.MeshBuilder.CreateBox(name + '_leftPod', {
                width: 0.2 * scale, height: 0.15 * scale, depth: 0.3 * scale
            }, scene);
            leftPod.position = new BABYLON.Vector3(-0.5 * scale, 0.85 * scale, 0.1 * scale);
            leftPod.parent = torsoCore;
            leftPod.material = darkMat;

            const rightPod = BABYLON.MeshBuilder.CreateBox(name + '_rightPod', {
                width: 0.2 * scale, height: 0.15 * scale, depth: 0.3 * scale
            }, scene);
            rightPod.position = new BABYLON.Vector3(0.5 * scale, 0.85 * scale, 0.1 * scale);
            rightPod.parent = torsoCore;
            rightPod.material = darkMat;

            // Legs - chicken walker style
            function createLeg(side) {
                const sign = side === 'left' ? -1 : 1;
                const legGroup = new BABYLON.TransformNode(name + '_' + side + 'LegGroup', scene);
                legGroup.parent = pelvis;

                const hip = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Hip', { diameter: 0.25 * scale }, scene);
                hip.position = new BABYLON.Vector3(sign * 0.5 * scale, -0.15 * scale, 0);
                hip.parent = legGroup;
                hip.material = darkMat;

                const upperLeg = BABYLON.MeshBuilder.CreateCylinder(name + '_' + side + 'Upper', {
                    diameterTop: 0.18 * scale, diameterBottom: 0.14 * scale, height: 0.9 * scale
                }, scene);
                upperLeg.rotation.x = 0.5;
                upperLeg.position = new BABYLON.Vector3(0, -0.45 * scale, 0.2 * scale);
                upperLeg.parent = hip;
                upperLeg.material = primaryMat;

                const knee = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Knee', { diameter: 0.16 * scale }, scene);
                knee.position.y = -0.5 * scale;
                knee.parent = upperLeg;
                knee.material = metalMat;

                const lowerLeg = BABYLON.MeshBuilder.CreateCylinder(name + '_' + side + 'Lower', {
                    diameterTop: 0.14 * scale, diameterBottom: 0.1 * scale, height: 1.0 * scale
                }, scene);
                lowerLeg.rotation.x = -0.7;
                lowerLeg.position = new BABYLON.Vector3(0, -0.5 * scale, 0);
                lowerLeg.parent = knee;
                lowerLeg.material = primaryMat;

                const footGroup = new BABYLON.TransformNode(name + '_' + side + 'FootGroup', scene);
                footGroup.position.y = -0.55 * scale;
                footGroup.parent = lowerLeg;

                const ankle = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Ankle', {
                    width: 0.12 * scale, height: 0.1 * scale, depth: 0.15 * scale
                }, scene);
                ankle.parent = footGroup;
                ankle.material = metalMat;

                const foot = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Foot', {
                    width: 0.2 * scale, height: 0.06 * scale, depth: 0.35 * scale
                }, scene);
                foot.position = new BABYLON.Vector3(0, -0.05 * scale, 0.08 * scale);
                foot.parent = footGroup;
                foot.material = darkMat;

                return { hip, upperLeg, knee, lowerLeg, ankle, foot, legGroup, footGroup };
            }

            const leftLeg = createLeg('left');
            const rightLeg = createLeg('right');

            return {
                name: 'COMMANDO',
                pelvis, pelvisAggregate: pelvisAgg,
                torso: torsoCore, head: headBase, cockpit: canopy,
                leftArm, rightArm, leftLeg, rightLeg,
                leftPod, rightPod,
                isPlayer, scale,
                stats: { maxHP: 80, mass: 40 },
                currentHP: 80, maxHP: 80,
                isWalking: false, walkCycle: 0, walkSpeed: 3.5,
                walkDirection: isPlayer ? 1 : -1,
                impactRecovery: 0, impactDirection: new BABYLON.Vector3(0,0,0),
                staggerTime: 0, recoilRecovery: 0, lastFiredArm: 'right',
                torsoTwist: 0, targetTorsoTwist: 0,
                ai: {
                    enabled: false,
                    state: 'idle',
                    target: null,
                    lastDecision: 0,
                    strafeDir: 0,
                    strafeEndTime: 0
                }
            };
        }

        // ============================================
        // CATAPULT - Medium Support Mech
        // ============================================
        function createCatapultMech(scene, xPos, zPos, isPlayer) {
            const name = (isPlayer ? 'player' : 'enemy') + '_catapult_' + Math.random().toString(36).substr(2, 4);
            const primary = isPlayer ? COLORS.playerPrimary : COLORS.enemyPrimary;
            const secondary = isPlayer ? COLORS.playerSecondary : COLORS.enemySecondary;
            const scale = 0.85;

            // Materials with textures
            const primaryMat = new BABYLON.StandardMaterial(name + '_primary', scene);
            primaryMat.diffuseTexture = TEXTURES.rustMetal.clone();
            primaryMat.diffuseTexture.uScale = 2.5;
            primaryMat.diffuseTexture.vScale = 2.5;
            primaryMat.diffuseColor = primary.scale(1.3);
            primaryMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            primaryMat.bumpTexture.uScale = 2.5;
            primaryMat.bumpTexture.vScale = 2.5;
            primaryMat.bumpTexture.level = 0.55;
            primaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            primaryMat.specularPower = 32;

            const secondaryMat = new BABYLON.StandardMaterial(name + '_secondary', scene);
            secondaryMat.diffuseTexture = TEXTURES.metal.clone();
            secondaryMat.diffuseTexture.uScale = 2;
            secondaryMat.diffuseTexture.vScale = 2;
            secondaryMat.diffuseColor = secondary.scale(1.2);
            secondaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);

            const darkMat = new BABYLON.StandardMaterial(name + '_dark', scene);
            darkMat.diffuseColor = COLORS.darkMetal;
            darkMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            const metalMat = new BABYLON.StandardMaterial(name + '_metal', scene);
            metalMat.diffuseTexture = TEXTURES.rustMetal.clone();
            metalMat.diffuseTexture.uScale = 3;
            metalMat.diffuseTexture.vScale = 3;
            metalMat.diffuseColor = COLORS.metal.scale(1.2);
            metalMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            metalMat.bumpTexture.uScale = 3;
            metalMat.bumpTexture.vScale = 3;
            metalMat.bumpTexture.level = 0.45;
            metalMat.specularColor = new BABYLON.Color3(0.45, 0.45, 0.45);
            metalMat.specularPower = 56;

            // Pelvis
            const pelvis = BABYLON.MeshBuilder.CreateBox(name + '_pelvis', {
                width: 1.5 * scale, height: 0.45 * scale, depth: 0.8 * scale
            }, scene);
            pelvis.position = new BABYLON.Vector3(xPos, 3.2, zPos);
            pelvis.material = darkMat;

            const pelvisShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -1.3, 0),
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(1.5 * scale, 3.0, 0.8 * scale),
                scene
            );
            const pelvisBody = new BABYLON.PhysicsBody(pelvis, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
            pelvisBody.shape = pelvisShape;
            pelvisBody.setMassProperties({ mass: 60 });
            pelvisBody.setAngularDamping(0.91);
            pelvisBody.setLinearDamping(0.22);
            pelvisShape.material = { friction: 0.1, restitution: 0.05 };
            const pelvisAgg = { body: pelvisBody, shape: pelvisShape };

            // Torso - boxy with rounded top
            const torsoCore = BABYLON.MeshBuilder.CreateBox(name + '_torso', {
                width: 1.3 * scale, height: 1.0 * scale, depth: 0.9 * scale
            }, scene);
            torsoCore.position.y = 0.7 * scale;
            torsoCore.parent = pelvis;
            torsoCore.material = primaryMat;

            // Head - sensor array
            const headBase = BABYLON.MeshBuilder.CreateBox(name + '_head', {
                width: 0.5 * scale, height: 0.35 * scale, depth: 0.4 * scale
            }, scene);
            headBase.position.y = 0.7 * scale;
            headBase.parent = torsoCore;
            headBase.material = secondaryMat;

            const canopy = BABYLON.MeshBuilder.CreateBox(name + '_canopy', {
                width: 0.35 * scale, height: 0.2 * scale, depth: 0.25 * scale
            }, scene);
            canopy.position = new BABYLON.Vector3(0, 0.1 * scale, 0.1 * scale);
            canopy.parent = headBase;
            canopy.material = new BABYLON.StandardMaterial(name + '_cockpit', scene);
            canopy.material.diffuseColor = COLORS.cockpit;
            canopy.material.emissiveColor = COLORS.cockpit.scale(0.5);
            canopy.material.alpha = 0.8;

            // Large missile pods on shoulders (Catapult's signature)
            const leftPod = BABYLON.MeshBuilder.CreateCylinder(name + '_leftPod', {
                diameter: 0.5 * scale, height: 0.9 * scale
            }, scene);
            leftPod.rotation.x = Math.PI / 2;
            leftPod.position = new BABYLON.Vector3(-0.85 * scale, 0.6 * scale, 0.2 * scale);
            leftPod.parent = torsoCore;
            leftPod.material = secondaryMat;

            const rightPod = BABYLON.MeshBuilder.CreateCylinder(name + '_rightPod', {
                diameter: 0.5 * scale, height: 0.9 * scale
            }, scene);
            rightPod.rotation.x = Math.PI / 2;
            rightPod.position = new BABYLON.Vector3(0.85 * scale, 0.6 * scale, 0.2 * scale);
            rightPod.parent = torsoCore;
            rightPod.material = secondaryMat;

            // Arms - smaller, laser focused
            function createArm(side) {
                const sign = side === 'left' ? -1 : 1;
                const shoulder = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Shoulder', {
                    diameter: 0.3 * scale
                }, scene);
                shoulder.position = new BABYLON.Vector3(sign * 0.6 * scale, 0.2 * scale, 0);
                shoulder.parent = torsoCore;
                shoulder.material = metalMat;

                const arm = BABYLON.MeshBuilder.CreateCylinder(name + '_' + side + 'Arm', {
                    diameter: 0.15 * scale, height: 0.7 * scale
                }, scene);
                arm.rotation.z = sign * 0.3;
                arm.position = new BABYLON.Vector3(sign * 0.2 * scale, -0.35 * scale, 0);
                arm.parent = shoulder;
                arm.material = primaryMat;

                // Weapon pod at end of arm (required for firing)
                const weaponPod = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'WeaponPod', {
                    width: 0.12 * scale, height: 0.18 * scale, depth: 0.14 * scale
                }, scene);
                weaponPod.position = new BABYLON.Vector3(0, -0.4 * scale, 0);
                weaponPod.parent = arm;
                weaponPod.material = darkMat;

                return { shoulder, arm, weaponPod };
            }

            const leftArm = createArm('left');
            const rightArm = createArm('right');

            // Legs
            function createLeg(side) {
                const sign = side === 'left' ? -1 : 1;
                const legGroup = new BABYLON.TransformNode(name + '_' + side + 'LegGroup', scene);
                legGroup.parent = pelvis;

                const hip = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Hip', { diameter: 0.3 * scale }, scene);
                hip.position = new BABYLON.Vector3(sign * 0.6 * scale, -0.2 * scale, 0);
                hip.parent = legGroup;
                hip.material = darkMat;

                const upperLeg = BABYLON.MeshBuilder.CreateCylinder(name + '_' + side + 'Upper', {
                    diameterTop: 0.22 * scale, diameterBottom: 0.18 * scale, height: 1.0 * scale
                }, scene);
                upperLeg.rotation.x = 0.5;
                upperLeg.position = new BABYLON.Vector3(0, -0.5 * scale, 0.25 * scale);
                upperLeg.parent = hip;
                upperLeg.material = primaryMat;

                const knee = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Knee', { diameter: 0.2 * scale }, scene);
                knee.position.y = -0.55 * scale;
                knee.parent = upperLeg;
                knee.material = metalMat;

                const lowerLeg = BABYLON.MeshBuilder.CreateCylinder(name + '_' + side + 'Lower', {
                    diameterTop: 0.18 * scale, diameterBottom: 0.12 * scale, height: 1.1 * scale
                }, scene);
                lowerLeg.rotation.x = -0.65;
                lowerLeg.position = new BABYLON.Vector3(0, -0.55 * scale, 0);
                lowerLeg.parent = knee;
                lowerLeg.material = primaryMat;

                const footGroup = new BABYLON.TransformNode(name + '_' + side + 'FootGroup', scene);
                footGroup.position.y = -0.6 * scale;
                footGroup.parent = lowerLeg;

                const ankle = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Ankle', {
                    width: 0.14 * scale, height: 0.12 * scale, depth: 0.18 * scale
                }, scene);
                ankle.parent = footGroup;
                ankle.material = metalMat;

                const foot = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Foot', {
                    width: 0.25 * scale, height: 0.08 * scale, depth: 0.4 * scale
                }, scene);
                foot.position = new BABYLON.Vector3(0, -0.06 * scale, 0.1 * scale);
                foot.parent = footGroup;
                foot.material = darkMat;

                return { hip, upperLeg, knee, lowerLeg, ankle, foot, legGroup, footGroup };
            }

            const leftLeg = createLeg('left');
            const rightLeg = createLeg('right');

            return {
                name: 'CATAPULT',
                pelvis, pelvisAggregate: pelvisAgg,
                torso: torsoCore, head: headBase, cockpit: canopy,
                leftArm, rightArm, leftLeg, rightLeg,
                leftPod, rightPod,
                isPlayer, scale,
                stats: { maxHP: 120, mass: 60 },
                currentHP: 120, maxHP: 120,
                isWalking: false, walkCycle: 0, walkSpeed: 2.5,
                walkDirection: isPlayer ? 1 : -1,
                impactRecovery: 0, impactDirection: new BABYLON.Vector3(0,0,0),
                staggerTime: 0, recoilRecovery: 0, lastFiredArm: 'right',
                torsoTwist: 0, targetTorsoTwist: 0,
                ai: {
                    enabled: false,
                    state: 'idle',
                    target: null,
                    lastDecision: 0,
                    strafeDir: 0,
                    strafeEndTime: 0
                }
            };
        }

        // ============================================
        // ANIMATION & PHYSICS
        // ============================================
        function updateMechs(dt) {
            allMechs.forEach(mech => {
                if (!mech || mech.isDestroyed) return;
                updateAI(mech, dt);      // AI controls movement and firing
                updateWalking(mech, dt);
                updateImpact(mech, dt);
                updateRecoil(mech, dt);
                updateTorsoTrack(mech, dt);
                stabilize(mech, dt);
            });
        }

        function updateWalking(mech, dt) {
            if (!mech.isWalking) {
                dampLegs(mech, dt);
                return;
            }

            mech.walkCycle += dt * mech.walkSpeed * 2;
            const cycle = mech.walkCycle;

            const leftPhase = Math.sin(cycle);
            const rightPhase = Math.sin(cycle + Math.PI);

            animateLeg(mech.leftLeg, leftPhase, mech.scale);
            animateLeg(mech.rightLeg, rightPhase, mech.scale);

            const sway = Math.sin(cycle) * 0.025;

            // Get pelvis facing direction from its rotation
            const body = mech.pelvisAggregate.body;
            const quat = body.transformNode.rotationQuaternion;
            let forwardDir = new BABYLON.Vector3(1, 0, 0);  // Default forward is +X
            if (quat) {
                // Get the forward vector from pelvis rotation (local +X in world space)
                const rotMatrix = new BABYLON.Matrix();
                quat.toRotationMatrix(rotMatrix);
                forwardDir = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(1, 0, 0), rotMatrix);
                forwardDir.y = 0;  // Keep movement horizontal
                forwardDir.normalize();
            }

            // Walking force in pelvis facing direction
            const walkForce = forwardDir.scale(mech.walkDirection * 120);
            body.applyForce(walkForce, mech.pelvis.getAbsolutePosition());

            const angVel = body.getAngularVelocity();
            body.setAngularVelocity(
                new BABYLON.Vector3(angVel.x * 0.9, angVel.y * 0.9, sway * 2)
            );
        }

        function animateLeg(leg, phase, scale) {
            // Chicken-walker animation with backward-bent knees
            const swing = phase * 0.25;
            // Upper leg swings forward/back (base position is forward-tilted)
            leg.upperLeg.rotation.x = 0.5 + swing;
            // Lower leg bends backward more when stepping
            const bend = (phase > 0 ? phase : 0) * 0.35;
            leg.lowerLeg.rotation.x = -0.65 - bend;
            // Foot stays relatively flat
            leg.foot.rotation.x = 0.1;
        }

        function dampLegs(mech, dt) {
            const d = 3 * dt;
            [mech.leftLeg, mech.rightLeg].forEach(leg => {
                // Return to chicken-walker stance
                leg.upperLeg.rotation.x = BABYLON.Scalar.Lerp(leg.upperLeg.rotation.x, 0.5, d);
                leg.lowerLeg.rotation.x = BABYLON.Scalar.Lerp(leg.lowerLeg.rotation.x, -0.65, d);
                leg.foot.rotation.x = BABYLON.Scalar.Lerp(leg.foot.rotation.x, 0.1, d);
            });
        }

        function updateImpact(mech, dt) {
            if (mech.impactRecovery <= 0) return;
            mech.impactRecovery -= dt * 2.2;
            if (mech.impactRecovery < 0) mech.impactRecovery = 0;

            const tilt = mech.impactRecovery * 0.28;
            mech.torso.rotation.x = mech.impactDirection.z * tilt;
            mech.torso.rotation.z = -mech.impactDirection.x * tilt;

            if (mech.staggerTime > 0) {
                mech.staggerTime -= dt;
                mech.isWalking = false;
            }
        }

        function updateRecoil(mech, dt) {
            if (mech.recoilRecovery <= 0) return;
            mech.recoilRecovery -= dt * 4.5;
            if (mech.recoilRecovery < 0) mech.recoilRecovery = 0;

            const arm = mech.lastFiredArm === 'left' ? mech.leftArm : mech.rightArm;
            arm.armGroup.rotation.x = -mech.recoilRecovery * 0.45;
            mech.torso.rotation.x = Math.max(mech.torso.rotation.x, -mech.recoilRecovery * 0.08);
        }

        function updateTorsoTrack(mech, dt) {
            const name = mech.isPlayer ? 'P' : 'E';
            const shouldLog = gameTime - lastDebugTime > DEBUG_INTERVAL;

            // Diagnostic: Check if mech object is valid
            if (!mech) {
                if (shouldLog) dbg(`${name}: updateTorsoTrack - mech is null/undefined!`, 'warn');
                return;
            }
            if (!mech.torso) {
                if (shouldLog) dbg(`${name}: updateTorsoTrack - mech.torso is null/undefined!`, 'warn');
                return;
            }
            if (!mech.pelvis) {
                if (shouldLog) dbg(`${name}: updateTorsoTrack - mech.pelvis is null/undefined!`, 'warn');
                return;
            }

            // Get or find target
            let target = mech.ai.target;
            if (!target || target.currentHP <= 0 || target.isDestroyed) {
                target = findNewTarget(mech);
                mech.ai.target = target;
            }

            // Diagnostic: Check target validity
            if (!target) {
                if (shouldLog) dbg(`${name}: updateTorsoTrack - no valid target found`, 'warn');
                return;
            }
            if (!target.pelvis) {
                if (shouldLog) dbg(`${name}: updateTorsoTrack - target.pelvis is null/undefined!`, 'warn');
                return;
            }

            const myPos = mech.pelvis.getAbsolutePosition();
            const targetPos = target.pelvis.getAbsolutePosition();
            const dx = targetPos.x - myPos.x;
            const dz = targetPos.z - myPos.z;

            // =============================================
            // TORSO ALWAYS FACES ENEMY
            // =============================================
            // Calculate angle to enemy (in XZ plane)
            // Mechs face along X axis, so we want to rotate Y to face target
            const angleToEnemy = Math.atan2(dz, dx);

            // Mech mesh faces +Z by default (chest at +Z, reactor at -Z)
            // Babylon.js uses LEFT-HANDED coordinates: +Y rotation is CLOCKWISE from above
            // rotation.y = 0 faces +Z, rotation.y = +/2 faces +X, rotation.y = -/2 faces -X
            // To convert world angle to mech rotation: baseAngle - angleToEnemy (not the reverse!)
            const baseAngle = Math.PI / 2;
            let torsoAngle = baseAngle - angleToEnemy;  // FIXED: was angleToEnemy - baseAngle

            // Normalize to -PI to PI range
            while (torsoAngle > Math.PI) torsoAngle -= Math.PI * 2;
            while (torsoAngle < -Math.PI) torsoAngle += Math.PI * 2;

            // Clamp torso rotation to reasonable range (about 60 degrees each way)
            mech.targetTorsoTwist = Math.max(-1.0, Math.min(1.0, torsoAngle));

            // Smooth interpolation for torso rotation
            mech.torsoTwist = BABYLON.Scalar.Lerp(mech.torsoTwist, mech.targetTorsoTwist, dt * 5);
            mech.torso.rotation.y = mech.torsoTwist;

            // Diagnostic: Log torso tracking calculations
            if (shouldLog) {
                dbg(`${name}: torso dx=${dx.toFixed(2)} dz=${dz.toFixed(2)} angleToEnemy=${(angleToEnemy * 180/Math.PI).toFixed(1)}`, 'torso');
                dbg(`${name}: torso baseAngle=${(baseAngle * 180/Math.PI).toFixed(0)} rawAngle=${(torsoAngle * 180/Math.PI).toFixed(1)} target=${(mech.targetTorsoTwist * 180/Math.PI).toFixed(1)} actual=${(mech.torsoTwist * 180/Math.PI).toFixed(1)}`, 'torso');
            }

            // Head follows torso but can look even more toward enemy
            if (mech.head) {
                mech.head.rotation.y = mech.torsoTwist * 1.2;
            }

            // =============================================
            // LEGS/FEET - NO LEFT/RIGHT ROTATION
            // =============================================
            // Legs and feet should NOT rotate left/right independently
            // They are rigidly attached to the pelvis which handles all Y rotation
            // Feet can only pitch up/down (X rotation) to stay flat on ground

            // Initialize foot pitch tracker if not set
            if (mech.leftFootPitch === undefined) mech.leftFootPitch = 0;
            if (mech.rightFootPitch === undefined) mech.rightFootPitch = 0;

            // Ensure legGroups have no Y rotation (they follow pelvis)
            if (mech.leftLeg.legGroup) {
                mech.leftLeg.legGroup.rotation.y = 0;
                mech.rightLeg.legGroup.rotation.y = 0;
            }

            // Feet should stay HORIZONTAL to ground regardless of pelvis tilt
            // Counter-rotate feet to compensate for pelvis X rotation (forward/back tilt)
            if (mech.leftLeg.footGroup) {
                const body = mech.pelvisAggregate.body;
                const quat = body.transformNode.rotationQuaternion;
                if (quat) {
                    const euler = quat.toEulerAngles();
                    // Counter-rotate feet on X axis to cancel pelvis forward/back tilt
                    // The foot is parented through ankle->lowerLeg->knee->upperLeg->hip->legGroup->pelvis
                    // We need to cancel out the pelvis tilt to keep feet flat
                    const pelvisTiltX = euler.x;  // Forward/back tilt
                    const pelvisTiltZ = euler.z;  // Left/right tilt

                    // Counter-rotate both feet to stay horizontal
                    // Negative pelvisTiltX because we want to cancel it out
                    mech.leftLeg.footGroup.rotation.x = -pelvisTiltX;
                    mech.rightLeg.footGroup.rotation.x = -pelvisTiltX;

                    // Z tilt affects left/right feet differently
                    // Left foot needs more counter-rotation when tilting left
                    // This is simplified - in reality legs would bend to compensate
                    mech.leftLeg.footGroup.rotation.z = -pelvisTiltZ * 0.5;
                    mech.rightLeg.footGroup.rotation.z = -pelvisTiltZ * 0.5;
                }

                // Never any Y rotation on feet
                mech.leftLeg.footGroup.rotation.y = 0;
                mech.rightLeg.footGroup.rotation.y = 0;
            }
        }

        function stabilize(mech, dt) {
            // Don't stabilize destroyed mechs - let them collapse!
            if (mech.currentHP <= 0 || mech.isDestroyed) return;

            const body = mech.pelvisAggregate.body;
            const quat = body.transformNode.rotationQuaternion;
            if (!quat) return;

            const euler = quat.toEulerAngles();
            const tiltMagnitude = Math.sqrt(euler.x * euler.x + euler.z * euler.z);
            const pos = mech.pelvis.getAbsolutePosition();

            // Initialize recovery state if not set
            if (mech.isRecovering === undefined) mech.isRecovering = false;
            if (mech.recoveryTime === undefined) mech.recoveryTime = 0;
            if (mech.fallCount === undefined) mech.fallCount = 0;

            // Detect if mech has fallen (tilt > 45 degrees - detect earlier)
            const fallenThreshold = 0.8; // ~45 degrees - start recovery sooner
            const severelyFallenThreshold = 1.2; // ~70 degrees - definitely fallen
            const groundLevel = 1.5;  // If pelvis is below this, mech is on ground

            // Check for fall: tilted too much OR pelvis too low (lying down)
            const isFallen = (tiltMagnitude > severelyFallenThreshold) ||
                            (tiltMagnitude > fallenThreshold && pos.y < groundLevel);

            if (isFallen && !mech.isRecovering) {
                // Mech has fallen - start recovery process
                mech.isRecovering = true;
                mech.recoveryTime = 0;
                mech.isWalking = false;
                mech.fallCount++;
                dbg(`${mech.isPlayer ? 'P' : 'E'}: FALLEN! (tilt=${(tiltMagnitude * 57.3).toFixed(0)} y=${pos.y.toFixed(1)}) Starting recovery #${mech.fallCount}...`, 'warn');
            }

            if (mech.isRecovering) {
                mech.recoveryTime += dt;

                // Phase 1 (0-0.5s): Stop all motion and prepare
                if (mech.recoveryTime < 0.5) {
                    body.setLinearVelocity(new BABYLON.Vector3(0, 0, 0));
                    body.setAngularVelocity(new BABYLON.Vector3(0, 0, 0));
                    dbg(`${mech.isPlayer ? 'P' : 'E'}: Recovery phase 1 - stopping...`, 'torso');
                }
                // Phase 2 (0.5-1.5s): Apply strong uprighting forces and lift
                else if (mech.recoveryTime < 1.5) {
                    // Very strong uprighting torque
                    const recoveryStrength = 400;
                    body.applyAngularImpulse(new BABYLON.Vector3(
                        -euler.x * recoveryStrength * dt,
                        -euler.y * 100 * dt,
                        -euler.z * recoveryStrength * dt
                    ));

                    // Strong upward force to lift mech
                    const normalHeight = 3.8;
                    if (pos.y < normalHeight) {
                        const liftForce = (normalHeight - pos.y) * 150;
                        body.applyForce(new BABYLON.Vector3(0, liftForce, 0), pos);
                    }

                    // Keep horizontal velocity low during lift
                    const vel = body.getLinearVelocity();
                    body.setLinearVelocity(new BABYLON.Vector3(vel.x * 0.9, vel.y, vel.z * 0.9));
                }
                // Phase 3 (1.5-2.5s): Check if recovered
                else if (mech.recoveryTime < 2.5) {
                    // Continue mild uprighting
                    body.applyAngularImpulse(new BABYLON.Vector3(
                        -euler.x * 150 * dt,
                        -euler.y * 50 * dt,
                        -euler.z * 150 * dt
                    ));
                }

                // End recovery when mostly upright and at good height
                if (tiltMagnitude < 0.25 && pos.y > 3.0 && mech.recoveryTime > 0.8) {
                    mech.isRecovering = false;
                    mech.recoveryTime = 0;
                    dbg(`${mech.isPlayer ? 'P' : 'E'}: Recovered! (tilt=${(tiltMagnitude * 57.3).toFixed(0)} y=${pos.y.toFixed(1)})`, 'ai');
                }

                // Force reset after 2.5 seconds - teleport mech upright
                if (mech.recoveryTime > 2.5) {
                    dbg(`${mech.isPlayer ? 'P' : 'E'}: Force reset! Teleporting upright...`, 'warn');

                    // Stop all motion
                    body.setLinearVelocity(new BABYLON.Vector3(0, 0, 0));
                    body.setAngularVelocity(new BABYLON.Vector3(0, 0, 0));

                    // Teleport to standing position - keep X/Z, reset Y and rotation
                    const standingY = 4.0;
                    body.disablePreStep = false;
                    mech.pelvis.position.y = standingY;

                    // Reset rotation to upright (keep Y rotation for facing)
                    const facingAngle = euler.y;
                    body.transformNode.rotationQuaternion = BABYLON.Quaternion.FromEulerAngles(0, facingAngle, 0);

                    mech.isRecovering = false;
                    mech.recoveryTime = 0;
                    dbg(`${mech.isPlayer ? 'P' : 'E'}: Teleported to y=${standingY}, facing=${(facingAngle * 57.3).toFixed(0)}`, 'ai');
                }

                return;  // Skip normal stabilization during recovery
            }

            // Normal stabilization for minor tilts
            const maxTilt = 0.25;
            if (tiltMagnitude > maxTilt) {
                // Progressive stabilization - stronger as tilt increases
                const strength = 55 + (tiltMagnitude - maxTilt) * 100;
                body.applyAngularImpulse(new BABYLON.Vector3(
                    -euler.x * strength * dt, 0, -euler.z * strength * dt
                ));
            }

            // Limit max velocity
            const vel = body.getLinearVelocity();
            if (vel.length() > 5.5) {
                body.setLinearVelocity(vel.normalize().scale(5.5));
            }

            // Prevent Y-axis spinning
            const angVel = body.getAngularVelocity();
            if (Math.abs(angVel.y) > 1.5) {
                body.setAngularVelocity(new BABYLON.Vector3(angVel.x, angVel.y * 0.8, angVel.z));
            }
        }

        // ============================================
        // MECH AI SYSTEM
        // ============================================
        function updateAI(mech, dt) {
            const name = mech.isPlayer ? 'P' : 'E';

            // Periodic verbose logging
            const shouldLog = gameTime - lastDebugTime > DEBUG_INTERVAL;

            if (!mech.ai.enabled) {
                if (shouldLog) dbg(`${name}: AI disabled`, 'warn');
                return;
            }
            if (mech.currentHP <= 0) {
                if (shouldLog) dbg(`${name}: HP=0, skip AI`, 'warn');
                return;
            }
            if (mech.staggerTime > 0) {
                if (shouldLog) dbg(`${name}: staggered (${mech.staggerTime.toFixed(2)}s)`, 'warn');
                return;
            }

            // Get or find target
            let target = mech.ai.target;
            if (!target || target.currentHP <= 0 || target.isDestroyed) {
                target = findNewTarget(mech);
                mech.ai.target = target;
            }
            if (!target) {
                if (shouldLog) dbg(`${name}: no valid target`, 'warn');
                return;
            }

            const body = mech.pelvisAggregate.body;
            const myPos = mech.pelvis.getAbsolutePosition();
            const targetPos = target.pelvis.getAbsolutePosition();
            const distance = BABYLON.Vector3.Distance(myPos, targetPos);
            const toTarget = targetPos.subtract(myPos).normalize();
            const vel = body.getLinearVelocity();

            // Log physics state periodically
            if (shouldLog) {
                dbg(`${name}: pos=(${myPos.x.toFixed(1)},${myPos.y.toFixed(1)},${myPos.z.toFixed(1)}) vel=(${vel.x.toFixed(2)},${vel.y.toFixed(2)},${vel.z.toFixed(2)}) dist=${distance.toFixed(1)}`, 'phys');
                dbg(`${name}: state=${mech.ai.state} walk=${mech.isWalking} dir=${mech.walkDirection}`, 'ai');
            }

            // Edge avoidance - high priority
            // Note: applyForce() is integrated by physics engine, don't multiply by dt
            let edgeForce = new BABYLON.Vector3(0, 0, 0);
            if (myPos.x < -AI_CONFIG.edgeBoundary) {
                edgeForce.x = AI_CONFIG.edgeForce;
                mech.ai.state = 'edge-avoid';
            } else if (myPos.x > AI_CONFIG.edgeBoundary) {
                edgeForce.x = -AI_CONFIG.edgeForce;
                mech.ai.state = 'edge-avoid';
            }
            if (Math.abs(myPos.z) > 7) {
                edgeForce.z = -Math.sign(myPos.z) * AI_CONFIG.edgeForce * 0.5;
            }

            // Apply edge avoidance force
            if (edgeForce.length() > 0) {
                mech.pelvisAggregate.body.applyForce(edgeForce, myPos);
                if (shouldLog) dbg(`${name}: edge force (${edgeForce.x.toFixed(0)},${edgeForce.z.toFixed(0)})`, 'phys');
            }

            // AI decision making (periodic, not every frame)
            if (gameTime - mech.ai.lastDecision > AI_CONFIG.decisionInterval) {
                mech.ai.lastDecision = gameTime;

                // Determine movement state based on range
                if (distance > AI_CONFIG.maxRange) {
                    mech.ai.state = 'advancing';
                    mech.walkDirection = toTarget.x > 0 ? 1 : -1;
                } else if (distance < AI_CONFIG.minRange) {
                    mech.ai.state = 'retreating';
                    mech.walkDirection = toTarget.x > 0 ? -1 : 1;
                } else {
                    // At optimal range - maybe strafe
                    if (Math.random() < AI_CONFIG.strafeChance) {
                        mech.ai.state = 'strafing';
                        mech.ai.strafeDir = Math.random() < 0.5 ? -1 : 1;
                        mech.ai.strafeEndTime = gameTime + AI_CONFIG.strafeDuration;
                    } else {
                        mech.ai.state = 'optimal';
                    }
                }

                // Fire weapons when in range (increased range for more action)
                if (distance <= 18 && distance >= AI_CONFIG.minRange * 0.5) {
                    const now = Date.now();
                    const mechKey = mech.name + '_' + (mech.isPlayer ? 'p' : 'e');
                    if (!mechCooldowns[mechKey]) mechCooldowns[mechKey] = { erlaser: 0, lrm: 0, ac: 0 };
                    const cooldowns = mechCooldowns[mechKey];
                    const weaponPriority = ['erlaser', 'ac', 'lrm'];

                    for (const wtype of weaponPriority) {
                        if (now >= cooldowns[wtype]) {
                            fireWeapon(mech, wtype);
                            cooldowns[wtype] = now + COOLDOWN_TIMES[wtype];
                            break;
                        }
                    }
                }
            }

            // Check if strafing should end
            if (mech.ai.state === 'strafing' && gameTime > mech.ai.strafeEndTime) {
                mech.ai.state = 'optimal';
                mech.ai.strafeDir = 0;
            }

            // Get pelvis forward direction for movement
            const pelvisQuat = body.transformNode.rotationQuaternion;
            let pelvisForward = new BABYLON.Vector3(1, 0, 0);
            let pelvisRight = new BABYLON.Vector3(0, 0, 1);
            if (pelvisQuat) {
                const rotMatrix = new BABYLON.Matrix();
                pelvisQuat.toRotationMatrix(rotMatrix);
                pelvisForward = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(1, 0, 0), rotMatrix);
                pelvisForward.y = 0;
                pelvisForward.normalize();
                pelvisRight = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(0, 0, 1), rotMatrix);
                pelvisRight.y = 0;
                pelvisRight.normalize();
            }

            // Apply movement based on state - mech moves in pelvis facing direction
            // Note: applyForce() is integrated by physics engine, don't multiply by dt
            let forceApplied = new BABYLON.Vector3(0, 0, 0);
            switch (mech.ai.state) {
                case 'advancing':
                    mech.isWalking = true;
                    mech.walkDirection = 1;  // Forward
                    forceApplied = pelvisForward.scale(AI_CONFIG.moveForce);
                    body.applyForce(forceApplied, myPos);
                    break;

                case 'retreating':
                    mech.isWalking = true;
                    mech.walkDirection = -1;  // Backward
                    forceApplied = pelvisForward.scale(-AI_CONFIG.moveForce * 1.2);
                    body.applyForce(forceApplied, myPos);
                    break;

                case 'strafing':
                    mech.isWalking = true;
                    // Strafe perpendicular to pelvis facing (sideways)
                    forceApplied = pelvisRight.scale(mech.ai.strafeDir * AI_CONFIG.strafeForce);
                    body.applyForce(forceApplied, myPos);
                    // Small forward/back adjustment toward ideal range
                    if (distance > AI_CONFIG.idealRange + 1) {
                        body.applyForce(pelvisForward.scale(AI_CONFIG.moveForce * 0.3), myPos);
                    } else if (distance < AI_CONFIG.idealRange - 1) {
                        body.applyForce(pelvisForward.scale(-AI_CONFIG.moveForce * 0.3), myPos);
                    }
                    break;

                case 'optimal':
                    // Small adjustments to stay at ideal range
                    if (distance > AI_CONFIG.idealRange + 2) {
                        mech.isWalking = true;
                        mech.walkDirection = 1;
                        forceApplied = pelvisForward.scale(AI_CONFIG.moveForce * 0.5);
                        body.applyForce(forceApplied, myPos);
                    } else if (distance < AI_CONFIG.idealRange - 2) {
                        mech.isWalking = true;
                        mech.walkDirection = -1;
                        forceApplied = pelvisForward.scale(-AI_CONFIG.moveForce * 0.5);
                        body.applyForce(forceApplied, myPos);
                    } else {
                        mech.isWalking = false;
                    }
                    break;

                case 'edge-avoid':
                    mech.isWalking = true;
                    break;

                default:
                    mech.isWalking = false;
            }

            // === FULL BODY ROTATION TOWARD TARGET ===
            // The whole mech (pelvis/legs) should always try to face the target
            // This is independent of torso twist - the body should orient toward enemy
            const quat = body.transformNode.rotationQuaternion;
            if (quat && !mech.isRecovering && !mech.isDestroyed) {
                const euler = quat.toEulerAngles();
                const currentYaw = euler.y;  // Current facing direction

                // Calculate desired facing angle (toward target)
                const dx = targetPos.x - myPos.x;
                const dz = targetPos.z - myPos.z;
                const angleToTarget = Math.atan2(dz, dx);  // Angle in XZ plane

                // Convert to body rotation (mesh faces +Z, so we need baseAngle offset)
                const baseAngle = Math.PI / 2;  // 90 offset because mesh faces +Z
                const desiredYaw = baseAngle - angleToTarget;

                // Calculate rotation error (shortest path)
                let yawError = desiredYaw - currentYaw;
                // Normalize to [-PI, PI]
                while (yawError > Math.PI) yawError -= 2 * Math.PI;
                while (yawError < -Math.PI) yawError += 2 * Math.PI;

                // ALWAYS try to face target - very low threshold (3 degrees)
                // This makes the mech constantly adjust its body to face the enemy
                const rotationThreshold = 0.05;  // ~3 degrees - always trying to align
                if (Math.abs(yawError) > rotationThreshold) {
                    // Rate-limited rotation - mechs turn deliberately, not instantly
                    const rotationStrength = 35;  // Moderate force for smooth turning
                    const maxRotationSpeed = 1.2;  // Rate limit: ~70 deg/sec max

                    // Current angular velocity
                    const angVel = body.getAngularVelocity();

                    // Calculate desired angular velocity (proportional to error, clamped)
                    const desiredAngVel = Math.sign(yawError) * Math.min(Math.abs(yawError) * 3, maxRotationSpeed);

                    // Apply torque to reach desired velocity
                    const yawCorrection = (desiredAngVel - angVel.y) * rotationStrength * dt;
                    body.applyAngularImpulse(new BABYLON.Vector3(0, yawCorrection, 0));

                    if (shouldLog) {
                        dbg(`${name}: BODY ROTATE yaw=${(currentYaw * 57.3).toFixed(0)} target=${(desiredYaw * 57.3).toFixed(0)} err=${(yawError * 57.3).toFixed(0)}`, 'torso');
                    }
                }
            }

            // Log force applied
            if (shouldLog && forceApplied.length() > 0) {
                dbg(`${name}: FORCE (${forceApplied.x.toFixed(0)},${forceApplied.z.toFixed(0)}) state=${mech.ai.state}`, 'phys');
            }
            // Note: lastDebugTime is updated in the main render loop after all subsystems log
        }

        // ============================================
        // COMBAT
        // ============================================
        function fireWeapon(mech, type) {
            try {
                const from = mech;
                const to = mech.ai.target;
                if (!from || !to || to.isDestroyed) return;

                log(`[FIRE] ${from.name} attempting ${type}...`);

                const weapon = WEAPONS[type];
                if (!weapon) {
                    log(`[ERROR] Unknown weapon type: ${type}`, 'error');
                    return;
                }

                from.recoilRecovery = weapon.recoil;
                from.lastFiredArm = from.lastFiredArm === 'left' ? 'right' : 'left';

                // Validate required properties
                if (!from.pelvis || !to.pelvis) {
                    log(`[ERROR] Missing pelvis: from=${!!from.pelvis} to=${!!to.pelvis}`, 'error');
                    return;
                }

                // Apply recoil in opposite direction of target
                const toTarget = to.pelvis.getAbsolutePosition().subtract(from.pelvis.getAbsolutePosition()).normalize();
                from.pelvisAggregate.body.applyImpulse(
                    toTarget.scale(-weapon.knockback * 0.25),
                    from.pelvis.getAbsolutePosition()
                );

                if (weapon.isBeam) fireBeam(from, to, weapon);
                else if (weapon.isCluster) fireCluster(from, to, weapon);
                else fireProjectile(from, to, weapon);

                log(`${from.name} fires ${weapon.name}!`);
            } catch (e) {
                log(`[FIRE ERROR] ${e.message}`, 'error');
                console.error('fireWeapon error:', e);
            }
        }

        function fireProjectile(from, to, weapon) {
            try {
                log(`[PROJ] Starting fireProjectile...`);
                const arm = from.lastFiredArm === 'left' ? from.leftArm : from.rightArm;

                // Validate arm structure
                if (!arm) {
                    log(`[ERROR] No arm found: lastFiredArm=${from.lastFiredArm}`, 'error');
                    return;
                }
                if (!arm.weaponPod) {
                    log(`[ERROR] No weaponPod on arm. Arm keys: ${Object.keys(arm).join(',')}`, 'error');
                    return;
                }
                if (!to.torso) {
                    log(`[ERROR] No torso on target`, 'error');
                    return;
                }

                const start = arm.weaponPod.getAbsolutePosition();
                start.z += 0.5;
                const target = to.torso.getAbsolutePosition();
                target.x += (Math.random() - 0.5) * 0.4;
                target.y += (Math.random() - 0.5) * 0.4;

                // Validate positions
                if (isNaN(start.x) || isNaN(target.x)) {
                    log(`[ERROR] NaN position: start=${start} target=${target}`, 'error');
                    return;
                }

                const dir = target.subtract(start).normalize();
                const projSize = weapon.projectileSize || 0.1;  // Default if missing
                const proj = BABYLON.MeshBuilder.CreateSphere('proj' + Date.now(), { diameter: projSize * 2 }, scene);
                proj.position = start.clone();

                const mat = new BABYLON.StandardMaterial('projMat' + Date.now(), scene);
                mat.emissiveColor = weapon.color;
                proj.material = mat;

                const agg = new BABYLON.PhysicsAggregate(proj, BABYLON.PhysicsShapeType.SPHERE,
                    { mass: 0.8, friction: 0, restitution: 0.1 }, scene);
                agg.body.setLinearVelocity(dir.scale(weapon.projectileSpeed));

                projectiles.push({ mesh: proj, aggregate: agg, weapon, target: to, firedAt: Date.now() });
                createMuzzleFlash(start, weapon.color);
                log(`[PROJ] Projectile created successfully`);
            } catch (e) {
                log(`[PROJ ERROR] ${e.message}`, 'error');
                console.error('fireProjectile error:', e);
            }
        }

        function fireBeam(from, to, weapon) {
            try {
                log(`[BEAM] Starting fireBeam...`);
                const arm = from.lastFiredArm === 'left' ? from.leftArm : from.rightArm;

                // Validate arm structure
                if (!arm) {
                    log(`[ERROR] No arm found: lastFiredArm=${from.lastFiredArm}`, 'error');
                    return;
                }
                if (!arm.weaponPod) {
                    log(`[ERROR] No weaponPod on arm. Arm keys: ${Object.keys(arm).join(',')}`, 'error');
                    return;
                }
                if (!to.torso) {
                    log(`[ERROR] No torso on target`, 'error');
                    return;
                }

                const start = arm.weaponPod.getAbsolutePosition();
                start.z += 0.6;
                const end = to.torso.getAbsolutePosition();

                // Validate positions and check for degenerate path
                if (isNaN(start.x) || isNaN(end.x)) {
                    log(`[ERROR] NaN position: start=${start} end=${end}`, 'error');
                    return;
                }
                const dist = BABYLON.Vector3.Distance(start, end);
                if (dist < 0.1) {
                    log(`[ERROR] Beam path too short: ${dist}`, 'error');
                    return;
                }

                log(`[BEAM] Creating tube: dist=${dist.toFixed(2)}`);
                const beam = BABYLON.MeshBuilder.CreateTube('beam' + Date.now(), {
                    path: [start, end], radius: 0.1, updatable: false
                }, scene);
                const mat = new BABYLON.StandardMaterial('beamMat' + Date.now(), scene);
                mat.emissiveColor = weapon.color;
                mat.alpha = 0.85;
                beam.material = mat;

                beams.push({ mesh: beam, material: mat, createdAt: Date.now(), duration: weapon.beamDuration });
                applyDamage(to, weapon, from.isPlayer ? 1 : -1);
                createImpact(end.clone(), weapon.color);
                log(`[BEAM] Beam created successfully`);
            } catch (e) {
                log(`[BEAM ERROR] ${e.message}`, 'error');
                console.error('fireBeam error:', e);
            }
        }

        function fireCluster(from, to, weapon) {
            try {
                log(`[CLUSTER] Starting fireCluster...`);

                // Validate pods exist
                if (!from.leftPod || !from.rightPod) {
                    log(`[ERROR] Missing pods: left=${!!from.leftPod} right=${!!from.rightPod}`, 'error');
                    return;
                }
                if (!to.torso) {
                    log(`[ERROR] No torso on target`, 'error');
                    return;
                }

                // Use shoulder missile launchers (leftPod/rightPod) instead of arm weapons
                const usePod = from.lastFiredArm === 'left' ? from.leftPod : from.rightPod;
                from.lastFiredArm = from.lastFiredArm === 'left' ? 'right' : 'left';  // Alternate pods

                const podPos = usePod.getAbsolutePosition();
                const target = to.torso.getAbsolutePosition();

                // Validate positions
                if (isNaN(podPos.x) || isNaN(target.x)) {
                    log(`[ERROR] NaN position in cluster: pod=${podPos} target=${target}`, 'error');
                    return;
                }

            for (let i = 0; i < weapon.clusterCount; i++) {
                setTimeout(() => {
                    // Calculate tube position within the missile rack (5x4 grid)
                    const row = Math.floor(i / 5) % 4;
                    const col = i % 5;

                    // Offset from pod center to simulate missiles coming from individual tubes
                    const tubeOffset = new BABYLON.Vector3(
                        (col - 2) * 0.13,   // X spread across columns
                        (row - 1.5) * 0.16, // Y spread across rows
                        0.7                  // Forward from pod center
                    );

                    // Transform offset to world space based on pod orientation
                    const worldMatrix = usePod.getWorldMatrix();
                    const start = BABYLON.Vector3.TransformCoordinates(tubeOffset, worldMatrix);

                    const spread = target.clone();
                    spread.x += (Math.random() - 0.5) * 2;
                    spread.y += (Math.random() - 0.5) * 1.5;
                    spread.z += (Math.random() - 0.5) * 1;

                    const dir = spread.subtract(start).normalize();
                    dir.y += 0.18;  // Arc upward slightly
                    dir.normalize();

                    const missile = BABYLON.MeshBuilder.CreateBox('missile' + Date.now() + i, {
                        width: 0.06, height: 0.06, depth: 0.18
                    }, scene);
                    missile.position = start.clone();
                    missile.lookAt(spread);

                    const mat = new BABYLON.StandardMaterial('missileMat' + Date.now(), scene);
                    mat.emissiveColor = weapon.color.scale(0.6);
                    missile.material = mat;

                    const agg = new BABYLON.PhysicsAggregate(missile, BABYLON.PhysicsShapeType.BOX,
                        { mass: 0.25, friction: 0, restitution: 0 }, scene);
                    agg.body.setLinearVelocity(dir.scale(weapon.projectileSpeed));

                    projectiles.push({
                        mesh: missile, aggregate: agg,
                        weapon: { ...weapon, damage: weapon.damage / weapon.clusterCount },
                        target: to, firedAt: Date.now(), isMissile: true
                    });

                    // Create small muzzle flash at each tube
                    createMuzzleFlash(start, weapon.color);
                }, i * 40);
            }
                log(`[CLUSTER] Cluster missiles launched`);
            } catch (e) {
                log(`[CLUSTER ERROR] ${e.message}`, 'error');
                console.error('fireCluster error:', e);
            }
        }

        function applyDamage(mech, weapon, dirSign) {
            // Skip if mech is already destroyed
            if (mech.isDestroyed) return;

            mech.currentHP -= weapon.damage;
            if (mech.currentHP < 0) mech.currentHP = 0;

            const impactDir = new BABYLON.Vector3(dirSign, 0, 0);
            mech.pelvisAggregate.body.applyImpulse(impactDir.scale(weapon.knockback), mech.pelvis.getAbsolutePosition());

            mech.impactRecovery = Math.min(1.0, weapon.knockback / 18);
            mech.impactDirection = impactDir;

            if (weapon.damage >= 22) {
                mech.staggerTime = 0.45;
                log(`${mech.name} STAGGERS!`, 'warn');
            }

            mech.pelvisAggregate.body.applyAngularImpulse(new BABYLON.Vector3(
                (Math.random() - 0.5) * weapon.knockback * 0.08,
                (Math.random() - 0.5) * weapon.knockback * 0.04,
                dirSign * weapon.knockback * 0.12
            ));

            if (mech.currentHP <= 0 && !mech.isDestroyed) {
                log(`${mech.name} DESTROYED!`, 'error');
                triggerDestruction(mech);
            }
        }

        function updateProjectiles(dt) {
            const now = Date.now();
            projectiles = projectiles.filter(p => {
                try {
                    if (now - p.firedAt > 3500) { p.mesh.dispose(); return false; }

                    // Safety check for target and torso
                    if (!p.target || !p.target.torso) {
                        log(`[WARN] Projectile has invalid target, removing`, 'warn');
                        p.mesh.dispose();
                        return false;
                    }

                    const dist = BABYLON.Vector3.Distance(p.mesh.position, p.target.torso.getAbsolutePosition());
                    if (dist < 1.6) {
                        applyDamage(p.target, p.weapon, p.target.isPlayer ? -1 : 1);
                        log(`HIT! ${p.target.name} -${p.weapon.damage} (${p.target.currentHP}/${p.target.maxHP})`, 'warn');
                        createImpact(p.mesh.position.clone(), p.weapon.color);
                        p.mesh.dispose();
                        return false;
                    }

                    if (p.mesh.position.y < -2 || Math.abs(p.mesh.position.x) > 22) {
                        p.mesh.dispose();
                        return false;
                    }

                    if (p.isMissile && Math.random() < 0.25) createSmoke(p.mesh.position.clone());
                    return true;
                } catch (e) {
                    console.error('[PROJECTILE ERROR]', e);
                    try { p.mesh.dispose(); } catch (e2) {}
                    return false;
                }
            });
        }

        function updateBeams() {
            const now = Date.now();
            beams = beams.filter(b => {
                const age = now - b.createdAt;
                if (age > b.duration) { b.mesh.dispose(); return false; }
                b.material.alpha = 0.85 * (1 - age / b.duration);
                return true;
            });
        }

        // ============================================
        // EFFECTS
        // ============================================
        function createMuzzleFlash(pos, color) {
            const flash = BABYLON.MeshBuilder.CreateSphere('flash', { diameter: 0.35 }, scene);
            flash.position = pos;
            const mat = new BABYLON.StandardMaterial('flashMat', scene);
            mat.emissiveColor = color;
            mat.disableLighting = true;
            flash.material = mat;

            let a = 1;
            const int = setInterval(() => {
                a -= 0.18;
                if (a <= 0) { clearInterval(int); flash.dispose(); }
                else flash.scaling.setAll(a);
            }, 16);
        }

        function createImpact(pos, color) {
            const ps = new BABYLON.ParticleSystem('impact', 60, scene);
            ps.particleTexture = new BABYLON.Texture('https://assets.babylonjs.com/textures/flare.png', scene);
            ps.emitter = pos;
            ps.color1 = new BABYLON.Color4(color.r, color.g, color.b, 1);
            ps.color2 = new BABYLON.Color4(color.r * 0.5, color.g * 0.5, color.b * 0.5, 1);
            ps.colorDead = new BABYLON.Color4(0.15, 0.1, 0, 0);
            ps.minSize = 0.08; ps.maxSize = 0.35;
            ps.minLifeTime = 0.12; ps.maxLifeTime = 0.35;
            ps.emitRate = 250; ps.manualEmitCount = 40;
            ps.minEmitPower = 3; ps.maxEmitPower = 7;
            ps.direction1 = new BABYLON.Vector3(-1, 1, -1);
            ps.direction2 = new BABYLON.Vector3(1, 1.5, 1);
            ps.gravity = new BABYLON.Vector3(0, -10, 0);
            ps.start();
            ps.targetStopDuration = 0.18;
            ps.disposeOnStop = true;
        }

        function createSmoke(pos) {
            const s = BABYLON.MeshBuilder.CreateSphere('smoke', { diameter: 0.08 }, scene);
            s.position = pos;
            const mat = new BABYLON.StandardMaterial('smokeMat', scene);
            mat.diffuseColor = new BABYLON.Color3(0.35, 0.35, 0.35);
            mat.alpha = 0.45;
            s.material = mat;

            let life = 0.4;
            const int = setInterval(() => {
                life -= 0.04;
                if (life <= 0) { clearInterval(int); s.dispose(); }
                else { s.scaling.scaleInPlace(1.06); mat.alpha = life; }
            }, 45);
        }

        function triggerDestruction(mech) {
            const pos = mech.pelvis.getAbsolutePosition();
            const mechName = mech.isPlayer ? 'TIMBER WOLF' : 'DIRE WOLF';

            // ========================================
            // SCREEN FLASH - bright orange/white
            // ========================================
            const flashPlane = BABYLON.MeshBuilder.CreatePlane('flash', { size: 100 }, scene);
            flashPlane.position = camera.position.add(camera.getForwardRay().direction.scale(5));
            flashPlane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
            const flashMat = new BABYLON.StandardMaterial('flashMat', scene);
            flashMat.emissiveColor = new BABYLON.Color3(1, 0.6, 0.2);
            flashMat.disableLighting = true;
            flashMat.alpha = 0.8;
            flashPlane.material = flashMat;

            let flashAlpha = 0.8;
            const flashFade = setInterval(() => {
                flashAlpha -= 0.04;
                if (flashAlpha <= 0) {
                    clearInterval(flashFade);
                    flashPlane.dispose();
                } else {
                    flashMat.alpha = flashAlpha;
                }
            }, 30);

            // ========================================
            // CAMERA SHAKE
            // ========================================
            const originalCamPos = camera.position.clone();
            let shakeTime = 0;
            const shakeInterval = setInterval(() => {
                shakeTime += 30;
                if (shakeTime > 1500) {
                    clearInterval(shakeInterval);
                    camera.position = originalCamPos;
                } else {
                    const intensity = 0.5 * (1 - shakeTime / 1500);
                    camera.position = originalCamPos.add(new BABYLON.Vector3(
                        (Math.random() - 0.5) * intensity,
                        (Math.random() - 0.5) * intensity * 0.5,
                        (Math.random() - 0.5) * intensity
                    ));
                }
            }, 30);

            // ========================================
            // MASSIVE CHAIN EXPLOSIONS
            // ========================================
            // Initial big explosion at center
            for (let i = 0; i < 3; i++) {
                createImpact(pos.clone(), new BABYLON.Color3(1, 0.4, 0));
            }

            // Ring of explosions spreading outward
            for (let i = 0; i < 16; i++) {
                setTimeout(() => {
                    const angle = (Math.PI * 2 * i) / 16;
                    const dist = 1.5 + Math.random() * 1.5;
                    createImpact(pos.add(new BABYLON.Vector3(
                        Math.cos(angle) * dist,
                        Math.random() * 2,
                        Math.sin(angle) * dist * 0.5
                    )), Math.random() > 0.5 ? COLORS.thruster : new BABYLON.Color3(1, 0.6, 0));
                }, i * 60);
            }

            // Delayed secondary explosions
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    createImpact(pos.add(new BABYLON.Vector3(
                        (Math.random() - 0.5) * 4,
                        Math.random() * 3,
                        (Math.random() - 0.5) * 2
                    )), new BABYLON.Color3(1, 0.3 + Math.random() * 0.4, 0));
                }, 500 + i * 100);
            }

            // ========================================
            // MAKE MECH COLLAPSE DRAMATICALLY
            // ========================================
            // Mark as destroyed so stabilize() and AI don't interfere
            mech.isDestroyed = true;
            mech.isRecovering = false;
            mech.ai.enabled = false;
            mech.isWalking = false;

            // Reduce damping so mech falls naturally
            mech.pelvisAggregate.body.setLinearDamping(0.05);
            mech.pelvisAggregate.body.setAngularDamping(0.05);

            // Strong upward impulse - mech explodes upward
            mech.pelvisAggregate.body.applyImpulse(
                new BABYLON.Vector3(
                    (Math.random() - 0.5) * 15,  // Slight random horizontal
                    80 + Math.random() * 30,      // Strong upward explosion
                    (Math.random() - 0.5) * 10
                ),
                mech.pelvis.getAbsolutePosition()
            );

            // Small random tilt to make it fall over when it lands
            mech.pelvisAggregate.body.applyAngularImpulse(new BABYLON.Vector3(
                (Math.random() - 0.5) * 50,  // Slight tilt
                0,                            // No spin
                (Math.random() - 0.5) * 50   // Slight tilt
            ));

            log(` ${mechName} HAS BEEN DESTROYED! `, 'error');
        }

        // ============================================
        // CONTROLS
        // ============================================
        function toggleWalking(isPlayer) {
            const mech = isPlayer ? playerMech : enemyMech;
            if (!mech) return;
            mech.isWalking = !mech.isWalking;
            log(`${mech.name} ${mech.isWalking ? 'walking' : 'stopped'}`);
        }

        function resetScene() {
            // Disable AI battle mode
            autoFireEnabled = false;
            battleEnded = false;
            const btn = document.getElementById('autoFireBtn');
            btn.textContent = 'AI Battle: OFF';
            btn.style.background = 'rgba(255, 200, 0, 0.3)';
            btn.style.borderColor = '#ffcc00';
            btn.style.color = '#ffcc00';

            // Starting positions for each team
            const playerPositions = [
                { x: -7, y: 3.5, z: 0 },
                { x: -9, y: 3.2, z: 3 },
                { x: -9, y: 3.0, z: -3 }
            ];
            const enemyPositions = [
                { x: 7, y: 3.8, z: 0 },
                { x: 9, y: 3.2, z: 3 },
                { x: 9, y: 3.0, z: -3 }
            ];

            // Reset player mechs
            playerMechs.forEach((mech, i) => {
                if (!mech) return;
                const pos = playerPositions[i] || playerPositions[0];
                mech.pelvis.position = new BABYLON.Vector3(pos.x, pos.y, pos.z);
                mech.pelvisAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                mech.pelvisAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());
                mech.pelvisAggregate.body.setAngularDamping(0.92);
                mech.pelvisAggregate.body.setLinearDamping(0.25);
                mech.currentHP = mech.maxHP;
                mech.isWalking = false;
                mech.isDestroyed = false;
                mech.isRecovering = false;
                mech.impactRecovery = 0;
                mech.recoilRecovery = 0;
                mech.torso.rotation.setAll(0);
                mech.ai.enabled = false;
                mech.ai.state = 'idle';
                mech.ai.target = null;
                mech.ai.lastDecision = 0;
                mech.ai.strafeDir = 0;
                mech.ai.strafeEndTime = 0;
            });

            // Reset enemy mechs
            enemyMechs.forEach((mech, i) => {
                if (!mech) return;
                const pos = enemyPositions[i] || enemyPositions[0];
                mech.pelvis.position = new BABYLON.Vector3(pos.x, pos.y, pos.z);
                mech.pelvisAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                mech.pelvisAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());
                mech.pelvisAggregate.body.setAngularDamping(0.92);
                mech.pelvisAggregate.body.setLinearDamping(0.25);
                mech.currentHP = mech.maxHP;
                mech.isWalking = false;
                mech.isDestroyed = false;
                mech.isRecovering = false;
                mech.impactRecovery = 0;
                mech.recoilRecovery = 0;
                mech.torso.rotation.setAll(0);
                mech.ai.enabled = false;
                mech.ai.state = 'idle';
                mech.ai.target = null;
                mech.ai.lastDecision = 0;
                mech.ai.strafeDir = 0;
                mech.ai.strafeEndTime = 0;
            });

            projectiles.forEach(p => p.mesh.dispose());
            projectiles = [];
            beams.forEach(b => b.mesh.dispose());
            beams = [];

            // Reset cooldowns for all mechs
            Object.keys(mechCooldowns).forEach(key => {
                mechCooldowns[key] = { erlaser: 0, lrm: 0, ac: 0 };
            });

            log('Scene reset');
        }

        // ============================================
        // AI BATTLE SYSTEM
        // ============================================
        function toggleAutoFire() {
            autoFireEnabled = !autoFireEnabled;
            const btn = document.getElementById('autoFireBtn');

            if (autoFireEnabled) {
                btn.textContent = 'AI Battle: ON';
                btn.style.background = 'rgba(0, 255, 136, 0.4)';
                btn.style.borderColor = '#00ff88';
                btn.style.color = '#00ff88';
                battleEnded = false;  // Allow AI loop to run again
                log('AI ENABLED - mechs will fight autonomously!');

                // Clear debug logs for fresh start
                debugLogs.length = 0;
                lastDebugTime = 0;
                dbg('=== AI BATTLE STARTED ===', 'ai');

                // Enable AI on all mechs with proper initialization
                allMechs.forEach(mech => {
                    if (!mech || mech.isDestroyed) return;
                    mech.ai.enabled = true;
                    mech.ai.state = 'advancing';
                    mech.ai.target = findNewTarget(mech);  // Find initial target
                    mech.ai.lastDecision = gameTime;
                    mech.isWalking = true;
                    mech.walkDirection = mech.isPlayer ? 1 : -1;
                    dbg(`${mech.name} init: ai.enabled=${mech.ai.enabled} target=${mech.ai.target?.name}`, 'ai');
                });

                log(`Battle started: ${playerMechs.length} vs ${enemyMechs.length} mechs!`);
            } else {
                btn.textContent = 'AI Battle: OFF';
                btn.style.background = 'rgba(255, 200, 0, 0.3)';
                btn.style.borderColor = '#ffcc00';
                btn.style.color = '#ffcc00';
                battleEnded = true;  // Stop the AI loop
                log('AI DISABLED');

                // Disable AI on all mechs
                allMechs.forEach(mech => {
                    if (!mech) return;
                    mech.ai.enabled = false;
                    mech.ai.state = 'idle';
                    mech.isWalking = false;
                });
            }
        }

        function checkBattleEnd() {
            if (battleEnded) return;  // Already ended
            if (!autoFireEnabled) return;

            // Check if either team is eliminated
            const alivePlayerMechs = getAliveMechs('player');
            const aliveEnemyMechs = getAliveMechs('enemy');

            if (alivePlayerMechs.length === 0 || aliveEnemyMechs.length === 0) {
                battleEnded = true;  // Mark as ended (AI already disabled in triggerDestruction)

                const winner = alivePlayerMechs.length > 0 ? 'PLAYER TEAM' : 'ENEMY TEAM';
                log(`Battle ended! ${winner} WINS!`, 'warn');

                // Delay UI update to allow destruction animation to play
                setTimeout(() => {
                    autoFireEnabled = false;
                    const btn = document.getElementById('autoFireBtn');
                    btn.textContent = 'AI Battle: OFF';
                    btn.style.background = 'rgba(255, 200, 0, 0.3)';
                    btn.style.borderColor = '#ffcc00';
                    btn.style.color = '#ffcc00';
                }, 4000);  // 4 second delay to watch destruction
            }
        }

        function updateUI() {
            // Triangle count
            const triCount = document.getElementById('triCount');
            if (triCount && scene) {
                triCount.textContent = scene.getActiveIndices() / 3 | 0;
            }

            // Calculate team HP totals
            let playerTotalHP = 0, playerMaxHP = 0, playerAlive = 0;
            let enemyTotalHP = 0, enemyMaxHP = 0, enemyAlive = 0;

            playerMechs.forEach(mech => {
                if (!mech) return;
                playerMaxHP += mech.maxHP;
                playerTotalHP += Math.max(0, mech.currentHP);
                if (mech.currentHP > 0 && !mech.isDestroyed) playerAlive++;
            });

            enemyMechs.forEach(mech => {
                if (!mech) return;
                enemyMaxHP += mech.maxHP;
                enemyTotalHP += Math.max(0, mech.currentHP);
                if (mech.currentHP > 0 && !mech.isDestroyed) enemyAlive++;
            });

            // Player team status
            if (playerMaxHP > 0) {
                document.getElementById('playerHP').style.width = (playerTotalHP / playerMaxHP * 100) + '%';
                document.getElementById('playerHPText').textContent = `Team HP: ${playerTotalHP}/${playerMaxHP} (${playerAlive} alive)`;

                let stateText = playerAlive === 0 ? 'ELIMINATED' : `${playerAlive} mechs fighting`;
                document.getElementById('playerState').textContent = stateText;
            }

            // Enemy team status
            if (enemyMaxHP > 0) {
                document.getElementById('enemyHP').style.width = (enemyTotalHP / enemyMaxHP * 100) + '%';
                document.getElementById('enemyHPText').textContent = `Team HP: ${enemyTotalHP}/${enemyMaxHP} (${enemyAlive} alive)`;

                let stateText = enemyAlive === 0 ? 'ELIMINATED' : `${enemyAlive} mechs fighting`;
                document.getElementById('enemyState').textContent = stateText;
            }
        }

        initEngine();
    </script>
</body>
</html>
