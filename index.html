<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mech Autobattler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            background-attachment: fixed;
            color: #eee;
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 10px;
        }

        header {
            background: rgba(0, 0, 0, 0.5);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 2px solid #00ff88;
        }

        h1 {
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin-bottom: 8px;
            font-size: 20px;
        }

        h2 {
            font-size: 18px;
            margin-bottom: 10px;
        }

        h3 {
            font-size: 16px;
        }

        .stats-bar {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 11px;
        }

        .stat {
            font-size: 11px;
        }

        .stat strong {
            color: #00ff88;
        }

        .screen {
            display: none;
        }

        .screen.active {
            display: block;
        }

        /* Battle Screen - MOBILE OPTIMIZED */
        .battle-area {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 15px;
        }

        .combatant {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #444;
        }

        .combatant h2 {
            font-size: 14px;
            margin-bottom: 8px;
        }

        .combatant.player {
            border-color: #00ff88;
        }

        .combatant.monster {
            border-color: #ff4444;
        }

        .abilities-display {
            margin-top: 12px;
            padding: 8px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 6px;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .abilities-display h4 {
            font-size: 11px;
            color: #00ff88;
            margin-bottom: 6px;
        }

        .ability-tag {
            display: inline-block;
            padding: 3px 6px;
            margin: 2px;
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            border-radius: 3px;
            font-size: 9px;
            color: #00ff88;
        }

        .trait-tag {
            display: inline-block;
            padding: 3px 6px;
            margin: 2px;
            background: rgba(255, 170, 0, 0.2);
            border: 1px solid #ffaa00;
            border-radius: 3px;
            font-size: 9px;
            color: #ffaa00;
        }

        .status-effects {
            margin-top: 8px;
            padding: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-size: 10px;
            min-height: 24px;
        }

        .status-effect {
            display: inline-block;
            padding: 2px 5px;
            margin: 2px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            font-size: 9px;
        }

        .status-shield {
            background: rgba(0, 204, 255, 0.3);
            border: 1px solid #00ccff;
            color: #00ccff;
        }

        .status-burn {
            background: rgba(255, 136, 0, 0.3);
            border: 1px solid #ff8800;
            color: #ff8800;
        }

        .status-bleed {
            background: rgba(255, 0, 100, 0.3);
            border: 1px solid #ff0064;
            color: #ff0064;
        }

        .mech-display {
            text-align: center;
        }

        .mech-display h3 {
            font-size: 14px;
        }

        .mech-visual {
            font-size: 40px;
            margin: 8px 0;
        }

        .health-bar {
            background: #333;
            height: 24px;
            border-radius: 12px;
            overflow: hidden;
            margin: 8px 0;
            border: 1px solid #555;
        }

        .health-fill {
            background: linear-gradient(90deg, #ff4444, #ff8844);
            height: 100%;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
        }

        .health-fill.player {
            background: linear-gradient(90deg, #00ff88, #00ccff);
        }

        .combat-log {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #444;
            height: 250px;
            overflow-y: auto;
            font-size: 12px;
        }

        .log-entry {
            padding: 6px;
            margin: 3px 0;
            border-left: 3px solid #444;
            padding-left: 8px;
            animation: slideIn 0.3s ease;
            line-height: 1.4;
        }

        .log-entry.player {
            border-left-color: #00ff88;
        }

        .log-entry.monster {
            border-left-color: #ff4444;
        }

        .log-entry.system {
            border-left-color: #00ccff;
            color: #00ccff;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.05);
            }
        }

        /* Salvage Screen - MOBILE OPTIMIZED */
        .salvage-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 15px 0;
        }

        .salvage-card, .mech-card {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #444;
            cursor: pointer;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .salvage-card:active, .mech-card:active {
            border-color: #00ff88;
            transform: scale(0.98);
            box-shadow: 0 3px 15px rgba(0, 255, 136, 0.3);
        }

        .component-name {
            color: #00ff88;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .component-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin: 10px 0;
            font-size: 11px;
        }

        .stat-item {
            padding: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            text-align: center;
        }

        /* Loadout Screen - MOBILE OPTIMIZED */
        .loadout-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .mech-panel {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00ff88;
        }

        .mech-panel h3 {
            font-size: 14px;
        }

        .mech-slots {
            margin-top: 15px;
        }

        .slot {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            margin: 8px 0;
            border-radius: 6px;
            border: 2px dashed #444;
            min-height: 55px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .slot.filled {
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
        }

        .slot:active {
            background: rgba(0, 255, 136, 0.2);
        }

        .slot-header {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .inventory-panel {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #444;
            max-height: 500px;
            overflow-y: auto;
        }

        .inventory-panel h3 {
            font-size: 16px;
        }

        .inventory-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 12px;
        }

        .inventory-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 6px;
            border: 2px solid #444;
            cursor: pointer;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .inventory-item:active {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.15);
            transform: scale(0.98);
        }

        .inventory-item.selected {
            border-color: #00ccff;
            background: rgba(0, 204, 255, 0.2);
        }

        /* Buttons - MOBILE OPTIMIZED */
        .btn {
            background: linear-gradient(135deg, #00ff88, #00ccff);
            color: #000;
            border: none;
            padding: 16px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 8px 0;
            width: 100%;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .btn:active {
            transform: scale(0.97);
            box-shadow: 0 3px 15px rgba(0, 255, 136, 0.5);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: scale(1);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #666, #888);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff4444, #ff8844);
        }

        /* Resource bars */
        .resource-bars {
            margin: 12px 0;
        }

        .resource-bar {
            margin: 10px 0;
        }

        .resource-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 11px;
        }

        .resource-fill-container {
            background: #333;
            height: 12px;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #555;
        }

        .resource-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .resource-fill.tier {
            background: linear-gradient(90deg, #ff4444, #ff8844);
        }

        .resource-fill.weight {
            background: linear-gradient(90deg, #00ccff, #0088ff);
        }

        .tier-indicator {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 5px;
        }

        .tier-1 { background: #888; }
        .tier-2 { background: #00ff88; color: #000; }
        .tier-3 { background: #00ccff; color: #000; }
        .tier-4 { background: #ff00ff; color: #fff; }
        .tier-5 { background: #ffaa00; color: #000; }

        /* Debug Panel - MOBILE OPTIMIZED */
        .debug-panel {
            position: fixed;
            top: 50px;
            right: 10px;
            background: rgba(0, 0, 0, 0.95);
            padding: 12px;
            border-radius: 6px;
            border: 2px solid #ff00ff;
            font-size: 10px;
            max-width: 250px;
            z-index: 1000;
            max-height: 80vh;
            overflow-y: auto;
        }

        .debug-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #ff00ff;
            color: #000;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 999;
            font-size: 11px;
            font-weight: bold;
            -webkit-tap-highlight-color: transparent;
        }

        /* Scrollbar styling - MOBILE */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        ::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00ccff;
        }

        .warning {
            color: #ff8844;
            font-weight: bold;
        }

        .success {
            color: #00ff88;
            font-weight: bold;
        }

        /* Tablet and larger screens */
        @media (min-width: 768px) {
            .container {
                max-width: 1400px;
                padding: 20px;
            }

            h1 {
                font-size: 28px;
            }

            h2 {
                font-size: 22px;
            }

            .stats-bar {
                display: flex;
                gap: 30px;
            }

            .stat {
                font-size: 14px;
            }

            .battle-area {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 20px;
            }

            .salvage-options {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 20px;
            }

            .loadout-container {
                display: grid;
                grid-template-columns: 400px 1fr;
                gap: 20px;
            }

            .inventory-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            }

            .btn {
                width: auto;
            }

            .btn:hover {
                transform: scale(1.05);
            }

            .salvage-card:hover, .mech-card:hover {
                border-color: #00ff88;
                transform: translateY(-5px);
            }

            .inventory-item:hover {
                border-color: #00ff88;
                background: rgba(0, 255, 136, 0.1);
            }

            .slot:hover {
                background: rgba(0, 255, 136, 0.15);
            }
        }

        /* Physics Canvas Styles */
        #physics-canvas {
            width: 100%;
            max-width: 800px;
            height: auto;
            aspect-ratio: 16 / 9;
            background: linear-gradient(180deg, #1a1a3e 0%, #0d0d1f 100%);
            border: 3px solid #00ff88;
            border-radius: 8px;
            margin: 0 auto 15px;
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3), inset 0 0 50px rgba(0, 0, 0, 0.5);
        }

        #physics-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        #physics-controls button {
            padding: 6px 12px;
            font-size: 11px;
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
        }

        #physics-controls button:hover {
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        #physics-controls button.active {
            background: rgba(0, 255, 136, 0.3);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.7);
        }
    </style>

    <!-- Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚öîÔ∏è MECH AUTOBATTLER ‚öîÔ∏è</h1>
            <div class="stats-bar">
                <div class="stat"><strong>Round:</strong> <span id="round-num">1</span></div>
                <div class="stat"><strong>Victories:</strong> <span id="victories">0</span></div>
                <div class="stat"><strong>Current Mech:</strong> <span id="current-mech-name">None</span></div>
                <div class="stat"><strong>Inventory:</strong> <span id="inventory-count">0/10</span></div>
            </div>
        </header>

        <!-- Battle Screen -->
        <div id="battle-screen" class="screen">
            <!-- Physics Combat Visualization -->
            <div id="physics-controls">
                <button id="toggle-physics" class="active">üéÆ Physics View</button>
                <button id="speed-1x" class="active">1x Speed</button>
                <button id="speed-2x">2x Speed</button>
                <button id="speed-4x">4x Speed</button>
                <button id="toggle-effects" class="active">‚ú® Effects</button>
            </div>
            <canvas id="physics-canvas" width="800" height="450"></canvas>

            <div class="battle-area">
                <div class="combatant player">
                    <h2>ü§ñ YOUR MECH</h2>
                    <div class="mech-display">
                        <div class="mech-visual" id="player-visual">ü§ñ</div>
                        <h3 id="player-name">Loading...</h3>
                        <div class="health-bar">
                            <div class="health-fill player" id="player-health">
                                <span id="player-health-text">100/100</span>
                            </div>
                        </div>
                        <div class="status-effects" id="player-status-effects">
                            <span style="color: #666; font-size: 9px;">No active effects</span>
                        </div>
                        <div id="player-stats" style="font-size: 12px; margin-top: 10px;"></div>
                        <div class="abilities-display" id="player-abilities-display" style="display: none;"></div>
                    </div>
                </div>

                <div class="combatant monster">
                    <h2>üëæ ENEMY</h2>
                    <div class="mech-display">
                        <div class="mech-visual" id="monster-visual">üëæ</div>
                        <h3 id="monster-name">Loading...</h3>
                        <div class="health-bar">
                            <div class="health-fill" id="monster-health">
                                <span id="monster-health-text">100/100</span>
                            </div>
                        </div>
                        <div class="status-effects" id="monster-status-effects">
                            <span style="color: #666; font-size: 9px;">No active effects</span>
                        </div>
                        <div id="monster-stats" style="font-size: 12px; margin-top: 10px;"></div>
                    </div>
                </div>
            </div>

            <div class="combat-log" id="combat-log"></div>

            <div style="text-align: center; margin-top: 20px;">
                <button class="btn" id="start-battle-btn">START BATTLE</button>
            </div>
        </div>

        <!-- Salvage Screen -->
        <div id="salvage-screen" class="screen">
            <h2>üîß SALVAGE SELECTION</h2>
            <p style="margin: 15px 0;">Choose one component to salvage from the battlefield:</p>
            <div class="salvage-options" id="salvage-options"></div>
        </div>

        <!-- Trait Selection Screen -->
        <div id="trait-select-screen" class="screen">
            <h2>‚≠ê MECH UPGRADE AVAILABLE ‚≠ê</h2>
            <p style="margin: 15px 0;">Your mech has proven itself in battle! Choose a permanent trait upgrade:</p>
            <div class="salvage-options" id="trait-options"></div>
        </div>

        <!-- Relic Selection Screen -->
        <div id="relic-select-screen" class="screen">
            <h2>‚ú® RELIC DISCOVERED ‚ú®</h2>
            <p style="margin: 15px 0;" id="relic-screen-desc">Choose a powerful relic to add to your collection:</p>
            <div style="margin-bottom: 15px; padding: 10px; background: rgba(255, 170, 0, 0.1); border: 2px solid #ffaa00; border-radius: 8px; font-size: 13px;">
                <strong>üí° TIP:</strong> Relics are <strong>PERMANENT</strong> and <strong>STACK</strong> with each other! Build synergies for exponential power.
            </div>
            <div class="salvage-options" id="relic-options"></div>
        </div>

        <!-- Item Selection Modal -->
        <div id="item-select-modal" class="screen">
            <h2 id="item-select-title">üì¶ SELECT COMPONENT</h2>
            <p style="margin: 15px 0;" id="item-select-desc">Choose a component to equip:</p>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <button class="btn btn-secondary" onclick="closeItemSelectModal()">‚Üê Back to Loadout</button>
                <button class="btn btn-danger" onclick="unequipSlot()" id="unequip-btn">üóëÔ∏è Unequip Current</button>
            </div>
            <div class="salvage-options" id="item-select-options"></div>
        </div>

        <!-- Loadout Screen -->
        <div id="loadout-screen" class="screen active">
            <h2>‚öôÔ∏è LOADOUT MANAGEMENT</h2>
            <div class="loadout-container">
                <div class="mech-panel">
                    <h3 id="loadout-mech-name">Select a Mech</h3>
                    <div class="mech-visual" style="text-align: center; font-size: 64px; margin: 20px 0;" id="loadout-mech-visual">ü§ñ</div>

                    <div class="resource-bars">
                        <div class="resource-bar">
                            <div class="resource-label">
                                <span>Tier Points:</span>
                                <span id="tier-usage">0/0</span>
                            </div>
                            <div class="resource-fill-container">
                                <div class="resource-fill tier" id="tier-bar"></div>
                            </div>
                        </div>
                        <div class="resource-bar">
                            <div class="resource-label">
                                <span>Weight:</span>
                                <span id="weight-usage">0/0</span>
                            </div>
                            <div class="resource-fill-container">
                                <div class="resource-fill weight" id="weight-bar"></div>
                            </div>
                        </div>
                    </div>

                    <div class="mech-slots" id="mech-slots"></div>

                    <button class="btn" id="ready-battle-btn" style="width: 100%; margin-top: 20px;">READY FOR BATTLE</button>
                </div>

                <div class="inventory-panel">
                    <h3>üì¶ Inventory</h3>
                    <div style="margin-bottom: 10px; padding: 8px; background: rgba(0, 204, 255, 0.1); border: 2px solid #00ccff; border-radius: 6px; font-size: 11px; color: #00ccff;">
                        üí° <strong>TIP:</strong> Click on a <strong>SLOT</strong> to equip items!
                    </div>
                    <button class="btn btn-secondary" id="toggle-abilities-guide" style="width: 100%; margin-bottom: 10px; padding: 8px; font-size: 12px;">
                        üìñ ABILITIES GUIDE
                    </button>
                    <div id="abilities-guide" style="display: none; background: rgba(0, 255, 136, 0.1); border: 2px solid #00ff88; border-radius: 8px; padding: 12px; margin-bottom: 15px; max-height: 300px; overflow-y: auto;">
                        <h4 style="color: #00ff88; margin-bottom: 10px; font-size: 14px;">‚ö° ABILITY REFERENCE</h4>
                        <div id="abilities-reference"></div>
                    </div>
                    <div class="inventory-grid" id="inventory-grid"></div>
                </div>
            </div>
        </div>
    </div>

    <button class="debug-toggle" id="debug-toggle">DEBUG</button>
    <div class="debug-panel" id="debug-panel" style="display: none;"></div>

    <script>
        // ============================================================================
        // GAME DATA STRUCTURES
        // ============================================================================

        const SLOT_TYPES = {
            HEAD: 'head',
            TORSO: 'torso',
            LEFT_ARM: 'leftArm',
            RIGHT_ARM: 'rightArm',
            LEFT_SHOULDER: 'leftShoulder',
            RIGHT_SHOULDER: 'rightShoulder',
            LEGS: 'legs'
        };

        const COMPONENT_TYPES = {
            WEAPON: 'weapon',
            ARMOR: 'armor',
            SYSTEM: 'system'
        };

        const MECH_CLASSES = {
            LIGHT: 'Light',
            MEDIUM: 'Medium',
            HEAVY: 'Heavy'
        };

        const DAMAGE_TYPES = {
            ENERGY: 'energy',
            KINETIC: 'kinetic',
            EXPLOSIVE: 'explosive',
            NONE: 'none'
        };

        // Rarity system with drop rates and visual styling
        const RARITY = {
            COMMON: {
                name: 'Common',
                color: '#888888',
                weight: 50,
                statMultiplier: 1.0
            },
            UNCOMMON: {
                name: 'Uncommon',
                color: '#00ff00',
                weight: 30,
                statMultiplier: 1.2
            },
            RARE: {
                name: 'Rare',
                color: '#4da6ff',
                weight: 15,
                statMultiplier: 1.4
            },
            EPIC: {
                name: 'Epic',
                color: '#a335ee',
                weight: 4,
                statMultiplier: 1.6
            },
            LEGENDARY: {
                name: 'Legendary',
                color: '#ff8000',
                weight: 1,
                statMultiplier: 2.0
            }
        };

        const ABILITIES = {
            // Damage abilities
            CRITICAL_STRIKE: { name: 'Critical Strike', desc: '25% crit chance (2x dmg)', tier: 2 },
            VAMPIRIC: { name: 'Vampiric', desc: 'Heal 25% of damage dealt', tier: 4 },
            ARMOR_PIERCING: { name: 'Armor Piercing', desc: 'Ignore 50% enemy armor', tier: 3 },
            BURN: { name: 'Plasma Burn', desc: 'Deal 5 dmg/turn for 3 turns', tier: 2 },
            BLEED: { name: 'Hemorrhage', desc: 'Crits cause 15 bleed over 5 turns', tier: 3 },

            // Defense abilities
            SHIELD_GEN: { name: 'Energy Shield', desc: 'Start with 50 shield HP', tier: 3 },
            REGENERATION: { name: 'Regeneration', desc: 'Heal 5 HP per turn', tier: 3 },
            REACTIVE: { name: 'Reactive Armor', desc: 'Reflect 25% damage taken', tier: 3 },
            DODGE: { name: 'Dodge Matrix', desc: '20% chance to avoid damage', tier: 3 },

            // Speed abilities
            LIGHTWEIGHT: { name: 'Lightweight Frame', desc: 'Weight doesn\'t affect speed', tier: 2 },
            OVERDRIVE: { name: 'Overdrive', desc: '+50 speed, -20% armor', tier: 3 },
            QUICK_DEPLOY: { name: 'Quick Deploy', desc: 'Always attack first on turn 1', tier: 2 },

            // Special abilities
            EFFICIENT: { name: 'Efficient Design', desc: 'Component costs -1 tier', tier: 3 },
            BERSERKER: { name: 'Berserker', desc: '+1% dmg per 1% HP missing', tier: 3 },
            EXECUTIONER: { name: 'Executioner', desc: '+100% dmg vs enemies <30% HP', tier: 3 },
            DOUBLE_STRIKE: { name: 'Multi-Strike', desc: 'Attack twice at 60% dmg each', tier: 4 },
            OVERCHARGE: { name: 'Overcharge', desc: '+100% dmg, take 10% max HP/attack', tier: 5 }
        };

        const MECH_TRAITS = {
            BERSERKER: {
                name: 'BERSERKER',
                desc: 'Gain +3% damage per 1% HP missing',
                tier: 4,
                icon: 'üí¢'
            },
            CRITICAL_CORE: {
                name: 'CRITICAL CORE',
                desc: 'All attacks have +30% crit chance, crits deal 3x damage',
                tier: 3,
                icon: 'üí•'
            },
            FORTRESS: {
                name: 'FORTRESS',
                desc: 'Armor increased by 100%, speed reduced by 50%',
                tier: 4,
                icon: 'üõ°Ô∏è'
            },
            REGENERATOR: {
                name: 'REGENERATOR',
                desc: 'Regenerate 8% max HP per turn',
                tier: 4,
                icon: 'üíö'
            },
            VAMPIRE: {
                name: 'VAMPIRE',
                desc: 'Heal for 40% of damage dealt, -30% armor',
                tier: 5,
                icon: 'ü©∏'
            },
            LIGHTNING_FAST: {
                name: 'LIGHTNING FAST',
                desc: 'Weight doesn\'t affect speed, +50 base speed',
                tier: 4,
                icon: '‚ö°'
            },
            EFFICIENT: {
                name: 'EFFICIENT',
                desc: 'All components cost -2 tier points (min 1)',
                tier: 5,
                icon: '‚öôÔ∏è'
            },
            SALVAGER: {
                name: 'SALVAGER',
                desc: 'Choose 2 salvage items instead of 1',
                tier: 4,
                icon: 'üîß'
            },
            ENERGY_MASTER: {
                name: 'ENERGY MASTER',
                desc: 'All Energy damage +100%, Energy components cost -1 tier',
                tier: 4,
                icon: '‚öõÔ∏è'
            },
            KINETIC_MASTER: {
                name: 'KINETIC MASTER',
                desc: 'All Kinetic damage +100%, ignore 50% armor',
                tier: 4,
                icon: 'üéØ'
            },
            EXPLOSIVE_MASTER: {
                name: 'EXPLOSIVE MASTER',
                desc: 'All Explosive damage +100%, apply burn effect',
                tier: 4,
                icon: 'üí£'
            },
            OVERCHARGED: {
                name: 'OVERCHARGED',
                desc: '+100% damage, lose 8% max HP per turn',
                tier: 5,
                icon: 'üî•'
            }
        };

        // Relics - Permanent upgrades that stack (with rarity)
        const RELICS = {
            // Damage Type Scaling
            ENERGY_CONDUIT: {
                name: 'Energy Conduit',
                desc: 'Energy damage +50% (stacks!)',
                icon: 'üîã',
                category: 'damage',
                rarity: 'UNCOMMON'
            },
            KINETIC_AMPLIFIER: {
                name: 'Kinetic Amplifier',
                desc: 'Kinetic damage +50%, ignore 25% armor',
                icon: 'üéØ',
                category: 'damage',
                rarity: 'UNCOMMON'
            },
            EXPLOSIVE_CATALYST: {
                name: 'Explosive Catalyst',
                desc: 'Explosive damage +50%, burns spread faster',
                icon: 'üí£',
                category: 'damage',
                rarity: 'UNCOMMON'
            },
            CRITICAL_MASS: {
                name: 'Critical Mass',
                desc: 'Critical chance +10%, crits +50% damage',
                icon: 'üí•',
                category: 'damage',
                rarity: 'RARE'
            },

            // Conversion Mechanics
            MOMENTUM_DRIVE: {
                name: 'Momentum Drive',
                desc: 'Each tier point spent = +2 damage',
                icon: '‚ö°',
                category: 'conversion',
                rarity: 'RARE'
            },
            BLOOD_PACT: {
                name: 'Blood Pact',
                desc: 'Max HP -20%, heal 50% of damage dealt',
                icon: 'ü©∏',
                category: 'conversion',
                rarity: 'EPIC'
            },

            // Investment/Snowball
            HUNTERS_MARK: {
                name: "Hunter's Mark",
                desc: 'Each kill grants +3 permanent damage',
                icon: 'üíÄ',
                category: 'investment',
                rarity: 'EPIC'
            },

            // Game Changers
            PERFECT_AEGIS: {
                name: 'Perfect Aegis',
                desc: 'Shields are 3x more effective',
                icon: 'üõ°Ô∏è',
                category: 'gameChanger',
                rarity: 'RARE'
            },
            CONTAGION: {
                name: 'Contagion',
                desc: 'DoTs deal 2x damage and last 2x longer',
                icon: 'üî•',
                category: 'gameChanger',
                rarity: 'EPIC'
            },
            GLASS_CANNON_CORE: {
                name: 'Glass Cannon Core',
                desc: 'All damage 2x, max HP -50%',
                icon: 'üíé',
                category: 'gameChanger',
                rarity: 'LEGENDARY'
            },
            FORTRESS_PROTOCOL: {
                name: 'Fortress Protocol',
                desc: 'Armor doubled, immune to one-shots',
                icon: 'üè∞',
                category: 'gameChanger',
                rarity: 'RARE'
            },
            VAMPIRIC_ASCENSION: {
                name: 'Vampiric Ascension',
                desc: 'Lifesteal from all damage (25%)',
                icon: 'üßõ',
                category: 'gameChanger',
                rarity: 'RARE'
            },

            // Build-Arounds
            ALL_IN: {
                name: 'All-In',
                desc: 'Abilities trigger twice, cost double tier',
                icon: 'üé≤',
                category: 'buildAround',
                rarity: 'LEGENDARY'
            },
            LAST_STAND: {
                name: 'Last Stand',
                desc: 'Below 30% HP: +200% damage, +50 armor',
                icon: '‚è±Ô∏è',
                category: 'buildAround',
                rarity: 'EPIC'
            },
            SCAVENGER: {
                name: 'Scavenger',
                desc: '+3 inventory slots, always salvage 2',
                icon: 'üîß',
                category: 'buildAround',
                rarity: 'UNCOMMON'
            }
        };

        // Mech Templates
        const MECH_TEMPLATES = {
            SCOUT: {
                name: 'Scout',
                class: MECH_CLASSES.LIGHT,
                tierCapacity: 25,
                baseHP: 80,
                baseArmor: 5,
                visual: 'üèÉ',
                slots: [SLOT_TYPES.HEAD, SLOT_TYPES.TORSO, SLOT_TYPES.LEFT_ARM, SLOT_TYPES.RIGHT_ARM, SLOT_TYPES.LEFT_SHOULDER, SLOT_TYPES.RIGHT_SHOULDER, SLOT_TYPES.LEGS]
            },
            WARRIOR: {
                name: 'Warrior',
                class: MECH_CLASSES.MEDIUM,
                tierCapacity: 38,
                baseHP: 120,
                baseArmor: 10,
                visual: 'ü§ñ',
                slots: [SLOT_TYPES.HEAD, SLOT_TYPES.TORSO, SLOT_TYPES.LEFT_ARM, SLOT_TYPES.RIGHT_ARM, SLOT_TYPES.LEFT_SHOULDER, SLOT_TYPES.RIGHT_SHOULDER, SLOT_TYPES.LEGS]
            },
            TITAN: {
                name: 'Titan',
                class: MECH_CLASSES.HEAVY,
                tierCapacity: 50,
                baseHP: 180,
                baseArmor: 15,
                visual: 'üèãÔ∏è',
                slots: [SLOT_TYPES.HEAD, SLOT_TYPES.TORSO, SLOT_TYPES.LEFT_ARM, SLOT_TYPES.RIGHT_ARM, SLOT_TYPES.LEFT_SHOULDER, SLOT_TYPES.RIGHT_SHOULDER, SLOT_TYPES.LEGS]
            }
        };

        // Component Templates (with rarity system)
        const COMPONENT_TEMPLATES = [
            // ENERGY WEAPONS
            { name: 'Laser Cannon', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_ARM, damage: 25, armor: 0, tier: 2, damageType: DAMAGE_TYPES.ENERGY, abilities: ['CRITICAL_STRIKE'], rarity: 'UNCOMMON' },
            { name: 'Plasma Rifle', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_ARM, damage: 30, armor: 0, tier: 3, damageType: DAMAGE_TYPES.ENERGY, abilities: ['BURN'], rarity: 'UNCOMMON' },
            { name: 'Ion Beam', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.LEFT_ARM, damage: 22, armor: 0, tier: 3, damageType: DAMAGE_TYPES.ENERGY, abilities: ['ARMOR_PIERCING'], rarity: 'UNCOMMON' },

            // KINETIC WEAPONS
            { name: 'Rail Gun', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_ARM, damage: 40, armor: -10, tier: 4, damageType: DAMAGE_TYPES.KINETIC, abilities: ['ARMOR_PIERCING'], rarity: 'RARE' },
            { name: 'Machine Gun', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.LEFT_ARM, damage: 15, armor: 0, tier: 1, damageType: DAMAGE_TYPES.KINETIC, abilities: [], rarity: 'COMMON' },
            { name: 'Autocannon', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_ARM, damage: 28, armor: -5, tier: 3, damageType: DAMAGE_TYPES.KINETIC, abilities: ['BLEED'], rarity: 'UNCOMMON' },

            // EXPLOSIVE WEAPONS
            { name: 'Missile Pod', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.LEFT_SHOULDER, damage: 35, armor: -3, tier: 3, damageType: DAMAGE_TYPES.EXPLOSIVE, abilities: ['BURN'], rarity: 'UNCOMMON' },
            { name: 'Rocket Launcher', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_SHOULDER, damage: 45, armor: -8, tier: 4, damageType: DAMAGE_TYPES.EXPLOSIVE, abilities: ['EXECUTIONER'], rarity: 'RARE' },
            { name: 'Grenade Launcher', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.LEFT_SHOULDER, damage: 30, armor: 0, tier: 2, damageType: DAMAGE_TYPES.EXPLOSIVE, abilities: [], rarity: 'COMMON' },

            // ARMOR
            { name: 'Light Plating', type: COMPONENT_TYPES.ARMOR, slot: SLOT_TYPES.TORSO, damage: 0, armor: 10, tier: 1, damageType: DAMAGE_TYPES.NONE, abilities: [], rarity: 'COMMON' },
            { name: 'Heavy Plating', type: COMPONENT_TYPES.ARMOR, slot: SLOT_TYPES.TORSO, damage: 0, armor: 20, tier: 2, damageType: DAMAGE_TYPES.NONE, abilities: [], rarity: 'COMMON' },
            { name: 'Composite Armor', type: COMPONENT_TYPES.ARMOR, slot: SLOT_TYPES.TORSO, damage: 0, armor: 35, tier: 4, damageType: DAMAGE_TYPES.NONE, abilities: ['REACTIVE'], rarity: 'RARE' },
            { name: 'Reactive Armor', type: COMPONENT_TYPES.ARMOR, slot: SLOT_TYPES.TORSO, damage: 0, armor: 25, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['REACTIVE'], rarity: 'UNCOMMON' },

            // SYSTEMS - Head
            { name: 'Targeting System', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.HEAD, damage: 10, armor: 5, tier: 2, damageType: DAMAGE_TYPES.NONE, abilities: ['CRITICAL_STRIKE'], rarity: 'UNCOMMON' },
            { name: 'Advanced Sensors', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.HEAD, damage: 15, armor: 10, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['EXECUTIONER'], rarity: 'RARE' },

            // SYSTEMS - Legs
            { name: 'Boost System', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.LEGS, damage: 5, armor: 0, tier: 2, damageType: DAMAGE_TYPES.NONE, abilities: [], rarity: 'COMMON' },
            { name: 'Overdrive Boosters', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.LEGS, damage: 8, armor: -5, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: [], rarity: 'UNCOMMON' },
            { name: 'Heavy Servos', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.LEGS, damage: 0, armor: 15, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: [], rarity: 'UNCOMMON' },

            // SYSTEMS - Special
            { name: 'Shield Generator', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 0, armor: 25, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['SHIELD_GEN'], rarity: 'RARE' },
            { name: 'Repair Nanobots', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 0, armor: 15, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['REGENERATION'], rarity: 'RARE' },
            { name: 'Power Core', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 10, armor: 10, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['EFFICIENT'], rarity: 'RARE' },
            { name: 'Vampiric Core', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 15, armor: -10, tier: 4, damageType: DAMAGE_TYPES.NONE, abilities: ['VAMPIRIC'], rarity: 'EPIC' },
            { name: 'Berserker Chip', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.HEAD, damage: 20, armor: -15, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['BERSERKER'], rarity: 'RARE' },
            { name: 'Overcharge Module', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 25, armor: -20, tier: 5, damageType: DAMAGE_TYPES.NONE, abilities: ['OVERCHARGE'], rarity: 'EPIC' }
        ];

        // ============================================================================
        // GAME STATE
        // ============================================================================

        class GameState {
            constructor() {
                this.round = 1;
                this.victories = 0;
                this.currentMech = null;
                this.inventory = [];
                this.currentMonster = null;
                this.battleInProgress = false;
                this.maxInventorySize = 10;
                this.relics = []; // Array of acquired relic keys
                this.permanentDamageBonus = 0; // From Hunter's Mark
                this.componentBattleCount = {}; // Track battles per component ID for Evolution Chamber
            }

            save() {
                localStorage.setItem('mechAutobattler', JSON.stringify({
                    round: this.round,
                    victories: this.victories,
                    currentMech: this.currentMech,
                    inventory: this.inventory,
                    relics: this.relics,
                    permanentDamageBonus: this.permanentDamageBonus,
                    componentBattleCount: this.componentBattleCount
                }));
            }

            load() {
                const saved = localStorage.getItem('mechAutobattler');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.round = data.round || 1;
                    this.victories = data.victories || 0;
                    this.currentMech = data.currentMech;
                    this.inventory = data.inventory || [];
                    this.relics = data.relics || [];
                    this.permanentDamageBonus = data.permanentDamageBonus || 0;
                    this.componentBattleCount = data.componentBattleCount || {};
                    return true;
                }
                return false;
            }

            reset() {
                this.round = 1;
                this.victories = 0;
                this.currentMech = null;
                this.inventory = [];
                localStorage.removeItem('mechAutobattler'); // Clear saved game
            }
        }

        const game = new GameState();

        // ============================================================================
        // PHYSICS ENGINE INITIALIZATION
        // ============================================================================

        let physicsEngine = null;
        let physicsEnabled = true;

        // Initialize physics after DOM is ready
        function initializePhysics() {
            try {
                physicsEngine = new PhysicsEngine('physics-canvas');
                console.log('Physics-driven battle system initialized successfully');
            } catch (error) {
                console.error('Failed to initialize physics:', error);
                physicsEnabled = false;
            }
        }

        // ============================================================================
        // COMPONENT & MECH MANAGEMENT
        // ============================================================================

        function createMech(template, tier = 1) {
            const loadout = {};
            template.slots.forEach(slot => {
                loadout[slot] = null;
            });

            return {
                name: template.name,
                class: template.class,
                tierCapacity: template.tierCapacity,
                baseHP: template.baseHP,
                baseArmor: template.baseArmor,
                visual: template.visual,
                slots: template.slots,
                tier: tier,
                loadout: loadout,
                currentHP: template.baseHP,
                maxHP: template.baseHP,
                traits: []  // Array of acquired traits
            };
        }

        // Helper function to select random rarity based on weights
        function selectWeightedRarity() {
            const rarities = Object.keys(RARITY);
            const totalWeight = rarities.reduce((sum, key) => sum + RARITY[key].weight, 0);
            let random = Math.random() * totalWeight;

            for (const key of rarities) {
                random -= RARITY[key].weight;
                if (random <= 0) {
                    return key;
                }
            }
            return 'COMMON'; // fallback
        }

        function createComponent(template, tier = 1, forcedRarity = null) {
            // Determine rarity - use forced if provided, otherwise weighted random
            const rarityKey = forcedRarity || selectWeightedRarity();
            const rarityData = RARITY[rarityKey];

            const comp = {
                name: template.name,
                type: template.type,
                slot: template.slot,
                damage: template.damage,
                armor: template.armor,
                tier: tier,
                damageType: template.damageType || DAMAGE_TYPES.NONE,
                abilities: template.abilities ? [...template.abilities] : [],
                rarity: rarityKey,
                id: Math.random().toString(36).substr(2, 9),
                seenInSlots: [] // Track which slots this item has been shown in
            };

            // Scale stats with tier
            const tierMultiplier = 1 + ((tier - 1) * 0.3);
            comp.damage = Math.floor(comp.damage * tierMultiplier);
            comp.armor = Math.floor(comp.armor * tierMultiplier);

            // Apply rarity multiplier on top of tier scaling
            comp.damage = Math.floor(comp.damage * rarityData.statMultiplier);
            comp.armor = Math.floor(comp.armor * rarityData.statMultiplier);

            return comp;
        }

        function generateRandomComponents(count, minTier, maxTier) {
            const components = [];
            for (let i = 0; i < count; i++) {
                const template = COMPONENT_TEMPLATES[Math.floor(Math.random() * COMPONENT_TEMPLATES.length)];
                const tier = Math.floor(Math.random() * (maxTier - minTier + 1)) + minTier;
                components.push(createComponent(template, tier));
            }
            return components;
        }

        function generateRandomMechs(count, tier) {
            const mechs = [];
            const templates = Object.values(MECH_TEMPLATES);
            for (let i = 0; i < count; i++) {
                const template = templates[Math.floor(Math.random() * templates.length)];
                mechs.push(createMech(template, tier));
            }
            return mechs;
        }

        function calculateMechStats(mech) {
            let totalDamage = 0;
            let totalArmor = mech.baseArmor;
            let totalTier = 0;

            const traits = mech.traits || [];

            Object.values(mech.loadout).forEach(component => {
                if (component) {
                    totalDamage += component.damage;
                    totalArmor += component.armor;

                    // Apply EFFICIENT trait/ability - reduce tier cost
                    let compTier = component.tier;
                    if (traits.some(t => t.name === 'EFFICIENT')) {
                        compTier = Math.max(1, compTier - 2);
                    } else if (component.abilities && component.abilities.includes('EFFICIENT')) {
                        compTier = Math.max(1, compTier - 1);
                    }

                    // Apply ALL_IN relic - abilities cost double tier
                    if (game.relics && game.relics.includes('ALL_IN') && component.abilities) {
                        component.abilities.forEach(abilityKey => {
                            const ability = ABILITIES[abilityKey];
                            if (ability && abilityKey !== 'EFFICIENT') {
                                compTier += ability.tier; // Adds double (once here, once below)
                            }
                        });
                    }

                    totalTier += compTier;

                    // Add ability tier costs
                    if (component.abilities) {
                        component.abilities.forEach(abilityKey => {
                            const ability = ABILITIES[abilityKey];
                            if (ability && abilityKey !== 'EFFICIENT') {
                                totalTier += ability.tier;
                            }
                        });
                    }
                }
            });

            // Apply FORTRESS trait - double armor
            if (traits.some(t => t.name === 'FORTRESS')) {
                totalArmor *= 2;
            }

            // Apply VAMPIRE trait - reduce armor
            if (traits.some(t => t.name === 'VAMPIRE')) {
                totalArmor = Math.floor(totalArmor * 0.7);
            }

            // Apply FORTRESS_PROTOCOL relic - double armor
            if (game.relics && game.relics.includes('FORTRESS_PROTOCOL')) {
                totalArmor *= 2;
            }

            // Apply MOMENTUM_DRIVE relic - tier ‚Üí damage
            if (game.relics && game.relics.includes('MOMENTUM_DRIVE')) {
                totalDamage += totalTier * 2;
            }

            // Add permanent damage bonus from Hunter's Mark
            if (game.permanentDamageBonus) {
                totalDamage += game.permanentDamageBonus;
            }

            return {
                damage: totalDamage,
                armor: totalArmor,
                tierUsed: totalTier
            };
        }

        function canAttachComponent(mech, component, slotName) {
            // Check slot type matches
            if (component.slot !== slotName) return false;

            // Calculate if adding this would exceed tier limit
            const currentStats = calculateMechStats(mech);
            let newTier = currentStats.tierUsed + component.tier;

            // Add ability tier costs for new component
            if (component.abilities) {
                component.abilities.forEach(abilityKey => {
                    const ability = ABILITIES[abilityKey];
                    if (ability && abilityKey !== 'EFFICIENT') {
                        newTier += ability.tier;
                    }
                });
            }

            // If slot is filled, subtract the old component's contribution
            if (mech.loadout[slotName]) {
                const oldComp = mech.loadout[slotName];
                let oldTier = oldComp.tier;
                if (oldComp.abilities) {
                    oldComp.abilities.forEach(abilityKey => {
                        const ability = ABILITIES[abilityKey];
                        if (ability && abilityKey !== 'EFFICIENT') {
                            oldTier += ability.tier;
                        }
                    });
                }
                newTier -= oldTier;
            }

            // Apply SCAVENGER relic - +3 inventory slots
            let tierCap = mech.tierCapacity;
            if (game.relics && game.relics.includes('SCAVENGER')) {
                tierCap += 10; // Extra tier budget
            }

            if (newTier > tierCap) return false;

            return true;
        }

        function attachComponent(mech, component, slotName) {
            if (!canAttachComponent(mech, component, slotName)) {
                return false;
            }

            // Remove from old slot if it's already attached
            Object.keys(mech.loadout).forEach(key => {
                if (mech.loadout[key]?.id === component.id) {
                    delete mech.loadout[key];
                }
            });

            // Remove old component from slot and return it to inventory
            if (mech.loadout[slotName]) {
                const oldComp = mech.loadout[slotName];
                game.inventory.push(oldComp);
            }

            // Attach new component
            mech.loadout[slotName] = component;

            // Remove from inventory
            const invIndex = game.inventory.findIndex(c => c.id === component.id);
            if (invIndex !== -1) {
                game.inventory.splice(invIndex, 1);
            }

            game.save();
            return true;
        }

        function detachComponent(mech, slotName) {
            if (mech.loadout[slotName]) {
                const component = mech.loadout[slotName];
                game.inventory.push(component);
                delete mech.loadout[slotName];
                game.save();
                return true;
            }
            return false;
        }

        // ============================================================================
        // MONSTER GENERATION
        // ============================================================================

        function generateMonster(round) {
            const difficultyMultiplier = 1 + ((round - 1) * 0.2);
            const isBoss = round % 5 === 0;

            if (isBoss) {
                // Boss fight every 5 rounds
                const bossTypes = [
                    {
                        name: 'FORTRESS TITAN',
                        visual: 'üè∞',
                        hp: 200,
                        damage: 20,
                        armor: 40,
                        special: 'ARMORED',
                        desc: 'Massive armor - Energy weapons recommended!'
                    },
                    {
                        name: 'PLASMA STORM',
                        visual: '‚ö°',
                        hp: 120,
                        damage: 45,
                        armor: 5,
                        special: 'SHIELD_IGNORE',
                        desc: 'Ignores shields and armor!'
                    },
                    {
                        name: 'BERSERKER PRIME',
                        visual: 'üòà',
                        hp: 150,
                        damage: 25,
                        armor: 10,
                        special: 'RAGE',
                        desc: 'Gains damage as HP drops!'
                    },
                    {
                        name: 'MIRROR WRAITH',
                        visual: 'üëª',
                        hp: 100,
                        damage: 30,
                        armor: 10,
                        special: 'REFLECT',
                        desc: 'Reflects 50% of damage taken!'
                    }
                ];

                const boss = bossTypes[Math.floor(Math.random() * bossTypes.length)];
                return {
                    name: boss.name,
                    visual: boss.visual,
                    maxHP: Math.floor(boss.hp * difficultyMultiplier),
                    currentHP: Math.floor(boss.hp * difficultyMultiplier),
                    damage: Math.floor(boss.damage * difficultyMultiplier),
                    armor: Math.floor(boss.armor * difficultyMultiplier),
                    speed: 50 + Math.floor(Math.random() * 30),
                    special: boss.special,
                    isBoss: true,
                    description: boss.desc
                };
            } else {
                // Regular enemies with variety
                const monsterTypes = [
                    { name: 'Scrap Bot', visual: 'ü§ñ', hp: 60, damage: 15, armor: 5, special: null },
                    { name: 'War Drone', visual: 'üëæ', hp: 80, damage: 20, armor: 8, special: 'FAST' },
                    { name: 'Battle Mech', visual: 'ü¶æ', hp: 100, damage: 25, armor: 10, special: null },
                    { name: 'Tank Unit', visual: 'üöõ', hp: 120, damage: 18, armor: 15, special: 'ARMORED' },
                    { name: 'Hunter Killer', visual: 'üíÄ', hp: 70, damage: 35, armor: 5, special: 'CRITICAL' },
                    { name: 'Shield Bot', visual: 'üõ°Ô∏è', hp: 90, damage: 18, armor: 8, special: 'SHIELD' }
                ];

                const baseMonster = monsterTypes[Math.floor(Math.random() * monsterTypes.length)];

                return {
                    name: `${baseMonster.name} Mk.${Math.ceil(round / 2)}`,
                    visual: baseMonster.visual,
                    maxHP: Math.floor(baseMonster.hp * difficultyMultiplier),
                    currentHP: Math.floor(baseMonster.hp * difficultyMultiplier),
                    damage: Math.floor(baseMonster.damage * difficultyMultiplier),
                    armor: Math.floor(baseMonster.armor * difficultyMultiplier),
                    speed: 50 + Math.floor(Math.random() * 30),
                    special: baseMonster.special,
                    isBoss: false
                };
            }
        }

        // ============================================================================
        // PHYSICS COMBAT VISUALIZATION SYSTEM
        // ============================================================================

        class PhysicsEngine {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');

                // Matter.js aliases
                const Engine = Matter.Engine;
                const Render = Matter.Render;
                const World = Matter.World;
                const Bodies = Matter.Bodies;
                const Body = Matter.Body;
                const Composite = Matter.Composite;
                const Constraint = Matter.Constraint;
                const Events = Matter.Events;

                // Create engine with custom gravity
                this.engine = Engine.create();
                this.engine.gravity.y = 1.2; // Increased gravity for better feel
                this.world = this.engine.world;

                // Canvas dimensions (pixelated low-res)
                this.width = 800;
                this.height = 450;

                // Render scale
                this.scale = 1;

                // Animation settings
                this.running = false;
                this.effectsEnabled = true;
                this.timeScale = 1;

                // Entities
                this.playerMech = null;
                this.enemyMech = null;
                this.terrain = [];
                this.projectiles = [];
                this.particles = [];

                // Camera shake
                this.cameraShake = { x: 0, y: 0, intensity: 0 };

                // Colors
                this.colors = {
                    player: '#00ff88',
                    enemy: '#ff4444',
                    terrain: '#4a4a6a',
                    explosion: '#ff6600',
                    energy: '#00ccff',
                    kinetic: '#ffaa00',
                    background: '#0d0d1f',
                    sky: '#1a1a3e'
                };

                // Initialize
                this.createTerrain();
                this.setupRenderLoop();
            }

            createTerrain() {
                const Bodies = Matter.Bodies;
                const groundHeight = 40;
                const platformY = this.height - groundHeight;

                // Main ground
                const ground = Bodies.rectangle(this.width / 2, this.height - groundHeight / 2, this.width, groundHeight, {
                    isStatic: true,
                    friction: 0.8,
                    render: { fillStyle: this.colors.terrain }
                });
                Matter.World.add(this.world, ground);

                // Destructible terrain blocks
                const blockSize = 20;
                const numBlocks = 15;

                for (let i = 0; i < numBlocks; i++) {
                    const x = 150 + i * (blockSize + 2) + Math.random() * 50;
                    const y = platformY - blockSize - Math.random() * 100;

                    // Random block configurations
                    const isLarge = Math.random() > 0.7;
                    const size = isLarge ? blockSize * 1.5 : blockSize;

                    const block = Bodies.rectangle(x, y, size, size, {
                        friction: 0.6,
                        restitution: 0.3,
                        density: 0.001,
                        label: 'terrain',
                        render: { fillStyle: this.colors.terrain }
                    });

                    Matter.World.add(this.world, block);
                    this.terrain.push(block);
                }
            }

            createMech(type, x, y, isPlayer) {
                const Bodies = Matter.Bodies;
                const Constraint = Matter.Constraint;
                const Composite = Matter.Composite;
                const Body = Matter.Body;

                // Size based on mech class
                let scale = 1;
                if (type === 'Light') scale = 0.8;
                if (type === 'Heavy') scale = 1.3;

                const baseSize = 30;
                const size = baseSize * scale;

                // Create body parts
                const torso = Bodies.rectangle(x, y, size * 1.2, size * 1.5, {
                    density: 0.002,
                    friction: 0.8,
                    restitution: 0.1,
                    label: isPlayer ? 'player_torso' : 'enemy_torso'
                });

                const head = Bodies.circle(x, y - size, size * 0.5, {
                    density: 0.001,
                    friction: 0.5,
                    label: isPlayer ? 'player_head' : 'enemy_head'
                });

                const leftArm = Bodies.rectangle(x - size * 0.8, y, size * 0.3, size, {
                    density: 0.001,
                    friction: 0.5,
                    label: isPlayer ? 'player_arm' : 'enemy_arm'
                });

                const rightArm = Bodies.rectangle(x + size * 0.8, y, size * 0.3, size, {
                    density: 0.001,
                    friction: 0.5,
                    label: isPlayer ? 'player_arm' : 'enemy_arm'
                });

                const leftLeg = Bodies.rectangle(x - size * 0.3, y + size * 1.2, size * 0.35, size * 0.8, {
                    density: 0.002,
                    friction: 0.9,
                    label: isPlayer ? 'player_leg' : 'enemy_leg'
                });

                const rightLeg = Bodies.rectangle(x + size * 0.3, y + size * 1.2, size * 0.35, size * 0.8, {
                    density: 0.002,
                    friction: 0.9,
                    label: isPlayer ? 'player_leg' : 'enemy_leg'
                });

                // Create composite mech
                const mech = Composite.create({ label: isPlayer ? 'player_mech' : 'enemy_mech' });

                // Add parts
                Composite.add(mech, [torso, head, leftArm, rightArm, leftLeg, rightLeg]);

                // Constraints (joints) - can be broken for ragdoll
                const constraints = [
                    // Head to torso
                    Constraint.create({
                        bodyA: head,
                        bodyB: torso,
                        pointA: { x: 0, y: size * 0.3 },
                        pointB: { x: 0, y: -size * 0.7 },
                        stiffness: 0.7,
                        length: 0,
                        label: 'neck'
                    }),
                    // Left arm
                    Constraint.create({
                        bodyA: leftArm,
                        bodyB: torso,
                        pointA: { x: 0, y: -size * 0.4 },
                        pointB: { x: -size * 0.5, y: -size * 0.3 },
                        stiffness: 0.5,
                        length: 0,
                        label: 'left_shoulder'
                    }),
                    // Right arm
                    Constraint.create({
                        bodyA: rightArm,
                        bodyB: torso,
                        pointA: { x: 0, y: -size * 0.4 },
                        pointB: { x: size * 0.5, y: -size * 0.3 },
                        stiffness: 0.5,
                        length: 0,
                        label: 'right_shoulder'
                    }),
                    // Left leg
                    Constraint.create({
                        bodyA: leftLeg,
                        bodyB: torso,
                        pointA: { x: 0, y: -size * 0.4 },
                        pointB: { x: -size * 0.2, y: size * 0.7 },
                        stiffness: 0.6,
                        length: 0,
                        label: 'left_hip'
                    }),
                    // Right leg
                    Constraint.create({
                        bodyA: rightLeg,
                        bodyB: torso,
                        pointA: { x: 0, y: -size * 0.4 },
                        pointB: { x: size * 0.2, y: size * 0.7 },
                        stiffness: 0.6,
                        length: 0,
                        label: 'right_hip'
                    })
                ];

                Composite.add(mech, constraints);

                // Add to world
                Matter.World.add(this.world, mech);

                return {
                    composite: mech,
                    torso: torso,
                    head: head,
                    leftArm: leftArm,
                    rightArm: rightArm,
                    leftLeg: leftLeg,
                    rightLeg: rightLeg,
                    constraints: constraints,
                    color: isPlayer ? this.colors.player : this.colors.enemy,
                    scale: scale,
                    isRagdoll: false
                };
            }

            fireProjectile(fromMech, toMech, weaponType, damage) {
                const Bodies = Matter.Bodies;
                const Body = Matter.Body;

                const startX = fromMech.torso.position.x;
                const startY = fromMech.torso.position.y;
                const targetX = toMech.torso.position.x;
                const targetY = toMech.torso.position.y;

                let projectile;

                if (weaponType === 'EXPLOSIVE') {
                    // Ballistic trajectory rocket
                    const angle = Math.atan2(targetY - startY, targetX - startX);
                    const power = 15 + Math.random() * 5;
                    const arcBoost = -8; // Upward boost for arc

                    projectile = Bodies.circle(startX, startY, 8, {
                        density: 0.001,
                        restitution: 0.3,
                        friction: 0.1,
                        label: 'rocket'
                    });

                    Body.setVelocity(projectile, {
                        x: Math.cos(angle) * power,
                        y: Math.sin(angle) * power + arcBoost
                    });

                    projectile.render.fillStyle = this.colors.explosion;
                    projectile.damage = damage;
                    projectile.type = 'EXPLOSIVE';
                    projectile.trail = [];

                } else if (weaponType === 'KINETIC') {
                    // Fast bullet
                    const angle = Math.atan2(targetY - startY, targetX - startX);
                    const speed = 25;

                    projectile = Bodies.circle(startX, startY, 4, {
                        density: 0.0005,
                        restitution: 0.8,
                        friction: 0.05,
                        label: 'bullet'
                    });

                    Body.setVelocity(projectile, {
                        x: Math.cos(angle) * speed,
                        y: Math.sin(angle) * speed
                    });

                    projectile.render.fillStyle = this.colors.kinetic;
                    projectile.damage = damage;
                    projectile.type = 'KINETIC';

                } else if (weaponType === 'ENERGY') {
                    // Energy beam (instant raycast) - damage handled by battle system
                    this.createEnergyBeam(startX, startY, targetX, targetY, damage);
                    if (toMech.battleSystem) {
                        toMech.battleSystem.applyDamageToMech(toMech, damage, 'ENERGY');
                    }
                    return null;
                }

                Matter.World.add(this.world, projectile);
                this.projectiles.push(projectile);

                // Check for impacts - collision will call battle system
                this.setupProjectileCollision(projectile, toMech);

                return projectile; // Return for battle system to attach metadata
            }

            createEnergyBeam(x1, y1, x2, y2, damage) {
                const beam = {
                    x1, y1, x2, y2,
                    life: 30, // frames
                    width: 4,
                    color: this.colors.energy,
                    damage: damage
                };
                this.particles.push(beam);
            }

            setupProjectileCollision(projectile, targetMech) {
                const Events = Matter.Events;

                Events.on(this.engine, 'collisionStart', (event) => {
                    event.pairs.forEach(pair => {
                        const { bodyA, bodyB } = pair;

                        // Check if projectile hit target
                        if ((bodyA === projectile || bodyB === projectile)) {
                            const other = bodyA === projectile ? bodyB : bodyA;

                            // Hit enemy mech
                            if (other.label && other.label.includes(targetMech === this.enemyMech ? 'enemy' : 'player')) {
                                // Apply physics effects (knockback, ragdoll)
                                this.applyPhysicalImpact(targetMech, projectile.damage, projectile.type);

                                // Apply gameplay damage through battle system
                                if (projectile.battleSystem) {
                                    projectile.battleSystem.applyDamageToMech(targetMech, projectile.damage, projectile.type);
                                }

                                this.createImpactEffect(other.position.x, other.position.y, projectile.type);
                                Matter.World.remove(this.world, projectile);
                                this.projectiles = this.projectiles.filter(p => p !== projectile);
                            }
                            // Hit terrain
                            else if (other.label === 'terrain') {
                                if (projectile.type === 'EXPLOSIVE') {
                                    this.createExplosion(other.position.x, other.position.y, 80);
                                    Matter.World.remove(this.world, other);
                                    this.terrain = this.terrain.filter(t => t !== other);
                                }
                                this.createImpactEffect(other.position.x, other.position.y, projectile.type);
                                Matter.World.remove(this.world, projectile);
                                this.projectiles = this.projectiles.filter(p => p !== projectile);
                            }
                        }
                    });
                });
            }

            applyPhysicalImpact(mech, damage, type) {
                const Body = Matter.Body;

                // Apply knockback force
                const force = type === 'EXPLOSIVE' ? 0.015 :
                             type === 'KINETIC' ? 0.008 : 0.003;

                const direction = mech === this.playerMech ? -1 : 1;

                Body.applyForce(mech.torso, mech.torso.position, {
                    x: direction * force * (1 + Math.random() * 0.5),
                    y: -force * 0.3
                });

                // Camera shake
                this.addCameraShake(damage / 20);
            }

            enableRagdoll(mech) {
                const Composite = Matter.Composite;

                // Remove some constraints for ragdoll effect
                mech.constraints.forEach(constraint => {
                    constraint.stiffness *= 0.3; // Make joints looser
                });

                mech.isRagdoll = true;

                // Auto-recover after time
                setTimeout(() => {
                    mech.constraints.forEach(constraint => {
                        constraint.stiffness /= 0.3; // Restore stiffness
                    });
                    mech.isRagdoll = false;
                }, 2000);
            }

            createExplosion(x, y, radius) {
                const Body = Matter.Body;
                const Query = Matter.Query;

                // Create explosion particles
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 3 + Math.random() * 5;

                    this.particles.push({
                        x, y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 30 + Math.random() * 30,
                        maxLife: 60,
                        size: 3 + Math.random() * 5,
                        color: Math.random() > 0.5 ? this.colors.explosion : '#ffaa00',
                        type: 'explosion'
                    });
                }

                // Apply force to nearby bodies
                const nearbyBodies = Query.region(Matter.Composite.allBodies(this.world), {
                    min: { x: x - radius, y: y - radius },
                    max: { x: x + radius, y: y + radius }
                });

                nearbyBodies.forEach(body => {
                    if (!body.isStatic) {
                        const dist = Math.hypot(body.position.x - x, body.position.y - y);
                        const forceMag = Math.max(0, (radius - dist) / radius) * 0.02;
                        const angle = Math.atan2(body.position.y - y, body.position.x - x);

                        Body.applyForce(body, body.position, {
                            x: Math.cos(angle) * forceMag,
                            y: Math.sin(angle) * forceMag
                        });
                    }
                });

                this.addCameraShake(8);
            }

            createImpactEffect(x, y, type) {
                const color = type === 'EXPLOSIVE' ? this.colors.explosion :
                             type === 'KINETIC' ? this.colors.kinetic :
                             this.colors.energy;

                for (let i = 0; i < 10; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 3;

                    this.particles.push({
                        x, y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 20 + Math.random() * 20,
                        maxLife: 40,
                        size: 2 + Math.random() * 3,
                        color: color,
                        type: 'impact'
                    });
                }

                this.addCameraShake(2);
            }

            addCameraShake(intensity) {
                this.cameraShake.intensity += intensity;
            }

            updateCameraShake() {
                if (this.cameraShake.intensity > 0) {
                    this.cameraShake.x = (Math.random() - 0.5) * this.cameraShake.intensity;
                    this.cameraShake.y = (Math.random() - 0.5) * this.cameraShake.intensity;
                    this.cameraShake.intensity *= 0.9; // Decay

                    if (this.cameraShake.intensity < 0.1) {
                        this.cameraShake.intensity = 0;
                        this.cameraShake.x = 0;
                        this.cameraShake.y = 0;
                    }
                }
            }

            setupRenderLoop() {
                const Engine = Matter.Engine;

                const animate = () => {
                    if (this.running) {
                        // Update physics
                        Engine.update(this.engine, 1000 / 60 * this.timeScale);

                        // Update particles
                        this.updateParticles();

                        // Update camera shake
                        this.updateCameraShake();

                        // Render
                        this.render();
                    }

                    requestAnimationFrame(animate);
                };

                animate();
            }

            updateParticles() {
                this.particles = this.particles.filter(p => {
                    p.life--;

                    if (p.type === 'explosion' || p.type === 'impact') {
                        p.x += p.vx;
                        p.y += p.vy;
                        p.vy += 0.2; // Gravity
                    }

                    return p.life > 0;
                });
            }

            render() {
                const ctx = this.ctx;

                // Clear
                ctx.fillStyle = this.colors.background;
                ctx.fillRect(0, 0, this.width, this.height);

                // Sky gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, this.height);
                gradient.addColorStop(0, this.colors.sky);
                gradient.addColorStop(1, this.colors.background);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.width, this.height * 0.7);

                // Apply camera shake
                ctx.save();
                ctx.translate(this.cameraShake.x, this.cameraShake.y);

                // Render terrain
                this.renderBodies(Matter.Composite.allBodies(this.world), ctx);

                // Render particles
                if (this.effectsEnabled) {
                    this.renderParticles(ctx);
                }

                // Render mechs with custom rendering
                if (this.playerMech) this.renderMech(this.playerMech, ctx);
                if (this.enemyMech) this.renderMech(this.enemyMech, ctx);

                // Render health bars
                if (this.playerMech) this.renderHealthBar(this.playerMech, ctx);
                if (this.enemyMech) this.renderHealthBar(this.enemyMech, ctx);

                ctx.restore();
            }

            renderHealthBar(mech, ctx) {
                if (!mech.currentHP || !mech.maxHP) return;

                const x = mech.torso.position.x;
                const y = mech.torso.position.y - 60;
                const width = 80;
                const height = 8;

                // Background
                ctx.fillStyle = '#000';
                ctx.fillRect(x - width/2 - 1, y - 1, width + 2, height + 2);

                // Health bar
                const healthPercent = mech.currentHP / mech.maxHP;
                const healthWidth = Math.max(0, (width * healthPercent));

                // Color based on health
                if (healthPercent > 0.6) {
                    ctx.fillStyle = '#00ff88';
                } else if (healthPercent > 0.3) {
                    ctx.fillStyle = '#ffaa00';
                } else {
                    ctx.fillStyle = '#ff4444';
                }

                ctx.fillRect(x - width/2, y, healthWidth, height);

                // Shield bar
                if (mech.shield && mech.shield > 0) {
                    const shieldY = y - 10;
                    const shieldMax = 50; // Estimate
                    const shieldPercent = Math.min(1, mech.shield / shieldMax);
                    const shieldWidth = width * shieldPercent;

                    ctx.fillStyle = '#00ccff';
                    ctx.fillRect(x - width/2, shieldY, shieldWidth, 4);
                }

                // HP text
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`${Math.max(0, Math.floor(mech.currentHP))}/${mech.maxHP}`, x, y - 5);
            }

            renderBodies(bodies, ctx) {
                bodies.forEach(body => {
                    if (body.label && (body.label.includes('player') || body.label.includes('enemy'))) {
                        return; // Skip mech parts, we render them separately
                    }

                    const vertices = body.vertices;
                    ctx.beginPath();
                    ctx.moveTo(vertices[0].x, vertices[0].y);

                    for (let i = 1; i < vertices.length; i++) {
                        ctx.lineTo(vertices[i].x, vertices[i].y);
                    }

                    ctx.closePath();
                    ctx.fillStyle = body.render.fillStyle || this.colors.terrain;
                    ctx.fill();

                    // Pixel-art outline
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            }

            renderMech(mech, ctx) {
                // Save context
                ctx.save();

                const scale = mech.scale || 1;
                const baseColor = mech.color;
                const darkColor = this.darkenColor(baseColor, 0.6);
                const lightColor = this.lightenColor(baseColor, 1.3);

                // Render mech components in proper order (back to front)
                this.renderMechLegs(mech, ctx, scale, baseColor, darkColor, lightColor);
                this.renderMechTorso(mech, ctx, scale, baseColor, darkColor, lightColor);
                this.renderMechArms(mech, ctx, scale, baseColor, darkColor, lightColor);
                this.renderMechHead(mech, ctx, scale, baseColor, darkColor, lightColor);

                ctx.restore();
            }

            renderMechLegs(mech, ctx, scale, baseColor, darkColor, lightColor) {
                // Mad Cat inspired reverse-joint legs
                const leftLeg = mech.leftLeg;
                const rightLeg = mech.rightLeg;
                const loadout = mech.loadout || {};
                const legsComponent = loadout.legs;
                const mechClass = mech.mechClass || 'Medium';

                [leftLeg, rightLeg].forEach((leg, index) => {
                    const isLeft = index === 0;
                    const legX = leg.position.x;
                    const legY = leg.position.y;
                    const angle = leg.angle;

                    ctx.save();
                    ctx.translate(legX, legY);
                    ctx.rotate(angle);

                    // Adjust size based on mech class
                    let sizeMultiplier = 1;
                    let legThickness = 12;
                    if (mechClass === 'Light') {
                        sizeMultiplier = 0.85;
                        legThickness = 10;
                    }
                    if (mechClass === 'Heavy') {
                        sizeMultiplier = 1.2;
                        legThickness = 14;
                    }

                    // Upper leg (thigh) - angular armored
                    ctx.fillStyle = baseColor;
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.rect(-legThickness/2 * scale, -15 * scale * sizeMultiplier, legThickness * scale, 18 * scale * sizeMultiplier);
                    ctx.fill();
                    ctx.stroke();

                    // Knee joint - exposed mechanical, larger for heavy mechs
                    const kneeSize = mechClass === 'Heavy' ? 6 : 5;
                    ctx.fillStyle = darkColor;
                    ctx.beginPath();
                    ctx.arc(0, 5 * scale * sizeMultiplier, kneeSize * scale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Lower leg (reverse joint) - characteristic Mad Cat feature
                    ctx.fillStyle = lightColor;
                    ctx.beginPath();
                    ctx.rect(-5 * scale * sizeMultiplier, 5 * scale * sizeMultiplier, 10 * scale * sizeMultiplier, 15 * scale * sizeMultiplier);
                    ctx.fill();
                    ctx.stroke();

                    // Foot - wider for Heavy, sleeker for Light
                    const footWidth = mechClass === 'Heavy' ? 18 : mechClass === 'Light' ? 14 : 16;
                    ctx.fillStyle = darkColor;
                    ctx.beginPath();
                    ctx.rect(-footWidth/2 * scale * sizeMultiplier, 18 * scale * sizeMultiplier, footWidth * scale * sizeMultiplier, 6 * scale * sizeMultiplier);
                    ctx.fill();
                    ctx.stroke();

                    // Jump jets for Light mechs with boosters
                    if (mechClass === 'Light' && legsComponent && legsComponent.name && legsComponent.name.includes('Boost')) {
                        ctx.fillStyle = '#4dd2ff';
                        ctx.globalAlpha = 0.6;
                        ctx.beginPath();
                        ctx.rect(-3 * scale, 10 * scale * sizeMultiplier, 6 * scale, 4 * scale);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }

                    // Hydraulic details - more for Heavy mechs
                    ctx.strokeStyle = darkColor;
                    ctx.lineWidth = 2 * scale;
                    const hydraulicCount = mechClass === 'Heavy' ? 2 : 1;
                    for (let i = 0; i < hydraulicCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo((-3 + i * 6) * scale, -10 * scale * sizeMultiplier);
                        ctx.lineTo((-3 + i * 6) * scale, 15 * scale * sizeMultiplier);
                        ctx.stroke();
                    }

                    ctx.restore();
                });
            }

            renderMechTorso(mech, ctx, scale, baseColor, darkColor, lightColor) {
                const torso = mech.torso;
                const torsoX = torso.position.x;
                const torsoY = torso.position.y;
                const angle = torso.angle;
                const loadout = mech.loadout || {};
                const torsoComponent = loadout.torso;
                const mechClass = mech.mechClass || 'Medium';

                ctx.save();
                ctx.translate(torsoX, torsoY);
                ctx.rotate(angle);

                // Adjust size based on mech class
                let sizeMultiplier = 1;
                if (mechClass === 'Light') sizeMultiplier = 0.9;
                if (mechClass === 'Heavy') sizeMultiplier = 1.15;

                // Main torso chassis - boxy Mad Cat style
                ctx.fillStyle = baseColor;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.rect(-18 * scale * sizeMultiplier, -22 * scale * sizeMultiplier, 36 * scale * sizeMultiplier, 44 * scale * sizeMultiplier);
                ctx.fill();
                ctx.stroke();

                // Cockpit area - angular center section
                ctx.fillStyle = lightColor;
                ctx.beginPath();
                ctx.rect(-8 * scale * sizeMultiplier, -18 * scale * sizeMultiplier, 16 * scale * sizeMultiplier, 12 * scale * sizeMultiplier);
                ctx.fill();
                ctx.stroke();

                // Viewport/canopy
                ctx.fillStyle = '#4dd2ff';
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.rect(-5 * scale * sizeMultiplier, -16 * scale * sizeMultiplier, 10 * scale * sizeMultiplier, 6 * scale * sizeMultiplier);
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.stroke();

                // Armor panels - enhanced if torso component equipped
                if (torsoComponent) {
                    const armorColor = torsoComponent.name && torsoComponent.name.includes('Heavy') ? '#4a4a4a' : darkColor;
                    const armorThickness = torsoComponent.armor > 10 ? 6 : 5;

                    // Heavy armor plating
                    ctx.fillStyle = armorColor;
                    ctx.beginPath();
                    ctx.rect(-18 * scale * sizeMultiplier, -5 * scale * sizeMultiplier, armorThickness * scale, 20 * scale * sizeMultiplier);
                    ctx.fill();
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.rect((18 - armorThickness) * scale * sizeMultiplier, -5 * scale * sizeMultiplier, armorThickness * scale, 20 * scale * sizeMultiplier);
                    ctx.fill();
                    ctx.stroke();

                    // Additional armor plates for heavy components
                    if (torsoComponent.armor > 15) {
                        ctx.beginPath();
                        ctx.rect(-10 * scale * sizeMultiplier, 8 * scale * sizeMultiplier, 20 * scale * sizeMultiplier, 3 * scale);
                        ctx.fill();
                        ctx.stroke();
                    }
                } else {
                    // Standard armor panels
                    ctx.fillStyle = darkColor;
                    ctx.beginPath();
                    ctx.rect(-18 * scale * sizeMultiplier, -5 * scale * sizeMultiplier, 5 * scale, 20 * scale * sizeMultiplier);
                    ctx.fill();
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.rect(13 * scale * sizeMultiplier, -5 * scale * sizeMultiplier, 5 * scale, 20 * scale * sizeMultiplier);
                    ctx.fill();
                    ctx.stroke();
                }

                // Center vent details
                ctx.strokeStyle = darkColor;
                ctx.lineWidth = 1.5;
                const ventCount = mechClass === 'Heavy' ? 4 : 3;
                for (let i = 0; i < ventCount; i++) {
                    ctx.beginPath();
                    ctx.moveTo(-6 * scale * sizeMultiplier, (i * 4 - 2) * scale);
                    ctx.lineTo(6 * scale * sizeMultiplier, (i * 4 - 2) * scale);
                    ctx.stroke();
                }

                // Power core indicator - brighter for Light mechs
                const coreColor = mechClass === 'Light' ? '#00ffff' : '#ff6b35';
                ctx.fillStyle = coreColor;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.arc(0, 8 * scale, 3 * scale * sizeMultiplier, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;

                ctx.restore();
            }

            renderMechArms(mech, ctx, scale, baseColor, darkColor, lightColor) {
                const leftArm = mech.leftArm;
                const rightArm = mech.rightArm;
                const loadout = mech.loadout || {};

                [leftArm, rightArm].forEach((arm, index) => {
                    const isLeft = index === 0;
                    const armX = arm.position.x;
                    const armY = arm.position.y;
                    const angle = arm.angle;

                    // Get equipped components for this side
                    const armSlot = isLeft ? 'leftArm' : 'rightArm';
                    const shoulderSlot = isLeft ? 'leftShoulder' : 'rightShoulder';
                    const armComponent = loadout[armSlot];
                    const shoulderComponent = loadout[shoulderSlot];

                    ctx.save();
                    ctx.translate(armX, armY);
                    ctx.rotate(angle);

                    // Shoulder mount - varies based on equipped shoulder component
                    if (shoulderComponent) {
                        this.renderShoulderWeapon(ctx, scale, shoulderComponent, darkColor);
                    } else {
                        // Default shoulder mount
                        ctx.fillStyle = darkColor;
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, -12 * scale, 6 * scale, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }

                    // Upper arm
                    ctx.fillStyle = baseColor;
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.rect(-4 * scale, -12 * scale, 8 * scale, 18 * scale);
                    ctx.fill();
                    ctx.stroke();

                    // Forearm/weapon mount - varies based on equipped arm component
                    if (armComponent) {
                        this.renderArmWeapon(ctx, scale, armComponent, lightColor, darkColor);
                    } else {
                        // Default forearm
                        ctx.fillStyle = lightColor;
                        ctx.beginPath();
                        ctx.rect(-5 * scale, 6 * scale, 10 * scale, 14 * scale);
                        ctx.fill();
                        ctx.stroke();

                        // Default actuator
                        ctx.fillStyle = '#666';
                        ctx.beginPath();
                        ctx.rect(-2 * scale, 18 * scale, 4 * scale, 8 * scale);
                        ctx.fill();
                        ctx.stroke();
                    }

                    ctx.restore();
                });
            }

            renderShoulderWeapon(ctx, scale, component, darkColor) {
                const weaponColor = this.getWeaponColor(component);

                // Larger shoulder mount for weapons
                ctx.fillStyle = darkColor;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, -12 * scale, 8 * scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Weapon pod based on type
                if (component.name && component.name.includes('Missile')) {
                    // Missile pods
                    ctx.fillStyle = weaponColor;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.rect((i - 1) * 4 * scale - 2 * scale, -16 * scale, 3 * scale, 6 * scale);
                        ctx.fill();
                        ctx.stroke();
                    }
                } else if (component.name && component.name.includes('Laser')) {
                    // Laser emitter
                    ctx.fillStyle = weaponColor;
                    ctx.beginPath();
                    ctx.rect(-3 * scale, -18 * scale, 6 * scale, 10 * scale);
                    ctx.fill();
                    ctx.stroke();

                    // Emitter tip
                    ctx.fillStyle = '#ff0000';
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.arc(0, -19 * scale, 2 * scale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                } else {
                    // Generic weapon pod
                    ctx.fillStyle = weaponColor;
                    ctx.beginPath();
                    ctx.rect(-4 * scale, -18 * scale, 8 * scale, 8 * scale);
                    ctx.fill();
                    ctx.stroke();
                }
            }

            renderArmWeapon(ctx, scale, component, lightColor, darkColor) {
                const weaponColor = this.getWeaponColor(component);

                // Forearm mount
                ctx.fillStyle = lightColor;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.rect(-5 * scale, 6 * scale, 10 * scale, 14 * scale);
                ctx.fill();
                ctx.stroke();

                // Weapon based on type
                if (component.name && (component.name.includes('Cannon') || component.name.includes('Rifle'))) {
                    // Ballistic weapon - long barrel
                    ctx.fillStyle = weaponColor;
                    ctx.beginPath();
                    ctx.rect(-3 * scale, 18 * scale, 6 * scale, 12 * scale);
                    ctx.fill();
                    ctx.stroke();

                    // Muzzle brake
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.rect(-4 * scale, 28 * scale, 8 * scale, 2 * scale);
                    ctx.fill();
                    ctx.stroke();
                } else if (component.name && component.name.includes('Blade')) {
                    // Melee weapon - blade
                    ctx.fillStyle = '#c0c0c0';
                    ctx.beginPath();
                    ctx.moveTo(0, 18 * scale);
                    ctx.lineTo(-4 * scale, 28 * scale);
                    ctx.lineTo(0, 32 * scale);
                    ctx.lineTo(4 * scale, 28 * scale);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (component.name && component.name.includes('Plasma')) {
                    // Energy weapon - glowing
                    ctx.fillStyle = weaponColor;
                    ctx.beginPath();
                    ctx.rect(-3 * scale, 18 * scale, 6 * scale, 10 * scale);
                    ctx.fill();
                    ctx.stroke();

                    // Energy glow
                    ctx.fillStyle = '#00ffff';
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.arc(0, 28 * scale, 3 * scale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                } else {
                    // Default weapon
                    ctx.fillStyle = weaponColor;
                    ctx.beginPath();
                    ctx.rect(-2 * scale, 18 * scale, 4 * scale, 10 * scale);
                    ctx.fill();
                    ctx.stroke();
                }
            }

            getWeaponColor(component) {
                if (!component || !component.damageType) return '#666';

                switch(component.damageType) {
                    case 'ENERGY': return '#00bfff';
                    case 'KINETIC': return '#808080';
                    case 'EXPLOSIVE': return '#ff6b35';
                    default: return '#666';
                }
            }

            renderMechHead(mech, ctx, scale, baseColor, darkColor, lightColor) {
                const head = mech.head;
                const headX = head.position.x;
                const headY = head.position.y;
                const angle = head.angle;
                const loadout = mech.loadout || {};
                const headComponent = loadout.head;
                const mechClass = mech.mechClass || 'Medium';

                ctx.save();
                ctx.translate(headX, headY);
                ctx.rotate(angle);

                // Adjust size based on mech class
                let sizeMultiplier = 1;
                if (mechClass === 'Light') sizeMultiplier = 0.85;
                if (mechClass === 'Heavy') sizeMultiplier = 1.2;

                // Mad Cat inspired head - angular and aggressive
                ctx.fillStyle = baseColor;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;

                // Main head structure - pentagonal
                ctx.beginPath();
                ctx.moveTo(0, -12 * scale * sizeMultiplier);
                ctx.lineTo(10 * scale * sizeMultiplier, -8 * scale * sizeMultiplier);
                ctx.lineTo(10 * scale * sizeMultiplier, 8 * scale * sizeMultiplier);
                ctx.lineTo(-10 * scale * sizeMultiplier, 8 * scale * sizeMultiplier);
                ctx.lineTo(-10 * scale * sizeMultiplier, -8 * scale * sizeMultiplier);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Sensor arrays (Mad Cat ears) - enhanced if head component has sensors
                const earSize = headComponent && headComponent.name && headComponent.name.includes('Sensor') ? 5 : 4;
                ctx.fillStyle = darkColor;
                ctx.beginPath();
                ctx.rect(-12 * scale * sizeMultiplier, -6 * scale * sizeMultiplier, earSize * scale, 8 * scale * sizeMultiplier);
                ctx.fill();
                ctx.stroke();

                ctx.beginPath();
                ctx.rect((12 - earSize) * scale * sizeMultiplier, -6 * scale * sizeMultiplier, earSize * scale, 8 * scale * sizeMultiplier);
                ctx.fill();
                ctx.stroke();

                // Additional sensor dishes if equipped
                if (headComponent && headComponent.name && headComponent.name.includes('Sensor')) {
                    ctx.fillStyle = '#4dd2ff';
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.arc(-10 * scale * sizeMultiplier, -2 * scale * sizeMultiplier, 2 * scale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(10 * scale * sizeMultiplier, -2 * scale * sizeMultiplier, 2 * scale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                // Main sensor/eye - color varies by component
                const eyeColor = headComponent && headComponent.name && headComponent.name.includes('Advanced') ? '#00ff00' : '#ff0000';
                ctx.fillStyle = eyeColor;
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.arc(0, -2 * scale * sizeMultiplier, 4 * scale * sizeMultiplier, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.stroke();

                // Visor/viewport
                ctx.strokeStyle = eyeColor;
                ctx.lineWidth = 2 * scale;
                ctx.beginPath();
                ctx.moveTo(-6 * scale * sizeMultiplier, -2 * scale * sizeMultiplier);
                ctx.lineTo(6 * scale * sizeMultiplier, -2 * scale * sizeMultiplier);
                ctx.stroke();

                // Antenna for communication systems
                if (headComponent && headComponent.name && headComponent.name.includes('Comm')) {
                    ctx.strokeStyle = darkColor;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(0, -12 * scale * sizeMultiplier);
                    ctx.lineTo(0, -16 * scale * sizeMultiplier);
                    ctx.stroke();

                    ctx.fillStyle = '#ff6b35';
                    ctx.beginPath();
                    ctx.arc(0, -16 * scale * sizeMultiplier, 1.5 * scale, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            darkenColor(color, factor) {
                // Simple color darkening
                const hex = color.replace('#', '');
                const r = Math.max(0, Math.floor(parseInt(hex.substr(0, 2), 16) * factor));
                const g = Math.max(0, Math.floor(parseInt(hex.substr(2, 2), 16) * factor));
                const b = Math.max(0, Math.floor(parseInt(hex.substr(4, 2), 16) * factor));
                return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
            }

            lightenColor(color, factor) {
                // Simple color lightening
                const hex = color.replace('#', '');
                const r = Math.min(255, Math.floor(parseInt(hex.substr(0, 2), 16) * factor));
                const g = Math.min(255, Math.floor(parseInt(hex.substr(2, 2), 16) * factor));
                const b = Math.min(255, Math.floor(parseInt(hex.substr(4, 2), 16) * factor));
                return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
            }

            renderParticles(ctx) {
                this.particles.forEach(p => {
                    if (p.type === 'explosion' || p.type === 'impact') {
                        const alpha = p.life / p.maxLife;
                        ctx.fillStyle = p.color;
                        ctx.globalAlpha = alpha;
                        ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
                        ctx.globalAlpha = 1;
                    } else if (p.x1 !== undefined) {
                        // Energy beam
                        const alpha = p.life / 30;
                        ctx.strokeStyle = p.color;
                        ctx.globalAlpha = alpha;
                        ctx.lineWidth = p.width;
                        ctx.beginPath();
                        ctx.moveTo(p.x1, p.y1);
                        ctx.lineTo(p.x2, p.y2);
                        ctx.stroke();

                        // Glow effect
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = p.color;
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                        ctx.globalAlpha = 1;
                    }
                });
            }

            start() {
                this.running = true;
            }

            stop() {
                this.running = false;
            }

            reset() {
                const World = Matter.World;
                const Composite = Matter.Composite;

                // Clear all bodies except ground
                World.clear(this.world, false);
                this.terrain = [];
                this.projectiles = [];
                this.particles = [];
                this.playerMech = null;
                this.enemyMech = null;

                // Recreate terrain
                this.createTerrain();
            }

            setTimeScale(scale) {
                this.timeScale = scale;
                this.engine.timing.timeScale = scale;
            }
        }

        // ============================================================================
        // PHYSICS BATTLE SYSTEM - Real-time physics-driven combat
        // ============================================================================

        class PhysicsBattleSystem {
            constructor(playerMech, monster, physicsEngine) {
                this.physics = physicsEngine;
                this.playerMechData = JSON.parse(JSON.stringify(playerMech));
                this.monsterData = JSON.parse(JSON.stringify(monster));
                this.log = [];

                // Battle state
                this.isActive = false;
                this.battleResult = null;

                // Combat stats
                this.playerStats = calculateMechStats(this.playerMechData);
                this.playerShield = 0;
                this.monsterShield = 0;
                this.playerDots = [];
                this.monsterDots = [];

                // Abilities and traits
                this.playerAbilities = this.collectAbilities(this.playerMechData);
                this.playerTraits = this.playerMechData.traits || [];

                // Weapon firing
                this.playerFireRate = 0;
                this.enemyFireRate = 0;
                this.lastPlayerShot = 0;
                this.lastEnemyShot = 0;

                // DoT timers
                this.dotInterval = null;
                this.regenInterval = null;

                // Physics mech references
                this.playerPhysMech = null;
                this.enemyPhysMech = null;
            }

            collectAbilities(mech) {
                const abilities = [];
                Object.values(mech.loadout || {}).forEach(comp => {
                    if (comp && comp.abilities) {
                        comp.abilities.forEach(abilityKey => {
                            if (ABILITIES[abilityKey]) {
                                abilities.push(abilityKey);
                            }
                        });
                    }
                });
                return abilities;
            }

            hasAbility(abilityKey) {
                return this.playerAbilities.includes(abilityKey);
            }

            hasTrait(traitName) {
                return this.playerTraits.some(t => t.name === traitName);
            }

            addLog(message, actor = 'system') {
                this.log.push({ message, actor, timestamp: Date.now() });
            }

            async initializeBattle() {
                this.physics.reset();

                // Create physics mechs
                this.playerPhysMech = this.physics.createMech(
                    this.playerMechData.class,
                    200,
                    300,
                    true
                );

                this.enemyPhysMech = this.physics.createMech(
                    this.monsterData.class || 'Medium',
                    600,
                    300,
                    false
                );

                // Add battle stats to physics mechs
                this.playerPhysMech.currentHP = this.playerMechData.currentHP;
                this.playerPhysMech.maxHP = this.playerMechData.maxHP;
                this.playerPhysMech.stats = this.playerStats;
                this.playerPhysMech.battleSystem = this;
                this.playerPhysMech.isPlayer = true;
                this.playerPhysMech.loadout = this.playerMechData.loadout;
                this.playerPhysMech.mechClass = this.playerMechData.class;

                this.enemyPhysMech.currentHP = this.monsterData.currentHP;
                this.enemyPhysMech.maxHP = this.monsterData.maxHP;
                this.enemyPhysMech.stats = {
                    damage: this.monsterData.damage,
                    armor: this.monsterData.armor,
                    speed: this.monsterData.speed || 50
                };
                this.enemyPhysMech.battleSystem = this;
                this.enemyPhysMech.isPlayer = false;
                this.enemyPhysMech.special = this.monsterData.special;
                this.enemyPhysMech.loadout = this.monsterData.loadout || {};
                this.enemyPhysMech.mechClass = this.monsterData.class || 'Medium';

                // Apply start of battle effects
                this.applyStartOfBattleAbilities();
                this.applyMonsterSpecialInit();

                // Calculate fire rates (attacks per second based on speed)
                this.playerFireRate = 1000 + (100 - this.playerStats.speed) * 20; // Faster mechs shoot more often
                this.enemyFireRate = 1000 + (100 - (this.monsterData.speed || 50)) * 20;

                // Start physics
                this.physics.start();
                this.isActive = true;

                // Start combat loop
                this.startCombatLoop();

                // Start DoT ticking
                this.startDoTLoop();

                // Start regeneration
                if (this.hasAbility('REGENERATION')) {
                    this.startRegenLoop();
                }

                this.addLog('‚öîÔ∏è BATTLE START! ‚öîÔ∏è', 'system');
            }

            applyStartOfBattleAbilities() {
                // Shield Generator
                if (this.hasAbility('SHIELD_GEN')) {
                    let shieldAmount = 50;

                    if (game.relics && game.relics.includes('PERFECT_AEGIS')) {
                        const aegisCount = game.relics.filter(r => r === 'PERFECT_AEGIS').length;
                        const multiplier = Math.pow(3, aegisCount);
                        shieldAmount = Math.floor(shieldAmount * multiplier);
                        this.addLog(`üõ°Ô∏è PERFECT AEGIS: Shield multiplied ${multiplier}x!`, 'player');
                    }

                    this.playerShield = shieldAmount;
                    this.playerPhysMech.shield = shieldAmount;
                    this.addLog(`üõ°Ô∏è ENERGY SHIELD: Activated with ${shieldAmount} shield HP`, 'player');
                }
            }

            applyMonsterSpecialInit() {
                if (this.monsterData.special === 'SHIELD') {
                    this.monsterShield = 40;
                    this.enemyPhysMech.shield = 40;
                    this.addLog('üõ°Ô∏è Enemy activated energy shield! (40 shield)', 'monster');
                }

                if (this.monsterData.isBoss && this.monsterData.description) {
                    this.addLog(`‚ö†Ô∏è BOSS: ${this.monsterData.description}`, 'system');
                }
            }

            startCombatLoop() {
                const combatTick = () => {
                    if (!this.isActive) return;

                    const now = Date.now();

                    // Player auto-fire
                    if (now - this.lastPlayerShot > this.playerFireRate && this.playerPhysMech && this.enemyPhysMech) {
                        this.fireWeapon(this.playerPhysMech, this.enemyPhysMech, true);
                        this.lastPlayerShot = now;
                    }

                    // Enemy auto-fire
                    if (now - this.lastEnemyShot > this.enemyFireRate && this.playerPhysMech && this.enemyPhysMech) {
                        this.fireWeapon(this.enemyPhysMech, this.playerPhysMech, false);
                        this.lastEnemyShot = now;
                    }

                    // Check win conditions
                    this.checkBattleEnd();

                    // Continue loop
                    if (this.isActive) {
                        setTimeout(combatTick, 16); // ~60fps
                    }
                };

                combatTick();
            }

            startDoTLoop() {
                this.dotInterval = setInterval(() => {
                    if (!this.isActive) return;

                    // Apply player DoTs to enemy
                    this.playerDots = this.playerDots.filter(dot => {
                        this.applyDirectDamage(this.enemyPhysMech, dot.damage, false, 'DOT');
                        dot.duration--;
                        if (dot.duration === 0) {
                            this.addLog(`üî• ${dot.type.toUpperCase()} expired`, 'player');
                        }
                        return dot.duration > 0;
                    });

                    // Apply enemy DoTs to player
                    this.monsterDots = this.monsterDots.filter(dot => {
                        this.applyDirectDamage(this.playerPhysMech, dot.damage, false, 'DOT');
                        dot.duration--;
                        return dot.duration > 0;
                    });
                }, 1000);
            }

            startRegenLoop() {
                this.regenInterval = setInterval(() => {
                    if (!this.isActive) return;

                    const healAmount = 5;
                    this.playerPhysMech.currentHP = Math.min(
                        this.playerPhysMech.maxHP,
                        this.playerPhysMech.currentHP + healAmount
                    );
                    this.addLog(`üíö REGENERATION: Healed ${healAmount} HP`, 'player');
                }, 1000);
            }

            getDamageType(mech) {
                // Determine damage type from equipped components
                if (mech.isPlayer) {
                    const components = Object.values(this.playerMechData.loadout || {});
                    const types = components.map(c => c?.damageType).filter(Boolean);

                    if (types.includes('EXPLOSIVE')) return 'EXPLOSIVE';
                    if (types.includes('ENERGY')) return 'ENERGY';
                    return 'KINETIC';
                }
                return Math.random() > 0.5 ? 'KINETIC' : 'EXPLOSIVE';
            }

            fireWeapon(fromMech, toMech, isPlayer) {
                if (!fromMech || !toMech) return;

                const weaponType = this.getDamageType(fromMech);
                const baseDamage = isPlayer ? this.calculatePlayerDamage() : this.calculateEnemyDamage();

                // Create physics projectile with damage attached
                const projectile = this.physics.fireProjectile(fromMech, toMech, weaponType, baseDamage);

                // Store combat data on projectile for collision handling
                if (projectile) {
                    projectile.isPlayer = isPlayer;
                    projectile.fromMech = fromMech;
                    projectile.toMech = toMech;
                    projectile.battleSystem = this;
                }
            }

            calculatePlayerDamage() {
                let baseDamage = this.playerStats.damage;

                // Apply trait bonuses
                const hpPercent = (this.playerPhysMech.currentHP / this.playerPhysMech.maxHP) * 100;

                if (hpPercent < 30 && game.relics && game.relics.includes('LAST_STAND')) {
                    baseDamage *= 3;
                }

                if (this.hasTrait('BERSERKER')) {
                    const hpLostPercent = ((this.playerPhysMech.maxHP - this.playerPhysMech.currentHP) / this.playerPhysMech.maxHP) * 100;
                    const bonus = Math.floor(baseDamage * (hpLostPercent * 0.03));
                    baseDamage += bonus;
                }

                if (this.hasTrait('OVERCHARGED')) {
                    baseDamage *= 2;
                }

                return baseDamage;
            }

            calculateEnemyDamage() {
                let baseDamage = this.monsterData.damage;

                if (this.monsterData.special === 'RAGE') {
                    const hpLostPercent = ((this.enemyPhysMech.maxHP - this.enemyPhysMech.currentHP) / this.enemyPhysMech.maxHP) * 100;
                    const bonus = Math.floor(baseDamage * (hpLostPercent * 0.02));
                    baseDamage += bonus;
                }

                return baseDamage;
            }

            applyDamageToMech(mech, damage, weaponType) {
                const isPlayer = mech.isPlayer;
                const targetArmor = isPlayer ? this.playerStats.armor : this.monsterData.armor;
                let armor = targetArmor;

                // ARMORED enemy - double effective armor
                if (!isPlayer && this.monsterData.special === 'ARMORED') {
                    armor *= 2;
                }

                // Armor reduction (max 70% reduction)
                const armorReduction = Math.min(armor * 0.5, damage * 0.7);
                let actualDamage = Math.max(1, Math.floor(damage - armorReduction));

                // Critical strike check
                let isCrit = false;
                if (isPlayer && this.hasAbility('CRITICAL_STRIKE') && Math.random() < 0.25) {
                    actualDamage *= 2;
                    isCrit = true;
                }

                // Apply to shield first
                const shield = isPlayer ? this.playerShield : this.monsterShield;
                if (shield > 0) {
                    if (shield >= actualDamage) {
                        if (isPlayer) {
                            this.playerShield -= actualDamage;
                            mech.shield = this.playerShield;
                        } else {
                            this.monsterShield -= actualDamage;
                            mech.shield = this.monsterShield;
                        }
                        this.addLog(`üõ°Ô∏è Shield absorbed ${actualDamage} damage!`, isPlayer ? 'player' : 'monster');
                        return;
                    } else {
                        const overflow = actualDamage - shield;
                        this.addLog(`üõ°Ô∏è Shield absorbed ${shield} damage, ${overflow} passed through!`, isPlayer ? 'player' : 'monster');
                        if (isPlayer) {
                            this.playerShield = 0;
                            mech.shield = 0;
                        } else {
                            this.monsterShield = 0;
                            mech.shield = 0;
                        }
                        actualDamage = overflow;
                    }
                }

                // Apply to HP
                this.applyDirectDamage(mech, actualDamage, isCrit, weaponType);

                // Apply DoTs
                if (!isPlayer && this.hasAbility('BURN')) {
                    let burnDamage = 5;
                    let burnDuration = 3;

                    if (game.relics && game.relics.includes('CONTAGION')) {
                        const contagionCount = game.relics.filter(r => r === 'CONTAGION').length;
                        const multiplier = Math.pow(2, contagionCount);
                        burnDamage = Math.floor(burnDamage * multiplier);
                        burnDuration = Math.floor(burnDuration * multiplier);
                    }

                    this.playerDots.push({ type: 'burn', damage: burnDamage, duration: burnDuration });
                    this.addLog(`üî• PLASMA BURN: ${burnDamage} dmg/turn for ${burnDuration} turns`, 'player');
                }

                // Vampiric healing
                if (!isPlayer) {
                    let totalHealPercent = 0;
                    if (this.hasAbility('VAMPIRIC')) totalHealPercent += 0.25;
                    if (this.hasTrait('VAMPIRE')) totalHealPercent += 0.4;
                    if (game.relics && game.relics.includes('VAMPIRIC_ASCENSION')) {
                        totalHealPercent += 0.25 * game.relics.filter(r => r === 'VAMPIRIC_ASCENSION').length;
                    }
                    if (game.relics && game.relics.includes('BLOOD_PACT')) {
                        totalHealPercent += 0.5 * game.relics.filter(r => r === 'BLOOD_PACT').length;
                    }

                    if (totalHealPercent > 0) {
                        const heal = Math.floor(actualDamage * totalHealPercent);
                        this.playerPhysMech.currentHP = Math.min(this.playerPhysMech.maxHP, this.playerPhysMech.currentHP + heal);
                        this.addLog(`ü©∏ VAMPIRIC: Healed ${heal} HP (${Math.floor(totalHealPercent * 100)}%)`, 'player');
                    }
                }
            }

            applyDirectDamage(mech, damage, isCrit, source) {
                mech.currentHP -= damage;
                mech.currentHP = Math.max(0, mech.currentHP);

                const critText = isCrit ? ' üí• CRITICAL HIT!' : '';
                const actor = mech.isPlayer ? 'monster' : 'player';
                const target = mech.isPlayer ? 'Player' : 'Enemy';

                if (source !== 'DOT') {
                    this.addLog(`‚öîÔ∏è ${damage} damage dealt!${critText} (${target}: ${Math.max(0, mech.currentHP)}/${mech.maxHP} HP)`, actor);
                }

                // Heavy damage triggers ragdoll
                if (damage > 50 && !mech.isRagdoll) {
                    this.physics.enableRagdoll(mech);
                }
            }

            checkBattleEnd() {
                if (this.playerPhysMech && this.playerPhysMech.currentHP <= 0) {
                    this.endBattle('defeat');
                } else if (this.enemyPhysMech && this.enemyPhysMech.currentHP <= 0) {
                    this.endBattle('victory');
                }
            }

            endBattle(result) {
                if (this.battleResult) return; // Already ended

                this.isActive = false;
                this.battleResult = result;

                // Clear intervals
                if (this.dotInterval) clearInterval(this.dotInterval);
                if (this.regenInterval) clearInterval(this.regenInterval);

                // Death animation
                if (result === 'victory' && this.enemyPhysMech) {
                    this.physics.enableRagdoll(this.enemyPhysMech);
                    this.physics.createExplosion(
                        this.enemyPhysMech.torso.position.x,
                        this.enemyPhysMech.torso.position.y,
                        120
                    );
                } else if (result === 'defeat' && this.playerPhysMech) {
                    this.physics.enableRagdoll(this.playerPhysMech);
                    this.physics.createExplosion(
                        this.playerPhysMech.torso.position.x,
                        this.playerPhysMech.torso.position.y,
                        120
                    );
                }

                this.addLog(result === 'victory' ? 'üéâ VICTORY!' : 'üíÄ DEFEAT!', 'system');
            }

            getState() {
                return {
                    playerMech: {
                        currentHP: this.playerPhysMech ? this.playerPhysMech.currentHP : 0,
                        maxHP: this.playerPhysMech ? this.playerPhysMech.maxHP : 0
                    },
                    monster: {
                        currentHP: this.enemyPhysMech ? this.enemyPhysMech.currentHP : 0,
                        maxHP: this.enemyPhysMech ? this.enemyPhysMech.maxHP : 0
                    },
                    playerShield: this.playerShield,
                    monsterShield: this.monsterShield,
                    isActive: this.isActive,
                    result: this.battleResult
                };
            }
        }

        // ============================================================================
        // BATTLE SYSTEM
        // ============================================================================

        class BattleSystem {
            constructor(playerMech, monster) {
                this.playerMech = JSON.parse(JSON.stringify(playerMech));
                this.monster = JSON.parse(JSON.stringify(monster));
                this.log = [];
                this.turn = 0;

                // Initialize battle state
                this.playerShield = 0;
                this.monsterShield = 0;
                this.playerDots = []; // {type, damage, duration}
                this.monsterDots = [];

                // Collect all player abilities
                this.playerAbilities = this.collectAbilities(this.playerMech);
                this.playerTraits = this.playerMech.traits || [];

                // Apply start-of-battle abilities
                this.applyStartOfBattleAbilities();

                // Apply monster special abilities
                this.applyMonsterSpecialInit();
            }

            collectAbilities(mech) {
                const abilities = [];
                Object.values(mech.loadout || {}).forEach(comp => {
                    if (comp && comp.abilities) {
                        comp.abilities.forEach(abilityKey => {
                            if (ABILITIES[abilityKey]) {
                                abilities.push(abilityKey);
                            }
                        });
                    }
                });
                return abilities;
            }

            applyStartOfBattleAbilities() {
                // Shield Generator
                if (this.playerAbilities.includes('SHIELD_GEN')) {
                    let shieldAmount = 50;

                    // Perfect Aegis relic - 3x shields
                    if (game.relics && game.relics.includes('PERFECT_AEGIS')) {
                        const aegisCount = game.relics.filter(r => r === 'PERFECT_AEGIS').length;
                        const multiplier = Math.pow(3, aegisCount);
                        shieldAmount = Math.floor(shieldAmount * multiplier);
                        this.addLog(`üõ°Ô∏è PERFECT AEGIS: Shield multiplied ${multiplier}x!`, 'player');
                    }

                    this.playerShield = shieldAmount;
                    this.addLog(`üõ°Ô∏è ENERGY SHIELD: Activated with ${shieldAmount} shield HP`, 'player');
                }
            }

            applyMonsterSpecialInit() {
                if (this.monster.special === 'SHIELD') {
                    this.monsterShield = 40;
                    this.addLog('üõ°Ô∏è Enemy activated energy shield! (40 shield)', 'monster');
                }

                if (this.monster.isBoss && this.monster.description) {
                    this.addLog(`‚ö†Ô∏è BOSS: ${this.monster.description}`, 'system');
                }
            }

            addLog(message, actor = 'system') {
                this.log.push({ message, actor, turn: this.turn });
            }

            hasAbility(abilityKey) {
                return this.playerAbilities.includes(abilityKey);
            }

            hasTrait(traitName) {
                return this.playerTraits.some(t => t.name === traitName);
            }

            calculateDamage(isPlayer, targetArmor) {
                const stats = calculateMechStats(this.playerMech);
                let baseDamage = isPlayer ? stats.damage : this.monster.damage;
                const currentArmor = targetArmor;

                // Enemy special abilities
                if (!isPlayer) {
                    // RAGE - gains damage as HP drops (like Berserker)
                    if (this.monster.special === 'RAGE') {
                        const hpLostPercent = ((this.monster.maxHP - this.monster.currentHP) / this.monster.maxHP) * 100;
                        const bonus = Math.floor(baseDamage * (hpLostPercent * 0.02));
                        if (bonus > 0) {
                            baseDamage += bonus;
                            this.addLog(`üòà RAGE: Enemy gains +${bonus} damage from low HP!`, 'monster');
                        }
                    }
                }

                if (isPlayer) {
                    // Last Stand relic - +200% damage if <30% HP, +50 armor
                    const hpPercent = (this.playerMech.currentHP / this.playerMech.maxHP) * 100;
                    if (game.relics && game.relics.includes('LAST_STAND') && hpPercent < 30) {
                        baseDamage *= 3; // +200% = 3x total
                        this.addLog(`‚è±Ô∏è LAST STAND: Below 30% HP - +200% damage!`, 'player');
                    }

                    // Apply trait bonuses
                    if (this.hasTrait('BERSERKER')) {
                        const hpLostPercent = ((this.playerMech.maxHP - this.playerMech.currentHP) / this.playerMech.maxHP) * 100;
                        const bonus = Math.floor(baseDamage * (hpLostPercent * 0.03));
                        if (bonus > 0) {
                            baseDamage += bonus;
                            this.addLog(`üí¢ BERSERKER TRAIT: +${bonus} damage (+3% per 1% HP lost)`, 'player');
                        }
                    }

                    if (this.hasTrait('OVERCHARGED')) {
                        baseDamage *= 2;
                    }

                    // Apply ability bonuses
                    if (this.hasAbility('BERSERKER')) {
                        const hpLostPercent = ((this.playerMech.maxHP - this.playerMech.currentHP) / this.playerMech.maxHP) * 100;
                        const bonus = Math.floor(baseDamage * (hpLostPercent * 0.01));
                        if (bonus > 0) {
                            baseDamage += bonus;
                            this.addLog(`üí¢ Berserker Chip: +${bonus} damage (+1% per 1% HP lost)`, 'player');
                        }
                    }

                    if (this.hasAbility('OVERCHARGE')) {
                        baseDamage *= 2;
                        const selfDamage = Math.floor(this.playerMech.maxHP * 0.1);
                        this.playerMech.currentHP -= selfDamage;
                        this.addLog(`‚ö° OVERCHARGE: Double damage! Cost: ${selfDamage} HP`, 'player');
                    }

                    // Apply damage type scaling relics
                    const loadoutComponents = Object.values(this.playerMech.loadout).filter(c => c);
                    const damageTypes = loadoutComponents.map(c => c.damageType);

                    // Count Energy damage and apply Energy Conduit
                    const energyCount = damageTypes.filter(t => t === DAMAGE_TYPES.ENERGY).length;
                    if (energyCount > 0 && game.relics) {
                        const conduitCount = game.relics.filter(r => r === 'ENERGY_CONDUIT').length;
                        if (conduitCount > 0) {
                            const multiplier = 1 + (0.5 * conduitCount);
                            const oldDmg = baseDamage;
                            baseDamage = Math.floor(baseDamage * multiplier);
                            this.addLog(`üîã ENERGY CONDUIT x${conduitCount}: ${oldDmg} ‚Üí ${baseDamage} damage`, 'player');
                        }
                    }

                    // Count Kinetic damage and apply Kinetic Amplifier
                    const kineticCount = damageTypes.filter(t => t === DAMAGE_TYPES.KINETIC).length;
                    if (kineticCount > 0 && game.relics) {
                        const amplifierCount = game.relics.filter(r => r === 'KINETIC_AMPLIFIER').length;
                        if (amplifierCount > 0) {
                            const multiplier = 1 + (0.5 * amplifierCount);
                            const oldDmg = baseDamage;
                            baseDamage = Math.floor(baseDamage * multiplier);
                            this.addLog(`üéØ KINETIC AMPLIFIER x${amplifierCount}: ${oldDmg} ‚Üí ${baseDamage} damage`, 'player');
                        }
                    }

                    // Count Explosive damage and apply Explosive Catalyst
                    const explosiveCount = damageTypes.filter(t => t === DAMAGE_TYPES.EXPLOSIVE).length;
                    if (explosiveCount > 0 && game.relics) {
                        const catalystCount = game.relics.filter(r => r === 'EXPLOSIVE_CATALYST').length;
                        if (catalystCount > 0) {
                            const multiplier = 1 + (0.5 * catalystCount);
                            const oldDmg = baseDamage;
                            baseDamage = Math.floor(baseDamage * multiplier);
                            this.addLog(`üí£ EXPLOSIVE CATALYST x${catalystCount}: ${oldDmg} ‚Üí ${baseDamage} damage`, 'player');
                        }
                    }

                    // Glass Cannon Core - 2x all damage (stacks multiplicatively)
                    if (game.relics && game.relics.includes('GLASS_CANNON_CORE')) {
                        const glassCount = game.relics.filter(r => r === 'GLASS_CANNON_CORE').length;
                        const multiplier = Math.pow(2, glassCount);
                        baseDamage = Math.floor(baseDamage * multiplier);
                        this.addLog(`üíé GLASS CANNON CORE: ${multiplier}x damage multiplier!`, 'player');
                    }
                }

                // Critical strike
                let isCrit = false;
                if (isPlayer && (this.hasAbility('CRITICAL_STRIKE') || this.hasTrait('CRITICAL_CORE') || (game.relics && game.relics.includes('CRITICAL_MASS')))) {
                    let critChance = this.hasTrait('CRITICAL_CORE') ? 0.30 : (this.hasAbility('CRITICAL_STRIKE') ? 0.25 : 0);
                    let critMultiplier = this.hasTrait('CRITICAL_CORE') ? 3 : 2;

                    // Critical Mass relic - +10% crit chance, +50% crit damage
                    if (game.relics && game.relics.includes('CRITICAL_MASS')) {
                        const massCount = game.relics.filter(r => r === 'CRITICAL_MASS').length;
                        critChance += 0.10 * massCount;
                        critMultiplier += 0.5 * massCount;
                    }

                    if (Math.random() < critChance) {
                        baseDamage = Math.floor(baseDamage * critMultiplier);
                        isCrit = true;
                    }
                } else if (!isPlayer && this.monster.special === 'CRITICAL') {
                    // Enemy crit ability
                    if (Math.random() < 0.30) {
                        baseDamage *= 2;
                        isCrit = true;
                    }
                }

                // Armor reduction
                let armorToUse = currentArmor;
                if (isPlayer && this.hasAbility('ARMOR_PIERCING')) {
                    armorToUse *= 0.5;
                    this.addLog(`üéØ ARMOR PIERCING: Ignoring 50% of enemy armor`, 'player');
                }

                // Kinetic Amplifier - ignore 25% armor per copy
                if (isPlayer && game.relics) {
                    const amplifierCount = game.relics.filter(r => r === 'KINETIC_AMPLIFIER').length;
                    if (amplifierCount > 0) {
                        const ignorePercent = 0.25 * amplifierCount;
                        armorToUse = Math.floor(armorToUse * (1 - ignorePercent));
                        this.addLog(`üéØ KINETIC AMPLIFIER: Ignoring ${Math.floor(ignorePercent * 100)}% enemy armor`, 'player');
                    }
                }

                // Add Last Stand +50 armor if <30% HP
                let effectiveArmorBonus = 0;
                if (isPlayer && game.relics && game.relics.includes('LAST_STAND')) {
                    const hpPercent = (this.playerMech.currentHP / this.playerMech.maxHP) * 100;
                    if (hpPercent < 30) {
                        effectiveArmorBonus += 50;
                    }
                }

                const damageReduction = Math.min(armorToUse * 0.5, baseDamage * 0.7);
                let finalDamage = Math.max(1, Math.floor(baseDamage - damageReduction));

                // Executioner
                if (isPlayer && this.hasAbility('EXECUTIONER') && this.monster.currentHP < this.monster.maxHP * 0.3) {
                    finalDamage *= 2;
                    this.addLog(`üéØ EXECUTIONER: Target below 30% HP - DOUBLE DAMAGE!`, 'player');
                }

                return { damage: finalDamage, isCrit };
            }

            applyDoTs(target, isPlayer) {
                const dots = isPlayer ? this.playerDots : this.monsterDots;
                let totalDotDamage = 0;

                for (let i = dots.length - 1; i >= 0; i--) {
                    const dot = dots[i];
                    if (target === 'player') {
                        this.playerMech.currentHP -= dot.damage;
                    } else {
                        this.monster.currentHP -= dot.damage;
                    }
                    totalDotDamage += dot.damage;

                    dot.duration--;
                    if (dot.duration <= 0) {
                        dots.splice(i, 1);
                    }
                }

                if (totalDotDamage > 0) {
                    const actor = target === 'player' ? 'monster' : 'player';
                    this.addLog(`üî• DoT damage: ${totalDotDamage}`, actor);
                }
            }

            applyRegeneration() {
                // Regeneration ability
                if (this.hasAbility('REGENERATION')) {
                    const heal = 5;
                    this.playerMech.currentHP = Math.min(this.playerMech.maxHP, this.playerMech.currentHP + heal);
                    this.addLog(`üíö REGENERATION: Healed ${heal} HP`, 'player');
                }

                // Regenerator trait
                if (this.hasTrait('REGENERATOR')) {
                    const heal = Math.floor(this.playerMech.maxHP * 0.08);
                    this.playerMech.currentHP = Math.min(this.playerMech.maxHP, this.playerMech.currentHP + heal);
                    this.addLog(`üíö REGENERATOR TRAIT: Restored ${heal} HP (8% of max HP)`, 'player');
                }
            }

            performAttack(isPlayer) {
                let targetArmor = isPlayer ? this.monster.armor : calculateMechStats(this.playerMech).armor;

                // ARMORED enemy - double effective armor
                if (!isPlayer && this.monster.special === 'ARMORED') {
                    targetArmor *= 2;
                }

                const { damage, isCrit } = this.calculateDamage(isPlayer, targetArmor);

                let actualDamage = damage;

                if (isPlayer) {
                    // Player attacking monster - check monster shield first
                    if (this.monsterShield > 0) {
                        if (this.monsterShield >= actualDamage) {
                            this.monsterShield -= actualDamage;
                            this.addLog(`üõ°Ô∏è Enemy shield absorbed ${actualDamage} damage! (${this.monsterShield} shield left)`, 'player');
                            actualDamage = 0;
                        } else {
                            const overflow = actualDamage - this.monsterShield;
                            this.addLog(`üõ°Ô∏è Enemy shield absorbed ${this.monsterShield} damage, ${overflow} passed through!`, 'player');
                            this.monsterShield = 0;
                            actualDamage = overflow;
                        }
                    }

                    // Apply remaining damage to monster HP
                    if (actualDamage > 0) {
                        this.monster.currentHP -= actualDamage;
                        const critText = isCrit ? ' üí• CRITICAL HIT!' : '';
                        this.addLog(`‚öîÔ∏è Your mech deals ${actualDamage} damage!${critText} (Enemy: ${Math.max(0, this.monster.currentHP)}/${this.monster.maxHP} HP)`, 'player');

                        // REFLECT - Monster reflects damage back
                        if (this.monster.special === 'REFLECT') {
                            const reflected = Math.floor(actualDamage * 0.5);
                            this.playerMech.currentHP -= reflected;
                            this.addLog(`üëª MIRROR WRAITH: Reflected ${reflected} damage back!`, 'monster');
                        }
                    }

                    // Vampiric healing - now stacks from multiple sources!
                    let totalHealPercent = 0;
                    let healSources = [];

                    if (this.hasAbility('VAMPIRIC')) {
                        totalHealPercent += 0.25;
                        healSources.push('Vampiric');
                    }
                    if (this.hasTrait('VAMPIRE')) {
                        totalHealPercent += 0.4;
                        healSources.push('VAMPIRE TRAIT');
                    }
                    if (game.relics && game.relics.includes('VAMPIRIC_ASCENSION')) {
                        const vampCount = game.relics.filter(r => r === 'VAMPIRIC_ASCENSION').length;
                        totalHealPercent += 0.25 * vampCount;
                        healSources.push(`VAMPIRIC ASCENSION x${vampCount}`);
                    }
                    if (game.relics && game.relics.includes('BLOOD_PACT')) {
                        const pactCount = game.relics.filter(r => r === 'BLOOD_PACT').length;
                        totalHealPercent += 0.5 * pactCount;
                        healSources.push(`BLOOD PACT x${pactCount}`);
                    }

                    if (totalHealPercent > 0) {
                        const heal = Math.floor(actualDamage * totalHealPercent);
                        this.playerMech.currentHP = Math.min(this.playerMech.maxHP, this.playerMech.currentHP + heal);
                        this.addLog(`ü©∏ ${healSources.join(' + ')}: Healed ${heal} HP (${Math.floor(totalHealPercent * 100)}% of damage)`, 'player');
                    }

                    // Apply DoTs with Contagion and ALL_IN support
                    if (this.hasAbility('BURN')) {
                        let burnDamage = 5;
                        let burnDuration = 3;
                        let triggers = 1;

                        // ALL_IN relic - abilities trigger twice
                        if (game.relics && game.relics.includes('ALL_IN')) {
                            triggers = 2;
                        }

                        // Contagion relic - 2x DoT damage and duration
                        if (game.relics && game.relics.includes('CONTAGION')) {
                            const contagionCount = game.relics.filter(r => r === 'CONTAGION').length;
                            const multiplier = Math.pow(2, contagionCount);
                            burnDamage = Math.floor(burnDamage * multiplier);
                            burnDuration = Math.floor(burnDuration * multiplier);
                        }

                        for (let i = 0; i < triggers; i++) {
                            this.monsterDots.push({ type: 'burn', damage: burnDamage, duration: burnDuration });
                        }

                        const triggerText = triggers > 1 ? ` x${triggers} (ALL-IN!)` : '';
                        this.addLog(`üî• PLASMA BURN${triggerText}: ${burnDamage} dmg/turn for ${burnDuration} turns`, 'player');
                    }

                    if (isCrit && this.hasAbility('BLEED')) {
                        let bleedDamage = 3;
                        let bleedDuration = 5;
                        let triggers = 1;

                        // ALL_IN relic
                        if (game.relics && game.relics.includes('ALL_IN')) {
                            triggers = 2;
                        }

                        // Contagion relic
                        if (game.relics && game.relics.includes('CONTAGION')) {
                            const contagionCount = game.relics.filter(r => r === 'CONTAGION').length;
                            const multiplier = Math.pow(2, contagionCount);
                            bleedDamage = Math.floor(bleedDamage * multiplier);
                            bleedDuration = Math.floor(bleedDuration * multiplier);
                        }

                        for (let i = 0; i < triggers; i++) {
                            this.monsterDots.push({ type: 'bleed', damage: bleedDamage, duration: bleedDuration });
                        }

                        const triggerText = triggers > 1 ? ` x${triggers} (ALL-IN!)` : '';
                        this.addLog(`ü©∏ HEMORRHAGE${triggerText}: ${bleedDamage} dmg/turn for ${bleedDuration} turns`, 'player');
                    }
                } else {
                    // Monster attacks player
                    const ignoresShield = this.monster.special === 'SHIELD_IGNORE';

                    // Check shield first (unless SHIELD_IGNORE)
                    if (!ignoresShield && this.playerShield > 0) {
                        if (this.playerShield >= actualDamage) {
                            this.playerShield -= actualDamage;
                            this.addLog(`üõ°Ô∏è Shield absorbed ${actualDamage} damage! (${this.playerShield} shield left)`, 'monster');
                            actualDamage = 0;
                        } else {
                            const overflow = actualDamage - this.playerShield;
                            this.addLog(`üõ°Ô∏è Shield absorbed ${this.playerShield} damage, ${overflow} passed through!`, 'monster');
                            this.playerShield = 0;
                            actualDamage = overflow;
                        }
                    } else if (ignoresShield && this.playerShield > 0) {
                        this.addLog(`‚ö° PLASMA STORM: Shields and armor ignored!`, 'monster');
                    }

                    // Apply remaining damage to HP
                    if (actualDamage > 0) {
                        const critText = isCrit ? ' üí• CRIT!' : '';
                        this.playerMech.currentHP -= actualDamage;
                        this.addLog(`üí• ${this.monster.name} deals ${actualDamage} damage!${critText} (${Math.max(0, this.playerMech.currentHP)}/${this.playerMech.maxHP} HP)`, 'monster');

                        // Reactive armor
                        if (this.hasAbility('REACTIVE')) {
                            const reflected = Math.floor(actualDamage * 0.25);
                            this.monster.currentHP -= reflected;
                            this.addLog(`‚ö° REACTIVE ARMOR: Reflected ${reflected} damage (25% of damage taken)`, 'player');
                        }
                    }
                }

                return actualDamage;
            }

            executeTurn() {
                this.turn++;

                // Apply Overcharged trait damage
                if (this.hasTrait('OVERCHARGED')) {
                    const damage = Math.floor(this.playerMech.maxHP * 0.08);
                    this.playerMech.currentHP -= damage;
                    this.addLog(`üî• OVERCHARGED TRAIT: Losing ${damage} HP (8% max HP per turn)`, 'player');
                }

                // Apply regeneration
                this.applyRegeneration();

                // Apply DoTs
                this.applyDoTs('player', true);
                this.applyDoTs('monster', false);

                // Check for deaths from DoTs
                if (this.playerMech.currentHP <= 0) {
                    this.addLog('üíÄ YOUR MECH IS DESTROYED! DEFEAT! üíÄ', 'monster');
                    return 'defeat';
                }
                if (this.monster.currentHP <= 0) {
                    this.addLog('üí• ENEMY DESTROYED! VICTORY! üí•', 'player');
                    return 'victory';
                }

                const playerStats = calculateMechStats(this.playerMech);
                let playerSpeed = playerStats.speed;

                // Apply speed traits
                if (this.hasTrait('LIGHTNING_FAST')) {
                    playerSpeed = 100 + 50;
                }
                if (this.hasTrait('FORTRESS')) {
                    playerSpeed = Math.floor(playerSpeed * 0.5);
                }

                // Determine turn order
                const playerGoesFirst = playerSpeed >= this.monster.speed;

                if (playerGoesFirst) {
                    this.performAttack(true);
                    if (this.monster.currentHP <= 0) {
                        this.addLog('üí• ENEMY DESTROYED! VICTORY! üí•', 'player');
                        return 'victory';
                    }
                    this.performAttack(false);
                    if (this.playerMech.currentHP <= 0) {
                        this.addLog('üíÄ YOUR MECH IS DESTROYED! DEFEAT! üíÄ', 'monster');
                        return 'defeat';
                    }
                } else {
                    this.performAttack(false);
                    if (this.playerMech.currentHP <= 0) {
                        this.addLog('üíÄ YOUR MECH IS DESTROYED! DEFEAT! üíÄ', 'monster');
                        return 'defeat';
                    }
                    this.performAttack(true);
                    if (this.monster.currentHP <= 0) {
                        this.addLog('üí• ENEMY DESTROYED! VICTORY! üí•', 'player');
                        return 'victory';
                    }
                }

                return 'continue';
            }

            getState() {
                return {
                    playerMech: this.playerMech,
                    monster: this.monster,
                    log: this.log,
                    playerShield: this.playerShield
                };
            }
        }

        // ============================================================================
        // UI MANAGEMENT
        // ============================================================================

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        function updateHeader() {
            document.getElementById('round-num').textContent = game.round;
            document.getElementById('victories').textContent = game.victories;
            document.getElementById('current-mech-name').textContent =
                game.currentMech ? `${game.currentMech.name} (T${game.currentMech.tier})` : 'None';

            const invCount = game.inventory.length;
            // Apply SCAVENGER relic +3 inventory
            let invMax = game.maxInventorySize;
            if (game.relics && game.relics.includes('SCAVENGER')) {
                invMax += 3;
            }
            const invText = `${invCount}/${invMax}`;
            const invElement = document.getElementById('inventory-count');
            invElement.textContent = invText;

            // Color code inventory status
            if (invCount >= invMax) {
                invElement.style.color = '#ff4444';
                invElement.style.fontWeight = 'bold';
            } else if (invCount >= invMax - 2) {
                invElement.style.color = '#ffaa00';
            } else {
                invElement.style.color = '';
                invElement.style.fontWeight = '';
            }
        }

        function renderLoadoutScreen() {
            if (!game.currentMech) {
                document.getElementById('loadout-mech-name').textContent = 'No Mech Selected';
                document.getElementById('mech-slots').innerHTML = '<p class="warning">Please select a mech to continue.</p>';
                return;
            }

            const mech = game.currentMech;
            const stats = calculateMechStats(mech);

            // Display mech name with traits
            const traitIcons = (mech.traits || []).map(t => t.icon).join(' ');
            document.getElementById('loadout-mech-name').textContent =
                `${mech.name} (${mech.class}) - Tier ${mech.tier} ${traitIcons}`;
            document.getElementById('loadout-mech-visual').textContent = mech.visual;

            // Update resource bars
            const tierPercent = (stats.tierUsed / mech.tierCapacity) * 100;
            const weightPercent = (stats.weightUsed / mech.weightCapacity) * 100;

            document.getElementById('tier-usage').textContent =
                `${stats.tierUsed}/${mech.tierCapacity}`;
            document.getElementById('tier-bar').style.width = `${Math.min(100, tierPercent)}%`;

            document.getElementById('weight-usage').textContent =
                `${stats.weightUsed}/${mech.weightCapacity}`;
            document.getElementById('weight-bar').style.width = `${Math.min(100, weightPercent)}%`;

            // Render slots
            const slotsHTML = Object.entries(SLOT_TYPES).map(([key, slotName]) => {
                const slot = mech.slots[slotName];
                const component = mech.loadout[slotName];
                const slotLabel = key.replace(/_/g, ' ');

                if (component) {
                    const damageTypeIcon = component.damageType === DAMAGE_TYPES.ENERGY ? '‚öõÔ∏è' :
                                           component.damageType === DAMAGE_TYPES.KINETIC ? 'üéØ' :
                                           component.damageType === DAMAGE_TYPES.EXPLOSIVE ? 'üí£' : '';
                    const abilities = component.abilities || [];
                    const abilityText = abilities.map(abilityKey => {
                        const ability = ABILITIES[abilityKey];
                        return ability ? `
                            <div style="font-size: 9px; color: #00ff88; margin-top: 3px; padding: 3px; background: rgba(0, 255, 136, 0.1); border-radius: 2px;">
                                <strong>‚ú® ${ability.name}</strong><br>
                                <span style="color: #aaa; font-size: 8px;">${ability.desc}</span>
                            </div>
                        ` : '';
                    }).join('');

                    // Rarity styling
                    const rarityData = RARITY[component.rarity] || RARITY.COMMON;

                    return `
                        <div class="slot filled" onclick="handleSlotClick('${slotName}')" style="border-left: 3px solid ${rarityData.color};">
                            <div class="slot-header">
                                <span>${slotLabel}</span>
                                <span class="tier-indicator tier-${component.tier}">T${component.tier}</span>
                                <span style="background: ${rarityData.color}; color: #000; padding: 1px 4px; border-radius: 2px; font-size: 8px; font-weight: bold; margin-left: 4px;">${rarityData.name[0]}</span>
                            </div>
                            <div class="component-name" style="color: ${rarityData.color};">${damageTypeIcon} ${component.name}</div>
                            <div style="font-size: 11px; margin-top: 5px;">
                                ‚öîÔ∏è${component.damage} üõ°Ô∏è${component.armor}
                            </div>
                            ${abilityText}
                        </div>
                    `;
                } else {
                    return `
                        <div class="slot" onclick="handleSlotClick('${slotName}')">
                            <div class="slot-header">
                                <span>${slotLabel}</span>
                                <span style="color: #666;">Empty</span>
                            </div>
                            <div style="font-size: 11px; color: #666;">Click to attach component</div>
                        </div>
                    `;
                }
            }).join('');

            document.getElementById('mech-slots').innerHTML = slotsHTML;

            // Render inventory
            renderInventory();
        }

        function renderInventory() {
            const inventoryGrid = document.getElementById('inventory-grid');

            if (game.inventory.length === 0) {
                inventoryGrid.innerHTML = '<p style="color: #666;">No components in inventory. Win battles to collect salvage!</p>';
                return;
            }

            inventoryGrid.innerHTML = game.inventory.map(comp => {
                const damageTypeIcon = comp.damageType === DAMAGE_TYPES.ENERGY ? '‚öõÔ∏è' :
                                       comp.damageType === DAMAGE_TYPES.KINETIC ? 'üéØ' :
                                       comp.damageType === DAMAGE_TYPES.EXPLOSIVE ? 'üí£' : '';
                const abilities = comp.abilities || [];
                const abilityText = abilities.map(abilityKey => {
                    const ability = ABILITIES[abilityKey];
                    return ability ? `
                        <div style="font-size: 10px; color: #00ff88; margin-top: 5px; padding: 4px; background: rgba(0, 255, 136, 0.1); border-radius: 3px; border-left: 2px solid #00ff88;">
                            <strong>‚ú® ${ability.name}</strong><br>
                            <span style="color: #ccc; font-size: 9px;">${ability.desc}</span>
                        </div>
                    ` : '';
                }).join('');

                // Rarity styling
                const rarityData = RARITY[comp.rarity] || RARITY.COMMON;
                const rarityBadge = `<span style="background: ${rarityData.color}; color: #000; padding: 2px 6px; border-radius: 3px; font-size: 9px; font-weight: bold; margin-left: 5px;">${rarityData.name.toUpperCase()}</span>`;

                return `
                    <div class="inventory-item" style="border-left: 3px solid ${rarityData.color};">
                        <div class="component-name" style="font-size: 14px; color: ${rarityData.color};">
                            ${damageTypeIcon} ${comp.name}
                            ${rarityBadge}
                            <span class="tier-indicator tier-${comp.tier}">T${comp.tier}</span>
                        </div>
                        <div class="component-stats">
                            <div class="stat-item">‚öîÔ∏è DMG: ${comp.damage}</div>
                            <div class="stat-item">üõ°Ô∏è ARM: ${comp.armor}</div>
                        </div>
                        <div style="font-size: 10px; color: #888; margin-top: 5px;">
                            Slot: ${comp.slot.replace(/([A-Z])/g, ' $1').trim()}
                        </div>
                        ${abilityText}
                    </div>
                `;
            }).join('');
        }

        // Global variable to track current slot being equipped
        let currentEquippingSlot = null;

        function handleSlotClick(slotName) {
            if (!game.currentMech) return;

            // Show item selection modal for this slot
            showItemSelectionModal(slotName);
        }

        function showItemSelectionModal(slotName) {
            currentEquippingSlot = slotName;
            const currentComponent = game.currentMech.loadout[slotName];

            // Update modal title
            const slotLabel = slotName.replace(/([A-Z])/g, ' $1').trim().toUpperCase();
            document.getElementById('item-select-title').textContent = `üì¶ SELECT COMPONENT FOR ${slotLabel}`;

            // Show/hide unequip button
            const unequipBtn = document.getElementById('unequip-btn');
            if (currentComponent) {
                unequipBtn.style.display = 'inline-block';
                unequipBtn.textContent = `üóëÔ∏è Unequip ${currentComponent.name}`;
            } else {
                unequipBtn.style.display = 'none';
            }

            // Get all compatible components from inventory
            const compatibleItems = game.inventory.filter(comp => comp.slot === slotName);

            // Sort by rarity (legendary first) then by tier
            const rarityOrder = { LEGENDARY: 0, EPIC: 1, RARE: 2, UNCOMMON: 3, COMMON: 4 };
            compatibleItems.sort((a, b) => {
                const rarityDiff = rarityOrder[a.rarity] - rarityOrder[b.rarity];
                if (rarityDiff !== 0) return rarityDiff;
                return b.tier - a.tier; // Higher tier first
            });

            // Render item options
            renderItemSelectionOptions(compatibleItems, slotName, currentComponent);

            showScreen('item-select-modal');
        }

        function renderItemSelectionOptions(items, slotName, currentComponent) {
            const optionsContainer = document.getElementById('item-select-options');

            if (items.length === 0) {
                optionsContainer.innerHTML = '<p style="color: #666; text-align: center; padding: 40px;">No compatible components in inventory for this slot.</p>';
                return;
            }

            const itemsHTML = items.map(comp => {
                const damageTypeIcon = comp.damageType === DAMAGE_TYPES.ENERGY ? '‚öõÔ∏è' :
                                       comp.damageType === DAMAGE_TYPES.KINETIC ? 'üéØ' :
                                       comp.damageType === DAMAGE_TYPES.EXPLOSIVE ? 'üí£' : '';
                const abilities = comp.abilities || [];
                const abilityText = abilities.map(abilityKey => {
                    const ability = ABILITIES[abilityKey];
                    return ability ? `
                        <div style="font-size: 10px; color: #00ff88; margin-top: 5px; padding: 4px; background: rgba(0, 255, 136, 0.1); border-radius: 3px; border-left: 2px solid #00ff88;">
                            <strong>‚ú® ${ability.name}</strong><br>
                            <span style="color: #ccc; font-size: 9px;">${ability.desc}</span>
                        </div>
                    ` : '';
                }).join('');

                // Rarity styling
                const rarityData = RARITY[comp.rarity] || RARITY.COMMON;
                const rarityBadge = `<span style="background: ${rarityData.color}; color: #000; padding: 2px 6px; border-radius: 3px; font-size: 9px; font-weight: bold; margin-left: 5px;">${rarityData.name.toUpperCase()}</span>`;

                // Check if this item is NEW for this slot
                if (!comp.seenInSlots) comp.seenInSlots = [];
                const isNew = !comp.seenInSlots.includes(slotName);
                const newBadge = isNew ? `<span style="background: #ff00ff; color: #fff; padding: 2px 6px; border-radius: 3px; font-size: 9px; font-weight: bold; margin-left: 5px; animation: pulse 1s infinite;">NEW!</span>` : '';

                // Mark as seen
                if (isNew) {
                    comp.seenInSlots.push(slotName);
                }

                // Check if can equip (tier budget)
                const canEquip = canAttachComponent(game.currentMech, comp, slotName);
                const disabledStyle = !canEquip ? 'opacity: 0.5; filter: grayscale(50%);' : '';
                const cannotEquipWarning = !canEquip ? '<div style="color: #ff4444; font-size: 10px; margin-top: 5px;">‚ö†Ô∏è Not enough tier budget</div>' : '';

                // Check if currently equipped
                const isEquipped = currentComponent && currentComponent.id === comp.id;
                const equippedBadge = isEquipped ? '<div style="color: #00ff88; font-size: 11px; margin-top: 5px;">‚úì Currently Equipped</div>' : '';

                return `
                    <div class="salvage-card" onclick="selectItemForSlot('${comp.id}')" style="border: 2px solid ${rarityData.color}; box-shadow: 0 0 10px ${rarityData.color}50; ${disabledStyle} cursor: ${canEquip ? 'pointer' : 'not-allowed'};">
                        <div class="component-name" style="color: ${rarityData.color};">
                            ${damageTypeIcon} ${comp.name}
                            ${rarityBadge}
                            ${newBadge}
                            <span class="tier-indicator tier-${comp.tier}">Tier ${comp.tier}</span>
                        </div>
                        <div style="margin: 10px 0; color: #888;">${comp.type.toUpperCase()}</div>
                        <div class="component-stats">
                            <div class="stat-item">‚öîÔ∏è Damage: ${comp.damage}</div>
                            <div class="stat-item">üõ°Ô∏è Armor: ${comp.armor}</div>
                        </div>
                        ${abilityText}
                        ${equippedBadge}
                        ${cannotEquipWarning}
                    </div>
                `;
            }).join('');

            optionsContainer.innerHTML = itemsHTML;
        }

        function selectItemForSlot(componentId) {
            if (!currentEquippingSlot) return;

            const component = game.inventory.find(c => c.id === componentId);
            if (!component) return;

            // Check if can attach
            if (!canAttachComponent(game.currentMech, component, currentEquippingSlot)) {
                return; // Silently ignore if can't attach (visual feedback already shown)
            }

            // Attach the component
            attachComponent(game.currentMech, component, currentEquippingSlot);

            // Close modal and refresh loadout
            closeItemSelectModal();
        }

        function unequipSlot() {
            if (!currentEquippingSlot) return;

            const currentComponent = game.currentMech.loadout[currentEquippingSlot];
            if (currentComponent) {
                detachComponent(game.currentMech, currentEquippingSlot);
            }

            closeItemSelectModal();
        }

        function closeItemSelectModal() {
            currentEquippingSlot = null;
            renderLoadoutScreen();
            showScreen('loadout-screen');
        }

        function renderBattleScreen() {
            if (!game.currentMech) {
                alert('No mech selected!');
                return;
            }

            // Reset mech HP
            game.currentMech.currentHP = game.currentMech.maxHP;

            // Generate monster
            game.currentMonster = generateMonster(game.round);

            const stats = calculateMechStats(game.currentMech);

            // Update player display
            document.getElementById('player-visual').textContent = game.currentMech.visual;
            document.getElementById('player-name').textContent = game.currentMech.name;
            document.getElementById('player-stats').innerHTML =
                `‚öîÔ∏è Damage: ${stats.damage} | üõ°Ô∏è Armor: ${stats.armor} | ‚ö° Speed: ${stats.speed}`;
            updateHealthBar('player', game.currentMech.currentHP, game.currentMech.maxHP);

            // Update monster display
            document.getElementById('monster-visual').textContent = game.currentMonster.visual;
            document.getElementById('monster-name').textContent = game.currentMonster.name;
            document.getElementById('monster-stats').innerHTML =
                `‚öîÔ∏è Damage: ${game.currentMonster.damage} | üõ°Ô∏è Armor: ${game.currentMonster.armor} | ‚ö° Speed: ${game.currentMonster.speed}`;
            updateHealthBar('monster', game.currentMonster.currentHP, game.currentMonster.maxHP);

            // Display active abilities and traits
            displayActiveAbilities();

            // Clear status effects
            document.getElementById('player-status-effects').innerHTML = '<span style="color: #666; font-size: 9px;">No active effects</span>';
            document.getElementById('monster-status-effects').innerHTML = '<span style="color: #666; font-size: 9px;">No active effects</span>';

            // Clear combat log
            document.getElementById('combat-log').innerHTML = '';

            showScreen('battle-screen');
        }

        function displayActiveAbilities() {
            const abilitiesDiv = document.getElementById('player-abilities-display');

            // Collect all abilities
            const abilities = [];
            Object.values(game.currentMech.loadout || {}).forEach(comp => {
                if (comp && comp.abilities) {
                    comp.abilities.forEach(abilityKey => {
                        if (ABILITIES[abilityKey] && !abilities.includes(abilityKey)) {
                            abilities.push(abilityKey);
                        }
                    });
                }
            });

            // Collect traits
            const traits = game.currentMech.traits || [];

            if (abilities.length === 0 && traits.length === 0) {
                abilitiesDiv.style.display = 'none';
                return;
            }

            let html = '<h4>‚ö° ACTIVE EFFECTS</h4>';

            if (traits.length > 0) {
                html += '<div style="margin-bottom: 5px;">';
                traits.forEach(trait => {
                    html += `<span class="trait-tag" title="${trait.desc}">${trait.icon} ${trait.name}</span>`;
                });
                html += '</div>';
            }

            if (abilities.length > 0) {
                html += '<div>';
                abilities.forEach(abilityKey => {
                    const ability = ABILITIES[abilityKey];
                    html += `<span class="ability-tag" title="${ability.desc}">‚ú® ${ability.name}</span>`;
                });
                html += '</div>';
            }

            abilitiesDiv.innerHTML = html;
            abilitiesDiv.style.display = 'block';
        }

        function updateStatusEffects(playerShield, playerDots, monsterDots) {
            // Update player status effects
            const playerStatusDiv = document.getElementById('player-status-effects');
            let playerEffects = [];

            if (playerShield > 0) {
                playerEffects.push(`<span class="status-effect status-shield">üõ°Ô∏è Shield: ${playerShield}</span>`);
            }

            if (playerEffects.length === 0) {
                playerStatusDiv.innerHTML = '<span style="color: #666; font-size: 9px;">No active effects</span>';
            } else {
                playerStatusDiv.innerHTML = playerEffects.join('');
            }

            // Update monster status effects
            const monsterStatusDiv = document.getElementById('monster-status-effects');
            let monsterEffects = [];

            monsterDots.forEach(dot => {
                if (dot.type === 'burn') {
                    monsterEffects.push(`<span class="status-effect status-burn">üî• Burn: ${dot.damage}x${dot.duration}</span>`);
                } else if (dot.type === 'bleed') {
                    monsterEffects.push(`<span class="status-effect status-bleed">ü©∏ Bleed: ${dot.damage}x${dot.duration}</span>`);
                }
            });

            if (monsterEffects.length === 0) {
                monsterStatusDiv.innerHTML = '<span style="color: #666; font-size: 9px;">No active effects</span>';
            } else {
                monsterStatusDiv.innerHTML = monsterEffects.join('');
            }
        }

        function updateHealthBar(actor, current, max) {
            const percent = (current / max) * 100;
            const fill = document.getElementById(`${actor}-health`);
            const text = document.getElementById(`${actor}-health-text`);

            fill.style.width = `${Math.max(0, percent)}%`;
            text.textContent = `${Math.max(0, current)}/${max}`;
        }

        function addCombatLog(message, actor) {
            const log = document.getElementById('combat-log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${actor}`;
            entry.textContent = message;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        async function startBattle() {
            if (!game.currentMech || !game.currentMonster) return;

            document.getElementById('start-battle-btn').disabled = true;

            // Create physics-driven battle system
            const battle = new PhysicsBattleSystem(game.currentMech, game.currentMonster, physicsEngine);

            // Initialize battle (starts physics and auto-combat)
            await battle.initializeBattle();

            addCombatLog('‚öîÔ∏è BATTLE START! ‚öîÔ∏è', 'system');

            // Track displayed logs
            let lastLogIndex = 0;

            // Real-time battle loop - polls physics state
            while (battle.isActive) {
                await new Promise(resolve => setTimeout(resolve, 100)); // Poll at 10Hz

                const state = battle.getState();

                // Update displays with real-time physics state
                updateHealthBar('player', state.playerMech.currentHP, state.playerMech.maxHP);
                updateHealthBar('monster', state.monster.currentHP, state.monster.maxHP);

                // Update status effects
                updateStatusEffects(state.playerShield, battle.playerDots, battle.monsterDots);

                // Show new log entries
                while (lastLogIndex < battle.log.length) {
                    const logEntry = battle.log[lastLogIndex];
                    addCombatLog(logEntry.message, logEntry.actor);
                    lastLogIndex++;
                }
            }

            // Battle ended - get result
            const result = battle.battleResult;

            await new Promise(resolve => setTimeout(resolve, 2000));

            if (result === 'victory') {
                game.victories++;

                // Apply Hunter's Mark relic - permanent damage per kill
                if (game.relics && game.relics.includes('HUNTERS_MARK')) {
                    const markCount = game.relics.filter(r => r === 'HUNTERS_MARK').length;
                    const bonusDmg = 3 * markCount;
                    game.permanentDamageBonus += bonusDmg;
                    addCombatLog(`üíÄ HUNTER'S MARK: +${bonusDmg} permanent damage (Total: +${game.permanentDamageBonus})`, 'player');
                }

                game.round++;
                game.save();

                const previousRound = game.round - 1;
                const isBossRound = previousRound % 5 === 0 && previousRound > 0;
                const isRelicRound = previousRound % 3 === 0 && previousRound > 0 && !isBossRound;

                // Boss rounds: Trait + Relic (boss reward)
                if (isBossRound) {
                    // Store that we need to show relic after trait
                    window.showRelicAfterTrait = true;
                    showTraitSelectionScreen();
                }
                // Relic rounds (every 3, but not bosses): Relic only
                else if (isRelicRound) {
                    showRelicSelectionScreen(false);
                }
                // Normal rounds: Salvage
                else {
                    showSalvageScreen();
                }
            } else {
                // Defeat - game over
                addCombatLog('', 'system');
                addCombatLog('GAME OVER! Starting new game...', 'system');
                await new Promise(resolve => setTimeout(resolve, 3000));
                game.reset();
                initializeGame();
            }

            document.getElementById('start-battle-btn').disabled = false;
            updateHeader();
        }

        function showSalvageScreen() {
            const tierLevel = Math.floor(game.round / 5) + 1;
            const salvageOptions = generateRandomComponents(3, tierLevel, tierLevel + 1);

            // Check if player has SALVAGER trait or SCAVENGER relic
            const hasSalvagerTrait = game.currentMech && game.currentMech.traits &&
                                     game.currentMech.traits.some(t => t.name === 'SALVAGER');
            const hasScavengerRelic = game.relics && game.relics.includes('SCAVENGER');
            const hasSalvager = hasSalvagerTrait || hasScavengerRelic;

            const titleText = hasSalvager ?
                (hasScavengerRelic && hasSalvagerTrait ?
                    'Choose TWO components to salvage (SCAVENGER relic + SALVAGER trait active!):' :
                    hasScavengerRelic ?
                        'Choose TWO components to salvage (SCAVENGER relic active!):' :
                        'Choose TWO components to salvage (SALVAGER trait active!):') :
                'Choose one component to salvage from the battlefield:';

            document.querySelector('#salvage-screen p').textContent = titleText;

            const optionsHTML = salvageOptions.map((comp, index) => {
                const damageTypeIcon = comp.damageType === DAMAGE_TYPES.ENERGY ? '‚öõÔ∏è' :
                                       comp.damageType === DAMAGE_TYPES.KINETIC ? 'üéØ' :
                                       comp.damageType === DAMAGE_TYPES.EXPLOSIVE ? 'üí£' : '';
                const abilities = comp.abilities || [];
                const abilityText = abilities.map(abilityKey => {
                    const ability = ABILITIES[abilityKey];
                    return ability ? `
                        <div style="font-size: 10px; color: #00ff88; margin-top: 5px; padding: 4px; background: rgba(0, 255, 136, 0.1); border-radius: 3px; border-left: 2px solid #00ff88;">
                            <strong>‚ú® ${ability.name}</strong><br>
                            <span style="color: #ccc; font-size: 9px;">${ability.desc}</span>
                        </div>
                    ` : '';
                }).join('');

                // Rarity styling
                const rarityData = RARITY[comp.rarity] || RARITY.COMMON;
                const rarityBadge = `<span style="background: ${rarityData.color}; color: #000; padding: 2px 6px; border-radius: 3px; font-size: 9px; font-weight: bold; margin-left: 5px;">${rarityData.name.toUpperCase()}</span>`;

                return `
                    <div class="salvage-card" onclick="selectSalvage(${index})" style="border: 2px solid ${rarityData.color}; box-shadow: 0 0 10px ${rarityData.color}50;">
                        <div class="component-name" style="color: ${rarityData.color};">
                            ${damageTypeIcon} ${comp.name}
                            ${rarityBadge}
                            <span class="tier-indicator tier-${comp.tier}">Tier ${comp.tier}</span>
                        </div>
                        <div style="margin: 10px 0; color: #888;">${comp.type.toUpperCase()}</div>
                        <div class="component-stats">
                            <div class="stat-item">‚öîÔ∏è Damage: ${comp.damage}</div>
                            <div class="stat-item">üõ°Ô∏è Armor: ${comp.armor}</div>
                            <div class="stat-item" style="grid-column: 1 / -1;">
                                üìç Slot: ${comp.slot.replace(/([A-Z])/g, ' $1').trim()}
                            </div>
                        </div>
                        ${abilityText}
                    </div>
                `;
            }).join('');

            document.getElementById('salvage-options').innerHTML = optionsHTML;

            // Store options temporarily
            window.currentSalvageOptions = salvageOptions;
            window.salvageSelections = [];
            window.salvageLimit = hasSalvager ? 2 : 1;

            showScreen('salvage-screen');
        }

        function selectSalvage(index) {
            const component = window.currentSalvageOptions[index];
            window.salvageSelections = window.salvageSelections || [];

            if (window.salvageSelections.includes(index)) {
                // Already selected, deselect
                window.salvageSelections = window.salvageSelections.filter(i => i !== index);
            } else {
                window.salvageSelections.push(index);
            }

            // Visual feedback - highlight selected
            document.querySelectorAll('#salvage-options .salvage-card').forEach((card, i) => {
                if (window.salvageSelections.includes(i)) {
                    card.style.borderColor = '#00ff88';
                    card.style.transform = 'scale(0.95)';
                } else {
                    card.style.borderColor = '#444';
                    card.style.transform = 'scale(1)';
                }
            });

            // If reached limit, auto-confirm
            if (window.salvageSelections.length >= window.salvageLimit) {
                setTimeout(() => {
                    // Check if inventory is full
                    const selectedComponents = window.salvageSelections.map(idx => window.currentSalvageOptions[idx]);

                    // Calculate actual max inventory (including SCAVENGER relic bonus)
                    let actualMaxInventory = game.maxInventorySize;
                    if (game.relics && game.relics.includes('SCAVENGER')) {
                        actualMaxInventory += 3;
                    }

                    if (game.inventory.length + selectedComponents.length > actualMaxInventory) {
                        // Inventory would overflow - need to drop items
                        const overflow = (game.inventory.length + selectedComponents.length) - actualMaxInventory;
                        showInventoryManagementScreen(selectedComponents, overflow, actualMaxInventory);
                    } else {
                        // Inventory has space
                        selectedComponents.forEach(comp => game.inventory.push(comp));
                        game.save();
                        updateHeader();
                        renderLoadoutScreen();
                        showScreen('loadout-screen');
                    }
                }, 300);
            }
        }

        function showInventoryManagementScreen(newComponents, mustDrop, maxInventory = null) {
            const actualMax = maxInventory || game.maxInventorySize;
            const message = `‚ö†Ô∏è INVENTORY FULL! (${game.inventory.length + newComponents.length}/${actualMax})\n\nYou must DROP ${mustDrop} component(s) to make room for your salvage.`;

            if (!confirm(message + '\n\nOK = Choose what to drop\nCancel = Skip salvage')) {
                // Skip salvage
                updateHeader();
                renderLoadoutScreen();
                showScreen('loadout-screen');
                return;
            }

            // Show inventory management UI
            window.pendingNewComponents = newComponents;
            window.mustDropCount = mustDrop;
            window.selectedForDrop = [];

            alert('Select ' + mustDrop + ' component(s) from your inventory to drop, then proceed to loadout screen.');

            // Add new components to temporary holding
            game.inventory.push(...newComponents);
            game.save();
            updateHeader();
            renderLoadoutScreen();
            showScreen('loadout-screen');

            // Add drop mode UI hint
            const inventoryPanel = document.querySelector('.inventory-panel h3');
            if (inventoryPanel) {
                inventoryPanel.innerHTML = `üì¶ Inventory <span style="color: #ff4444; font-size: 12px;">(MUST DROP ${mustDrop} ITEMS - Click to drop)</span>`;
            }
        }

        function showTraitSelectionScreen() {
            // Generate 3 random trait options
            const allTraits = Object.values(MECH_TRAITS);
            const availableTraits = allTraits.filter(trait =>
                !game.currentMech.traits.some(t => t.name === trait.name)
            );

            const traitOptions = [];
            for (let i = 0; i < 3 && availableTraits.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * availableTraits.length);
                traitOptions.push(availableTraits.splice(randomIndex, 1)[0]);
            }

            const traitsHTML = traitOptions.map((trait, index) => `
                <div class="mech-card" onclick="selectTrait(${index})" style="border-color: #ffaa00;">
                    <div style="font-size: 48px; text-align: center; margin: 15px 0;">${trait.icon}</div>
                    <div class="component-name" style="color: #ffaa00;">
                        ${trait.name}
                        <span class="tier-indicator tier-${trait.tier}">T${trait.tier}</span>
                    </div>
                    <div style="margin: 15px 0; color: #ccc; font-size: 13px; line-height: 1.5;">
                        ${trait.desc}
                    </div>
                    <div style="margin-top: 15px; padding: 10px; background: rgba(255,170,0,0.2); border-radius: 5px; font-size: 11px;">
                        This trait is permanent and will transform your playstyle!
                    </div>
                </div>
            `).join('');

            document.getElementById('trait-options').innerHTML = traitsHTML;
            window.currentTraitOptions = traitOptions;

            showScreen('trait-select-screen');
        }

        function selectTrait(index) {
            const trait = window.currentTraitOptions[index];

            if (!game.currentMech.traits) {
                game.currentMech.traits = [];
            }

            game.currentMech.traits.push(trait);
            game.save();

            alert(`${trait.icon} Trait Acquired: ${trait.name}!\n\n${trait.desc}`);

            // Check if we should show relic selection (after boss)
            if (window.showRelicAfterTrait) {
                window.showRelicAfterTrait = false;
                showRelicSelectionScreen(true); // true = boss reward
            } else {
                updateHeader();
                renderLoadoutScreen();
                showScreen('loadout-screen');
            }
        }

        function showRelicSelectionScreen(isBossReward = false) {
            // Generate 3 random relic options using weighted rarity selection
            const allRelics = Object.entries(RELICS);
            const availableRelics = allRelics.filter(([key, relic]) =>
                // Allow duplicates for stacking (except unique ones like Scavenger)
                key !== 'SCAVENGER' || !game.relics.includes(key)
            );

            // Select relics using weighted rarity
            const relicOptions = [];
            const attempts = [];

            for (let i = 0; i < 3 && availableRelics.length > 0; i++) {
                // Select a rarity using weighted random
                const targetRarity = selectWeightedRarity();

                // Find relics of this rarity
                const relicsOfRarity = availableRelics.filter(([key, relic]) => relic.rarity === targetRarity);

                let selectedRelic;
                if (relicsOfRarity.length > 0) {
                    // Pick random from this rarity
                    const randomIndex = Math.floor(Math.random() * relicsOfRarity.length);
                    const [key, relic] = relicsOfRarity[randomIndex];
                    selectedRelic = { key, ...relic };
                } else {
                    // Fallback to any available relic if no relics of target rarity
                    const randomIndex = Math.floor(Math.random() * availableRelics.length);
                    const [key, relic] = availableRelics[randomIndex];
                    selectedRelic = { key, ...relic };
                }

                relicOptions.push(selectedRelic);

                // Remove selected relic from pool temporarily for this selection
                const indexToRemove = availableRelics.findIndex(([k, r]) => k === selectedRelic.key);
                const removedRelic = availableRelics.splice(indexToRemove, 1)[0];

                // Only permanently remove if it's a unique relic
                if (selectedRelic.key !== 'SCAVENGER' && selectedRelic.key !== 'GLASS_CANNON_CORE') {
                    // For stackable relics, add it back for next iteration
                    attempts.push(removedRelic);
                }
            }

            // Restore non-unique relics to pool
            availableRelics.push(...attempts);

            // Update description based on context
            const descText = isBossReward ?
                'üèÜ BOSS DEFEATED! Choose a powerful relic as your reward:' :
                'You\'ve survived 3 more rounds! Choose a relic to enhance your build:';
            document.getElementById('relic-screen-desc').textContent = descText;

            const relicsHTML = relicOptions.map((relic, index) => {
                const count = game.relics.filter(r => r === relic.key).length;
                const stackText = count > 0 ? `<div style="color: #ffaa00; font-size: 11px; margin-top: 5px;">‚≠ê You have ${count} copy! Effects stack!</div>` : '';

                // Rarity styling
                const rarityData = RARITY[relic.rarity] || RARITY.COMMON;
                const rarityBadge = `<span style="background: ${rarityData.color}; color: #000; padding: 3px 8px; border-radius: 4px; font-size: 10px; font-weight: bold; margin-top: 8px; display: inline-block;">${rarityData.name.toUpperCase()}</span>`;

                return `
                    <div class="mech-card" onclick="selectRelic(${index})" style="border: 3px solid ${rarityData.color}; box-shadow: 0 0 15px ${rarityData.color}60;">
                        <div style="font-size: 48px; text-align: center; margin: 15px 0;">${relic.icon}</div>
                        <div class="component-name" style="color: ${rarityData.color};">
                            ${relic.name}
                        </div>
                        ${rarityBadge}
                        <div style="margin: 15px 0; color: #ccc; font-size: 13px; line-height: 1.5;">
                            ${relic.desc}
                        </div>
                        ${stackText}
                        <div style="margin-top: 15px; padding: 10px; background: rgba(0,204,255,0.2); border-radius: 5px; font-size: 10px; color: #00ccff;">
                            ${relic.category === 'damage' ? '‚öîÔ∏è SCALING' :
                              relic.category === 'conversion' ? '‚ö° CONVERSION' :
                              relic.category === 'investment' ? 'üìà INVESTMENT' :
                              relic.category === 'gameChanger' ? 'üíé GAME CHANGER' : 'üé≤ BUILD-AROUND'}
                        </div>
                    </div>
                `;
            }).join('');

            document.getElementById('relic-options').innerHTML = relicsHTML;
            window.currentRelicOptions = relicOptions;

            showScreen('relic-select-screen');
        }

        function selectRelic(index) {
            const relic = window.currentRelicOptions[index];

            if (!game.relics) {
                game.relics = [];
            }

            game.relics.push(relic.key);

            // Apply immediate effects
            if (relic.key === 'SCAVENGER') {
                // Increase max inventory
                updateHeader();
            } else if (relic.key === 'GLASS_CANNON_CORE') {
                // Reduce max HP by 50%
                game.currentMech.maxHP = Math.floor(game.currentMech.maxHP * 0.5);
                game.currentMech.currentHP = Math.min(game.currentMech.currentHP, game.currentMech.maxHP);
            } else if (relic.key === 'BLOOD_PACT') {
                // Reduce max HP by 20%
                game.currentMech.maxHP = Math.floor(game.currentMech.maxHP * 0.8);
                game.currentMech.currentHP = Math.min(game.currentMech.currentHP, game.currentMech.maxHP);
            }

            game.save();

            const count = game.relics.filter(r => r === relic.key).length;
            const stackMsg = count > 1 ? `\n\n‚ú® You now have ${count} copies! Effects stack!` : '';
            alert(`${relic.icon} Relic Acquired: ${relic.name}!\n\n${relic.desc}${stackMsg}`);

            updateHeader();
            renderLoadoutScreen();
            showScreen('loadout-screen');
        }

        // ============================================================================
        // INITIALIZATION
        // ============================================================================

        function initializeGame() {
            // Initialize physics engine
            initializePhysics();

            // Try to load saved game
            if (!game.load()) {
                // New game - choose starting mech
                const startingMechs = [
                    createMech(MECH_TEMPLATES.SCOUT, 1),
                    createMech(MECH_TEMPLATES.WARRIOR, 1),
                    createMech(MECH_TEMPLATES.TITAN, 1)
                ];

                // Add some starter components
                game.inventory = generateRandomComponents(6, 1, 2);

                const choice = confirm('Welcome to Mech Autobattler!\n\nChoose your starting mech:\n\nOK = Scout (Fast, Light)\nCancel = Warrior (Balanced)\n\n(Heavy Titan also available)');

                if (choice) {
                    game.currentMech = startingMechs[0];
                } else {
                    const choice2 = confirm('Warrior (Balanced) or Titan (Heavy)?\n\nOK = Warrior\nCancel = Titan');
                    game.currentMech = choice2 ? startingMechs[1] : startingMechs[2];
                }

                game.save();
            }

            updateHeader();
            renderLoadoutScreen();
        }

        // ============================================================================
        // EVENT LISTENERS
        // ============================================================================

        document.getElementById('ready-battle-btn').addEventListener('click', () => {
            if (!game.currentMech) {
                alert('No mech selected!');
                return;
            }
            renderBattleScreen();
        });

        document.getElementById('start-battle-btn').addEventListener('click', startBattle);

        // Physics controls
        document.getElementById('toggle-physics').addEventListener('click', function() {
            physicsEnabled = !physicsEnabled;
            this.classList.toggle('active');
            if (physicsEngine) {
                const canvas = document.getElementById('physics-canvas');
                canvas.style.display = physicsEnabled ? 'block' : 'none';
            }
        });

        document.getElementById('speed-1x').addEventListener('click', function() {
            if (physicsEngine) physicsEngine.setTimeScale(1);
            document.querySelectorAll('#physics-controls button[id^="speed-"]').forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
        });

        document.getElementById('speed-2x').addEventListener('click', function() {
            if (physicsEngine) physicsEngine.setTimeScale(2);
            document.querySelectorAll('#physics-controls button[id^="speed-"]').forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
        });

        document.getElementById('speed-4x').addEventListener('click', function() {
            if (physicsEngine) physicsEngine.setTimeScale(4);
            document.querySelectorAll('#physics-controls button[id^="speed-"]').forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
        });

        document.getElementById('toggle-effects').addEventListener('click', function() {
            if (physicsEngine) {
                physicsEngine.effectsEnabled = !physicsEngine.effectsEnabled;
                this.classList.toggle('active');
            }
        });

        // Abilities guide toggle
        document.getElementById('toggle-abilities-guide').addEventListener('click', () => {
            const guide = document.getElementById('abilities-guide');
            if (guide.style.display === 'none') {
                guide.style.display = 'block';
                populateAbilitiesGuide();
            } else {
                guide.style.display = 'none';
            }
        });

        function populateAbilitiesGuide() {
            const referenceDiv = document.getElementById('abilities-reference');

            let html = '<div style="font-size: 11px; line-height: 1.6;">';

            // Group abilities by category
            const damageAbilities = ['CRITICAL_STRIKE', 'ARMOR_PIERCING', 'BURN', 'BLEED', 'EXECUTIONER', 'DOUBLE_STRIKE', 'OVERCHARGE'];
            const defenseAbilities = ['SHIELD_GEN', 'REGENERATION', 'REACTIVE', 'DODGE'];
            const utilityAbilities = ['VAMPIRIC', 'BERSERKER', 'LIGHTWEIGHT', 'OVERDRIVE', 'QUICK_DEPLOY', 'EFFICIENT'];

            html += '<div style="margin-bottom: 12px;"><strong style="color: #ff8844; font-size: 12px;">‚öîÔ∏è DAMAGE ABILITIES</strong></div>';
            damageAbilities.forEach(key => {
                const ability = ABILITIES[key];
                if (ability) {
                    html += `
                        <div style="margin-bottom: 8px; padding: 6px; background: rgba(255, 136, 68, 0.1); border-left: 3px solid #ff8844; border-radius: 3px;">
                            <strong style="color: #ff8844;">${ability.name}</strong> <span style="color: #666; font-size: 9px;">(Tier ${ability.tier})</span><br>
                            <span style="color: #ccc; font-size: 10px;">${ability.desc}</span>
                        </div>
                    `;
                }
            });

            html += '<div style="margin: 12px 0;"><strong style="color: #00ccff; font-size: 12px;">üõ°Ô∏è DEFENSE ABILITIES</strong></div>';
            defenseAbilities.forEach(key => {
                const ability = ABILITIES[key];
                if (ability) {
                    html += `
                        <div style="margin-bottom: 8px; padding: 6px; background: rgba(0, 204, 255, 0.1); border-left: 3px solid #00ccff; border-radius: 3px;">
                            <strong style="color: #00ccff;">${ability.name}</strong> <span style="color: #666; font-size: 9px;">(Tier ${ability.tier})</span><br>
                            <span style="color: #ccc; font-size: 10px;">${ability.desc}</span>
                        </div>
                    `;
                }
            });

            html += '<div style="margin: 12px 0;"><strong style="color: #ffaa00; font-size: 12px;">‚ö° UTILITY ABILITIES</strong></div>';
            utilityAbilities.forEach(key => {
                const ability = ABILITIES[key];
                if (ability) {
                    html += `
                        <div style="margin-bottom: 8px; padding: 6px; background: rgba(255, 170, 0, 0.1); border-left: 3px solid #ffaa00; border-radius: 3px;">
                            <strong style="color: #ffaa00;">${ability.name}</strong> <span style="color: #666; font-size: 9px;">(Tier ${ability.tier})</span><br>
                            <span style="color: #ccc; font-size: 10px;">${ability.desc}</span>
                        </div>
                    `;
                }
            });

            html += '</div>';
            referenceDiv.innerHTML = html;
        }

        // Debug panel
        document.getElementById('debug-toggle').addEventListener('click', () => {
            const panel = document.getElementById('debug-panel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        });

        function updateDebugPanel() {
            const panel = document.getElementById('debug-panel');
            const stats = game.currentMech ? calculateMechStats(game.currentMech) : null;

            panel.innerHTML = `
                <h4 style="color: #ff00ff;">DEBUG INFO</h4>
                <div style="margin-bottom: 10px; padding: 5px; background: rgba(255,0,255,0.2); border-radius: 4px; font-size: 10px;">
                    <strong>Version:</strong> 3.3.0 - INVENTORY OVERHAUL
                </div>
                <div style="margin: 10px 0;">
                    <strong>Round:</strong> ${game.round}<br>
                    <strong>Victories:</strong> ${game.victories}<br>
                    <strong>Inventory:</strong> ${game.inventory.length} items<br>
                    ${stats ? `
                        <strong>Mech Stats:</strong><br>
                        - Damage: ${stats.damage}<br>
                        - Armor: ${stats.armor}<br>
                        - Speed: ${stats.speed}<br>
                        - Tier: ${stats.tierUsed}/${game.currentMech.tierCapacity}<br>
                        - Weight: ${stats.weightUsed}/${game.currentMech.weightCapacity}
                    ` : '<em>No mech selected</em>'}
                </div>
                <button class="btn btn-danger" onclick="if(confirm('Reset game?')) { game.reset(); initializeGame(); }" style="width: 100%; padding: 8px; font-size: 12px;">
                    RESET GAME
                </button>
            `;
        }

        // Update debug panel every second
        setInterval(updateDebugPanel, 1000);

        // ============================================================================
        // START GAME
        // ============================================================================

        initializeGame();
    </script>
</body>
</html>
