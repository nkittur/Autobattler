<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Physics Battle Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            font-family: monospace;
            color: #00ff88;
        }
        #canvas {
            border: 3px solid #00ff88;
            display: block;
            margin: 20px auto;
            image-rendering: pixelated;
        }
        #status {
            max-width: 800px;
            margin: 0 auto;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #00ff88;
        }
        .log {
            font-size: 12px;
            margin: 2px 0;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
</head>
<body>
    <h1 style="text-align: center;">‚öîÔ∏è Physics Battle Test ‚öîÔ∏è</h1>
    <h2 style="text-align: center; color: #ff00ff; background: #000; padding: 10px;">VERSION 3.2 - PHYSICS STABILITY FIX</h2>
    <p style="text-align: center; color: #ff6b35; font-size: 18px; font-weight: bold;">üîß Rigid joints | 2x ground friction | Mechs should STAND!</p>
    <p style="text-align: center; color: #00ff88; font-size: 14px;">Look for "Modern Rendering: YES" in top left of game</p>
    <div id="status">
        <div id="logs"></div>
    </div>
    <canvas id="canvas" width="800" height="450"></canvas>

    <script>
        // Simple logging
        const logs = [];
        function log(msg) {
            console.log(msg);
            logs.push(msg);
            const logsDiv = document.getElementById('logs');
            logsDiv.innerHTML = logs.slice(-15).map(l => `<div class="log">${l}</div>`).join('');
        }

        console.log('%c‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'color: #ff00ff; font-weight: bold; font-size: 16px');
        console.log('%cüî• PHYSICS TEST VERSION 3.0 üî•', 'color: #ff00ff; font-size: 24px; font-weight: bold; background: #000; padding: 5px');
        console.log('%c‚úÖ GLOWING EFFECTS ACTIVE', 'color: #00ff88; font-size: 16px; font-weight: bold');
        console.log('%c4x Mass | 0.9 Stiffness | Angular Design', 'color: #4dd2ff; font-size: 14px');
        console.log('%cOrange knee glow | Cyan viewport | Orange core | Red visor', 'color: #ff6b35; font-size: 12px');
        console.log('%c‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'color: #ff00ff; font-weight: bold; font-size: 16px');
        log('üî• Starting physics battle test v3.0 - GLOWING VISUALS ACTIVE...');

        // Minimal mech data
        const testPlayer = {
            name: 'Test Mech',
            class: 'Medium',
            currentHP: 120,
            maxHP: 120,
            damage: 30,
            armor: 10,
            speed: 50
        };

        const testEnemy = {
            name: 'Enemy Bot',
            currentHP: 80,
            maxHP: 80,
            damage: 20,
            armor: 5,
            speed: 40
        };

        // Simple Physics Engine (minimal version)
        class SimplePhysicsEngine {
            constructor(canvasId) {
                log('Initializing physics engine...');
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');

                const Engine = Matter.Engine;
                const World = Matter.World;
                const Bodies = Matter.Bodies;

                this.engine = Engine.create();
                this.engine.gravity.y = 1.2;
                this.world = this.engine.world;

                this.width = 800;
                this.height = 450;
                this.running = false;

                this.playerMech = null;
                this.enemyMech = null;
                this.projectiles = [];
                this.laserBeams = [];  // Track active laser beams for rendering
                this.impactEffects = [];  // Track impact animations
                this.damageNumbers = [];  // Track floating damage numbers
                this.projectileFired = 0;
                this.projectileHit = 0;
                this.projectileMissed = 0;
                this.battleEnded = false;

                // WEAPON DEFINITIONS LIBRARY
                this.weaponDefs = {
                    // PROJECTILE WEAPONS
                    autocannon: {
                        type: 'projectile',
                        name: 'Autocannon',
                        damage: 18,
                        cooldown: 1500,
                        minRange: 150,
                        maxRange: 400,
                        visuals: {
                            projectileColor: '#ffaa00',
                            projectileSize: 8,
                            speed: 35,
                            trail: false
                        }
                    },
                    heavyCannon: {
                        type: 'projectile',
                        name: 'Heavy Cannon',
                        damage: 30,
                        cooldown: 2500,
                        minRange: 100,
                        maxRange: 350,
                        visuals: {
                            projectileColor: '#ff4400',
                            projectileSize: 12,
                            speed: 25,
                            trail: true,
                            trailColor: '#ff6600'
                        }
                    },
                    machineGun: {
                        type: 'projectile',
                        name: 'Machine Gun',
                        damage: 8,
                        cooldown: 600,
                        minRange: 120,
                        maxRange: 380,
                        visuals: {
                            projectileColor: '#ffff00',
                            projectileSize: 5,
                            speed: 45,
                            trail: false
                        }
                    },
                    missile: {
                        type: 'projectile',
                        name: 'Missile',
                        damage: 25,
                        cooldown: 2000,
                        minRange: 200,
                        maxRange: 500,
                        visuals: {
                            projectileColor: '#00ffff',
                            projectileSize: 10,
                            speed: 30,
                            trail: true,
                            trailColor: '#88ffff'
                        }
                    },

                    // LASER WEAPONS
                    laser: {
                        type: 'laser',
                        name: 'Laser',
                        damage: 12,
                        cooldown: 1200,
                        minRange: 100,
                        maxRange: 450,
                        visuals: {
                            beamColor: '#ff0000',
                            glowColor: '#ff3333',
                            coreColor: '#ffff00',
                            width: 8,
                            duration: 150
                        }
                    },
                    pulseLaser: {
                        type: 'laser',
                        name: 'Pulse Laser',
                        damage: 6,
                        cooldown: 800,
                        minRange: 80,
                        maxRange: 400,
                        visuals: {
                            beamColor: '#00ff00',
                            glowColor: '#00ff88',
                            coreColor: '#ffffff',
                            width: 6,
                            duration: 100
                        }
                    },
                    heavyLaser: {
                        type: 'laser',
                        name: 'Heavy Laser',
                        damage: 20,
                        cooldown: 2000,
                        minRange: 150,
                        maxRange: 500,
                        visuals: {
                            beamColor: '#ff0088',
                            glowColor: '#ff00ff',
                            coreColor: '#ffffff',
                            width: 12,
                            duration: 200
                        }
                    },
                    blueBeam: {
                        type: 'laser',
                        name: 'Blue Beam',
                        damage: 10,
                        cooldown: 1000,
                        minRange: 100,
                        maxRange: 420,
                        visuals: {
                            beamColor: '#0088ff',
                            glowColor: '#00ccff',
                            coreColor: '#ffffff',
                            width: 8,
                            duration: 120
                        }
                    }
                };

                log('Physics engine created');
                this.createGround();
                this.createWalls();
                this.setupCollisionDetection(); // Set up once
                this.setupRenderLoop();
                this.setupProjectileCleanup();
            }

            createGround() {
                const Bodies = Matter.Bodies;
                const ground = Bodies.rectangle(400, 430, 800, 40, {
                    isStatic: true,
                    friction: 2.0,  // VERY high friction to prevent sliding
                    label: 'ground',
                    collisionFilter: {
                        category: 0x0008,  // Ground category
                        mask: 0xFFFF  // Collide with everything
                    }
                });
                Matter.World.add(this.world, ground);
                log('Ground created with high friction');
            }

            createWalls() {
                const Bodies = Matter.Bodies;

                // Left wall at x=0
                const leftWall = Bodies.rectangle(0, 225, 20, 450, {
                    isStatic: true,
                    friction: 0.5,
                    label: 'wall',
                    collisionFilter: {
                        category: 0x0008,  // Ground/wall category
                        mask: 0xFFFF  // Collide with everything
                    }
                });

                // Right wall at x=800
                const rightWall = Bodies.rectangle(800, 225, 20, 450, {
                    isStatic: true,
                    friction: 0.5,
                    label: 'wall',
                    collisionFilter: {
                        category: 0x0008,  // Ground/wall category
                        mask: 0xFFFF  // Collide with everything
                    }
                });

                Matter.World.add(this.world, [leftWall, rightWall]);
                log('Boundary walls created at x=0 and x=800');
            }

            setupCollisionDetection() {
                const Events = Matter.Events;

                Events.on(this.engine, 'collisionStart', (event) => {
                    event.pairs.forEach(pair => {
                        const { bodyA, bodyB } = pair;

                        // Check if either body is a projectile
                        const projectile = this.projectiles.find(p => p === bodyA || p === bodyB);
                        if (!projectile) return;

                        const other = bodyA === projectile ? bodyB : bodyA;

                        // Find which mech and component was hit
                        const hitResult = this.findHitComponent(other);

                        if (hitResult) {
                            // HIT A MECH COMPONENT!
                            const { mech, componentKey, component } = hitResult;

                            // Calculate damage with armor reduction
                            const rawDamage = projectile.damage;
                            const actualDamage = Math.max(1, rawDamage - component.armor);

                            // Apply damage
                            component.health -= actualDamage;
                            this.projectileHit++;

                            // Create impact effect
                            this.createImpactEffect(projectile.position.x, projectile.position.y, projectile.velocity);

                            // Create floating damage number
                            this.createDamageNumber(projectile.position.x, projectile.position.y, actualDamage, component.armor);

                            log(`üí• ${mech.isPlayer ? 'PLAYER' : 'ENEMY'} ${component.name} HIT! -${actualDamage} dmg (${rawDamage}-${component.armor} armor) ‚Üí ${Math.floor(component.health)}/${component.maxHealth} HP`);

                            // Check if component destroyed
                            if (component.health <= 0) {
                                this.destroyComponent(mech, componentKey, component);
                            }

                            // Remove projectile
                            Matter.World.remove(this.world, projectile);
                            this.projectiles = this.projectiles.filter(p => p !== projectile);

                        } else {
                            // Hit ground or other object - EXPLODE AND DISAPPEAR
                            log(`üí• Projectile exploded on ${other.label || 'unknown'}`);

                            // CREATE IMPACT EFFECT
                            this.createImpactEffect(projectile.position.x, projectile.position.y, projectile.velocity);

                            // Remove projectile immediately
                            Matter.World.remove(this.world, projectile);
                            this.projectiles = this.projectiles.filter(p => p !== projectile);
                            this.projectileMissed++;
                        }
                    });
                });

                log('‚úÖ Collision detection setup complete');
            }

            findHitComponent(body) {
                // Check player mech components
                if (this.playerMech && !this.playerMech.destroyed) {
                    for (const [key, component] of Object.entries(this.playerMech.components)) {
                        if (component.body === body && component.health > 0) {
                            return { mech: this.playerMech, componentKey: key, component: component };
                        }
                    }
                }

                // Check enemy mech components
                if (this.enemyMech && !this.enemyMech.destroyed) {
                    for (const [key, component] of Object.entries(this.enemyMech.components)) {
                        if (component.body === body && component.health > 0) {
                            return { mech: this.enemyMech, componentKey: key, component: component };
                        }
                    }
                }

                return null;  // Not a mech component
            }

            destroyComponent(mech, componentKey, component) {
                log(`üî• ${mech.isPlayer ? 'PLAYER' : 'ENEMY'} ${component.name} DESTROYED!`);

                // Create large explosion effect
                this.createImpactEffect(component.body.position.x, component.body.position.y, { x: 0, y: 0 });
                this.createImpactEffect(component.body.position.x, component.body.position.y, { x: 0, y: 0 });  // Double explosion

                // Remove component from world
                Matter.World.remove(this.world, component.body);

                // Mark as destroyed
                mech.destroyedComponents.push(componentKey);

                // If critical component (torso or head), destroy entire mech
                if (component.critical) {
                    this.destroyMech(mech);
                }
            }

            destroyMech(mech) {
                if (mech.destroyed) return;  // Already destroyed

                log(`üíÄ ${mech.isPlayer ? 'PLAYER' : 'ENEMY'} MECH DESTROYED!`);

                mech.destroyed = true;

                // Create massive explosion effects
                const torsoPos = mech.components.torso.body.position;
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        this.createImpactEffect(
                            torsoPos.x + (Math.random() - 0.5) * 40,
                            torsoPos.y + (Math.random() - 0.5) * 40,
                            { x: (Math.random() - 0.5) * 10, y: (Math.random() - 0.5) * 10 }
                        );
                    }, i * 100);
                }

                // Remove all remaining components from world
                for (const [key, component] of Object.entries(mech.components)) {
                    if (component.health > 0) {
                        setTimeout(() => {
                            Matter.World.remove(this.world, component.body);
                        }, 500);
                    }
                }

                // Check if battle should end
                this.checkBattleEnd();
            }

            checkBattleEnd() {
                if (this.battleEnded) return;

                const playerAlive = this.playerMech && !this.playerMech.destroyed;
                const enemyAlive = this.enemyMech && !this.enemyMech.destroyed;

                if (!playerAlive && !enemyAlive) {
                    this.battleEnded = true;
                    log('‚öîÔ∏è BATTLE ENDED: DRAW - Both mechs destroyed!');
                } else if (!playerAlive) {
                    this.battleEnded = true;
                    log('üíÄ BATTLE ENDED: ENEMY WINS!');
                } else if (!enemyAlive) {
                    this.battleEnded = true;
                    log('üéâ BATTLE ENDED: PLAYER WINS!');
                }
            }

            createDamageNumber(x, y, damage, armorBlocked) {
                this.damageNumbers.push({
                    x: x,
                    y: y,
                    damage: damage,
                    armorBlocked: armorBlocked,
                    createdAt: Date.now(),
                    life: 1.0  // Fades from 1 to 0
                });
            }

            setupProjectileCleanup() {
                // Remove projectiles that have been alive for too long (missed/went off screen)
                setInterval(() => {
                    const now = Date.now();
                    const oldProjectiles = this.projectiles.filter(p => now - p.firedAt > 3000);

                    if (oldProjectiles.length > 0) {
                        oldProjectiles.forEach(p => {
                            Matter.World.remove(this.world, p);
                            this.projectileMissed++;
                        });
                        this.projectiles = this.projectiles.filter(p => now - p.firedAt <= 3000);
                        log(`üóëÔ∏è Cleaned up ${oldProjectiles.length} old projectiles (total missed: ${this.projectileMissed})`);
                    }
                }, 1000);
                log('‚úÖ Projectile cleanup setup');
            }

            createMech(x, y, isPlayer) {
                log(`Creating ${isPlayer ? 'player' : 'enemy'} mech at (${x}, ${y})`);
                const Bodies = Matter.Bodies;
                const Constraint = Matter.Constraint;

                const size = 30;

                // COLLISION CATEGORIES - prevent mechs from physically pushing each other!
                // Category bits: Player=0x0001, Enemy=0x0002, Projectile=0x0004, Ground=0x0008
                const mechCategory = isPlayer ? 0x0001 : 0x0002;
                const mechCollisionMask = 0x0004 | 0x0008;  // Only collide with projectiles and ground

                // MAD CAT DESIGN: Wide, low, stable base for maximum stability
                // WIDE TORSO - low center of gravity, wide base
                const torso = Bodies.rectangle(x, y, size * 2.0, size * 1.0, {
                    density: 0.020,  // Heavy central mass for stability
                    friction: 1.2,
                    frictionAir: 0.08,  // High air resistance prevents sliding
                    restitution: 0.0,
                    inertia: Infinity,  // PREVENT ROTATION - stays upright!
                    label: isPlayer ? 'player_torso' : 'enemy_torso',
                    collisionFilter: {
                        category: mechCategory,
                        mask: mechCollisionMask
                    }
                });

                const head = Bodies.circle(x, y - size * 0.8, size * 0.5, {
                    density: 0.004,
                    friction: 0.8,
                    frictionAir: 0.01,
                    label: isPlayer ? 'player_head' : 'enemy_head',
                    collisionFilter: {
                        category: mechCategory,
                        mask: mechCollisionMask
                    }
                });

                // Arms mounted on sides of wide torso
                const leftArm = Bodies.rectangle(x - size * 1.1, y, size * 0.3, size, {
                    density: 0.004,
                    friction: 0.8,
                    frictionAir: 0.01,
                    label: isPlayer ? 'player_arm' : 'enemy_arm',
                    collisionFilter: {
                        category: mechCategory,
                        mask: mechCollisionMask
                    }
                });

                const rightArm = Bodies.rectangle(x + size * 1.1, y, size * 0.3, size, {
                    density: 0.004,
                    friction: 0.8,
                    frictionAir: 0.01,
                    label: isPlayer ? 'player_arm' : 'enemy_arm',
                    collisionFilter: {
                        category: mechCategory,
                        mask: mechCollisionMask
                    }
                });

                // MAD CAT LEGS: WIDE STANCE at outer edges of torso
                // Torso bottom is at y + size*0.5, legs must connect there
                const leftLeg = Bodies.rectangle(x - size * 0.9, y + size * 0.85, size * 0.5, size * 0.6, {
                    density: 0.015,  // Heavy legs for stability
                    friction: 2.5,
                    frictionAir: 0.05,
                    restitution: 0.0,
                    inertia: Infinity,  // Legs don't rotate - stay vertical
                    label: isPlayer ? 'player_leg' : 'enemy_leg',
                    collisionFilter: {
                        category: mechCategory,
                        mask: mechCollisionMask
                    }
                });

                const rightLeg = Bodies.rectangle(x + size * 0.9, y + size * 0.85, size * 0.5, size * 0.6, {
                    density: 0.015,
                    friction: 2.5,
                    frictionAir: 0.05,
                    restitution: 0.0,
                    inertia: Infinity,  // Legs don't rotate - stay vertical
                    label: isPlayer ? 'player_leg' : 'enemy_leg',
                    collisionFilter: {
                        category: mechCategory,
                        mask: mechCollisionMask
                    }
                });

                // SEPARATE FEET for maximum ground contact and stability
                const leftFoot = Bodies.rectangle(x - size * 0.9, y + size * 1.35, size * 1.0, size * 0.3, {
                    density: 0.012,
                    friction: 5.0,  // EXTREME friction - no sliding!
                    frictionAir: 0.05,
                    restitution: 0.0,
                    inertia: Infinity,  // Feet stay flat on ground
                    label: isPlayer ? 'player_foot' : 'enemy_foot',
                    collisionFilter: {
                        category: mechCategory,
                        mask: mechCollisionMask
                    }
                });

                const rightFoot = Bodies.rectangle(x + size * 0.9, y + size * 1.35, size * 1.0, size * 0.3, {
                    density: 0.012,
                    friction: 5.0,  // EXTREME friction - no sliding!
                    frictionAir: 0.05,
                    restitution: 0.0,
                    inertia: Infinity,  // Feet stay flat on ground
                    label: isPlayer ? 'player_foot' : 'enemy_foot',
                    collisionFilter: {
                        category: mechCategory,
                        mask: mechCollisionMask
                    }
                });

                // EXTREMELY RIGID CONSTRAINTS - welded together
                const constraints = [
                    // Head welded to torso
                    Constraint.create({
                        bodyA: head,
                        bodyB: torso,
                        pointA: { x: 0, y: size * 0.3 },
                        pointB: { x: 0, y: -size * 0.45 },
                        stiffness: 1.0,
                        damping: 0.8,  // Very high damping
                        length: 0
                    }),
                    // Left arm - rigid
                    Constraint.create({
                        bodyA: leftArm,
                        bodyB: torso,
                        pointA: { x: 0, y: -size * 0.4 },
                        pointB: { x: -size * 0.9, y: 0 },
                        stiffness: 1.0,
                        damping: 0.6,
                        length: 0
                    }),
                    // Right arm - rigid
                    Constraint.create({
                        bodyA: rightArm,
                        bodyB: torso,
                        pointA: { x: 0, y: -size * 0.4 },
                        pointB: { x: size * 0.9, y: 0 },
                        stiffness: 1.0,
                        damping: 0.6,
                        length: 0
                    }),
                    // Left leg welded - absolutely rigid
                    Constraint.create({
                        bodyA: leftLeg,
                        bodyB: torso,
                        pointA: { x: 0, y: -size * 0.3 },
                        pointB: { x: -size * 0.8, y: size * 0.45 },
                        stiffness: 1.0,
                        damping: 0.9,  // Maximum damping
                        length: 0
                    }),
                    // Right leg welded - absolutely rigid
                    Constraint.create({
                        bodyA: rightLeg,
                        bodyB: torso,
                        pointA: { x: 0, y: -size * 0.3 },
                        pointB: { x: size * 0.8, y: size * 0.45 },
                        stiffness: 1.0,
                        damping: 0.9,  // Maximum damping
                        length: 0
                    }),
                    // Left foot welded - absolutely rigid
                    Constraint.create({
                        bodyA: leftFoot,
                        bodyB: leftLeg,
                        pointA: { x: 0, y: -size * 0.1 },
                        pointB: { x: 0, y: size * 0.3 },
                        stiffness: 1.0,
                        damping: 0.9,  // Maximum damping
                        length: 0
                    }),
                    // Right foot welded - absolutely rigid
                    Constraint.create({
                        bodyA: rightFoot,
                        bodyB: rightLeg,
                        pointA: { x: 0, y: -size * 0.1 },
                        pointB: { x: 0, y: size * 0.3 },
                        stiffness: 1.0,
                        damping: 0.9,  // Maximum damping
                        length: 0
                    })
                ];

                Matter.World.add(this.world, [torso, head, leftArm, rightArm, leftLeg, rightLeg, leftFoot, rightFoot]);
                Matter.World.add(this.world, constraints);

                // WEAPON LOADOUTS FROM LIBRARY
                const weapons = isPlayer ? [
                    // Player loadout: Machine Gun + Heavy Cannon
                    { ...this.weaponDefs.machineGun, lastFired: 0 },
                    { ...this.weaponDefs.heavyCannon, lastFired: 0 }
                ] : [
                    // Enemy loadout: Autocannon + Pulse Laser + Blue Beam
                    { ...this.weaponDefs.autocannon, lastFired: 0 },
                    { ...this.weaponDefs.pulseLaser, lastFired: 0 },
                    { ...this.weaponDefs.blueBeam, lastFired: 0 }
                ];

                // Calculate movement ranges from weapons
                const minRange = Math.min(...weapons.map(w => w.minRange));
                const maxRange = Math.max(...weapons.map(w => w.maxRange));
                const optimalRange = (minRange + maxRange) / 2;

                // COMPONENT-BASED HEALTH AND ARMOR SYSTEM
                // Armor is uniform (8) across all components - health is the differentiator
                const mech = {
                    // Components with individual health and armor
                    components: {
                        torso: {
                            body: torso,
                            health: 120,
                            maxHealth: 120,
                            armor: 8,
                            name: 'Torso',
                            critical: true  // Destroys mech when destroyed
                        },
                        head: {
                            body: head,
                            health: 60,
                            maxHealth: 60,
                            armor: 8,
                            name: 'Head',
                            critical: true  // Destroys mech when destroyed
                        },
                        leftArm: {
                            body: leftArm,
                            health: 50,
                            maxHealth: 50,
                            armor: 8,
                            name: 'Left Arm',
                            critical: false
                        },
                        rightArm: {
                            body: rightArm,
                            health: 50,
                            maxHealth: 50,
                            armor: 8,
                            name: 'Right Arm',
                            critical: false
                        },
                        leftLeg: {
                            body: leftLeg,
                            health: 60,
                            maxHealth: 60,
                            armor: 8,
                            name: 'Left Leg',
                            critical: false
                        },
                        rightLeg: {
                            body: rightLeg,
                            health: 60,
                            maxHealth: 60,
                            armor: 8,
                            name: 'Right Leg',
                            critical: false
                        },
                        leftFoot: {
                            body: leftFoot,
                            health: 40,
                            maxHealth: 40,
                            armor: 8,
                            name: 'Left Foot',
                            critical: false
                        },
                        rightFoot: {
                            body: rightFoot,
                            health: 40,
                            maxHealth: 40,
                            armor: 8,
                            name: 'Right Foot',
                            critical: false
                        }
                    },
                    // Quick access to bodies (for backwards compatibility)
                    torso: torso,
                    head: head,
                    leftArm: leftArm,
                    rightArm: rightArm,
                    leftLeg: leftLeg,
                    rightLeg: rightLeg,
                    leftFoot: leftFoot,
                    rightFoot: rightFoot,
                    constraints: constraints,
                    color: isPlayer ? '#00ff88' : '#ff4444',
                    moveDirection: 0,
                    moveSpeed: 0.002,
                    nextMoveChange: Date.now() + 1000,
                    isPlayer: isPlayer,
                    destroyed: false,  // Full mech destroyed flag
                    destroyedComponents: [],  // Track destroyed component names
                    // Weapons assigned above
                    weapons: weapons,
                    // Range for movement AI (calculated above)
                    weapon: {
                        minRange: minRange,
                        maxRange: maxRange,
                        optimalRange: optimalRange
                    }
                };

                log(`Component-based mech created: Torso=${mech.components.torso.health}HP/${mech.components.torso.armor}Armor`);
                return mech;
            }

            fireProjectile(fromMech, toMech, damage, visuals) {
                const Bodies = Matter.Bodies;
                const Body = Matter.Body;

                // Calculate firing direction first
                const targetVel = toMech.torso.velocity;
                let targetX = toMech.torso.position.x;
                let targetY = toMech.torso.position.y;

                const speed = visuals.speed || 35;
                const tempStartX = fromMech.torso.position.x;
                const tempStartY = fromMech.torso.position.y;
                const distance = Math.sqrt((targetX - tempStartX) ** 2 + (targetY - tempStartY) ** 2);
                const travelTime = distance / speed;

                // Predict where target will be
                const predictedX = targetX + targetVel.x * travelTime * 16;
                const predictedY = targetY + targetVel.y * travelTime * 16;

                const angle = Math.atan2(predictedY - tempStartY, predictedX - tempStartX);

                // SPAWN PROJECTILE OUTSIDE MECH BODY
                // Offset by 40 pixels in firing direction (torso is 60 wide)
                const spawnOffset = 40;
                const startX = tempStartX + Math.cos(angle) * spawnOffset;
                const startY = tempStartY + Math.sin(angle) * spawnOffset;

                const finalDistance = Math.sqrt((predictedX - startX) ** 2 + (predictedY - startY) ** 2);

                // Create projectile with custom size
                const projectileSize = visuals.projectileSize || 8;
                const projectile = Bodies.circle(startX, startY, projectileSize, {
                    density: 0.005,
                    label: 'projectile',
                    restitution: 0.2,
                    frictionAir: 0.008,
                    isSensor: false,
                    collisionFilter: {
                        category: 0x0004,
                        mask: 0x0001 | 0x0002 | 0x0008
                    }
                });

                Body.setVelocity(projectile, {
                    x: Math.cos(angle) * speed,
                    y: Math.sin(angle) * speed
                });

                // Store custom properties for rendering
                projectile.damage = damage;
                projectile.targetMech = toMech;
                projectile.firedAt = Date.now();
                projectile.visuals = visuals;  // Store visual properties

                Matter.World.add(this.world, projectile);
                this.projectiles.push(projectile);
                this.projectileFired++;

                const velMag = Math.sqrt(targetVel.x ** 2 + targetVel.y ** 2);
                const leadDistance = Math.floor(Math.sqrt((predictedX - targetX) ** 2 + (predictedY - targetY) ** 2));
                log(`üöÄ Projectile #${this.projectileFired}: ${damage} dmg, dist=${Math.floor(finalDistance)}u, lead=${leadDistance}u (vel=${velMag.toFixed(1)})`);

                return projectile;
            }

            fireLaser(fromMech, toMech, damage, visuals) {
                // INSTANTANEOUS LASER - hits immediately with raycast
                const fromPos = fromMech.torso.position;
                const toPos = toMech.torso.position;

                // Calculate laser beam direction
                const dx = toPos.x - fromPos.x;
                const dy = toPos.y - fromPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);

                // Spawn laser from front of mech
                const spawnOffset = 40;
                const startX = fromPos.x + Math.cos(angle) * spawnOffset;
                const startY = fromPos.y + Math.sin(angle) * spawnOffset;

                // RAYCAST to find which component is hit
                // Check all components of target mech for intersection
                let hitComponent = null;
                let hitComponentKey = null;
                let closestDist = Infinity;

                for (const [key, component] of Object.entries(toMech.components)) {
                    if (component.health <= 0) continue;  // Skip destroyed components

                    const compPos = component.body.position;
                    const compBounds = component.body.bounds;

                    // Simple AABB ray intersection check
                    // Check if ray passes through component bounding box
                    const inBoundsX = compPos.x >= Math.min(startX, toPos.x) - 30 &&
                                     compPos.x <= Math.max(startX, toPos.x) + 30;
                    const inBoundsY = compPos.y >= Math.min(startY, toPos.y) - 30 &&
                                     compPos.y <= Math.max(startY, toPos.y) + 30;

                    if (inBoundsX && inBoundsY) {
                        const distToComp = Math.sqrt(
                            Math.pow(compPos.x - startX, 2) +
                            Math.pow(compPos.y - startY, 2)
                        );
                        if (distToComp < closestDist) {
                            closestDist = distToComp;
                            hitComponent = component;
                            hitComponentKey = key;
                        }
                    }
                }

                // Default to torso if no specific component hit
                if (!hitComponent && toMech.components.torso.health > 0) {
                    hitComponent = toMech.components.torso;
                    hitComponentKey = 'torso';
                }

                let hitX = toPos.x;
                let hitY = toPos.y;

                // Apply damage if hit
                if (hitComponent) {
                    const rawDamage = damage;
                    const actualDamage = Math.max(1, rawDamage - hitComponent.armor);
                    hitComponent.health -= actualDamage;

                    hitX = hitComponent.body.position.x;
                    hitY = hitComponent.body.position.y;

                    // Create impact effect at hit location
                    this.createImpactEffect(hitX, hitY, { x: 0, y: 0 });
                    this.createDamageNumber(hitX, hitY, actualDamage, hitComponent.armor);

                    log(`‚ö° LASER HIT ${toMech.isPlayer ? 'PLAYER' : 'ENEMY'} ${hitComponent.name}: ${actualDamage} dmg (${hitComponent.health}HP left)`);

                    // Check if component destroyed
                    if (hitComponent.health <= 0) {
                        this.destroyComponent(toMech, hitComponentKey, hitComponent);
                    }
                }

                // Create visual beam effect with custom visuals
                this.laserBeams.push({
                    startX: startX,
                    startY: startY,
                    endX: hitX,
                    endY: hitY,
                    createdAt: Date.now(),
                    duration: visuals.duration || 150,
                    life: 1.0,
                    visuals: visuals  // Store visual properties for rendering
                });

                return true;
            }

            createImpactEffect(x, y, velocity) {
                // Create impact effect with particles and flash
                const effect = {
                    x: x,
                    y: y,
                    createdAt: Date.now(),
                    duration: 300,  // 300ms animation
                    particles: []
                };

                // Create 8 impact particles flying outward
                const particleCount = 8;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 * i) / particleCount;
                    effect.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * 3 + (velocity.x * 0.3),  // Inherit some projectile velocity
                        vy: Math.sin(angle) * 3 + (velocity.y * 0.3),
                        life: 1.0  // Fades from 1 to 0
                    });
                }

                this.impactEffects.push(effect);
            }

            updateMechMovement() {
                const Body = Matter.Body;
                const now = Date.now();

                // Get both mechs
                const mechs = [this.playerMech, this.enemyMech].filter(m => m && !m.destroyed);
                if (mechs.length < 2) return;  // Need both mechs for range-based AI

                mechs.forEach(mech => {
                    const otherMech = mech === this.playerMech ? this.enemyMech : this.playerMech;
                    if (!otherMech || otherMech.destroyed) return;

                    const pos = mech.torso.position;
                    const otherPos = otherMech.torso.position;
                    const vel = mech.torso.velocity;

                    // Calculate distance between mechs
                    const distance = Math.abs(pos.x - otherPos.x);

                    // Track if we need emergency forces
                    let needsEmergencyForce = false;
                    let emergencyForce = 0;

                    // RANGE-BASED MOVEMENT AI
                    let desiredDirection = 0;
                    let forceMultiplier = 1;

                    if (distance > mech.weapon.maxRange) {
                        // Too far - move closer
                        desiredDirection = pos.x < otherPos.x ? 1 : -1;
                    } else if (distance < mech.weapon.minRange) {
                        // Too close - move away with STRONG force
                        desiredDirection = pos.x < otherPos.x ? -1 : 1;
                        forceMultiplier = 50;  // 50x force when below minimum range!
                    } else if (distance > mech.weapon.optimalRange + 30) {
                        // Outside optimal range - move closer
                        desiredDirection = pos.x < otherPos.x ? 1 : -1;
                        forceMultiplier = 2;
                    } else if (distance < mech.weapon.optimalRange - 30) {
                        // Outside optimal range - move away
                        desiredDirection = pos.x < otherPos.x ? -1 : 1;
                        forceMultiplier = 2;
                    } else {
                        // In optimal range - stay still
                        desiredDirection = 0;
                    }

                    // EXTREME REPULSION when mechs are too close
                    if (distance < 120) {
                        // Mechs too close - repel strongly
                        desiredDirection = pos.x < otherPos.x ? -1 : 1;
                        forceMultiplier = 200;  // 200x force when colliding!
                        needsEmergencyForce = true;
                    }

                    // Apply movement forces
                    if (desiredDirection !== 0) {
                        const force = mech.moveSpeed * forceMultiplier;

                        Body.applyForce(mech.torso, pos, {
                            x: desiredDirection * force,
                            y: 0
                        });
                    }

                    // SMART VELOCITY DAMPENING - only dampen when NOT in emergency
                    if (!needsEmergencyForce && Math.abs(vel.x) > 0.1) {
                        Body.setVelocity(mech.torso, {
                            x: vel.x * 0.85,  // Dampen horizontal movement
                            y: vel.y
                        });
                    }
                });
            }

            start() {
                this.running = true;
                log('Physics started');
            }

            stop() {
                this.running = false;
                log('Physics stopped');
            }

            setupRenderLoop() {
                const animate = () => {
                    if (this.running) {
                        this.updateMechMovement(); // Update mech AI movement
                        Matter.Engine.update(this.engine, 16);
                        this.render();
                    }
                    requestAnimationFrame(animate);
                };
                animate();
            }

            render() {
                const ctx = this.ctx;

                // Clear
                ctx.fillStyle = '#0d0d1f';
                ctx.fillRect(0, 0, this.width, this.height);

                // Render ground and terrain
                const bodies = Matter.Composite.allBodies(this.world);
                bodies.forEach(body => {
                    // Only render non-mech bodies with simple rendering
                    if (!body.label.includes('player_') && !body.label.includes('enemy_') || body.label === 'ground') {
                        const vertices = body.vertices;

                        ctx.beginPath();
                        ctx.moveTo(vertices[0].x, vertices[0].y);
                        for (let i = 1; i < vertices.length; i++) {
                            ctx.lineTo(vertices[i].x, vertices[i].y);
                        }
                        ctx.closePath();

                        // Color based on label and custom visuals
                        if (body.label === 'projectile') {
                            const visuals = body.visuals || {};
                            const color = visuals.projectileColor || '#ffaa00';

                            // Draw trail if weapon has trail
                            if (visuals.trail) {
                                ctx.save();
                                ctx.globalAlpha = 0.4;
                                ctx.strokeStyle = visuals.trailColor || color;
                                ctx.lineWidth = (visuals.projectileSize || 8) * 1.5;
                                ctx.lineCap = 'round';

                                // Draw trail behind projectile
                                const vel = body.velocity;
                                const trailLength = 20;
                                ctx.beginPath();
                                ctx.moveTo(vertices[0].x, vertices[0].y);
                                ctx.lineTo(
                                    vertices[0].x - vel.x * 0.5,
                                    vertices[0].y - vel.y * 0.5
                                );
                                ctx.stroke();
                                ctx.restore();
                            }

                            ctx.fillStyle = color;
                        } else {
                            ctx.fillStyle = '#4a4a6a';
                        }

                        ctx.fill();
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                });

                // Render mechs with detailed rendering
                if (this.playerMech) {
                    this.renderMech(this.playerMech, ctx);
                }
                if (this.enemyMech) {
                    this.renderMech(this.enemyMech, ctx);
                }

                // Render impact effects
                this.renderImpactEffects(ctx);

                // Render damage numbers
                this.renderDamageNumbers(ctx);

                // Render laser beams
                this.renderLaserBeams(ctx);

                // Render HP bars (component health)
                if (this.playerMech && !this.playerMech.destroyed) {
                    this.renderComponentHealth(this.playerMech, ctx);
                }
                if (this.enemyMech && !this.enemyMech.destroyed) {
                    this.renderComponentHealth(this.enemyMech, ctx);
                }

                // Debug info with V4 STATUS
                ctx.fillStyle = '#ff00ff';
                ctx.font = 'bold 16px monospace';
                ctx.fillText('V4.4 WEAPON LIBRARY', 10, 20);

                ctx.fillStyle = '#00ff88';
                ctx.font = '14px monospace';
                const pDir = this.playerMech ? (this.playerMech.moveDirection < 0 ? '‚Üê' : this.playerMech.moveDirection > 0 ? '‚Üí' : '‚Ä¢') : '‚Ä¢';
                const eDir = this.enemyMech ? (this.enemyMech.moveDirection < 0 ? '‚Üê' : this.enemyMech.moveDirection > 0 ? '‚Üí' : '‚Ä¢') : '‚Ä¢';
                ctx.fillText(`Player ${pDir}: ${this.playerMech ? Math.floor(this.playerMech.currentHP) : 0}/${this.playerMech ? this.playerMech.maxHP : 0} HP`, 10, 45);
                ctx.fillText(`Enemy ${eDir}: ${this.enemyMech ? Math.floor(this.enemyMech.currentHP) : 0}/${this.enemyMech ? this.enemyMech.maxHP : 0} HP`, 10, 65);
                ctx.fillText(`Projectiles: ${this.projectiles.length} active`, 10, 85);
                ctx.fillText(`Fired: ${this.projectileFired} | Hit: ${this.projectileHit} | Miss: ${this.projectileMissed}`, 10, 105);

                // RENDER VERIFICATION
                ctx.fillStyle = '#ff6b35';
                ctx.fillText('Modern Rendering: ' + (this._v3verified ? 'YES' : 'NO'), 10, 125);
            }

            renderMech(mech, ctx) {
                // Save context
                ctx.save();

                const scale = 1; // Test mechs are all medium scale
                const baseColor = mech.color;
                const darkColor = this.darkenColor(baseColor, 0.6);
                const lightColor = this.lightenColor(baseColor, 1.3);

                // V3.0 VERIFICATION - Log once on first render
                if (!this._v3verified) {
                    console.log('%c‚úÖ V3.0 RENDERING ACTIVE - Angular + Glow Effects', 'color: #00ff88; font-size: 14px; font-weight: bold');
                    this._v3verified = true;
                }

                // Render mech components in proper order (back to front)
                this.renderMechLegs(mech, ctx, scale, baseColor, darkColor, lightColor);
                this.renderMechTorso(mech, ctx, scale, baseColor, darkColor, lightColor);
                this.renderMechArms(mech, ctx, scale, baseColor, darkColor, lightColor);
                this.renderMechHead(mech, ctx, scale, baseColor, darkColor, lightColor);

                ctx.restore();
            }

            renderMechLegs(mech, ctx, scale, baseColor, darkColor, lightColor) {
                // SVG-INSPIRED INDUSTRIAL DESIGN
                const armorBase = '#7c8a7c';  // Olive drab
                const armorDark = '#4a524a';  // Dark olive
                const mechGrey = '#555';      // Mechanical grey
                const mechDark = '#333';      // Dark mech
                const jointGrey = '#444';     // Joint color
                const accentYellow = '#fc0';  // Yellow accent

                const leftLeg = mech.leftLeg;
                const rightLeg = mech.rightLeg;

                // Render legs (thigh + shin)
                [leftLeg, rightLeg].forEach((leg, index) => {
                    const legX = leg.position.x;
                    const legY = leg.position.y;
                    const angle = leg.angle;
                    const isFront = index === 1;  // Second leg is front

                    ctx.save();
                    ctx.translate(legX, legY);
                    ctx.rotate(angle);

                    // Thigh - angular armored shape (trapezoid)
                    ctx.fillStyle = isFront ? armorBase : mechGrey;
                    ctx.strokeStyle = isFront ? '#333' : '#222';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-8 * scale, -10 * scale);
                    ctx.lineTo(8 * scale, -10 * scale);
                    ctx.lineTo(7 * scale, 18 * scale);
                    ctx.lineTo(-7 * scale, 18 * scale);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Thigh armor panel (darker)
                    ctx.fillStyle = isFront ? armorDark : mechDark;
                    ctx.beginPath();
                    ctx.moveTo(-6 * scale, -5 * scale);
                    ctx.lineTo(6 * scale, -5 * scale);
                    ctx.lineTo(5 * scale, 10 * scale);
                    ctx.lineTo(-5 * scale, 10 * scale);
                    ctx.closePath();
                    ctx.fill();

                    // Yellow accent strip (front leg only)
                    if (isFront) {
                        ctx.fillStyle = accentYellow;
                        ctx.fillRect(-6 * scale, 5 * scale, 4 * scale, 8 * scale);
                    }

                    // Hip joint circle
                    ctx.fillStyle = jointGrey;
                    ctx.strokeStyle = isFront ? '#333' : '#222';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 5 * scale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Inner joint detail
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.arc(0, 0, 3 * scale, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                });

                // Render separate FEET
                if (mech.leftFoot && mech.rightFoot) {
                    [mech.leftFoot, mech.rightFoot].forEach((foot, index) => {
                        const footX = foot.position.x;
                        const footY = foot.position.y;
                        const angle = foot.angle;
                        const isFront = index === 1;

                        ctx.save();
                        ctx.translate(footX, footY);
                        ctx.rotate(angle);

                        // Ankle joint circle
                        ctx.fillStyle = jointGrey;
                        ctx.strokeStyle = isFront ? '#333' : '#222';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, -3 * scale, 4 * scale, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();

                        // Foot - angular armored boot shape
                        ctx.fillStyle = isFront ? armorBase : mechGrey;
                        ctx.strokeStyle = isFront ? '#333' : '#222';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(-12 * scale, -2 * scale);
                        ctx.lineTo(12 * scale, -2 * scale);
                        ctx.lineTo(15 * scale, 4 * scale);
                        ctx.lineTo(-15 * scale, 4 * scale);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();

                        // Foot armor detail
                        ctx.fillStyle = isFront ? armorDark : mechDark;
                        ctx.beginPath();
                        ctx.moveTo(-10 * scale, 0);
                        ctx.lineTo(10 * scale, 0);
                        ctx.lineTo(12 * scale, 3 * scale);
                        ctx.lineTo(-12 * scale, 3 * scale);
                        ctx.closePath();
                        ctx.fill();

                        // Tread lines
                        ctx.strokeStyle = '#222';
                        ctx.lineWidth = 1;
                        for (let i = -10; i <= 10; i += 5) {
                            ctx.beginPath();
                            ctx.moveTo(i * scale, 1 * scale);
                            ctx.lineTo(i * scale, 3.5 * scale);
                            ctx.stroke();
                        }

                        ctx.restore();
                    });
                }
            }

            renderMechTorso(mech, ctx, scale, baseColor, darkColor, lightColor) {
                // SVG-INSPIRED COLORS
                const armorBase = '#7c8a7c';
                const armorDark = '#4a524a';
                const mechGrey = '#555';

                const torso = mech.torso;
                const torsoX = torso.position.x;
                const torsoY = torso.position.y;
                const angle = torso.angle;

                ctx.save();
                ctx.translate(torsoX, torsoY);
                ctx.rotate(angle);

                // Main torso - angular trapezoid (SVG style)
                ctx.fillStyle = armorBase;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-25 * scale, -15 * scale);  // Top left
                ctx.lineTo(25 * scale, -15 * scale);   // Top right
                ctx.lineTo(20 * scale, 15 * scale);    // Bottom right
                ctx.lineTo(-20 * scale, 15 * scale);   // Bottom left
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Inner mechanical panel
                ctx.fillStyle = mechGrey;
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-15 * scale, -10 * scale);
                ctx.lineTo(15 * scale, -10 * scale);
                ctx.lineTo(10 * scale, 5 * scale);
                ctx.lineTo(-10 * scale, 5 * scale);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Cockpit viewport - glowing cyan (animated)
                const gradient = ctx.createLinearGradient(0, -10 * scale, 0, -5 * scale);
                gradient.addColorStop(0, '#00ffff');
                gradient.addColorStop(1, '#0088ff');
                ctx.fillStyle = gradient;
                ctx.globalAlpha = 0.9;
                ctx.fillRect(-8 * scale, -10 * scale, 16 * scale, 4 * scale);
                ctx.globalAlpha = 1;
                ctx.strokeStyle = '#0088ff';
                ctx.lineWidth = 2;
                ctx.strokeRect(-8 * scale, -10 * scale, 16 * scale, 4 * scale);

                // Shoulder armor plates
                ctx.fillStyle = armorBase;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                // Left shoulder
                ctx.beginPath();
                ctx.moveTo(-35 * scale, -18 * scale);
                ctx.lineTo(-20 * scale, -18 * scale);
                ctx.lineTo(-20 * scale, -8 * scale);
                ctx.lineTo(-30 * scale, -5 * scale);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                // Right shoulder
                ctx.beginPath();
                ctx.moveTo(20 * scale, -18 * scale);
                ctx.lineTo(35 * scale, -18 * scale);
                ctx.lineTo(30 * scale, -5 * scale);
                ctx.lineTo(20 * scale, -8 * scale);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Panel lines for detail
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    const y = (-6 + i * 6) * scale;
                    ctx.beginPath();
                    ctx.moveTo(-10 * scale, y);
                    ctx.lineTo(10 * scale, y);
                    ctx.stroke();
                }

                // Vent ports
                ctx.fillStyle = '#1a1a1a';
                for (let i = 0; i < 3; i++) {
                    const x = (-6 + i * 6) * scale;
                    ctx.fillRect(x - 1.5 * scale, 8 * scale, 3 * scale, 4 * scale);
                }

                ctx.restore();
            }

            renderMechArms(mech, ctx, scale, baseColor, darkColor, lightColor) {
                // SVG-INSPIRED COLORS
                const armorBase = '#7c8a7c';
                const mechGrey = '#555';
                const mechDark = '#333';
                const jointGrey = '#444';
                const accentYellow = '#fc0';

                const leftArm = mech.leftArm;
                const rightArm = mech.rightArm;

                [leftArm, rightArm].forEach((arm, index) => {
                    const armX = arm.position.x;
                    const armY = arm.position.y;
                    const angle = arm.angle;
                    const isRight = index === 1;

                    ctx.save();
                    ctx.translate(armX, armY);
                    ctx.rotate(angle);

                    // Shoulder joint
                    ctx.fillStyle = jointGrey;
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 6 * scale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Upper arm - angular armor
                    ctx.fillStyle = isRight ? armorBase : mechGrey;
                    ctx.strokeStyle = isRight ? '#333' : '#222';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-7 * scale, -5 * scale);
                    ctx.lineTo(7 * scale, -5 * scale);
                    ctx.lineTo(6 * scale, 12 * scale);
                    ctx.lineTo(-6 * scale, 12 * scale);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Weapon mount (forearm) - rectangular cannon
                    ctx.fillStyle = mechGrey;
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 2;
                    ctx.fillRect(-6 * scale, 10 * scale, 12 * scale, 12 * scale);
                    ctx.strokeRect(-6 * scale, 10 * scale, 12 * scale, 12 * scale);

                    // Weapon barrel
                    ctx.fillStyle = mechDark;
                    ctx.strokeStyle = '#222';
                    ctx.fillRect(-4 * scale, 22 * scale, 8 * scale, 6 * scale);
                    ctx.strokeRect(-4 * scale, 22 * scale, 8 * scale, 6 * scale);

                    // Muzzle tip
                    ctx.fillStyle = '#222';
                    ctx.fillRect(-3 * scale, 28 * scale, 6 * scale, 2 * scale);

                    // Yellow accent panel (right arm only)
                    if (isRight) {
                        ctx.fillStyle = accentYellow;
                        ctx.fillRect(-8 * scale, 14 * scale, 3 * scale, 6 * scale);
                    }

                    ctx.restore();
                });
            }

            renderMechHead(mech, ctx, scale, baseColor, darkColor, lightColor) {
                // SVG-INSPIRED COLORS
                const armorBase = '#7c8a7c';

                const head = mech.head;
                const headX = head.position.x;
                const headY = head.position.y;
                const angle = head.angle;

                ctx.save();
                ctx.translate(headX, headY);
                ctx.rotate(angle);

                // Head - angular trapezoid (SVG style)
                ctx.fillStyle = armorBase;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-8 * scale, 0);       // Bottom left
                ctx.lineTo(8 * scale, 0);        // Bottom right
                ctx.lineTo(6 * scale, -12 * scale);  // Top right
                ctx.lineTo(-6 * scale, -12 * scale); // Top left
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Red visor - glowing sensor strip
                ctx.fillStyle = '#ff3300';
                ctx.strokeStyle = '#880000';
                ctx.lineWidth = 1;
                ctx.fillRect(-4 * scale, -8 * scale, 8 * scale, 3 * scale);
                ctx.strokeRect(-4 * scale, -8 * scale, 8 * scale, 3 * scale);

                // Visor glow effect
                ctx.fillStyle = '#ff3300';
                ctx.globalAlpha = 0.3;
                ctx.fillRect(-5 * scale, -9 * scale, 10 * scale, 5 * scale);
                ctx.globalAlpha = 1;

                // Neck connection joint
                ctx.fillStyle = '#444';
                ctx.beginPath();
                ctx.arc(0, 2 * scale, 3 * scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.stroke();

                ctx.restore();
            }

            darkenColor(color, factor) {
                const hex = color.replace('#', '');
                const r = Math.max(0, Math.floor(parseInt(hex.substr(0, 2), 16) * factor));
                const g = Math.max(0, Math.floor(parseInt(hex.substr(2, 2), 16) * factor));
                const b = Math.max(0, Math.floor(parseInt(hex.substr(4, 2), 16) * factor));
                return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
            }

            lightenColor(color, factor) {
                const hex = color.replace('#', '');
                const r = Math.min(255, Math.floor(parseInt(hex.substr(0, 2), 16) * factor));
                const g = Math.min(255, Math.floor(parseInt(hex.substr(2, 2), 16) * factor));
                const b = Math.min(255, Math.floor(parseInt(hex.substr(4, 2), 16) * factor));
                return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
            }

            renderHPBar(mech) {
                const ctx = this.ctx;
                const x = mech.torso.position.x;
                const y = mech.torso.position.y - 60;
                const width = 80;
                const height = 8;

                const hpPercent = mech.currentHP / mech.maxHP;

                ctx.fillStyle = '#000';
                ctx.fillRect(x - width/2, y, width, height);

                ctx.fillStyle = hpPercent > 0.5 ? '#00ff88' : hpPercent > 0.25 ? '#ffaa00' : '#ff4444';
                ctx.fillRect(x - width/2, y, width * hpPercent, height);
            }

            renderImpactEffects(ctx) {
                const now = Date.now();

                // Update and render each impact effect
                this.impactEffects = this.impactEffects.filter(effect => {
                    const age = now - effect.createdAt;
                    if (age > effect.duration) return false;  // Remove expired effects

                    const progress = age / effect.duration;  // 0 to 1

                    // Central flash that fades quickly
                    const flashAlpha = Math.max(0, 1 - progress * 2);  // Fades faster
                    if (flashAlpha > 0) {
                        ctx.save();
                        ctx.globalAlpha = flashAlpha;

                        // Bright orange flash
                        const flashRadius = 15 + progress * 10;
                        const gradient = ctx.createRadialGradient(effect.x, effect.y, 0, effect.x, effect.y, flashRadius);
                        gradient.addColorStop(0, '#fff');
                        gradient.addColorStop(0.3, '#ffaa00');
                        gradient.addColorStop(0.6, '#ff6b35');
                        gradient.addColorStop(1, 'rgba(255, 107, 53, 0)');

                        ctx.fillStyle = gradient;
                        ctx.fillRect(effect.x - flashRadius, effect.y - flashRadius, flashRadius * 2, flashRadius * 2);
                        ctx.restore();
                    }

                    // Render particles flying outward
                    effect.particles.forEach(particle => {
                        particle.x += particle.vx;
                        particle.y += particle.vy;
                        particle.life = 1 - progress;

                        if (particle.life > 0) {
                            ctx.save();
                            ctx.globalAlpha = particle.life;
                            ctx.fillStyle = '#ffaa00';
                            ctx.beginPath();
                            ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                    });

                    return true;  // Keep effect
                });
            }

            renderDamageNumbers(ctx) {
                const now = Date.now();
                const duration = 1000;  // 1 second

                this.damageNumbers = this.damageNumbers.filter(dmg => {
                    const age = now - dmg.createdAt;
                    if (age > duration) return false;  // Remove expired

                    const progress = age / duration;
                    dmg.life = 1 - progress;

                    // Float upward
                    const yOffset = -progress * 50;

                    ctx.save();
                    ctx.globalAlpha = dmg.life;
                    ctx.font = 'bold 20px monospace';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;

                    // Show damage in red
                    const text = `-${dmg.damage}`;
                    ctx.strokeText(text, dmg.x, dmg.y + yOffset);
                    ctx.fillStyle = '#ff3300';
                    ctx.fillText(text, dmg.x, dmg.y + yOffset);

                    // Show armor blocked in small grey text below
                    if (dmg.armorBlocked > 0) {
                        ctx.font = 'bold 12px monospace';
                        ctx.fillStyle = '#888';
                        const armorText = `(${dmg.armorBlocked} blocked)`;
                        ctx.fillText(armorText, dmg.x - 20, dmg.y + yOffset + 18);
                    }

                    ctx.restore();

                    return true;  // Keep
                });
            }

            renderLaserBeams(ctx) {
                const now = Date.now();

                this.laserBeams = this.laserBeams.filter(beam => {
                    const age = now - beam.createdAt;
                    if (age > beam.duration) return false;  // Remove expired

                    const progress = age / beam.duration;
                    beam.life = 1 - progress;

                    ctx.save();

                    // Draw beam with glow effect using custom colors
                    const alpha = beam.life;
                    const visuals = beam.visuals || {};
                    const beamColor = visuals.beamColor || '#ff0000';
                    const glowColor = visuals.glowColor || '#ff3333';
                    const coreColor = visuals.coreColor || '#ffff00';
                    const width = visuals.width || 8;

                    // Outer glow (wider, dimmer)
                    ctx.globalAlpha = alpha * 0.3;
                    ctx.strokeStyle = beamColor;
                    ctx.lineWidth = width;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(beam.startX, beam.startY);
                    ctx.lineTo(beam.endX, beam.endY);
                    ctx.stroke();

                    // Middle glow
                    ctx.globalAlpha = alpha * 0.6;
                    ctx.strokeStyle = glowColor;
                    ctx.lineWidth = width * 0.5;
                    ctx.beginPath();
                    ctx.moveTo(beam.startX, beam.startY);
                    ctx.lineTo(beam.endX, beam.endY);
                    ctx.stroke();

                    // Core beam (bright, thin)
                    ctx.globalAlpha = alpha;
                    ctx.strokeStyle = coreColor;
                    ctx.lineWidth = width * 0.25;
                    ctx.beginPath();
                    ctx.moveTo(beam.startX, beam.startY);
                    ctx.lineTo(beam.endX, beam.endY);
                    ctx.stroke();

                    ctx.restore();

                    return true;  // Keep
                });
            }

            renderComponentHealth(mech, ctx) {
                const torso = mech.components.torso;
                const x = torso.body.position.x;
                const y = torso.body.position.y - 80;

                // Torso health bar (main)
                this.renderHealthBar(ctx, x, y, torso.health, torso.maxHealth, '#00ff88', 'Torso');

                // Show damaged/destroyed components
                let yOffset = 15;
                for (const [key, component] of Object.entries(mech.components)) {
                    if (key === 'torso') continue;  // Already showing torso

                    if (component.health < component.maxHealth) {
                        const percent = component.health / component.maxHealth;
                        const color = percent > 0.5 ? '#ffaa00' : percent > 0 ? '#ff4444' : '#666';
                        this.renderHealthBar(ctx, x, y + yOffset, component.health, component.maxHealth, color, component.name);
                        yOffset += 12;
                    }
                }
            }

            renderHealthBar(ctx, x, y, current, max, color, label) {
                const width = 100;
                const height = 8;
                const healthPercent = Math.max(0, current / max);

                // Background
                ctx.fillStyle = '#000';
                ctx.fillRect(x - width/2, y, width, height);

                // Health
                ctx.fillStyle = color;
                ctx.fillRect(x - width/2, y, width * healthPercent, height);

                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(x - width/2, y, width, height);

                // Label
                if (label) {
                    ctx.font = 'bold 10px monospace';
                    ctx.fillStyle = '#fff';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    const text = `${label}: ${Math.floor(current)}/${max}`;
                    ctx.strokeText(text, x - width/2, y - 2);
                    ctx.fillText(text, x - width/2, y - 2);
                }
            }
        }

        // Create physics engine
        const physics = new SimplePhysicsEngine('canvas');

        // Create mechs closer together (300 units apart for firing range)
        log('Creating mechs...');
        physics.playerMech = physics.createMech(200, 300, true);
        physics.enemyMech = physics.createMech(500, 300, false);  // 300 units apart

        log('Mechs created with component-based health!');
        log(`Player Torso: ${physics.playerMech.components.torso.health}HP (${physics.playerMech.components.torso.armor} armor)`);
        log(`Enemy Torso: ${physics.enemyMech.components.torso.health}HP (${physics.enemyMech.components.torso.armor} armor)`);

        // Start physics
        physics.start();
        log('Physics running!');

        // Auto-fire test with DUAL WEAPON SYSTEM and RANGE CHECKING
        // Run weapon firing every 100ms to check cooldowns
        setInterval(() => {
            if (physics.battleEnded) return;
            if (physics.playerMech.destroyed || physics.enemyMech.destroyed) return;

            const now = Date.now();
            const playerPos = physics.playerMech.torso.position;
            const enemyPos = physics.enemyMech.torso.position;
            const distance = Math.abs(playerPos.x - enemyPos.x);

            // Check each mech's weapons
            [physics.playerMech, physics.enemyMech].forEach(mech => {
                const target = mech === physics.playerMech ? physics.enemyMech : physics.playerMech;
                const mechName = mech.isPlayer ? 'PLAYER' : 'ENEMY';

                mech.weapons.forEach(weapon => {
                    // Check if weapon is off cooldown
                    if (now - weapon.lastFired < weapon.cooldown) return;

                    // Check if target is in weapon range
                    if (distance < weapon.minRange || distance > weapon.maxRange) return;

                    // Fire weapon!
                    weapon.lastFired = now;

                    if (weapon.type === 'projectile') {
                        physics.fireProjectile(mech, target, weapon.damage, weapon.visuals);
                        log(`üî´ ${mechName} ${weapon.name}: ${weapon.damage}dmg (range=${Math.floor(distance)})`);
                    } else if (weapon.type === 'laser') {
                        physics.fireLaser(mech, target, weapon.damage, weapon.visuals);
                        log(`‚ö° ${mechName} ${weapon.name}: ${weapon.damage}dmg (range=${Math.floor(distance)})`);
                    }
                });
            });
        }, 100);  // Check every 100ms

        log('Auto-fire started - dual weapon system active!');
        log('Watch the canvas and logs!');
    </script>
</body>
</html>
