<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>BattleTech Arena - MechBuilder</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            padding: 0;
            background: #0a0a12;
            font-family: 'Courier New', monospace;
            color: #00ff88;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        /* ============================================
           GAME CONTAINER
           ============================================ */
        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        /* ============================================
           MECHBUILDER UI OVERLAY
           ============================================ */
        #mechBuilderUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
        }

        /* Top bar - Header Panel */
        #statsPanel {
            pointer-events: auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: linear-gradient(180deg, rgba(0,20,10,0.95) 0%, rgba(0,20,10,0.7) 100%);
            border-bottom: 2px solid #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.3);
        }

        #statsPanel .nav-spacer {
            flex: 1;
        }

        .header-nav-btn {
            pointer-events: auto;
            padding: 10px 20px;
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .header-nav-btn:hover:not(:disabled) {
            background: rgba(0, 255, 136, 0.4);
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
        }

        .header-nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #555;
            color: #555;
        }

        .header-nav-btn.warning {
            border-color: #ff4444;
            color: #ff4444;
        }

        /* Mech Stats (above grid) */
        #mechStats {
            display: flex;
            justify-content: center;
            gap: 30px;
            padding: 10px;
            pointer-events: auto;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .stat-label {
            font-size: 10px;
            color: #00aa66;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-bar {
            width: 150px;
            height: 16px;
            background: rgba(0,0,0,0.6);
            border: 1px solid #00ff88;
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }

        .stat-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .stat-fill.weight {
            background: linear-gradient(90deg, #00ff88, #88ffaa);
        }

        .stat-fill.energy {
            background: linear-gradient(90deg, #00aaff, #88ddff);
        }

        .stat-fill.over-limit {
            background: linear-gradient(90deg, #ff4444, #ff8888);
        }

        .stat-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            color: #fff;
            text-shadow: 0 0 4px #000;
        }

        .stat-fill.hp {
            background: linear-gradient(90deg, #ff4444, #ff8888);
        }

        .stat-fill.armor {
            background: linear-gradient(90deg, #888888, #aaaaaa);
        }

        .stat-fill.accuracy {
            background: linear-gradient(90deg, #ffaa00, #ffcc44);
        }

        /* Loadout Main Layout - Bench on left, Mech Grid on right */
        #loadoutMain {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Left Bench Panel */
        #benchPanel {
            width: 200px;
            min-width: 200px;
            background: linear-gradient(90deg, rgba(0,20,10,0.95) 0%, rgba(0,20,10,0.8) 100%);
            border-right: 2px solid #00ff88;
            display: flex;
            flex-direction: column;
            pointer-events: auto;
        }

        #benchHeader {
            padding: 15px;
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
            text-align: center;
        }

        #benchTitle {
            font-size: 14px;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
        }

        #benchSubtitle {
            font-size: 10px;
            color: #00aa66;
        }

        #benchScroll {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .bench-item-vertical {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(0, 40, 20, 0.6);
            border: 2px solid #00aa66;
            border-radius: 6px;
            cursor: grab;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bench-item-vertical:hover {
            background: rgba(0, 60, 30, 0.8);
            border-color: #00ff88;
            transform: translateX(3px);
        }

        .bench-item-vertical:active {
            cursor: grabbing;
        }

        .bench-item-vertical.dragging {
            opacity: 0.5;
        }

        .bench-item-vertical .item-icon {
            font-size: 24px;
            flex-shrink: 0;
        }

        .bench-item-vertical .item-info {
            flex: 1;
            min-width: 0;
        }

        .bench-item-vertical .item-name {
            font-size: 11px;
            color: #00ff88;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .bench-item-vertical .item-stats {
            font-size: 9px;
            color: #00aa66;
        }

        .bench-item-vertical.weapon { border-color: #ff6644; }
        .bench-item-vertical.weapon .item-icon { color: #ff6644; }
        .bench-item-vertical.armor { border-color: #4488ff; }
        .bench-item-vertical.armor .item-icon { color: #4488ff; }
        .bench-item-vertical.reactor { border-color: #ffaa00; }
        .bench-item-vertical.reactor .item-icon { color: #ffaa00; }
        .bench-item-vertical.system { border-color: #aa44ff; }
        .bench-item-vertical.system .item-icon { color: #aa44ff; }
        .bench-item-vertical.cooling { border-color: #44ddff; }
        .bench-item-vertical.cooling .item-icon { color: #44ddff; }

        #benchEmpty {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
            font-size: 11px;
        }

        /* Mech Grid Area */
        #mechGridArea {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow: auto;
        }

        /* Unified Mech Grid */
        #unifiedMechGrid {
            display: grid;
            gap: 2px;
            padding: 10px;
            background: rgba(0, 20, 10, 0.9);
            border: 2px solid rgba(0, 255, 136, 0.6);
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            pointer-events: auto;
        }

        .mech-cell {
            width: 45px;
            height: 45px;
            background: rgba(0, 255, 136, 0.15);
            border: 1px solid rgba(0, 255, 136, 0.5);
            border-radius: 3px;
            transition: all 0.2s ease;
            position: relative;
        }

        .mech-cell.invalid {
            background: transparent;
            border-color: transparent;
            pointer-events: none;
        }

        .mech-cell:not(.invalid):hover {
            background: rgba(0, 255, 136, 0.25);
            border-color: #00ff88;
        }

        .mech-cell.valid-drop {
            background: rgba(0, 255, 136, 0.4);
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0,255,136,0.5);
        }

        .mech-cell.invalid-drop {
            background: rgba(255, 68, 68, 0.4);
            border-color: #ff4444;
        }

        .mech-cell.occupied {
            background: rgba(0, 170, 255, 0.3);
            border-color: #00aaff;
        }

        /* Placed items in unified grid */
        .placed-item-unified {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-size: 20px;
            cursor: grab;
            z-index: 10;
            transition: transform 0.1s;
        }

        .placed-item-unified:hover {
            transform: scale(1.05);
            z-index: 20;
        }

        .placed-item-unified.weapon { background: rgba(255, 102, 68, 0.7); border: 2px solid #ff6644; }
        .placed-item-unified.armor { background: rgba(68, 136, 255, 0.7); border: 2px solid #4488ff; }
        .placed-item-unified.reactor { background: rgba(255, 170, 0, 0.7); border: 2px solid #ffaa00; }
        .placed-item-unified.system { background: rgba(170, 68, 255, 0.7); border: 2px solid #aa44ff; }
        .placed-item-unified.cooling { background: rgba(68, 221, 255, 0.7); border: 2px solid #44ddff; }

        #pileViewerClose {
            margin-top: 20px;
            padding: 10px 30px;
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            border-radius: 4px;
        }

        #gameTitle {
            font-size: 18px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            letter-spacing: 2px;
        }

        /* Middle area - Grid Overlays (compact layout) */
        #gridOverlayContainer {
            flex: 1;
            pointer-events: none;
            display: grid;
            grid-template-columns: auto auto auto;
            grid-template-rows: auto auto;
            grid-template-areas:
                "leftArm torso rightArm"
                "legs legs legs";
            gap: 5px;
            padding: 20px 10px 20px 10px;
            justify-content: center;
            align-content: center;
            align-items: start;
            overflow-y: auto;
        }

        #legsContainer {
            grid-area: legs;
            display: flex;
            justify-content: center;
            gap: 5px;
            pointer-events: none;
        }

        .mech-grid-overlay {
            position: relative;
            pointer-events: auto;
            display: grid;
            gap: 2px;
            padding: 4px;
            background: rgba(0, 20, 10, 0.9);
            border: 2px solid rgba(0, 255, 136, 0.6);
            border-radius: 4px;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
            transition: border-color 0.15s, box-shadow 0.15s;
        }

        .mech-grid-overlay[data-slot="torso"] { grid-area: torso; }
        .mech-grid-overlay[data-slot="leftArm"] { grid-area: leftArm; }
        .mech-grid-overlay[data-slot="rightArm"] { grid-area: rightArm; }

        .mech-grid-overlay.slot-valid {
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .mech-grid-overlay.slot-invalid {
            border-color: #ff4444;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.4);
            opacity: 0.6;
        }

        .mech-grid-overlay.slot-invalid .grid-label {
            color: #ff6666;
        }

        .grid-cell {
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 136, 0.15);
            border: 1px solid rgba(0, 255, 136, 0.5);
            border-radius: 2px;
            transition: all 0.2s ease;
        }

        .grid-cell:hover {
            background: rgba(0, 255, 136, 0.25);
            border-color: #00ff88;
        }

        .grid-cell.valid-drop {
            background: rgba(0, 255, 136, 0.4);
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0,255,136,0.5);
        }

        .grid-cell.invalid-drop {
            background: rgba(255, 68, 68, 0.4);
            border-color: #ff4444;
            box-shadow: 0 0 10px rgba(255,68,68,0.5);
        }

        .grid-cell.occupied {
            background: rgba(0, 170, 255, 0.3);
            border-color: #00aaff;
        }

        .grid-label {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #00aa66;
            text-transform: uppercase;
            letter-spacing: 1px;
            white-space: nowrap;
        }

        /* Bottom area - The Bench (Hand) */
        #benchContainer {
            pointer-events: auto;
            padding: 15px 20px;
            background: linear-gradient(0deg, rgba(0,20,10,0.95) 0%, rgba(0,20,10,0.7) 100%);
            border-top: 2px solid #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.3);
            transition: border-color 0.15s, box-shadow 0.15s;
        }

        #benchContainer.drop-target {
            border-top-color: #00ffaa;
            box-shadow: 0 0 30px rgba(0,255,170,0.5);
            background: linear-gradient(0deg, rgba(0,40,20,0.95) 0%, rgba(0,30,15,0.8) 100%);
        }

        #benchLabel {
            font-size: 12px;
            color: #00aa66;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
            text-align: center;
        }

        #bench {
            display: flex;
            gap: 15px;
            overflow-x: auto;
            overflow-y: visible;
            padding: 10px 0;
            padding-top: 120px;
            margin-top: -110px;
            min-height: 100px;
            justify-content: center;
        }

        .bench-item {
            flex-shrink: 0;
            width: 80px;
            height: 80px;
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: grab;
            transition: all 0.2s ease;
            position: relative;
        }

        .bench-item:hover {
            background: rgba(0, 255, 136, 0.2);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,255,136,0.3);
        }

        .bench-item:active {
            cursor: grabbing;
        }

        .bench-item.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .bench-item .item-icon {
            font-size: 28px;
            margin-bottom: 4px;
        }

        .bench-item .item-name {
            font-size: 9px;
            color: #00ff88;
            text-align: center;
            padding: 0 4px;
        }

        .bench-item .item-shape {
            display: none;  /* Hidden, replaced by visual grid */
        }

        .bench-item .shape-preview {
            display: grid;
            gap: 1px;
            margin-top: 4px;
        }

        .bench-item .shape-cell {
            width: 10px;
            height: 10px;
            background: currentColor;
            opacity: 0.6;
            border-radius: 1px;
        }

        .bench-item .shape-cell.empty {
            background: transparent;
        }

        .bench-item.weapon { border-color: #ff6644; }
        .bench-item.weapon .item-icon { color: #ff6644; }
        .bench-item.armor { border-color: #4488ff; }
        .bench-item.armor .item-icon { color: #4488ff; }
        .bench-item.reactor { border-color: #ffaa00; }
        .bench-item.reactor .item-icon { color: #ffaa00; }
        .bench-item.system { border-color: #aa44ff; }
        .bench-item.system .item-icon { color: #aa44ff; }
        .bench-item.cooling { border-color: #44ddff; }
        .bench-item.cooling .item-icon { color: #44ddff; }

        /* Rotate button on bench items */
        .bench-item .rotate-btn {
            position: absolute;
            top: -8px;
            left: -8px;
            width: 22px;
            height: 22px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid currentColor;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s, visibility 0.15s, transform 0.15s;
            z-index: 50;
        }
        .bench-item:hover .rotate-btn {
            opacity: 1;
            visibility: visible;
        }
        .bench-item .rotate-btn:hover {
            transform: scale(1.2);
            background: rgba(0, 255, 136, 0.3);
        }
        .bench-item .rotate-btn:active {
            transform: scale(0.9);
        }

        /* Bench item tooltip */
        .bench-item .bench-tooltip {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 10, 0.95);
            border: 1px solid currentColor;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s, visibility 0.15s;
            z-index: 100;
            pointer-events: none;
        }

        .bench-item:hover .bench-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .bench-item .bench-tooltip .tooltip-name {
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 4px;
        }

        .bench-item .bench-tooltip .tooltip-stats {
            color: #aaa;
        }

        .bench-item .bench-tooltip .tooltip-stats span {
            display: block;
            margin: 2px 0;
        }

        .bench-item .bench-tooltip .tooltip-slots {
            color: #666;
            font-size: 9px;
            margin-top: 4px;
            border-top: 1px solid #333;
            padding-top: 4px;
        }

        .bench-item .bench-tooltip .tooltip-special {
            color: #44ddff;
            font-size: 9px;
            margin-top: 4px;
            border-top: 1px solid #44ddff44;
            padding-top: 4px;
        }

        .bench-item .bench-tooltip .tooltip-special span {
            display: block;
            margin: 2px 0;
        }

        /* Mission Selection - Hidden (use tab instead) */
        #missionContainer {
            display: none;
        }

        #missionLabel {
            font-size: 12px;
            color: #00aa66;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 12px;
            text-align: center;
        }

        .mission-card {
            background: rgba(0, 255, 136, 0.05);
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-radius: 6px;
            padding: 10px 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .mission-card:hover {
            background: rgba(0, 255, 136, 0.15);
            border-color: #00ff88;
            transform: translateX(-3px);
        }

        .mission-card.selected {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0,255,136,0.4);
        }

        .mission-card.easy { border-left: 4px solid #44ff44; }
        .mission-card.medium { border-left: 4px solid #ffaa00; }
        .mission-card.hard { border-left: 4px solid #ff4444; }

        .mission-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .mission-name {
            font-size: 13px;
            font-weight: bold;
            color: #00ff88;
        }

        .mission-difficulty {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            text-transform: uppercase;
        }

        .mission-difficulty.easy { background: rgba(68, 255, 68, 0.3); color: #44ff44; }
        .mission-difficulty.medium { background: rgba(255, 170, 0, 0.3); color: #ffaa00; }
        .mission-difficulty.hard { background: rgba(255, 68, 68, 0.3); color: #ff4444; }

        .mission-desc {
            font-size: 10px;
            color: #888;
            margin-bottom: 8px;
        }

        .mission-reward {
            font-size: 10px;
            color: #ffcc00;
        }

        .mission-reward span {
            margin-right: 12px;
        }

        /* Mission enemy tooltip */
        .mission-card .enemy-tooltip {
            position: absolute;
            left: calc(100% + 10px);
            top: 0;
            width: 200px;
            background: rgba(10, 0, 0, 0.95);
            border: 1px solid #ff4444;
            border-radius: 4px;
            padding: 10px;
            font-size: 10px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s, visibility 0.15s;
            z-index: 100;
            pointer-events: none;
        }

        .mission-card:hover .enemy-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .enemy-tooltip .enemy-name {
            font-weight: bold;
            color: #ff6666;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .enemy-tooltip .enemy-chassis {
            color: #888;
            margin-bottom: 8px;
        }

        .enemy-tooltip .enemy-stats {
            color: #aaa;
        }

        .enemy-tooltip .enemy-stats div {
            margin: 3px 0;
        }

        .enemy-tooltip .enemy-equipment {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #333;
            color: #888;
        }

        .enemy-tooltip .enemy-equipment div {
            margin: 2px 0;
        }

        /* Drag ghost element */
        #dragGhost {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.9;
            transform: translate(-50%, -50%) scale(1.1);
            transition: transform 0.1s ease;
        }

        #dragGhost .ghost-grid {
            display: grid;
            gap: 2px;
            padding: 4px;
            background: rgba(0, 255, 136, 0.3);
            border: 2px solid #00ff88;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
        }

        #dragGhost .ghost-cell {
            width: 38px;
            height: 38px;
            background: rgba(0, 255, 136, 0.5);
            border: 1px solid #00ff88;
            border-radius: 2px;
        }

        #dragGhost.invalid .ghost-grid {
            background: rgba(255, 68, 68, 0.3);
            border-color: #ff4444;
            box-shadow: 0 0 20px rgba(255,68,68,0.5);
        }

        #dragGhost.invalid .ghost-cell {
            background: rgba(255, 68, 68, 0.5);
            border-color: #ff4444;
        }

        /* Placed items on grid */
        .placed-item {
            position: absolute;
            display: grid;
            gap: 2px;
            padding: 2px;
            background: rgba(0, 170, 255, 0.2);
            border: 2px solid #00aaff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .placed-item:hover {
            background: rgba(0, 170, 255, 0.4);
            box-shadow: 0 0 15px rgba(0,170,255,0.6);
            z-index: 10;
        }

        .placed-item .placed-cell {
            width: 36px;
            height: 36px;
            background: rgba(0, 170, 255, 0.3);
            border: 1px solid rgba(0, 170, 255, 0.6);
            border-radius: 2px;
        }

        .placed-item.weapon { border-color: #ff6644; background: rgba(255,102,68,0.2); }
        .placed-item.weapon .placed-cell { background: rgba(255,102,68,0.3); border-color: rgba(255,102,68,0.6); }
        .placed-item.armor { border-color: #4488ff; background: rgba(68,136,255,0.2); }
        .placed-item.armor .placed-cell { background: rgba(68,136,255,0.3); border-color: rgba(68,136,255,0.6); }
        .placed-item.reactor { border-color: #ffaa00; background: rgba(255,170,0,0.2); }
        .placed-item.reactor .placed-cell { background: rgba(255,170,0,0.3); border-color: rgba(255,170,0,0.6); }
        .placed-item.system { border-color: #aa44ff; background: rgba(170,68,255,0.2); }
        .placed-item.system .placed-cell { background: rgba(170,68,255,0.3); border-color: rgba(170,68,255,0.6); }
        .placed-item.cooling { border-color: #44ddff; background: rgba(68,221,255,0.2); }
        .placed-item.cooling .placed-cell { background: rgba(68,221,255,0.3); border-color: rgba(68,221,255,0.6); }
        .placed-item.locked { opacity: 0.7; }
        .placed-item.locked::after {
            content: 'üîí';
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 10px;
        }

        .placed-item .item-icon-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            opacity: 0.9;
            text-shadow: 0 0 8px rgba(0,0,0,0.8);
            pointer-events: none;
        }

        .placed-item .item-tooltip {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 10, 0.95);
            border: 1px solid currentColor;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 100;
            pointer-events: none;
        }

        .placed-item:hover .item-tooltip,
        .placed-item.show-tooltip .item-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .placed-item .item-tooltip .tooltip-name {
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 4px;
        }

        .placed-item .item-tooltip .tooltip-stats {
            color: #aaa;
        }

        .placed-item .item-tooltip .tooltip-stats span {
            display: block;
            margin: 2px 0;
        }

        .placed-item .item-tooltip .tooltip-hint {
            margin-top: 6px;
            color: #666;
            font-style: italic;
        }


        /* Hidden during battle */
        .battle-mode #mechBuilderUI {
            display: none;
        }

        /* ============================================
           BATTLE UI
           ============================================ */
        #battleUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
        }

        .battle-mode #battleUI {
            display: block;
        }

        .battle-mode #mechBuilderUI {
            display: none;
        }

        #battleHeader {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        #missionTitle {
            font-size: 24px;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 20px rgba(0,255,136,0.5);
        }

        #battleStatus {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            border: 2px solid #00ff88;
            border-radius: 8px;
            padding: 15px 30px;
            display: flex;
            align-items: center;
            gap: 30px;
            pointer-events: auto;
        }

        #battleVS {
            font-size: 24px;
            font-weight: bold;
            color: #ffcc00;
            text-shadow: 0 0 10px rgba(255,204,0,0.5);
        }

        .team-status {
            text-align: center;
            min-width: 180px;
        }

        .team-status.player { color: #00ff88; }
        .team-status.enemy { color: #ff4444; }

        #playerMechName, #enemyMechName {
            font-size: 11px;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        .hp-bar {
            width: 180px;
            height: 16px;
            background: #222;
            border-radius: 3px;
            overflow: hidden;
            margin: 6px 0;
            border: 1px solid #444;
        }

        .hp-fill {
            height: 100%;
            transition: width 0.3s;
        }

        .hp-fill.player { background: linear-gradient(90deg, #00aa55, #00ff88); }
        .hp-fill.enemy { background: linear-gradient(90deg, #aa2222, #ff4444); }

        #battleLog {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            max-height: 200px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #00aa66;
            border-radius: 6px;
            padding: 10px 15px;
            overflow-y: auto;
            pointer-events: auto;
        }

        #battleLogContent {
            font-size: 12px;
            color: #aaa;
        }

        .log-entry {
            margin: 4px 0;
            padding: 4px 0;
            border-bottom: 1px solid #333;
        }

        .log-entry.player-action { color: #00ff88; }
        .log-entry.enemy-action { color: #ff6666; }
        .log-entry.damage { color: #ffaa00; }
        .log-entry.victory { color: #44ff44; font-weight: bold; }
        .log-entry.defeat { color: #ff4444; font-weight: bold; }

        #battleResult {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,20,10,0.95);
            border: 3px solid #00ff88;
            border-radius: 12px;
            padding: 40px 60px;
            text-align: center;
            pointer-events: auto;
            box-shadow: 0 0 50px rgba(0,255,136,0.4);
        }

        #resultTitle {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 0 0 20px currentColor;
        }

        #resultTitle.victory { color: #44ff44; }
        #resultTitle.defeat { color: #ff4444; }

        #resultRewards {
            font-size: 16px;
            color: #ffcc00;
            margin-bottom: 25px;
        }

        #resultRewards div {
            margin: 8px 0;
        }

        #returnToBuilderBtn {
            padding: 12px 30px;
            font-size: 16px;
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            border-radius: 6px;
            font-family: monospace;
            transition: all 0.2s;
        }

        #returnToBuilderBtn:hover {
            background: rgba(0, 255, 136, 0.4);
            transform: scale(1.05);
        }

        /* Tab Content Areas */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        #loadoutTab {
            display: none;
            flex-direction: column;
            flex: 1;
            position: relative;
        }

        #loadoutTab.active {
            display: flex;
        }

        /* Tab Navigation Headers */
        .tab-nav-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(0, 20, 10, 0.8);
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
            pointer-events: auto;
        }

        .tab-nav-header .nav-btn {
            padding: 8px 16px;
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .tab-nav-header .nav-btn:hover:not(:disabled) {
            background: rgba(0, 255, 136, 0.4);
            box-shadow: 0 0 15px rgba(0,255,136,0.4);
        }

        .tab-nav-header .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #555;
            color: #555;
        }

        .tab-nav-header .nav-btn.primary {
            background: rgba(0, 255, 136, 0.3);
        }

        .tab-nav-header .nav-btn.primary:hover:not(:disabled) {
            background: rgba(0, 255, 136, 0.5);
        }

        .tab-nav-header .nav-btn.warning {
            border-color: #ff4444;
            color: #ff4444;
        }

        .tab-nav-header .nav-spacer {
            flex: 1;
        }

        .tab-nav-header .nav-title {
            font-size: 14px;
            color: #00aa66;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Mission Tab - Full screen panel */
        #missionTab {
            display: none;
            flex-direction: column;
            flex: 1;
            background: rgba(0, 10, 5, 0.98);
            overflow-y: auto;
            pointer-events: auto;
        }

        #missionTab.active {
            display: flex;
        }

        #missionTab .mission-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        #missionTab .mission-header {
            text-align: center;
            margin-bottom: 20px;
        }

        #missionTab .mission-title {
            font-size: 24px;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 8px;
        }

        #missionTab .mission-subtitle {
            font-size: 12px;
            color: #00aa66;
        }

        #missionTab .mission-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            max-width: 900px;
            margin: 0 auto;
        }

        #missionTab .mission-card {
            background: rgba(0, 255, 136, 0.05);
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #missionTab .mission-card:hover {
            background: rgba(0, 255, 136, 0.15);
            border-color: #00ff88;
            transform: translateY(-2px);
        }

        #missionTab .mission-card.selected {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.4);
        }

        #missionTab .mission-card.easy { border-left: 4px solid #44ff44; }
        #missionTab .mission-card.medium { border-left: 4px solid #ffaa00; }
        #missionTab .mission-card.hard { border-left: 4px solid #ff4444; }

        #missionTab .mission-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        #missionTab .mission-name {
            font-size: 16px;
            font-weight: bold;
            color: #00ff88;
        }

        #missionTab .mission-difficulty {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 4px;
            text-transform: uppercase;
            font-weight: bold;
        }

        #missionTab .mission-difficulty.easy { background: rgba(68, 255, 68, 0.3); color: #44ff44; }
        #missionTab .mission-difficulty.medium { background: rgba(255, 170, 0, 0.3); color: #ffaa00; }
        #missionTab .mission-difficulty.hard { background: rgba(255, 68, 68, 0.3); color: #ff4444; }

        #missionTab .mission-desc {
            font-size: 12px;
            color: #888;
            margin-bottom: 12px;
            line-height: 1.4;
        }

        #missionTab .mission-details {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            flex-wrap: wrap;
            gap: 10px;
        }

        #missionTab .mission-reward {
            font-size: 12px;
            color: #ffcc00;
        }

        #missionTab .mission-reward span {
            display: block;
            margin: 3px 0;
        }

        #missionTab .mission-enemy {
            font-size: 11px;
            color: #ff6666;
            text-align: right;
        }

        #missionTab .mission-enemy-name {
            font-weight: bold;
            margin-bottom: 3px;
        }

        /* ============================================
           MOBILE RESPONSIVE STYLES
           ============================================ */
        @media (max-width: 768px) {
            /* Stats Panel - Compact for mobile */
            #statsPanel {
                flex-wrap: wrap;
                padding: 8px 12px;
                gap: 8px;
            }

            .stat-group {
                gap: 15px;
                order: 2;
                flex: 1;
            }

            .stat-bar {
                width: 100px;
                height: 14px;
            }

            .stat-label {
                font-size: 9px;
            }

            .stat-text {
                font-size: 9px;
            }

            #gameTitle {
                font-size: 14px;
                order: 1;
                width: 100%;
                text-align: center;
                margin-bottom: 5px;
            }

            #battleReadyBtn {
                order: 3;
                padding: 8px 15px;
                font-size: 11px;
            }

            /* Grid cells smaller on mobile */
            .grid-cell {
                width: 32px;
                height: 32px;
            }

            .placed-item .placed-cell {
                width: 28px;
                height: 28px;
            }

            /* Bench smaller on mobile */
            #benchContainer {
                padding: 10px 12px;
            }

            #benchLabel {
                font-size: 10px;
                margin-bottom: 8px;
            }

            #bench {
                gap: 10px;
                min-height: 80px;
            }

            .bench-item {
                width: 65px;
                height: 65px;
            }

            .bench-item .item-icon {
                font-size: 22px;
            }

            .bench-item .item-name {
                font-size: 8px;
            }

            /* Adjust grid label size */
            .grid-label {
                font-size: 8px;
                top: -16px;
            }

            /* Mission tab padding */
            #missionTab {
                padding: 15px;
            }

            #missionTab .mission-title {
                font-size: 20px;
            }
        }

        /* Very small screens */
        @media (max-width: 480px) {
            .grid-cell {
                width: 28px;
                height: 28px;
            }

            .placed-item .placed-cell {
                width: 24px;
                height: 24px;
            }

            .placed-item .item-icon-overlay {
                font-size: 16px;
            }

            .stat-bar {
                width: 80px;
            }

            .bench-item {
                width: 55px;
                height: 55px;
            }

            .bench-item .item-icon {
                font-size: 18px;
            }

            #missionTab .mission-grid {
                grid-template-columns: 1fr;
            }

            /* Smaller grid layout */
            #gridOverlayContainer {
                gap: 5px;
                padding: 5px;
            }
        }

        /* Landscape mobile - side by side layout */
        @media (max-width: 900px) and (orientation: landscape) {
            #mechBuilderUI {
                flex-direction: row;
                flex-wrap: wrap;
            }

            #statsPanel {
                width: 100%;
            }

            #loadoutTab {
                flex-direction: row;
            }

            #gridOverlayContainer {
                flex: 1;
            }

            #benchContainer {
                width: 200px;
                height: calc(100vh - 120px);
                border-top: none;
                border-left: 2px solid #00ff88;
            }

            #bench {
                flex-direction: column;
                overflow-y: auto;
                overflow-x: hidden;
                max-height: 100%;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="renderCanvas"></canvas>

        <!-- MechBuilder UI Overlay -->
        <div id="mechBuilderUI">
            <!-- Header Panel -->
            <div id="statsPanel">
                <div id="gameTitle">Loadout</div>
                <div id="headerInfo" style="display: flex; gap: 20px; align-items: center;">
                    <div id="roundDisplay" style="color: #00aa66; font-size: 12px;">Round <span id="roundNum">1</span></div>
                    <div id="goldDisplay" style="color: #ffcc00; font-size: 14px; font-weight: bold;">üí∞ <span id="goldAmount">10</span></div>
                    <div id="backpackDisplay" style="color: #88aaff; font-size: 12px;">üéí <span id="backpackCount">0</span>/<span id="backpackMax">12</span></div>
                </div>
                <div class="nav-spacer"></div>
                <button id="goToShopBtn" class="header-nav-btn" style="margin-right: 10px;">Shop</button>
                <button id="goToBackpackBtn" class="header-nav-btn" style="margin-right: 10px;">Backpack</button>
                <button id="goToMissionsBtn" class="header-nav-btn" disabled>Battle ‚Üí</button>
            </div>

            <!-- Loadout Tab Content -->
            <div id="loadoutTab" class="tab-content active">
                <!-- Weight/Energy Stats (above mech) -->
                <div id="mechStats">
                    <div class="stat-item">
                        <span class="stat-label">HP</span>
                        <div class="stat-bar">
                            <div class="stat-fill hp" id="hpFill" style="width: 100%"></div>
                            <span class="stat-text" id="hpText">100</span>
                        </div>
                    </div>
                    <div class="stat-item" id="armorStatItem" style="display: none;">
                        <span class="stat-label">Armor</span>
                        <div class="stat-bar">
                            <div class="stat-fill armor" id="armorFill" style="width: 0%"></div>
                            <span class="stat-text" id="armorText">0</span>
                        </div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Accuracy</span>
                        <div class="stat-bar">
                            <div class="stat-fill accuracy" id="accuracyFill" style="width: 60%"></div>
                            <span class="stat-text" id="accuracyText">60%</span>
                        </div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Weight</span>
                        <div class="stat-bar">
                            <div class="stat-fill weight" id="weightFill" style="width: 0%"></div>
                            <span class="stat-text" id="weightText">0 / 100</span>
                        </div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Energy</span>
                        <div class="stat-bar">
                            <div class="stat-fill energy" id="energyFill" style="width: 0%"></div>
                            <span class="stat-text" id="energyText">0 / 50</span>
                        </div>
                    </div>
                </div>

                <!-- Main Layout: Bench on left, Mech Grid on right -->
                <div id="loadoutMain">
                    <!-- Left Bench Panel -->
                    <div id="benchPanel">
                        <div id="benchHeader">
                            <div id="benchTitle">Equipment</div>
                            <div id="benchSubtitle">Drag to equip</div>
                        </div>
                        <div id="benchScroll">
                            <!-- Items populated by JS -->
                        </div>
                        <div id="benchEmpty" style="display: none;">No items available</div>
                    </div>

                    <!-- Mech Grid Area -->
                    <div id="mechGridArea">
                        <div id="unifiedMechGrid">
                            <!-- Unified mech-shaped grid populated by JS -->
                        </div>
                    </div>
                </div>

            </div>

            <!-- Mission Tab Content -->
            <div id="missionTab" class="tab-content">
                <!-- Navigation Header -->
                <div class="tab-nav-header">
                    <button class="nav-btn" onclick="switchTab('loadout')">‚Üê Back to Loadout</button>
                    <div class="nav-spacer"></div>
                    <button class="nav-btn primary" id="missionContinueBtn" onclick="startBattleFromMission()" disabled>
                        Continue to Battle ‚Üí
                    </button>
                </div>

                <div class="mission-content">
                    <div class="mission-header">
                        <div class="mission-title">Select Mission</div>
                        <div class="mission-subtitle">Choose your next deployment</div>
                    </div>
                    <div class="mission-grid" id="missionTabList">
                        <!-- Missions populated by JS -->
                    </div>
                </div>
            </div>

            <!-- Shop Tab Content (solid background to hide 3D mech) -->
            <div id="shopTab" class="tab-content" style="background: linear-gradient(180deg, #0a1a0f 0%, #051008 100%); position: relative; z-index: 100;">
                <div class="tab-nav-header">
                    <button class="nav-btn" onclick="switchTab('loadout')">‚Üê Back to Loadout</button>
                    <div class="nav-spacer"></div>
                    <div style="color: #ffcc00; font-size: 16px; font-weight: bold;">üí∞ <span id="shopGoldDisplay">10</span> Gold</div>
                </div>
                <div class="shop-content" style="flex: 1; padding: 20px; overflow-y: auto;">
                    <div style="text-align: center; margin-bottom: 20px;">
                        <div style="font-size: 24px; color: #00ff88; letter-spacing: 3px;">SHOP</div>
                        <div style="font-size: 12px; color: #666;">Buy mechs and weapons to strengthen your arsenal</div>
                    </div>

                    <!-- Mechs Section -->
                    <div style="margin-bottom: 30px;">
                        <div style="font-size: 14px; color: #00aa66; margin-bottom: 15px; letter-spacing: 2px; border-bottom: 1px solid #00aa66; padding-bottom: 5px;">MECHS FOR SALE</div>
                        <div id="shopMechsContainer" style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center;">
                            <!-- Populated by JS -->
                        </div>
                    </div>

                    <!-- Weapons Section -->
                    <div style="margin-bottom: 30px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 1px solid #00aa66; padding-bottom: 5px;">
                            <div style="font-size: 14px; color: #00aa66; letter-spacing: 2px;">WEAPONS FOR SALE</div>
                            <button id="refreshShopBtn" onclick="handleRefreshShop()" style="padding: 6px 15px; background: rgba(255, 170, 0, 0.2); border: 1px solid #ffaa00; color: #ffaa00; cursor: pointer; border-radius: 4px; font-family: monospace; font-size: 11px;">
                                Refresh (2g)
                            </button>
                        </div>
                        <div id="shopWeaponsContainer" style="display: flex; flex-wrap: wrap; gap: 12px; justify-content: center;">
                            <!-- Populated by JS -->
                        </div>
                    </div>

                    <!-- Owned Mechs Section -->
                    <div>
                        <div style="font-size: 14px; color: #00aa66; margin-bottom: 15px; letter-spacing: 2px; border-bottom: 1px solid #00aa66; padding-bottom: 5px;">YOUR MECHS</div>
                        <div id="ownedMechsContainer" style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center;">
                            <!-- Populated by JS -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Backpack Tab Content (solid background) -->
            <div id="backpackTab" class="tab-content" style="background: linear-gradient(180deg, #0a1a0f 0%, #051008 100%); position: relative; z-index: 100;">
                <div class="tab-nav-header">
                    <button class="nav-btn" onclick="switchTab('loadout')">‚Üê Back to Loadout</button>
                    <div class="nav-spacer"></div>
                    <div style="display: flex; gap: 15px; align-items: center;">
                        <div style="color: #88aaff; font-size: 14px;">üéí <span id="backpackSlotsDisplay">0/12</span></div>
                        <button id="upgradeBackpackBtn" onclick="handleUpgradeBackpack()" style="padding: 6px 15px; background: rgba(0, 255, 136, 0.2); border: 1px solid #00ff88; color: #00ff88; cursor: pointer; border-radius: 4px; font-family: monospace; font-size: 11px;">
                            Upgrade (+3 slots, 10g)
                        </button>
                    </div>
                </div>
                <div class="backpack-content" style="flex: 1; padding: 20px; overflow-y: auto;">
                    <div style="text-align: center; margin-bottom: 20px;">
                        <div style="font-size: 24px; color: #88aaff; letter-spacing: 3px;">BACKPACK</div>
                        <div style="font-size: 12px; color: #666;">Manage your inventory - equip items or sell for gold</div>
                    </div>

                    <div id="backpackItemsContainer" style="display: flex; flex-wrap: wrap; gap: 12px; justify-content: center;">
                        <!-- Populated by JS -->
                    </div>

                    <div id="backpackEmpty" style="display: none; text-align: center; padding: 40px; color: #666; font-style: italic;">
                        Your backpack is empty. Salvage items after battles or buy from the shop!
                    </div>
                </div>
            </div>
        </div>

        <!-- Battle UI Overlay (hidden during builder) -->
        <div id="battleUI">
            <div id="battleHeader">
                <div id="missionTitle">Mission: Border Patrol</div>
            </div>

            <div id="battleStatus">
                <div class="team-status player">
                    <strong>YOUR MECH</strong>
                    <div id="playerMechName">Timber Wolf</div>
                    <div class="hp-bar"><div class="hp-fill player" id="playerHP" style="width: 100%"></div></div>
                    <div id="playerHPText">HP: 150/150</div>
                </div>
                <div id="battleVS">VS</div>
                <div class="team-status enemy">
                    <strong>ENEMY</strong>
                    <div id="enemyMechName">Scout Mech</div>
                    <div class="hp-bar"><div class="hp-fill enemy" id="enemyHP" style="width: 100%"></div></div>
                    <div id="enemyHPText">HP: 80/80</div>
                </div>
            </div>

            <div id="battleLog">
                <div id="battleLogContent">
                    <!-- Battle events will be logged here -->
                </div>
            </div>

            <div id="battleResult" style="display: none;">
                <div id="resultTitle">VICTORY!</div>
                <div id="resultRewards">
                    <div>üí∞ Credits: +500</div>
                    <div>‚≠ê XP: +100</div>
                </div>
                <button id="returnToBuilderBtn" onclick="returnToBuilder()">Return to Loadout</button>
            </div>

        </div>

        <!-- Drag Ghost (hidden until dragging) -->
        <div id="dragGhost" style="display: none;"></div>

        <!-- Battle UI Overlay (hidden initially) -->
        <div id="battleUI" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; flex-direction: column;">
            <!-- Battle Status Bar -->
            <div style="pointer-events: auto; display: flex; justify-content: space-between; padding: 15px 30px; background: linear-gradient(180deg, rgba(0,20,10,0.95) 0%, rgba(0,20,10,0.7) 100%); border-bottom: 2px solid #00ff88;">
                <!-- Player HP -->
                <div style="flex: 1; max-width: 300px;">
                    <div style="font-size: 14px; color: #00ff88; margin-bottom: 5px;" id="playerName">PLAYER</div>
                    <div style="height: 20px; background: #333; border: 1px solid #00ff88; border-radius: 3px; overflow: hidden;">
                        <div id="playerHP" style="height: 100%; width: 100%; background: linear-gradient(90deg, #00ff88, #44ff88); transition: width 0.3s;"></div>
                    </div>
                </div>
                <!-- VS -->
                <div style="font-size: 24px; color: #ffaa00; padding: 0 30px;">VS</div>
                <!-- Enemy HP -->
                <div style="flex: 1; max-width: 300px;">
                    <div style="font-size: 14px; color: #ff4444; margin-bottom: 5px; text-align: right;" id="enemyName">ENEMY</div>
                    <div style="height: 20px; background: #333; border: 1px solid #ff4444; border-radius: 3px; overflow: hidden;">
                        <div id="enemyHP" style="height: 100%; width: 100%; background: linear-gradient(90deg, #ff4444, #ff6644); transition: width 0.3s;"></div>
                    </div>
                </div>
            </div>

            <!-- Battle Result Overlay -->
            <div id="battleResultOverlay" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); justify-content: center; align-items: center; flex-direction: column; pointer-events: auto;">
                <div id="battleResult" style="font-size: 64px; font-weight: bold; text-shadow: 0 0 30px currentColor;">VICTORY!</div>
                <button onclick="returnToLoadout()" style="margin-top: 30px; padding: 15px 40px; font-size: 18px; background: rgba(0, 255, 136, 0.2); border: 2px solid #00ff88; color: #00ff88; cursor: pointer; border-radius: 5px;">Return to Loadout</button>
            </div>
        </div>

        <!-- Battle iframe (loads the original physics simulation) -->
        <iframe id="battleFrame" src="" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; z-index: 1000;"></iframe>
    </div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>

    <script>
        // ============================================
        // GAME STATE & PHASE MANAGEMENT
        // ============================================
        const GamePhase = {
            MECHBUILDER: 'mechbuilder',
            BATTLE: 'battle'
        };

        let currentPhase = GamePhase.MECHBUILDER;
        let engine, scene, camera, havokInstance, havokPlugin;
        let builderCamera, battleCamera;
        let gameTime = 0;

        // ============================================
        // MECHBUILDER DATA STRUCTURES
        // ============================================

        // Mech Chassis Definition - Unified grid shape
        const MECH_CHASSIS = {
            id: 'starter_chassis',
            name: 'Timber Wolf Chassis',
            maxWeight: 100,
            baseEnergy: 7,
            // Unified mech-shaped grid (7 cols x 7 rows)
            // 1 = valid cell, 0 = empty/invalid
            gridCols: 7,
            gridRows: 7,
            gridShape: [
                // Row 0: Head
                [0, 0, 1, 1, 1, 0, 0],
                // Row 1: Shoulders
                [0, 1, 1, 1, 1, 1, 0],
                // Row 2: Arms + Torso
                [1, 1, 1, 1, 1, 1, 1],
                // Row 3: Arms + Torso
                [1, 1, 1, 1, 1, 1, 1],
                // Row 4: Waist
                [0, 0, 1, 1, 1, 0, 0],
                // Row 5: Upper Legs (split)
                [0, 1, 1, 0, 1, 1, 0],
                // Row 6: Lower Legs (split)
                [0, 1, 1, 0, 1, 1, 0]
            ],
            // For backwards compat - map old slot names to grid regions (not used with unified grid)
            slots: {}
        };

        // Item Definitions (The Deck)
        const ITEM_DATABASE = {
            railgun_mk1: {
                id: 'railgun_mk1',
                name: 'Training Railgun',
                type: 'WEAPON',
                category: 'weapon',
                icon: 'üî´',
                gridShape: [[1], [1], [1], [1], [1]],  // 1x5 Vertical
                gridDimensions: { w: 1, h: 5 },
                stats: {
                    weight: 18,
                    energyDraw: 2,
                    damage: 25
                },
                constraints: {},
                // Battle properties
                battle: {
                    projectileSpeed: 40,
                    projectileSize: 0.12,
                    knockback: 20,
                    recoil: 0.1,
                    cooldown: 1800,
                    color: [1, 0.9, 0.3],  // Yellow-orange
                    isProjectile: true
                }
            },
            laser_array: {
                id: 'laser_array',
                name: 'Medium Laser',
                type: 'WEAPON',
                category: 'weapon',
                icon: '‚ö°',
                gridShape: [[1, 1]],  // 2x1 Horizontal
                gridDimensions: { w: 2, h: 1 },
                stats: {
                    weight: 10,
                    energyDraw: 2,
                    damage: 18
                },
                constraints: {},
                // Battle properties
                battle: {
                    isBeam: true,
                    beamDuration: 150,
                    knockback: 5,
                    recoil: 0.15,
                    cooldown: 2200,
                    color: [0.2, 1, 0.3]  // Green
                }
            },
            armor_plate: {
                id: 'armor_plate',
                name: 'Basic Plating',
                type: 'ARMOR',
                category: 'armor',
                icon: 'üõ°Ô∏è',
                gridShape: [[1, 1], [1, 1]],  // 2x2 Square
                gridDimensions: { w: 2, h: 2 },
                stats: {
                    weight: 28,
                    energyDraw: 0,
                    armorBonus: 30
                },
                constraints: {}
            },
            reactor_core: {
                id: 'reactor_core',
                name: 'Basic Reactor',
                type: 'REACTOR',
                category: 'reactor',
                icon: '‚öõÔ∏è',
                gridShape: [[1], [1]],  // 1x2 Vertical
                gridDimensions: { w: 1, h: 2 },
                stats: {
                    weight: 8,
                    energyDraw: -3,  // Negative = provides energy
                    heatCapacity: 15
                },
                constraints: {}
            },
            targeting_computer: {
                id: 'targeting_computer',
                name: 'Basic Targeting',
                type: 'SYSTEM',
                category: 'system',
                icon: 'üéØ',
                gridShape: [[1]],  // 1x1 Single
                gridDimensions: { w: 1, h: 1 },
                stats: {
                    weight: 6,
                    energyDraw: 1,
                    accuracyBonus: 8
                },
                constraints: {}
            },
            heat_sink: {
                id: 'heat_sink',
                name: 'Basic Heat Sink',
                type: 'COOLING',
                category: 'cooling',
                icon: '‚ùÑÔ∏è',
                gridShape: [[1]],  // 1x1 Single
                gridDimensions: { w: 1, h: 1 },
                stats: {
                    weight: 8,
                    energyDraw: 0,
                    energyReduction: 1  // Reduces energy cost of adjacent items
                },
                constraints: {},
                special: {
                    onPlace: 'drawCard',      // Draw a card when placed
                    locksOnPlace: true        // Cannot be moved after placement this round
                }
            }
        };

        // ============================================
        // COMPONENT GENERATION SYSTEM
        // ============================================

        // Budget Exchange Rates: 1 square of "currency" converts to these values
        const COMPONENT_GENERATION = {
            // Base exchange rates (1 square = X) - energy scaled to smaller units
            exchangeRates: {
                damage: 5,           // 1 square = 5 damage
                weight: -10,         // 1 square = -10 weight (lighter is better, costs budget)
                energyCost: -1.5,    // 1 square = -1.5 energy cost (cheaper is better)
                energyProvided: 1.5, // 1 square = 1.5 energy provided
                armor: 8,            // 1 square = 8 armor
                accuracy: 4,         // 1 square = 4% accuracy
                cooldownReduction: -100,  // 1 square = -100ms cooldown
                knockback: 5,        // 1 square = 5 knockback
                projectileSpeed: 8,  // 1 square = 8 projectile speed
                heatCapacity: 8,     // 1 square = 8 heat capacity
                energyReduction: 0.3 // 1 square = 0.3 energy reduction (for heat sinks)
            },

            // Resource conversion rates (for trade-offs within same item) - energy scaled
            conversionRates: {
                energyToDamage: 14,     // 1 energy cost = 14 damage (scaled from 2)
                weightToDamage: 0.5,    // 1 weight = 0.5 damage
                cooldownToDamage: 0.05, // 1ms cooldown = 0.05 damage
                accuracyToDamage: 1.5,  // 1% accuracy = 1.5 damage
                armorToWeight: 0.6      // 1 armor = 0.6 weight
            },

            // Shape bonuses: longer shapes get bonus budget squares
            // This rewards specialized narrow/long items
            lengthBonuses: {
                4: 1,   // 4 length = +1 square bonus
                5: 3,   // 5 length = +3 squares bonus
                6: 6    // 6 length = +6 squares bonus
            },

            // Aspect ratio bonuses (max dimension / min dimension)
            aspectBonuses: {
                3: 0.5,   // 3:1 ratio = +0.5 squares
                4: 1,     // 4:1 ratio = +1 square
                5: 2,     // 5:1 ratio = +2 squares
                6: 3      // 6:1 ratio = +3 squares
            },

            // Rarity multipliers for budget
            rarityMultipliers: {
                common: 1.0,
                uncommon: 1.15,
                rare: 1.35,
                epic: 1.6,
                legendary: 2.0
            },

            // Rarity colors for display
            rarityColors: {
                common: '#aaaaaa',
                uncommon: '#00ff88',
                rare: '#4488ff',
                epic: '#aa44ff',
                legendary: '#ffaa00'
            },

            // Level bonus: each level adds this much budget
            levelBudgetBonus: 0.5,

            // Budget variance within same level/rarity (percentage)
            budgetVariance: 0.15   // +/- 15% variance
        };

        // Base item templates - define the "class" of item with typical shape/stats
        const ITEM_TEMPLATES = {
            // WEAPONS
            railgun: {
                type: 'WEAPON',
                category: 'weapon',
                icon: 'üî´',
                namePrefix: ['Light', 'Standard', 'Heavy', 'Precision', 'Rapid'],
                nameSuffix: ['Railgun', 'Cannon', 'Driver', 'Accelerator'],
                baseShape: [[1], [1], [1], [1], [1]],  // 5x1 vertical
                validSlots: ['leftArm', 'rightArm'],
                baseStats: {
                    weight: 22,
                    energyDraw: 3,
                    damage: 45
                },
                baseBattle: {
                    projectileSpeed: 55,
                    projectileSize: 0.15,
                    knockback: 30,
                    recoil: 0.12,
                    cooldown: 1300,
                    color: [1, 0.9, 0.3],
                    isProjectile: true
                },
                statWeights: { damage: 0.6, knockback: 0.2, projectileSpeed: 0.2 }
            },
            laser: {
                type: 'WEAPON',
                category: 'weapon',
                icon: '‚ö°',
                namePrefix: ['ER', 'Pulse', 'Focused', 'Burst', 'Heavy'],
                nameSuffix: ['Laser', 'Beam', 'Array', 'Emitter'],
                baseShape: [[1, 1], [1, 1]],  // Typical 2x2 square
                validSlots: ['torso', 'leftArm', 'rightArm'],
                baseStats: {
                    weight: 14,
                    energyDraw: 3,
                    damage: 35
                },
                baseBattle: {
                    isBeam: true,
                    beamDuration: 200,
                    knockback: 8,
                    recoil: 0.15,
                    cooldown: 1600,
                    color: [0.2, 1, 0.3]
                },
                statWeights: { damage: 0.7, cooldownReduction: 0.3 }
            },
            missile: {
                type: 'WEAPON',
                category: 'weapon',
                icon: 'üöÄ',
                namePrefix: ['Light', 'Cluster', 'Heavy', 'Guided', 'Swarm'],
                nameSuffix: ['Missile', 'Rocket', 'Launcher', 'Pod'],
                baseShape: [[1, 1, 1]],  // Typical 3x1 horizontal
                validSlots: ['torso', 'leftArm', 'rightArm'],
                baseStats: {
                    weight: 20,
                    energyDraw: 2,
                    damage: 55
                },
                baseBattle: {
                    projectileSpeed: 30,
                    projectileSize: 0.2,
                    knockback: 35,
                    recoil: 0.2,
                    cooldown: 2200,
                    color: [1, 0.4, 0.2],
                    isProjectile: true
                },
                statWeights: { damage: 0.5, knockback: 0.4, cooldownReduction: 0.1 }
            },
            machinegun: {
                type: 'WEAPON',
                category: 'weapon',
                icon: 'üî•',
                namePrefix: ['Rapid', 'Twin', 'Auto', 'Rotary', 'Ultra'],
                nameSuffix: ['Cannon', 'Gun', 'Repeater', 'Vulcan'],
                baseShape: [[1], [1]],  // Typical 2x1 vertical
                validSlots: ['leftArm', 'rightArm'],
                baseStats: {
                    weight: 10,
                    energyDraw: 1,
                    damage: 22
                },
                baseBattle: {
                    projectileSpeed: 60,
                    projectileSize: 0.08,
                    knockback: 8,
                    recoil: 0.05,
                    cooldown: 400,
                    color: [1, 1, 0.5],
                    isProjectile: true
                },
                statWeights: { damage: 0.4, cooldownReduction: 0.5, projectileSpeed: 0.1 }
            },

            // ARMOR
            armor: {
                type: 'ARMOR',
                category: 'armor',
                icon: 'üõ°Ô∏è',
                namePrefix: ['Light', 'Standard', 'Heavy', 'Reinforced', 'Composite'],
                nameSuffix: ['Plating', 'Armor', 'Shield', 'Carapace'],
                baseShape: [[1, 1], [1, 1]],  // Typical 2x2
                validSlots: ['torso', 'leftLeg', 'rightLeg'],
                baseStats: {
                    weight: 22,
                    energyDraw: 0,
                    armorBonus: 55
                },
                statWeights: { armor: 0.8, weight: 0.2 }
            },
            reactive_armor: {
                type: 'ARMOR',
                category: 'armor',
                icon: 'üí•',
                namePrefix: ['Reactive', 'Ablative', 'Hardened', 'Explosive'],
                nameSuffix: ['Plates', 'Panels', 'Coating', 'Layer'],
                baseShape: [[1, 1, 1], [1, 1, 1]],  // 3x2 wide
                validSlots: ['torso'],
                baseStats: {
                    weight: 35,
                    energyDraw: 1,
                    armorBonus: 65
                },
                statWeights: { armor: 0.9, weight: 0.1 }
            },

            // REACTORS - less common, lighter weight
            reactor: {
                type: 'REACTOR',
                category: 'reactor',
                icon: '‚öõÔ∏è',
                namePrefix: ['Compact', 'Standard', 'High-Output', 'Fusion', 'Plasma'],
                nameSuffix: ['Reactor', 'Core', 'Generator', 'Cell'],
                baseShape: [[1], [1]],  // Typical 1x2
                validSlots: ['torso'],
                baseStats: {
                    weight: 6,
                    energyDraw: -4,  // Provides energy
                    heatCapacity: 20
                },
                statWeights: { energyProvided: 0.8, heatCapacity: 0.2 }
            },
            power_cell: {
                type: 'REACTOR',
                category: 'reactor',
                icon: 'üîã',
                namePrefix: ['Emergency', 'Backup', 'Auxiliary', 'Micro'],
                nameSuffix: ['Cell', 'Battery', 'Pack', 'Unit'],
                baseShape: [[1]],  // 1x1 small
                validSlots: ['torso', 'leftLeg', 'rightLeg'],
                baseStats: {
                    weight: 3,
                    energyDraw: -2,
                    heatCapacity: 10
                },
                statWeights: { energyProvided: 0.9, weight: 0.1 }
            },

            // SYSTEMS
            targeting: {
                type: 'SYSTEM',
                category: 'system',
                icon: 'üéØ',
                namePrefix: ['Advanced', 'Precision', 'Neural', 'Quantum', 'Elite'],
                nameSuffix: ['Targeting', 'Computer', 'System', 'Interface'],
                baseShape: [[1]],  // 1x1
                validSlots: ['torso', 'leftArm', 'rightArm'],
                baseStats: {
                    weight: 4,
                    energyDraw: 1,
                    accuracyBonus: 15
                },
                statWeights: { accuracy: 1.0 }
            },
            gyro: {
                type: 'SYSTEM',
                category: 'system',
                icon: 'üîÑ',
                namePrefix: ['Light', 'Standard', 'Heavy', 'Stabilized'],
                nameSuffix: ['Gyro', 'Stabilizer', 'Balance Unit'],
                baseShape: [[1], [1]],  // 1x2
                validSlots: ['torso', 'leftLeg', 'rightLeg'],
                baseStats: {
                    weight: 10,
                    energyDraw: 1,
                    accuracyBonus: 8
                },
                statWeights: { accuracy: 0.7, weight: 0.3 }
            },

            // COOLING
            heat_sink: {
                type: 'COOLING',
                category: 'cooling',
                icon: '‚ùÑÔ∏è',
                namePrefix: ['Double', 'Enhanced', 'Cryo', 'Advanced'],
                nameSuffix: ['Heat Sink', 'Cooler', 'Radiator', 'Vent'],
                baseShape: [[1]],  // 1x1
                validSlots: ['torso', 'leftArm', 'rightArm', 'leftLeg', 'rightLeg'],
                baseStats: {
                    weight: 5,
                    energyDraw: 0,
                    energyReduction: 2
                },
                special: {
                    onPlace: 'drawCard',
                    locksOnPlace: true
                },
                statWeights: { energyReduction: 1.0 }
            },
            cooling_system: {
                type: 'COOLING',
                category: 'cooling',
                icon: 'üå°Ô∏è',
                namePrefix: ['Advanced', 'Integrated', 'Active', 'Elite'],
                nameSuffix: ['Cooling', 'System', 'Module', 'Array'],
                baseShape: [[1, 1]],  // 2x1 horizontal
                validSlots: ['torso', 'leftArm', 'rightArm'],
                baseStats: {
                    weight: 10,
                    energyDraw: 1,
                    energyReduction: 3
                },
                statWeights: { energyReduction: 0.8, weight: 0.2 }
            }
        };

        // Variant modifications that can be applied to generated items
        const ITEM_VARIANTS = {
            // Shape variants
            extended: {
                name: 'Extended',
                shapeModifier: (shape) => {
                    // Add one row
                    const newShape = [...shape.map(row => [...row])];
                    newShape.push(new Array(shape[0].length).fill(1));
                    return newShape;
                },
                budgetCost: -1  // Costs 1 budget square (larger = more space used)
            },
            compact: {
                name: 'Compact',
                shapeModifier: (shape) => {
                    // Remove one row if possible
                    if (shape.length > 1) {
                        return shape.slice(0, -1).map(row => [...row]);
                    }
                    return shape.map(row => [...row]);
                },
                budgetCost: 1  // Gives 1 budget square (smaller = bonus)
            },
            widened: {
                name: 'Wide',
                shapeModifier: (shape) => {
                    // Add one column
                    return shape.map(row => [...row, 1]);
                },
                budgetCost: -1
            },

            // Stat variants
            overcharged: {
                name: 'Overcharged',
                statModifier: (stats) => ({
                    ...stats,
                    damage: Math.round((stats.damage || 0) * 1.25),
                    energyDraw: Math.round((stats.energyDraw || 0) * 1.4)
                }),
                budgetCost: 0  // Trade-off, no net budget change
            },
            lightweight: {
                name: 'Lightweight',
                statModifier: (stats) => ({
                    ...stats,
                    weight: Math.round((stats.weight || 0) * 0.7),
                    armorBonus: Math.round((stats.armorBonus || 0) * 0.85)
                }),
                budgetCost: 0.5
            },
            armored: {
                name: 'Armored',
                statModifier: (stats) => ({
                    ...stats,
                    weight: Math.round((stats.weight || 0) * 1.3),
                    armorBonus: (stats.armorBonus || 0) + 15
                }),
                budgetCost: 0
            },
            efficient: {
                name: 'Efficient',
                statModifier: (stats) => ({
                    ...stats,
                    energyDraw: Math.round((stats.energyDraw || 0) * 0.75)
                }),
                budgetCost: -0.5
            },
            rapid: {
                name: 'Rapid',
                battleModifier: (battle) => ({
                    ...battle,
                    cooldown: Math.round((battle.cooldown || 1000) * 0.8)
                }),
                budgetCost: -1
            },
            heavy: {
                name: 'Heavy',
                statModifier: (stats) => ({
                    ...stats,
                    damage: Math.round((stats.damage || 0) * 1.15),
                    weight: Math.round((stats.weight || 0) * 1.25)
                }),
                budgetCost: 0
            }
        };

        // Track enemy level progression
        let currentEnemyLevel = 1;

        // Generate a unique ID for generated items
        let generatedItemCounter = 0;
        function generateItemId(templateType, rarity, level) {
            generatedItemCounter++;
            return `gen_${templateType}_${rarity}_l${level}_${generatedItemCounter}_${Date.now()}`;
        }

        // Calculate budget for a shape based on area and shape bonuses
        function calculateShapeBudget(shape) {
            let area = 0;
            let maxLength = shape.length;
            let maxWidth = shape[0] ? shape[0].length : 0;

            // Count actual squares in shape
            for (let row of shape) {
                for (let cell of row) {
                    if (cell === 1) area++;
                }
            }

            // Calculate length bonus
            let lengthBonus = 0;
            const maxDim = Math.max(maxLength, maxWidth);
            for (let len in COMPONENT_GENERATION.lengthBonuses) {
                if (maxDim >= parseInt(len)) {
                    lengthBonus = COMPONENT_GENERATION.lengthBonuses[len];
                }
            }

            // Calculate aspect ratio bonus
            let aspectBonus = 0;
            const minDim = Math.min(maxLength, maxWidth);
            if (minDim > 0) {
                const aspectRatio = Math.floor(maxDim / minDim);
                for (let ratio in COMPONENT_GENERATION.aspectBonuses) {
                    if (aspectRatio >= parseInt(ratio)) {
                        aspectBonus = COMPONENT_GENERATION.aspectBonuses[ratio];
                    }
                }
            }

            return {
                area,
                lengthBonus,
                aspectBonus,
                total: area + lengthBonus + aspectBonus
            };
        }

        // Generate a random component based on template, level, and rarity
        function generateComponent(templateType, level = 1, rarity = 'common', options = {}) {
            const template = ITEM_TEMPLATES[templateType];
            if (!template) {
                console.error(`Unknown template type: ${templateType}`);
                return null;
            }

            // Clone base shape
            let shape = template.baseShape.map(row => [...row]);

            // Apply random variant (30% chance)
            let appliedVariants = [];
            const variantChance = options.variantChance !== undefined ? options.variantChance : 0.3;

            if (Math.random() < variantChance) {
                const variantKeys = Object.keys(ITEM_VARIANTS);
                const variantKey = variantKeys[Math.floor(Math.random() * variantKeys.length)];
                const variant = ITEM_VARIANTS[variantKey];

                if (variant.shapeModifier) {
                    shape = variant.shapeModifier(shape);
                }
                appliedVariants.push(variantKey);
            }

            // Calculate budget from shape
            const shapeBudget = calculateShapeBudget(shape);

            // Calculate total budget with rarity and level multipliers
            const rarityMult = COMPONENT_GENERATION.rarityMultipliers[rarity] || 1.0;
            const levelBonus = (level - 1) * COMPONENT_GENERATION.levelBudgetBonus;

            // Apply variance (+/- budgetVariance%)
            const variance = 1 + (Math.random() * 2 - 1) * COMPONENT_GENERATION.budgetVariance;

            let totalBudget = (shapeBudget.total + levelBonus) * rarityMult * variance;

            // Subtract variant costs
            for (let variantKey of appliedVariants) {
                const variant = ITEM_VARIANTS[variantKey];
                totalBudget += variant.budgetCost || 0;
            }

            // Clone base stats
            let stats = { ...template.baseStats };
            let battle = template.baseBattle ? { ...template.baseBattle } : null;

            // Apply stat variants
            for (let variantKey of appliedVariants) {
                const variant = ITEM_VARIANTS[variantKey];
                if (variant.statModifier) {
                    stats = variant.statModifier(stats);
                }
                if (variant.battleModifier && battle) {
                    battle = variant.battleModifier(battle);
                }
            }

            // Distribute remaining budget based on stat weights
            const statWeights = template.statWeights || {};
            const exchangeRates = COMPONENT_GENERATION.exchangeRates;

            // Allocate budget to different stats based on weights
            const budgetToSpend = Math.max(0, totalBudget - shapeBudget.area);  // Budget above base area

            for (let stat in statWeights) {
                const weight = statWeights[stat];
                const budgetForStat = budgetToSpend * weight;

                switch(stat) {
                    case 'damage':
                        stats.damage = (stats.damage || 0) + Math.round(budgetForStat * exchangeRates.damage);
                        break;
                    case 'armor':
                        stats.armorBonus = (stats.armorBonus || 0) + Math.round(budgetForStat * exchangeRates.armor);
                        break;
                    case 'accuracy':
                        stats.accuracyBonus = (stats.accuracyBonus || 0) + Math.round(budgetForStat * exchangeRates.accuracy);
                        break;
                    case 'energyProvided':
                        stats.energyDraw = (stats.energyDraw || 0) - Math.round(budgetForStat * exchangeRates.energyProvided);
                        break;
                    case 'weight':
                        stats.weight = Math.max(1, (stats.weight || 0) - Math.round(budgetForStat * Math.abs(exchangeRates.weight) * 0.3));
                        break;
                    case 'knockback':
                        if (battle) {
                            battle.knockback = (battle.knockback || 0) + Math.round(budgetForStat * exchangeRates.knockback);
                        }
                        break;
                    case 'projectileSpeed':
                        if (battle) {
                            battle.projectileSpeed = (battle.projectileSpeed || 0) + Math.round(budgetForStat * exchangeRates.projectileSpeed);
                        }
                        break;
                    case 'cooldownReduction':
                        if (battle) {
                            battle.cooldown = Math.max(200, (battle.cooldown || 1000) + Math.round(budgetForStat * exchangeRates.cooldownReduction));
                        }
                        break;
                    case 'heatCapacity':
                        stats.heatCapacity = (stats.heatCapacity || 0) + Math.round(budgetForStat * exchangeRates.heatCapacity);
                        break;
                    case 'energyReduction':
                        stats.energyReduction = (stats.energyReduction || 0) + Math.round(budgetForStat * exchangeRates.energyReduction);
                        break;
                }
            }

            // Generate name
            const prefix = template.namePrefix[Math.floor(Math.random() * template.namePrefix.length)];
            const suffix = template.nameSuffix[Math.floor(Math.random() * template.nameSuffix.length)];
            let name = `${prefix} ${suffix}`;

            // Add variant names
            for (let variantKey of appliedVariants) {
                const variant = ITEM_VARIANTS[variantKey];
                if (!name.includes(variant.name)) {
                    name = `${variant.name} ${name}`;
                }
            }

            // Add level indicator for higher levels
            if (level > 1) {
                name = `${name} Mk.${level}`;
            }

            // Generate unique ID
            const id = generateItemId(templateType, rarity, level);

            // Calculate grid dimensions
            const gridDimensions = {
                w: shape[0] ? shape[0].length : 1,
                h: shape.length
            };

            // Build the complete item
            const generatedItem = {
                id,
                name,
                type: template.type,
                category: template.category,
                icon: template.icon,
                gridShape: shape,
                gridDimensions,
                stats,
                constraints: {
                    validSlots: [...template.validSlots]
                },
                // Metadata for display
                rarity,
                level,
                isGenerated: true,
                templateType,
                appliedVariants,
                budgetInfo: {
                    shapeBudget: shapeBudget.total,
                    totalBudget,
                    variance: variance
                }
            };

            // Add battle properties if weapon
            if (battle) {
                generatedItem.battle = battle;
            }

            // Add special properties if they exist
            if (template.special) {
                generatedItem.special = { ...template.special };
            }

            return generatedItem;
        }

        // Generate random rarity based on probabilities
        function getRandomRarity(enemyLevel = 1) {
            // Higher enemy levels increase chance of better rarity
            const levelBonus = (enemyLevel - 1) * 0.02;  // 2% better per level

            const rand = Math.random() - levelBonus;

            if (rand < 0.02) return 'legendary';      // 2% base
            if (rand < 0.08) return 'epic';           // 6% base
            if (rand < 0.22) return 'rare';           // 14% base
            if (rand < 0.45) return 'uncommon';       // 23% base
            return 'common';                           // 55% base
        }

        // Generate salvage components after battle
        function generateSalvageOptions(result, enemyLevel = 1) {
            const options = [];
            const round = gameProgression.round;
            const isBoss = DIFFICULTY.isBossRound(round);

            // Determine number of options based on result and boss status
            let numOptions;
            if (result === 'victory') {
                numOptions = isBoss ? SALVAGE.bossOptions : SALVAGE.normalOptions;
            } else {
                numOptions = Math.max(1, Math.floor((isBoss ? SALVAGE.bossOptions : SALVAGE.normalOptions) / 2));
            }

            // Available templates with weighted selection (reactors are rare)
            const templateWeights = {
                railgun: 3,
                laser: 3,
                missile: 3,
                machinegun: 3,
                armor: 2,
                reactive_armor: 2,
                reactor: 0.5,      // Much less common
                power_cell: 0.5,   // Much less common
                targeting: 2,
                gyro: 2,
                heat_sink: 2,
                cooling_system: 2
            };

            // Build weighted template list
            const weightedTemplates = [];
            for (const [key, weight] of Object.entries(templateWeights)) {
                if (ITEM_TEMPLATES[key]) {
                    for (let w = 0; w < weight * 2; w++) {
                        weightedTemplates.push(key);
                    }
                }
            }

            for (let i = 0; i < numOptions; i++) {
                // Pick weighted random template
                const templateType = weightedTemplates[Math.floor(Math.random() * weightedTemplates.length)];

                // Generate rarity (better on boss rounds)
                const rarityBonus = isBoss ? 2 : 0;
                const rarity = getRandomRarity(enemyLevel + rarityBonus);

                // Item level based on enemy level with some variance
                const level = Math.max(1, enemyLevel + Math.floor(Math.random() * 3) - 1);

                // Generate the component
                const component = generateComponent(templateType, level, rarity);
                if (component) {
                    // Mark some items as high resale value
                    if (Math.random() < SALVAGE.highValueChance) {
                        component.isHighValue = true;
                        component.resaleBonus = 0.5;  // 50% extra sell value
                    }
                    options.push(component);
                }
            }

            return options;
        }

        // Get number of salvage picks allowed
        function getSalvagePicks(result) {
            const isBoss = DIFFICULTY.isBossRound(gameProgression.round);
            if (result !== 'victory') return 1;  // Always at least 1 on defeat
            return isBoss ? SALVAGE.bossPicks : SALVAGE.normalPicks;
        }

        // Add a generated component to the ITEM_DATABASE so it can be used
        function registerGeneratedComponent(component) {
            ITEM_DATABASE[component.id] = component;
            return component.id;
        }

        // ============================================
        // ENEMY GENERATION SYSTEM
        // ============================================

        // Enemy generation constants
        const ENEMY_GENERATION = {
            // Base budget per enemy level
            baseBudget: 100,
            budgetPerLevel: 50,

            // Budget allocation weights
            allocation: {
                health: 0.35,      // 35% to health
                damage: 0.30,      // 30% to damage
                armor: 0.20,       // 20% to armor
                weapons: 0.15      // 15% to weapon count/quality
            },

            // Conversion rates (HP doubled for longer battles)
            rates: {
                healthPerBudget: 6,     // 1 budget = 6 HP (doubled)
                damagePerBudget: 2,     // 1 budget = 2 damage
                armorPerBudget: 1.5,    // 1 budget = 1.5 armor
                weaponBudget: 25        // Cost per weapon slot
            },

            // Enemy chassis types
            chassisTypes: [
                { name: 'Scout Frame', weight: 'light', healthMult: 0.7, damageMult: 0.8, armorMult: 0.5 },
                { name: 'Light Frame', weight: 'light', healthMult: 0.85, damageMult: 0.9, armorMult: 0.7 },
                { name: 'Medium Frame', weight: 'medium', healthMult: 1.0, damageMult: 1.0, armorMult: 1.0 },
                { name: 'Heavy Frame', weight: 'heavy', healthMult: 1.2, damageMult: 1.1, armorMult: 1.3 },
                { name: 'Assault Frame', weight: 'heavy', healthMult: 1.4, damageMult: 1.2, armorMult: 1.5 }
            ],

            // Enemy name prefixes by level tier
            namePrefixes: {
                1: ['Rusty', 'Worn', 'Patrol', 'Scout'],
                2: ['Standard', 'Militia', 'Guard', 'Sentry'],
                3: ['Veteran', 'Battle', 'Assault', 'Strike'],
                4: ['Elite', 'Heavy', 'Siege', 'War'],
                5: ['Champion', 'Destroyer', 'Havoc', 'Titan']
            },

            // Enemy name suffixes
            nameSuffixes: ['Mech', 'Walker', 'Unit', 'Bot', 'Drone', 'Hunter', 'Striker']
        };

        // ============================================
        // DIFFICULTY SCALING SYSTEM
        // ============================================
        const DIFFICULTY = {
            // Base difficulty multiplier by round
            getMultiplier: function(round) {
                // Slow ramp for rounds 1-4 (easy intro)
                if (round <= 4) {
                    return 0.6 + (round - 1) * 0.1;  // 0.6, 0.7, 0.8, 0.9
                }
                // Spike at round 5 (first boss wave)
                if (round === 5) {
                    return 1.5;  // 1.5x difficulty spike
                }
                // Moderate ramp for rounds 6-9
                if (round <= 9) {
                    return 1.0 + (round - 5) * 0.15;  // 1.0, 1.15, 1.3, 1.45
                }
                // Big spike at round 10 (major boss)
                if (round === 10) {
                    return 2.5;  // 2.5x difficulty spike!
                }
                // Continued scaling after round 10
                return 2.0 + (round - 10) * 0.2;
            },

            // Is this round a boss round?
            isBossRound: function(round) {
                return round === 5 || round === 10 || (round > 10 && round % 5 === 0);
            },

            // Get boss type for boss rounds
            getBossType: function(round) {
                if (round === 5) return 'ELITE_COMMANDER';
                if (round === 10) return 'WARLORD';
                if (round === 15) return 'TITAN_PRIME';
                return 'BOSS_' + round;
            },

            // Boss stat multipliers
            bossMultipliers: {
                ELITE_COMMANDER: { hp: 1.8, damage: 1.4, armor: 1.5 },
                WARLORD: { hp: 2.5, damage: 1.8, armor: 2.0 },
                TITAN_PRIME: { hp: 3.5, damage: 2.2, armor: 2.5 }
            }
        };

        // ============================================
        // SALVAGE SYSTEM (Multiple Options, Limited Picks)
        // ============================================
        const SALVAGE = {
            normalOptions: 4,      // Number of salvage options after normal rounds
            bossOptions: 6,        // More options after boss rounds
            normalPicks: 1,        // Can pick 1 after normal rounds
            bossPicks: 2,          // Can pick 2 after boss rounds
            highValueChance: 0.2,  // 20% chance for high resale value item
            comboChance: 0.15      // 15% chance for combo items (synergize)
        };

        // Item combos that synergize
        const ITEM_COMBOS = {
            laser_set: {
                name: 'Laser Array Set',
                items: ['laser', 'laser'],
                bonus: '+15% Laser Damage',
                effect: { type: 'damage_boost', damageType: 'laser', amount: 0.15 }
            },
            missile_barrage: {
                name: 'Missile Barrage Kit',
                items: ['missile', 'missile'],
                bonus: '+20% Knockback',
                effect: { type: 'knockback_boost', amount: 0.20 }
            },
            rapid_assault: {
                name: 'Rapid Assault Package',
                items: ['machinegun', 'machinegun'],
                bonus: '-15% Cooldown',
                effect: { type: 'cooldown_reduction', amount: 0.15 }
            },
            heavy_hitter: {
                name: 'Heavy Hitter Bundle',
                items: ['railgun', 'armor'],
                bonus: '+10% Damage, +10 Armor',
                effect: { type: 'mixed', damage: 0.10, armor: 10 }
            }
        };

        // Mission templates (base structure, enemies generated dynamically)
        const MISSION_TEMPLATES = {
            patrol: {
                id: 'patrol',
                name: 'Border Patrol',
                difficulty: 'Easy',
                risk: 1,
                baseBudgetMult: 0.6,    // 60% of standard budget
                enemyCount: 1,
                description: 'Light recon mission. Expect minimal resistance.',
                rewardMult: 1.0
            },
            skirmish: {
                id: 'skirmish',
                name: 'Skirmish Zone',
                difficulty: 'Easy',
                risk: 1,
                baseBudgetMult: 0.5,    // Lower budget per enemy
                enemyCount: 2,          // But 2 enemies
                description: 'Light engagement. Multiple weak hostiles detected.',
                rewardMult: 1.2
            },
            convoy: {
                id: 'convoy',
                name: 'Convoy Assault',
                difficulty: 'Medium',
                risk: 2,
                baseBudgetMult: 1.0,
                enemyCount: 1,
                description: 'Intercept enemy supply convoy. Medium resistance expected.',
                rewardMult: 1.5
            },
            ambush: {
                id: 'ambush',
                name: 'Ambush Site',
                difficulty: 'Medium',
                risk: 2,
                baseBudgetMult: 0.7,
                enemyCount: 2,
                description: 'Clear hostile ambush. Two medium threats detected.',
                rewardMult: 1.8
            },
            fortress: {
                id: 'fortress',
                name: 'Fortress Breach',
                difficulty: 'Hard',
                risk: 3,
                baseBudgetMult: 1.5,
                enemyCount: 1,
                description: 'Assault heavily defended position. Prepare for heavy combat.',
                rewardMult: 2.5
            },
            warzone: {
                id: 'warzone',
                name: 'Active Warzone',
                difficulty: 'Hard',
                risk: 3,
                baseBudgetMult: 0.9,
                enemyCount: 3,
                description: 'Enter active combat zone. Multiple hostiles incoming.',
                rewardMult: 3.0
            }
        };

        // Game progression state (defined early for getEnemyLevel)
        let gameProgression = {
            round: 1,
            wins: 0,
            losses: 0,
            maxRound: 1
        };

        // Calculate enemy level based on currentEnemyLevel and mission difficulty
        function getEnemyLevel(missionRisk) {
            // Use new difficulty system based on round
            const round = gameProgression.round;
            const difficultyMult = DIFFICULTY.getMultiplier(round);
            const isBoss = DIFFICULTY.isBossRound(round);

            // Base level scales with difficulty multiplier
            const baseLevel = Math.max(1, Math.floor(difficultyMult * 2));

            // Add variance for non-boss rounds
            const levelVariance = isBoss ? 0 : (Math.floor(Math.random() * 2) - 1);

            // Risk affects level (1=easy, 2=medium, 3=hard)
            const riskBonus = missionRisk - 2;

            // Boss rounds get extra levels
            const bossBonus = isBoss ? 2 : 0;

            return Math.max(1, Math.min(15, baseLevel + riskBonus + levelVariance + bossBonus));
        }

        // Generate a single enemy mech
        function generateEnemy(level, budget) {
            // Select chassis based on budget and level
            const chassisIndex = Math.min(
                ENEMY_GENERATION.chassisTypes.length - 1,
                Math.floor((level - 1) / 2) + Math.floor(Math.random() * 2)
            );
            const chassis = ENEMY_GENERATION.chassisTypes[chassisIndex];

            // Allocate budget
            const healthBudget = budget * ENEMY_GENERATION.allocation.health;
            const damageBudget = budget * ENEMY_GENERATION.allocation.damage;
            const armorBudget = budget * ENEMY_GENERATION.allocation.armor;
            const weaponBudget = budget * ENEMY_GENERATION.allocation.weapons;

            // Calculate stats
            const baseHealth = 100 + Math.round(healthBudget * ENEMY_GENERATION.rates.healthPerBudget * chassis.healthMult);
            const baseDamage = 20 + Math.round(damageBudget * ENEMY_GENERATION.rates.damagePerBudget * chassis.damageMult);
            const baseArmor = Math.round(armorBudget * ENEMY_GENERATION.rates.armorPerBudget * chassis.armorMult);

            // Determine weapon count
            const weaponCount = Math.max(1, Math.min(3, Math.floor(weaponBudget / ENEMY_GENERATION.rates.weaponBudget) + 1));

            // Generate equipment
            const equipment = [];
            const weaponSlots = ['rightArm', 'leftArm', 'torso'];
            const weaponTypes = ['railgun_mk1', 'laser_array'];

            for (let i = 0; i < weaponCount && i < weaponSlots.length; i++) {
                equipment.push({
                    itemId: weaponTypes[i % weaponTypes.length],
                    slot: weaponSlots[i],
                    position: { x: 0, y: 0 }
                });
            }

            // Add armor if high enough level
            if (level >= 2 && baseArmor > 20) {
                equipment.push({
                    itemId: 'armor_plate',
                    slot: 'torso',
                    position: { x: 0, y: 0 }
                });
            }

            // Add reactor for energy
            if (weaponCount >= 2) {
                equipment.push({
                    itemId: 'reactor_core',
                    slot: 'torso',
                    position: { x: 2, y: 0 }
                });
            }

            // Generate name
            const tierIndex = Math.min(5, Math.ceil(level / 2));
            const prefixes = ENEMY_GENERATION.namePrefixes[tierIndex] || ENEMY_GENERATION.namePrefixes[1];
            const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
            const suffix = ENEMY_GENERATION.nameSuffixes[Math.floor(Math.random() * ENEMY_GENERATION.nameSuffixes.length)];

            return {
                name: `${prefix} ${suffix}`,
                chassis: chassis.name,
                level: level,
                maxHealth: baseHealth,
                equipment: equipment,
                stats: {
                    weight: 30 + level * 8,
                    energy: 30 + weaponCount * 15,
                    damage: baseDamage,
                    armor: baseArmor
                }
            };
        }

        // Generate enemies for a mission
        function generateMissionEnemies(missionTemplate) {
            const enemies = [];
            const enemyLevel = getEnemyLevel(missionTemplate.risk);

            // Calculate total budget
            const totalBudget = (ENEMY_GENERATION.baseBudget + ENEMY_GENERATION.budgetPerLevel * enemyLevel)
                              * missionTemplate.baseBudgetMult;

            // Divide budget among enemies (with slight variance)
            const budgetPerEnemy = totalBudget / missionTemplate.enemyCount;

            for (let i = 0; i < missionTemplate.enemyCount; i++) {
                // Add variance to individual enemy budget (+/- 15%)
                const variance = 0.85 + Math.random() * 0.3;
                const enemyBudget = budgetPerEnemy * variance;

                // Slight level variance for multi-enemy missions
                const levelVariance = missionTemplate.enemyCount > 1 ? Math.floor(Math.random() * 2) - 1 : 0;
                const individualLevel = Math.max(1, enemyLevel + levelVariance);

                enemies.push(generateEnemy(individualLevel, enemyBudget));
            }

            return enemies;
        }

        // Build dynamic missions based on current enemy level
        function buildMissions() {
            const missions = {};

            // Select 3 random mission templates for variety
            const templateEntries = Object.entries(MISSION_TEMPLATES);
            const shuffled = templateEntries.sort(() => Math.random() - 0.5);
            const selectedTemplates = shuffled.slice(0, 3);

            for (const [id, template] of selectedTemplates) {
                const enemies = generateMissionEnemies(template);
                const avgLevel = Math.round(enemies.reduce((sum, e) => sum + e.level, 0) / enemies.length);

                // Scale rewards with level
                const levelMult = 1 + (avgLevel - 1) * 0.15;
                const baseCredits = [300, 500, 800, 1200, 2000, 3500][template.risk + Math.floor(avgLevel / 2) - 1] || 500;
                const baseXP = [50, 100, 150, 250, 400, 600][template.risk + Math.floor(avgLevel / 2) - 1] || 100;

                missions[id] = {
                    ...template,
                    enemyMechs: enemies,
                    averageLevel: avgLevel,
                    reward: {
                        credits: Math.round(baseCredits * template.rewardMult * levelMult),
                        xp: Math.round(baseXP * template.rewardMult * levelMult)
                    }
                };
            }

            return missions;
        }

        // Current missions (regenerated after each battle)
        let MISSIONS = buildMissions();

        let selectedMission = null;
        let lastBattleMission = null;  // Track mission info for salvage generation

        // ============================================
        // PHYSICS BATTLE SYSTEM
        // ============================================
        let battleMechs = [];       // All mechs in battle
        let playerBattleMech = null;
        let enemyBattleMech = null;
        let projectiles = [];       // Active projectiles
        let beams = [];             // Active beam weapons
        let battleActive = false;
        let battleScene = null;     // Separate scene for battle
        let battleGround = null;
        let weaponCooldowns = {};   // Track weapon cooldowns per mech

        // Battle colors
        const BATTLE_COLORS = {
            playerPrimary: new BABYLON.Color3(0.15, 0.35, 0.2),
            playerSecondary: new BABYLON.Color3(0.25, 0.45, 0.3),
            enemyPrimary: new BABYLON.Color3(0.4, 0.12, 0.12),
            enemySecondary: new BABYLON.Color3(0.5, 0.18, 0.18),
            metal: new BABYLON.Color3(0.35, 0.35, 0.4),
            darkMetal: new BABYLON.Color3(0.12, 0.12, 0.15)
        };

        // Mech state machine
        const MechState = {
            WALKING: 'walking',
            RAGDOLL: 'ragdoll',
            RECOVERING: 'recovering'
        };

        // AI Configuration
        const AI_CONFIG = {
            idealRange: 10,
            minRange: 6,
            maxRange: 14,
            moveSpeed: 4,
            turnSpeed: 2,
            strafeChance: 0.4,
            decisionInterval: 0.3
        };

        // Arena bounds
        const ARENA_BOUNDS = {
            minX: -15,
            maxX: 15,
            minZ: -10,
            maxZ: 10
        };

        // Texture URLs
        const TEXTURE_URLS = {
            grass: 'https://i.imgur.com/c3l8U9o.png',
            rustMetal: 'https://assets.babylonjs.com/textures/rustediron2_basecolor.png'
        };

        let BATTLE_TEXTURES = {};

        // ============================================
        // BATTLE SYSTEM FUNCTIONS
        // ============================================

        // Get weapons from loadout
        function getLoadoutWeapons() {
            const weapons = [];
            loadoutState.equipment.forEach(eq => {
                const item = ITEM_DATABASE[eq.itemId];
                if (item && item.type === 'WEAPON' && item.battle) {
                    weapons.push({
                        itemId: eq.itemId,
                        slot: eq.slot,
                        name: item.name,
                        damage: item.stats.damage,
                        battle: item.battle,
                        lastFired: 0
                    });
                }
            });
            return weapons;
        }

        // Create battle scene with physics
        async function createBattleScene() {
            // Initialize Havok if not done
            if (!havokInstance) {
                havokInstance = await HavokPhysics();
            }

            battleScene = new BABYLON.Scene(engine);
            battleScene.clearColor = new BABYLON.Color3(0.5, 0.6, 0.75);

            // Enable physics
            havokPlugin = new BABYLON.HavokPlugin(true, havokInstance);
            battleScene.enablePhysics(new BABYLON.Vector3(0, -18, 0), havokPlugin);

            // Camera
            battleCamera = new BABYLON.ArcRotateCamera('battleCam', -Math.PI/2, Math.PI/3.5, 25,
                new BABYLON.Vector3(0, 2, 0), battleScene);
            battleCamera.attachControl(document.getElementById('renderCanvas'), true);
            battleCamera.lowerRadiusLimit = 10;
            battleCamera.upperRadiusLimit = 50;

            // Lighting
            const hemi = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0, 1, 0), battleScene);
            hemi.intensity = 0.5;

            const sun = new BABYLON.DirectionalLight('sun', new BABYLON.Vector3(-1, -2, -1), battleScene);
            sun.intensity = 1.2;

            // Ground
            battleGround = BABYLON.MeshBuilder.CreateGround('ground', { width: 40, height: 30 }, battleScene);
            const groundMat = new BABYLON.StandardMaterial('groundMat', battleScene);
            groundMat.diffuseColor = new BABYLON.Color3(0.3, 0.4, 0.3);
            battleGround.material = groundMat;
            battleGround.receiveShadows = true;

            // Ground physics
            const groundShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -0.5, 0),
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(40, 1, 30),
                battleScene
            );
            const groundBody = new BABYLON.PhysicsBody(battleGround, BABYLON.PhysicsMotionType.STATIC, false, battleScene);
            groundBody.shape = groundShape;

            return battleScene;
        }

        // Create a battle mech with physics and loadout weapons
        // Matches the proportions of the builder mech for consistency
        function createBattleMech(scene, xPos, zPos, isPlayer, weapons, maxHP) {
            const name = isPlayer ? 'player' : 'enemy';
            const colors = isPlayer ?
                { primary: BATTLE_COLORS.playerPrimary, secondary: BATTLE_COLORS.playerSecondary } :
                { primary: BATTLE_COLORS.enemyPrimary, secondary: BATTLE_COLORS.enemySecondary };

            // Materials - match builder holographic style but solid
            const primaryMat = new BABYLON.StandardMaterial(name + '_primary', scene);
            primaryMat.diffuseColor = colors.primary;
            primaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);

            const secondaryMat = new BABYLON.StandardMaterial(name + '_secondary', scene);
            secondaryMat.diffuseColor = colors.secondary;

            const metalMat = new BABYLON.StandardMaterial(name + '_metal', scene);
            metalMat.diffuseColor = BATTLE_COLORS.metal;
            metalMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);

            const darkMat = new BABYLON.StandardMaterial(name + '_dark', scene);
            darkMat.diffuseColor = BATTLE_COLORS.darkMetal;

            // Cockpit material (glowing)
            const cockpitMat = new BABYLON.StandardMaterial(name + '_cockpit', scene);
            cockpitMat.diffuseColor = isPlayer ? new BABYLON.Color3(0, 0.5, 0.5) : new BABYLON.Color3(0.5, 0.2, 0.2);
            cockpitMat.emissiveColor = isPlayer ? new BABYLON.Color3(0, 0.8, 0.9) : new BABYLON.Color3(0.9, 0.3, 0.2);
            cockpitMat.alpha = 0.9;

            // Pelvis (physics body) - matches builder: width: 0.9, height: 0.4, depth: 0.6
            const pelvis = BABYLON.MeshBuilder.CreateBox(name + '_pelvis', { width: 0.9, height: 0.4, depth: 0.6 }, scene);
            pelvis.position = new BABYLON.Vector3(xPos, 1.5, zPos);
            pelvis.material = darkMat;

            // Physics body - taller collision box to represent full mech
            const pelvisShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, 0.5, 0),
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(1.4, 2.5, 0.9),
                scene
            );
            const pelvisBody = new BABYLON.PhysicsBody(pelvis, BABYLON.PhysicsMotionType.ANIMATED, false, scene);
            pelvisBody.shape = pelvisShape;
            pelvisBody.setMassProperties({ mass: 50 });
            pelvisBody.setAngularDamping(5);
            pelvisBody.setLinearDamping(0.5);

            // Torso - matches builder: width: 1.2, height: 1.0, depth: 0.8
            const torso = BABYLON.MeshBuilder.CreateBox(name + '_torso', { width: 1.2, height: 1.0, depth: 0.8 }, scene);
            torso.position.y = 0.7;
            torso.parent = pelvis;
            torso.material = primaryMat;

            // Torso upper - matches builder: width: 1.4, height: 0.5, depth: 0.9
            const torsoUpper = BABYLON.MeshBuilder.CreateBox(name + '_torsoUpper', { width: 1.4, height: 0.5, depth: 0.9 }, scene);
            torsoUpper.position.y = 0.6;
            torsoUpper.parent = torso;
            torsoUpper.material = secondaryMat;

            // Head - matches builder: width: 0.5, height: 0.4, depth: 0.5
            const head = BABYLON.MeshBuilder.CreateBox(name + '_head', { width: 0.5, height: 0.4, depth: 0.5 }, scene);
            head.position.y = 0.65;
            head.parent = torsoUpper;
            head.material = primaryMat;

            // Cockpit glass - matches builder
            const cockpit = BABYLON.MeshBuilder.CreateBox(name + '_cockpit', { width: 0.4, height: 0.15, depth: 0.1 }, scene);
            cockpit.position = new BABYLON.Vector3(0, 0, 0.28);
            cockpit.parent = head;
            cockpit.material = cockpitMat;

            // Left Arm - shoulder + upper arm + lower arm
            const leftShoulder = BABYLON.MeshBuilder.CreateBox(name + '_leftShoulder', { width: 0.35, height: 0.3, depth: 0.35 }, scene);
            leftShoulder.position = new BABYLON.Vector3(-0.85, 0.35, 0);
            leftShoulder.parent = torso;
            leftShoulder.material = secondaryMat;

            const leftUpperArm = BABYLON.MeshBuilder.CreateBox(name + '_leftUpperArm', { width: 0.25, height: 0.5, depth: 0.25 }, scene);
            leftUpperArm.position.y = -0.35;
            leftUpperArm.parent = leftShoulder;
            leftUpperArm.material = metalMat;

            const leftLowerArm = BABYLON.MeshBuilder.CreateBox(name + '_leftLowerArm', { width: 0.3, height: 0.6, depth: 0.3 }, scene);
            leftLowerArm.position.y = -0.5;
            leftLowerArm.parent = leftUpperArm;
            leftLowerArm.material = primaryMat;

            // Left Weapon barrel
            const leftWeapon = BABYLON.MeshBuilder.CreateCylinder(name + '_leftWpn', { diameter: 0.15, height: 0.5 }, scene);
            leftWeapon.rotation.x = Math.PI / 2;
            leftWeapon.position = new BABYLON.Vector3(0, -0.2, 0.25);
            leftWeapon.parent = leftLowerArm;
            leftWeapon.material = darkMat;

            // Right Arm - shoulder + upper arm + lower arm
            const rightShoulder = BABYLON.MeshBuilder.CreateBox(name + '_rightShoulder', { width: 0.35, height: 0.3, depth: 0.35 }, scene);
            rightShoulder.position = new BABYLON.Vector3(0.85, 0.35, 0);
            rightShoulder.parent = torso;
            rightShoulder.material = secondaryMat;

            const rightUpperArm = BABYLON.MeshBuilder.CreateBox(name + '_rightUpperArm', { width: 0.25, height: 0.5, depth: 0.25 }, scene);
            rightUpperArm.position.y = -0.35;
            rightUpperArm.parent = rightShoulder;
            rightUpperArm.material = metalMat;

            const rightLowerArm = BABYLON.MeshBuilder.CreateBox(name + '_rightLowerArm', { width: 0.3, height: 0.6, depth: 0.3 }, scene);
            rightLowerArm.position.y = -0.5;
            rightLowerArm.parent = rightUpperArm;
            rightLowerArm.material = primaryMat;

            // Right Weapon barrel
            const rightWeapon = BABYLON.MeshBuilder.CreateCylinder(name + '_rightWpn', { diameter: 0.15, height: 0.5 }, scene);
            rightWeapon.rotation.x = Math.PI / 2;
            rightWeapon.position = new BABYLON.Vector3(0, -0.2, 0.25);
            rightWeapon.parent = rightLowerArm;
            rightWeapon.material = darkMat;

            // Legs - matching builder structure
            // Left leg
            const leftHip = BABYLON.MeshBuilder.CreateBox(name + '_leftHip', { width: 0.25, height: 0.25, depth: 0.25 }, scene);
            leftHip.position = new BABYLON.Vector3(-0.3, -0.25, 0);
            leftHip.parent = pelvis;
            leftHip.material = darkMat;

            const leftUpperLeg = BABYLON.MeshBuilder.CreateBox(name + '_leftUpperLeg', { width: 0.2, height: 0.5, depth: 0.2 }, scene);
            leftUpperLeg.position.y = -0.35;
            leftUpperLeg.parent = leftHip;
            leftUpperLeg.material = metalMat;

            const leftLowerLeg = BABYLON.MeshBuilder.CreateBox(name + '_leftLowerLeg', { width: 0.22, height: 0.55, depth: 0.22 }, scene);
            leftLowerLeg.position.y = -0.5;
            leftLowerLeg.parent = leftUpperLeg;
            leftLowerLeg.material = primaryMat;

            const leftFoot = BABYLON.MeshBuilder.CreateBox(name + '_leftFoot', { width: 0.25, height: 0.12, depth: 0.4 }, scene);
            leftFoot.position = new BABYLON.Vector3(0, -0.3, 0.08);
            leftFoot.parent = leftLowerLeg;
            leftFoot.material = darkMat;

            // Right leg
            const rightHip = BABYLON.MeshBuilder.CreateBox(name + '_rightHip', { width: 0.25, height: 0.25, depth: 0.25 }, scene);
            rightHip.position = new BABYLON.Vector3(0.3, -0.25, 0);
            rightHip.parent = pelvis;
            rightHip.material = darkMat;

            const rightUpperLeg = BABYLON.MeshBuilder.CreateBox(name + '_rightUpperLeg', { width: 0.2, height: 0.5, depth: 0.2 }, scene);
            rightUpperLeg.position.y = -0.35;
            rightUpperLeg.parent = rightHip;
            rightUpperLeg.material = metalMat;

            const rightLowerLeg = BABYLON.MeshBuilder.CreateBox(name + '_rightLowerLeg', { width: 0.22, height: 0.55, depth: 0.22 }, scene);
            rightLowerLeg.position.y = -0.5;
            rightLowerLeg.parent = rightUpperLeg;
            rightLowerLeg.material = primaryMat;

            const rightFoot = BABYLON.MeshBuilder.CreateBox(name + '_rightFoot', { width: 0.25, height: 0.12, depth: 0.4 }, scene);
            rightFoot.position = new BABYLON.Vector3(0, -0.3, 0.08);
            rightFoot.parent = rightLowerLeg;
            rightFoot.material = darkMat;

            return {
                name: name,
                pelvis: pelvis,
                pelvisBody: pelvisBody,
                torso: torso,
                head: head,
                leftArm: leftLowerArm,
                rightArm: rightLowerArm,
                leftWeapon: leftWeapon,
                rightWeapon: rightWeapon,
                leftLeg: leftLowerLeg,
                rightLeg: rightLowerLeg,
                isPlayer: isPlayer,
                maxHP: maxHP,
                currentHP: maxHP,
                weapons: weapons,
                isDestroyed: false,
                walkCycle: 0,
                walkDirection: 0,
                isWalking: false,
                torsoTwist: 0,
                lastFiredArm: 'left',
                ai: {
                    target: null,
                    decisionTimer: 0,
                    strafeAmount: 0
                }
            };
        }

        // Fire a weapon from loadout
        function fireLoadoutWeapon(mech, weaponData, target) {
            const now = performance.now();
            if (now - weaponData.lastFired < weaponData.battle.cooldown) {
                return; // Still on cooldown
            }
            weaponData.lastFired = now;

            const battle = weaponData.battle;
            const fromPos = mech.pelvis.getAbsolutePosition();
            const toPos = target.pelvis.getAbsolutePosition();
            const direction = toPos.subtract(fromPos).normalize();

            // Fire from alternating arms
            const arm = mech.lastFiredArm === 'left' ? mech.rightArm : mech.leftArm;
            mech.lastFiredArm = mech.lastFiredArm === 'left' ? 'right' : 'left';
            const armPos = arm.getAbsolutePosition();

            if (battle.isBeam) {
                // Create beam
                const beamLength = BABYLON.Vector3.Distance(armPos, toPos);
                const beam = BABYLON.MeshBuilder.CreateCylinder('beam_' + Date.now(), {
                    diameter: 0.15,
                    height: beamLength
                }, battleScene);

                const midpoint = armPos.add(toPos).scale(0.5);
                beam.position = midpoint;
                beam.lookAt(toPos);
                beam.rotation.x += Math.PI / 2;

                const beamMat = new BABYLON.StandardMaterial('beamMat', battleScene);
                beamMat.emissiveColor = new BABYLON.Color3(battle.color[0], battle.color[1], battle.color[2]);
                beamMat.alpha = 0.8;
                beam.material = beamMat;

                beams.push({
                    mesh: beam,
                    damage: weaponData.damage,
                    knockback: battle.knockback,
                    target: target,
                    startTime: now,
                    duration: battle.beamDuration,
                    applied: false
                });
            } else {
                // Create projectile
                const projectile = BABYLON.MeshBuilder.CreateSphere('proj_' + Date.now(), {
                    diameter: battle.projectileSize * 2
                }, battleScene);
                projectile.position = armPos.clone();

                const projMat = new BABYLON.StandardMaterial('projMat', battleScene);
                projMat.emissiveColor = new BABYLON.Color3(battle.color[0], battle.color[1], battle.color[2]);
                projectile.material = projMat;

                projectiles.push({
                    mesh: projectile,
                    velocity: direction.scale(battle.projectileSpeed),
                    damage: weaponData.damage,
                    knockback: battle.knockback,
                    target: target,
                    startTime: now
                });
            }

            // Apply recoil
            const recoilImpulse = direction.scale(-battle.knockback * 0.2);
            mech.pelvisBody.applyImpulse(recoilImpulse, fromPos);
        }

        // Update projectiles
        function updateProjectiles(dt) {
            const toRemove = [];
            projectiles.forEach((proj, idx) => {
                proj.mesh.position.addInPlace(proj.velocity.scale(dt));

                // Check if hit target
                const dist = BABYLON.Vector3.Distance(proj.mesh.position, proj.target.pelvis.getAbsolutePosition());
                if (dist < 1.5) {
                    // Hit!
                    applyDamage(proj.target, proj.damage, proj.knockback, proj.velocity.normalize());
                    toRemove.push(idx);
                }

                // Remove if too old or out of bounds
                if (performance.now() - proj.startTime > 3000 ||
                    Math.abs(proj.mesh.position.x) > 30 ||
                    Math.abs(proj.mesh.position.z) > 30) {
                    toRemove.push(idx);
                }
            });

            // Remove hit/expired projectiles
            toRemove.reverse().forEach(idx => {
                projectiles[idx].mesh.dispose();
                projectiles.splice(idx, 1);
            });
        }

        // Update beams
        function updateBeams(dt) {
            const now = performance.now();
            const toRemove = [];

            beams.forEach((beam, idx) => {
                if (now - beam.startTime > beam.duration) {
                    toRemove.push(idx);
                } else if (!beam.applied) {
                    // Apply damage once
                    const direction = beam.target.pelvis.getAbsolutePosition().subtract(
                        beam.mesh.position
                    ).normalize();
                    applyDamage(beam.target, beam.damage, beam.knockback, direction);
                    beam.applied = true;
                }
            });

            toRemove.reverse().forEach(idx => {
                beams[idx].mesh.dispose();
                beams.splice(idx, 1);
            });
        }

        // Apply damage to mech
        function applyDamage(mech, damage, knockback, direction) {
            mech.currentHP -= damage;

            // Apply knockback
            const impulse = direction.scale(knockback);
            mech.pelvisBody.applyImpulse(impulse, mech.pelvis.getAbsolutePosition());

            // Check death
            if (mech.currentHP <= 0) {
                mech.isDestroyed = true;
                mech.currentHP = 0;
            }

            updateBattleUI();
        }

        // Update mech AI and movement
        function updateMechAI(mech, dt) {
            if (!mech || mech.isDestroyed) return;
            if (!mech.pelvis) {
                console.error('Mech pelvis is undefined:', mech.name);
                return;
            }

            const target = mech.ai.target;
            if (!target || target.isDestroyed || !target.pelvis) return;

            const myPos = mech.pelvis.getAbsolutePosition();
            const targetPos = target.pelvis.getAbsolutePosition();
            const dx = targetPos.x - myPos.x;
            const dz = targetPos.z - myPos.z;
            const distance = Math.sqrt(dx * dx + dz * dz);

            // Decision making
            mech.ai.decisionTimer -= dt;
            if (mech.ai.decisionTimer <= 0) {
                mech.ai.decisionTimer = AI_CONFIG.decisionInterval;

                // Decide to strafe
                if (Math.random() < AI_CONFIG.strafeChance) {
                    mech.ai.strafeAmount = (Math.random() - 0.5) * 2;
                } else {
                    mech.ai.strafeAmount = 0;
                }
            }

            // Movement - try to stay at ideal range
            if (distance > AI_CONFIG.maxRange) {
                mech.walkDirection = 1;  // Move forward
                mech.isWalking = true;
            } else if (distance < AI_CONFIG.minRange) {
                mech.walkDirection = -1;  // Back up
                mech.isWalking = true;
            } else {
                mech.walkDirection = 0;
                mech.isWalking = Math.abs(mech.ai.strafeAmount) > 0.3;
            }

            // Calculate facing angle
            const angleToTarget = Math.atan2(dz, dx);
            const baseAngle = Math.PI / 2;

            // Get pelvis rotation
            const body = mech.pelvisBody;
            const quat = body.transformNode.rotationQuaternion;
            let pelvisYaw = 0;
            if (quat) {
                const euler = quat.toEulerAngles();
                pelvisYaw = euler.y;
            }

            // Calculate desired yaw change
            let desiredYaw = baseAngle - angleToTarget;
            while (desiredYaw > Math.PI) desiredYaw -= Math.PI * 2;
            while (desiredYaw < -Math.PI) desiredYaw += Math.PI * 2;

            const yawError = desiredYaw - pelvisYaw;

            // Apply rotation
            const rotSpeed = AI_CONFIG.turnSpeed * dt;
            if (Math.abs(yawError) > 0.1) {
                const rot = Math.sign(yawError) * Math.min(Math.abs(yawError), rotSpeed);
                body.setAngularVelocity(new BABYLON.Vector3(0, rot * 3, 0));
            }

            // Walking animation
            if (mech.isWalking) {
                mech.walkCycle += dt * 4;
                const legSwing = Math.sin(mech.walkCycle) * 0.3;
                mech.leftLeg.rotation.x = legSwing;
                mech.rightLeg.rotation.x = -legSwing;
            }

            // Move
            if (mech.isWalking || mech.walkDirection !== 0) {
                let forwardDir = new BABYLON.Vector3(1, 0, 0);
                let rightDir = new BABYLON.Vector3(0, 0, 1);
                if (quat) {
                    const rotMatrix = new BABYLON.Matrix();
                    quat.toRotationMatrix(rotMatrix);
                    forwardDir = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(1, 0, 0), rotMatrix);
                    forwardDir.y = 0;
                    forwardDir.normalize();
                    rightDir = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(0, 0, 1), rotMatrix);
                    rightDir.y = 0;
                    rightDir.normalize();
                }

                const moveSpeed = AI_CONFIG.moveSpeed;
                let velocity = forwardDir.scale(mech.walkDirection * moveSpeed);
                velocity.addInPlace(rightDir.scale(mech.ai.strafeAmount * moveSpeed * 0.6));
                velocity.y = (2.5 - myPos.y) * 5; // Ground seeking
                body.setLinearVelocity(velocity);
            }

            // Torso twist toward target (local rotation)
            let localTorsoAngle = desiredYaw - pelvisYaw;
            while (localTorsoAngle > Math.PI) localTorsoAngle -= Math.PI * 2;
            while (localTorsoAngle < -Math.PI) localTorsoAngle += Math.PI * 2;
            localTorsoAngle = Math.max(-1.0, Math.min(1.0, localTorsoAngle));
            mech.torsoTwist = BABYLON.Scalar.Lerp(mech.torsoTwist, localTorsoAngle, dt * 5);
            mech.torso.rotation.y = mech.torsoTwist;

            // Fire weapons at target
            if (distance < 15 && mech.weapons.length > 0) {
                // Fire first available weapon
                mech.weapons.forEach(weapon => {
                    fireLoadoutWeapon(mech, weapon, target);
                });
            }
        }

        // Battle update loop
        function updateBattle(dt) {
            if (!battleActive) return;

            // Update all mechs
            battleMechs.forEach(mech => {
                updateMechAI(mech, dt);
            });

            // Update weapons
            updateProjectiles(dt);
            updateBeams(dt);

            // Check battle end
            if (playerBattleMech.isDestroyed || enemyBattleMech.isDestroyed) {
                endBattle(playerBattleMech.isDestroyed ? 'defeat' : 'victory');
            }
        }

        // Battle UI
        function updateBattleUI() {
            const playerHP = document.getElementById('playerHP');
            const enemyHP = document.getElementById('enemyHP');
            if (playerHP && playerBattleMech) {
                const pct = (playerBattleMech.currentHP / playerBattleMech.maxHP) * 100;
                playerHP.style.width = pct + '%';
            }
            if (enemyHP && enemyBattleMech) {
                const pct = (enemyBattleMech.currentHP / enemyBattleMech.maxHP) * 100;
                enemyHP.style.width = pct + '%';
            }
        }

        // End battle
        function endBattle(result) {
            battleActive = false;

            // Show result
            const overlay = document.getElementById('battleResultOverlay');
            const resultText = document.getElementById('battleResult');
            if (overlay && resultText) {
                resultText.textContent = result === 'victory' ? 'VICTORY!' : 'DEFEAT';
                resultText.style.color = result === 'victory' ? '#00ff88' : '#ff4444';
                overlay.style.display = 'flex';
            }
        }

        // Return to loadout (fallback if no rewards data)
        function returnToLoadout() {
            // Hide battle iframe
            const battleFrame = document.getElementById('battleFrame');
            battleFrame.style.display = 'none';
            battleFrame.src = '';  // Unload the iframe

            // Clear localStorage config
            localStorage.removeItem('battleConfig');

            // Show builder UI and canvas
            document.getElementById('mechBuilderUI').style.display = 'flex';
            document.getElementById('renderCanvas').style.display = 'block';

            // Switch to loadout tab (not mission)
            switchTab('loadout');

            // Switch to builder phase
            currentPhase = GamePhase.MECHBUILDER;
        }

        // Persistent bench items (no deck system - items stay on bench or mech)
        let benchItems = [];  // Array of item objects on the bench

        // Initialize with starter items
        function initializeStarterItems() {
            benchItems = [];
            // Add starter weapons
            const starterWeapon1 = { ...ITEM_DATABASE.railgun_mk1, instanceId: 'start_1' };
            const starterWeapon2 = { ...ITEM_DATABASE.laser_array, instanceId: 'start_2' };
            const starterReactor = { ...ITEM_DATABASE.reactor_core, instanceId: 'start_3' };
            benchItems.push(starterWeapon1, starterWeapon2, starterReactor);
        }

        // Player resources
        let playerResources = {
            xp: 0,
            scrap: 0,
            gold: 10  // Starting gold
        };

        // ============================================
        // ECONOMY & INTEREST SYSTEM
        // ============================================
        const ECONOMY = {
            startingGold: 10,
            winBonus: 3,           // Gold for winning
            lossBonus: 1,          // Gold for losing (consolation)
            interestRate: 0.1,     // 10% interest
            interestCap: 5,        // Max 5 gold interest per round
            interestThreshold: 10, // Need 10+ gold to earn interest
            streakBonus: 1,        // Extra gold per win streak
            maxStreak: 5,          // Cap streak bonus at 5

            // Shop costs
            shopRefreshCost: 2,
            mechPrices: {
                common: 3,
                uncommon: 6,
                rare: 12,
                epic: 20,
                legendary: 35
            },
            weaponPrices: {
                common: 2,
                uncommon: 4,
                rare: 8,
                epic: 15,
                legendary: 25
            },
            sellMultiplier: 0.5,  // Sell back for 50% of buy price
            bargainDiscount: 0.6   // Bargain items cost 60% of normal
        };

        // Calculate interest earned
        function calculateInterest() {
            if (playerResources.gold < ECONOMY.interestThreshold) return 0;
            const interest = Math.floor(playerResources.gold * ECONOMY.interestRate);
            return Math.min(interest, ECONOMY.interestCap);
        }

        // Award end-of-round gold
        function awardRoundGold(isVictory) {
            let goldEarned = isVictory ? ECONOMY.winBonus : ECONOMY.lossBonus;

            // Win streak bonus
            if (isVictory) {
                const streak = Math.min(gameProgression.wins, ECONOMY.maxStreak);
                goldEarned += streak * ECONOMY.streakBonus;
            }

            // Interest on savings
            const interest = calculateInterest();
            goldEarned += interest;

            playerResources.gold += goldEarned;

            return {
                base: isVictory ? ECONOMY.winBonus : ECONOMY.lossBonus,
                streak: isVictory ? Math.min(gameProgression.wins, ECONOMY.maxStreak) * ECONOMY.streakBonus : 0,
                interest: interest,
                total: goldEarned
            };
        }

        // ============================================
        // MECH CHASSIS SYSTEM (Multiple Mechs)
        // ============================================
        const MECH_TEMPLATES = {
            scout: {
                id: 'scout',
                name: 'Scout Frame',
                class: 'Light',
                icon: 'üèÉ',
                tonnage: 35,           // Low weight capacity
                modSpace: 12,          // Grid cells available
                growthCapacity: 3,     // Max upgrades
                baseHP: 80,
                baseArmor: 5,
                baseSpeed: 1.3,
                baseAccuracy: 70,
                specialAbility: 'EVASION',  // 15% dodge chance
                specialDesc: '+15% Evasion',
                price: 0,  // Starting mech (free)
                rarity: 'common',
                slots: {
                    torso: { cols: 2, rows: 2 },
                    leftArm: { cols: 1, rows: 3 },
                    rightArm: { cols: 1, rows: 3 },
                    leftLeg: { cols: 1, rows: 2 },
                    rightLeg: { cols: 1, rows: 2 }
                }
            },
            warrior: {
                id: 'warrior',
                name: 'Warrior Frame',
                class: 'Medium',
                icon: '‚öîÔ∏è',
                tonnage: 55,
                modSpace: 18,
                growthCapacity: 4,
                baseHP: 120,
                baseArmor: 10,
                baseSpeed: 1.0,
                baseAccuracy: 65,
                specialAbility: 'FOCUS_FIRE',  // +10% damage to same target
                specialDesc: '+10% Damage Focus',
                price: 8,
                rarity: 'uncommon',
                slots: {
                    torso: { cols: 2, rows: 2 },
                    leftArm: { cols: 2, rows: 3 },
                    rightArm: { cols: 2, rows: 3 },
                    leftLeg: { cols: 2, rows: 2 },
                    rightLeg: { cols: 2, rows: 2 }
                }
            },
            titan: {
                id: 'titan',
                name: 'Titan Frame',
                class: 'Heavy',
                icon: 'üõ°Ô∏è',
                tonnage: 80,
                modSpace: 24,
                growthCapacity: 5,
                baseHP: 180,
                baseArmor: 20,
                baseSpeed: 0.7,
                baseAccuracy: 55,
                specialAbility: 'FORTIFY',  // +25% armor when stationary
                specialDesc: '+25% Armor (Stationary)',
                price: 15,
                rarity: 'rare',
                slots: {
                    torso: { cols: 3, rows: 3 },
                    leftArm: { cols: 2, rows: 4 },
                    rightArm: { cols: 2, rows: 4 },
                    leftLeg: { cols: 2, rows: 3 },
                    rightLeg: { cols: 2, rows: 3 }
                }
            },
            striker: {
                id: 'striker',
                name: 'Striker Frame',
                class: 'Medium',
                icon: '‚ö°',
                tonnage: 45,
                modSpace: 16,
                growthCapacity: 4,
                baseHP: 100,
                baseArmor: 8,
                baseSpeed: 1.2,
                baseAccuracy: 75,
                specialAbility: 'FIRST_STRIKE',  // Attack first, +20% first attack damage
                specialDesc: '+20% First Attack',
                price: 12,
                rarity: 'rare',
                slots: {
                    torso: { cols: 2, rows: 2 },
                    leftArm: { cols: 2, rows: 4 },
                    rightArm: { cols: 2, rows: 4 },
                    leftLeg: { cols: 1, rows: 2 },
                    rightLeg: { cols: 1, rows: 2 }
                }
            },
            juggernaut: {
                id: 'juggernaut',
                name: 'Juggernaut Frame',
                class: 'Assault',
                icon: 'üíÄ',
                tonnage: 100,
                modSpace: 30,
                growthCapacity: 6,
                baseHP: 250,
                baseArmor: 30,
                baseSpeed: 0.5,
                baseAccuracy: 50,
                specialAbility: 'UNSTOPPABLE',  // Immune to knockback, +50% knockback dealt
                specialDesc: 'Immune to KB, +50% KB',
                price: 25,
                rarity: 'epic',
                slots: {
                    torso: { cols: 4, rows: 3 },
                    leftArm: { cols: 2, rows: 5 },
                    rightArm: { cols: 2, rows: 5 },
                    leftLeg: { cols: 2, rows: 3 },
                    rightLeg: { cols: 2, rows: 3 }
                }
            },
            phantom: {
                id: 'phantom',
                name: 'Phantom Frame',
                class: 'Light',
                icon: 'üëª',
                tonnage: 30,
                modSpace: 10,
                growthCapacity: 3,
                baseHP: 60,
                baseArmor: 0,
                baseSpeed: 1.5,
                baseAccuracy: 80,
                specialAbility: 'CLOAK',  // 30% miss chance against this mech
                specialDesc: '30% Enemy Miss Chance',
                price: 18,
                rarity: 'epic',
                slots: {
                    torso: { cols: 2, rows: 2 },
                    leftArm: { cols: 1, rows: 2 },
                    rightArm: { cols: 1, rows: 2 },
                    leftLeg: { cols: 1, rows: 2 },
                    rightLeg: { cols: 1, rows: 2 }
                }
            },
            berserker: {
                id: 'berserker',
                name: 'Berserker Frame',
                class: 'Medium',
                icon: 'üî•',
                tonnage: 50,
                modSpace: 14,
                growthCapacity: 4,
                baseHP: 90,
                baseArmor: 5,
                baseSpeed: 1.1,
                baseAccuracy: 60,
                specialAbility: 'RAGE',  // +2% damage per 1% HP missing
                specialDesc: '+2% DMG per 1% HP Lost',
                price: 20,
                rarity: 'epic',
                slots: {
                    torso: { cols: 2, rows: 2 },
                    leftArm: { cols: 2, rows: 3 },
                    rightArm: { cols: 2, rows: 3 },
                    leftLeg: { cols: 1, rows: 2 },
                    rightLeg: { cols: 1, rows: 2 }
                }
            }
        };

        // Player's owned mechs
        let ownedMechs = ['scout'];  // Start with scout

        // Currently selected mech for battle
        let activeMechId = 'scout';

        // Get active mech template
        function getActiveMech() {
            return MECH_TEMPLATES[activeMechId] || MECH_TEMPLATES.scout;
        }

        // ============================================
        // BACKPACK / INVENTORY SYSTEM
        // ============================================
        const BACKPACK = {
            maxSlots: 12,              // Starting backpack size
            upgradeSlots: 3,           // Slots added per upgrade
            upgradeCost: 10,           // Gold to upgrade backpack
            maxUpgrades: 4             // Max 4 upgrades (12 + 12 = 24 slots max)
        };

        let backpack = {
            items: [],         // Array of item IDs owned
            slots: BACKPACK.maxSlots,
            upgrades: 0
        };

        // Add item to backpack
        function addToBackpack(itemId) {
            if (backpack.items.length >= backpack.slots) {
                return { success: false, reason: 'Backpack full!' };
            }
            backpack.items.push(itemId);
            return { success: true };
        }

        // Remove item from backpack
        function removeFromBackpack(itemId) {
            const index = backpack.items.indexOf(itemId);
            if (index > -1) {
                backpack.items.splice(index, 1);
                return true;
            }
            return false;
        }

        // Sell item from backpack
        function sellItem(itemId) {
            const item = ITEM_DATABASE[itemId];
            if (!item) return { success: false, reason: 'Item not found' };

            // Calculate sell price
            const basePrice = item.type === 'WEAPON' ?
                ECONOMY.weaponPrices[item.rarity || 'common'] :
                ECONOMY.weaponPrices[item.rarity || 'common'];
            const sellPrice = Math.floor(basePrice * ECONOMY.sellMultiplier);

            if (removeFromBackpack(itemId)) {
                playerResources.gold += sellPrice;
                return { success: true, gold: sellPrice };
            }
            return { success: false, reason: 'Item not in backpack' };
        }

        // Upgrade backpack
        function upgradeBackpack() {
            if (backpack.upgrades >= BACKPACK.maxUpgrades) {
                return { success: false, reason: 'Max upgrades reached' };
            }
            if (playerResources.gold < BACKPACK.upgradeCost) {
                return { success: false, reason: 'Not enough gold' };
            }
            playerResources.gold -= BACKPACK.upgradeCost;
            backpack.upgrades++;
            backpack.slots += BACKPACK.upgradeSlots;
            return { success: true, newSlots: backpack.slots };
        }

        // ============================================
        // SHOP SYSTEM
        // ============================================
        const SHOP = {
            mechSlots: 2,      // Number of mechs in shop
            weaponSlots: 4,    // Number of weapons in shop
            bargainChance: 0.15 // 15% chance for bargain
        };

        let shopInventory = {
            mechs: [],      // Array of mech IDs available
            weapons: [],    // Array of weapon objects { itemId, isBargain, price }
            refreshes: 0    // Free refreshes used this round
        };

        // Generate shop inventory
        function generateShopInventory() {
            shopInventory.mechs = [];
            shopInventory.weapons = [];
            shopInventory.refreshes = 0;

            // Generate mech offerings based on round
            const availableMechs = Object.keys(MECH_TEMPLATES).filter(id => {
                const mech = MECH_TEMPLATES[id];
                // Don't offer mechs player already owns
                if (ownedMechs.includes(id)) return false;
                // Rarer mechs appear in later rounds
                if (mech.rarity === 'epic' && gameProgression.round < 5) return false;
                if (mech.rarity === 'legendary' && gameProgression.round < 8) return false;
                return true;
            });

            // Pick random mechs for shop
            const shuffledMechs = [...availableMechs].sort(() => Math.random() - 0.5);
            shopInventory.mechs = shuffledMechs.slice(0, SHOP.mechSlots);

            // Generate weapon offerings
            const weaponTemplates = Object.keys(ITEM_TEMPLATES).filter(key => {
                return ITEM_TEMPLATES[key].type === 'WEAPON';
            });

            for (let i = 0; i < SHOP.weaponSlots; i++) {
                const templateType = weaponTemplates[Math.floor(Math.random() * weaponTemplates.length)];
                const rarity = getShopWeaponRarity();
                const level = Math.max(1, Math.floor(gameProgression.round / 3) + 1);
                const weapon = generateComponent(templateType, level, rarity);

                if (weapon) {
                    registerGeneratedComponent(weapon);

                    const isBargain = Math.random() < SHOP.bargainChance;
                    const basePrice = ECONOMY.weaponPrices[rarity] || 5;
                    const price = isBargain ?
                        Math.floor(basePrice * ECONOMY.bargainDiscount) :
                        basePrice;

                    shopInventory.weapons.push({
                        itemId: weapon.id,
                        isBargain: isBargain,
                        price: price,
                        originalPrice: basePrice
                    });
                }
            }
        }

        // Get weapon rarity based on round (better items later)
        function getShopWeaponRarity() {
            const round = gameProgression.round;
            const rand = Math.random();

            // Rarity chances improve with rounds
            const legendaryChance = Math.min(0.02 + round * 0.01, 0.15);
            const epicChance = Math.min(0.05 + round * 0.02, 0.25);
            const rareChance = Math.min(0.15 + round * 0.03, 0.35);
            const uncommonChance = 0.30;

            if (rand < legendaryChance) return 'legendary';
            if (rand < legendaryChance + epicChance) return 'epic';
            if (rand < legendaryChance + epicChance + rareChance) return 'rare';
            if (rand < legendaryChance + epicChance + rareChance + uncommonChance) return 'uncommon';
            return 'common';
        }

        // Buy mech from shop
        function buyMech(mechId) {
            const mech = MECH_TEMPLATES[mechId];
            if (!mech) return { success: false, reason: 'Mech not found' };
            if (ownedMechs.includes(mechId)) return { success: false, reason: 'Already owned' };
            if (playerResources.gold < mech.price) return { success: false, reason: 'Not enough gold' };

            playerResources.gold -= mech.price;
            ownedMechs.push(mechId);

            // Remove from shop
            const idx = shopInventory.mechs.indexOf(mechId);
            if (idx > -1) shopInventory.mechs.splice(idx, 1);

            return { success: true };
        }

        // Buy weapon from shop
        function buyWeapon(shopIndex) {
            if (shopIndex < 0 || shopIndex >= shopInventory.weapons.length) {
                return { success: false, reason: 'Invalid shop index' };
            }

            const shopItem = shopInventory.weapons[shopIndex];
            if (playerResources.gold < shopItem.price) {
                return { success: false, reason: 'Not enough gold' };
            }

            const result = addToBackpack(shopItem.itemId);
            if (!result.success) return result;

            playerResources.gold -= shopItem.price;

            // Remove from shop
            shopInventory.weapons.splice(shopIndex, 1);

            return { success: true };
        }

        // Refresh shop
        function refreshShop() {
            if (playerResources.gold < ECONOMY.shopRefreshCost) {
                return { success: false, reason: 'Not enough gold' };
            }
            playerResources.gold -= ECONOMY.shopRefreshCost;
            generateShopInventory();
            return { success: true };
        }

        // Loadout state (items placed on mech)
        let loadoutState = {
            mechId: MECH_CHASSIS.id,
            equipment: []  // Array of { itemId, instanceId, position: {x, y}, rotation }
        };

        // Track locked items (cannot be moved this round - e.g. heat sinks after placement)
        let lockedItems = new Set();

        // Unified grid occupation tracking (single mech-shaped grid)
        let unifiedGridOccupation = null;  // InventoryGrid instance for the unified mech grid
        let gridElements = {};  // For backwards compat - now just stores the unified grid element

        // ============================================
        // 2D GRID DATA STRUCTURE CLASS (Supports mech-shaped grids)
        // ============================================
        class MechGrid {
            constructor(cols, rows, shapeMatrix) {
                this.cols = cols;
                this.rows = rows;
                this.shapeMatrix = shapeMatrix;  // 2D array where 1=valid cell, 0=invalid
                this.cells = [];
                for (let y = 0; y < rows; y++) {
                    this.cells[y] = [];
                    for (let x = 0; x < cols; x++) {
                        // Use 'invalid' for cells outside the mech shape, null for empty valid cells
                        this.cells[y][x] = shapeMatrix[y][x] === 1 ? null : 'invalid';
                    }
                }
            }

            isValidCell(x, y) {
                if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) return false;
                return this.shapeMatrix[y][x] === 1;
            }

            canPlaceItem(item, posX, posY) {
                const shape = item.gridShape;
                const h = shape.length;
                const w = shape[0].length;

                // Check each cell of the shape
                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        if (shape[dy][dx] === 1) {
                            const cellX = posX + dx;
                            const cellY = posY + dy;
                            // Check if position is valid in mech shape
                            if (!this.isValidCell(cellX, cellY)) {
                                return false;
                            }
                            // Check if cell is occupied
                            if (this.cells[cellY][cellX] !== null) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            placeItem(item, posX, posY, instanceId) {
                const shape = item.gridShape;
                const h = shape.length;
                const w = shape[0].length;

                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        if (shape[dy][dx] === 1) {
                            this.cells[posY + dy][posX + dx] = instanceId;
                        }
                    }
                }
            }

            removeItem(instanceId) {
                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        if (this.cells[y][x] === instanceId) {
                            this.cells[y][x] = null;
                        }
                    }
                }
            }

            isCellOccupied(x, y) {
                if (!this.isValidCell(x, y)) return true;
                return this.cells[y][x] !== null;
            }
        }

        // Initialize the unified mech grid
        function initializeGrids() {
            unifiedGridOccupation = new MechGrid(
                MECH_CHASSIS.gridCols,
                MECH_CHASSIS.gridRows,
                MECH_CHASSIS.gridShape
            );
        }

        // ============================================
        // ITEM MANAGEMENT (NO DECK - PERSISTENT BENCH)
        // ============================================

        // Shuffle an array in place
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // Add an item to the bench
        function addItemToBench(itemId, instanceId = null) {
            const item = ITEM_DATABASE[itemId];
            if (!item) return null;

            const newItem = {
                ...item,
                instanceId: instanceId || `item_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
            };
            benchItems.push(newItem);
            return newItem;
        }

        // Remove an item from the bench by instanceId
        function removeItemFromBench(instanceId) {
            const idx = benchItems.findIndex(item => item.instanceId === instanceId);
            if (idx !== -1) {
                return benchItems.splice(idx, 1)[0];
            }
            return null;
        }

        // Get item from bench by instanceId
        function getBenchItem(instanceId) {
            return benchItems.find(item => item.instanceId === instanceId);
        }

        // Rotate an item's gridShape 90 degrees clockwise
        function rotateItemShape(item) {
            const shape = item.gridShape;
            const rows = shape.length;
            const cols = shape[0].length;

            // Create new rotated shape (swap dimensions)
            const newShape = [];
            for (let x = 0; x < cols; x++) {
                newShape[x] = [];
                for (let y = rows - 1; y >= 0; y--) {
                    newShape[x][rows - 1 - y] = shape[y][x];
                }
            }

            // Update item
            item.gridShape = newShape;
            item.gridDimensions = { w: rows, h: cols };  // Swap dimensions

            // Re-render bench to show updated shape
            renderBench();
        }

        // ============================================
        // DRAG & DROP SYSTEM
        // ============================================
        let dragState = {
            isDragging: false,
            item: null,
            sourceType: null,  // 'bench' or 'grid'
            sourceSlot: null,
            sourcePosition: null,
            startX: 0,
            startY: 0
        };

        let placedItemElements = {};  // Store references to placed item DOM elements

        function initDragAndDrop() {
            const dragGhost = document.getElementById('dragGhost');

            // Touch/Mouse event handlers
            document.addEventListener('mousedown', handleDragStart);
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);

            document.addEventListener('touchstart', handleDragStart, { passive: false });
            document.addEventListener('touchmove', handleDragMove, { passive: false });
            document.addEventListener('touchend', handleDragEnd);
        }

        function handleDragStart(e) {
            const touch = e.touches ? e.touches[0] : e;
            const target = document.elementFromPoint(touch.clientX, touch.clientY);

            // Skip if clicking on rotate button
            if (target.closest('.rotate-btn')) {
                return;  // Let the rotate button handle its own click
            }

            // Check if we clicked on a bench item (supports both old and new class names)
            const benchItem = target.closest('.bench-item-vertical') || target.closest('.bench-item');
            if (benchItem) {
                e.preventDefault();
                const instanceId = benchItem.dataset.instanceId;
                const item = benchItems.find(i => i.instanceId === instanceId);
                if (item) {
                    startDrag(item, 'bench', null, null, touch.clientX, touch.clientY);
                    benchItem.classList.add('dragging');
                }
                return;
            }

            // Check if we clicked on a placed item (unified grid)
            const placedItem = target.closest('.placed-item-unified');
            if (placedItem) {
                e.preventDefault();
                const instanceId = placedItem.dataset.instanceId;

                // Check if item is locked (e.g., heat sink after placement)
                if (lockedItems.has(instanceId)) {
                    return;  // Cannot drag locked items
                }

                const equipment = loadoutState.equipment.find(eq => eq.instanceId === instanceId);
                if (equipment) {
                    const item = equipment.item || { ...ITEM_DATABASE[equipment.itemId], instanceId };
                    startDrag(item, 'grid', null, equipment.position, touch.clientX, touch.clientY);

                    // Remove from grid temporarily
                    removeItemFromGrid(instanceId);
                    placedItem.style.opacity = '0.3';
                }
                return;
            }
        }

        function startDrag(item, sourceType, sourceSlot, sourcePosition, x, y) {
            dragState = {
                isDragging: true,
                item: item,
                sourceType: sourceType,
                sourceSlot: sourceSlot,
                sourcePosition: sourcePosition,
                startX: x,
                startY: y
            };

            // Create ghost element
            const ghost = document.getElementById('dragGhost');
            ghost.innerHTML = createGhostHTML(item);
            ghost.style.display = 'block';
            ghost.style.left = x + 'px';
            ghost.style.top = y + 'px';

            // Highlight which grids are valid for this item
            updateSlotValidity(item);
        }

        function updateSlotValidity(item) {
            // With unified grid, all valid cells can accept any item
            // No slot-specific highlighting needed
        }

        function createGhostHTML(item) {
            const shape = item.gridShape;
            const h = shape.length;
            const w = shape[0].length;

            let cellsHTML = '';
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    if (shape[y][x] === 1) {
                        cellsHTML += '<div class="ghost-cell"></div>';
                    }
                }
            }

            return `<div class="ghost-grid" style="grid-template-columns: repeat(${w}, 38px);">${cellsHTML}</div>`;
        }

        function handleDragMove(e) {
            if (!dragState.isDragging) return;
            e.preventDefault();

            const touch = e.touches ? e.touches[0] : e;
            const ghost = document.getElementById('dragGhost');
            ghost.style.left = touch.clientX + 'px';
            ghost.style.top = touch.clientY + 'px';

            // Check for valid drop target
            const dropInfo = getDropTarget(touch.clientX, touch.clientY);
            updateDropHighlight(dropInfo);

            // Check if over bench (for items from grid)
            const benchPanel = document.getElementById('benchPanel');
            let overBench = false;
            if (benchPanel) {
                const benchRect = benchPanel.getBoundingClientRect();
                overBench = dragState.sourceType === 'grid' &&
                            touch.clientX >= benchRect.left &&
                            touch.clientX <= benchRect.right &&
                            touch.clientY >= benchRect.top &&
                            touch.clientY <= benchRect.bottom;

                if (overBench) {
                    benchPanel.classList.add('drop-target');
                    ghost.classList.remove('invalid');
                } else {
                    benchPanel.classList.remove('drop-target');
                }
            }

            // Update ghost validity
            if (dropInfo && dropInfo.valid) {
                ghost.classList.remove('invalid');
            } else if (dropInfo && !overBench) {
                ghost.classList.add('invalid');
            }
        }

        function handleDragEnd(e) {
            if (!dragState.isDragging) return;

            const touch = e.changedTouches ? e.changedTouches[0] : e;
            const dropInfo = getDropTarget(touch.clientX, touch.clientY);

            // Check if dropped on bench panel area
            const benchPanel = document.getElementById('benchPanel');
            let droppedOnBench = false;
            if (benchPanel) {
                const benchRect = benchPanel.getBoundingClientRect();
                droppedOnBench = touch.clientX >= benchRect.left &&
                                 touch.clientX <= benchRect.right &&
                                 touch.clientY >= benchRect.top &&
                                 touch.clientY <= benchRect.bottom;
            }

            if (dropInfo && dropInfo.valid) {
                // Place item on grid
                placeItemOnGrid(dragState.item, dropInfo.gridX, dropInfo.gridY);

                // Remove from bench if it came from there
                if (dragState.sourceType === 'bench') {
                    removeItemFromBench(dragState.item.instanceId);
                }
            } else if (droppedOnBench && dragState.sourceType === 'grid') {
                // Return item to bench
                benchItems.push(dragState.item);
            } else if (dragState.sourceType === 'grid') {
                // Return to original position on grid
                placeItemOnGrid(
                    dragState.item,
                    dragState.sourcePosition.x,
                    dragState.sourcePosition.y
                );
            }

            // Cleanup
            cleanupDrag();
            renderBench();
            renderUnifiedGridItems();
            updateStats();
        }

        function cleanupDrag() {
            document.querySelectorAll('.bench-item-vertical.dragging').forEach(el => el.classList.remove('dragging'));
            document.querySelectorAll('.placed-item-unified').forEach(el => el.style.opacity = '1');
            document.querySelectorAll('.mech-cell').forEach(el => {
                el.classList.remove('valid-drop', 'invalid-drop');
            });
            const benchPanel = document.getElementById('benchPanel');
            if (benchPanel) benchPanel.classList.remove('drop-target');

            const ghost = document.getElementById('dragGhost');
            ghost.style.display = 'none';
            ghost.classList.remove('invalid');

            dragState = {
                isDragging: false,
                item: null,
                sourceType: null,
                sourceSlot: null,
                sourcePosition: null,
                startX: 0,
                startY: 0
            };
        }

        function getDropTarget(clientX, clientY) {
            if (!dragState.item) return null;

            // Check the unified mech grid
            const gridEl = document.getElementById('unifiedMechGrid');
            if (!gridEl) return null;

            const rect = gridEl.getBoundingClientRect();

            if (clientX >= rect.left && clientX <= rect.right &&
                clientY >= rect.top && clientY <= rect.bottom) {

                // Calculate grid cell position
                const cellSize = 47;  // 45px + 2px gap
                const padding = 10;
                const localX = clientX - rect.left - padding;
                const localY = clientY - rect.top - padding;

                const item = dragState.item;
                const shape = item.gridShape;
                const itemW = shape[0].length;
                const itemH = shape.length;

                // Calculate the cell the cursor is over
                const cursorCellX = Math.floor(localX / cellSize);
                const cursorCellY = Math.floor(localY / cellSize);

                // Find the best position for the item nearest to cursor
                const bestPos = findBestPosition(unifiedGridOccupation, item, cursorCellX, cursorCellY);

                if (bestPos) {
                    return {
                        gridX: bestPos.x,
                        gridY: bestPos.y,
                        valid: true
                    };
                } else {
                    // No valid position, show where cursor would place it (clamped)
                    let gridX = cursorCellX - Math.floor(itemW / 2);
                    let gridY = cursorCellY - Math.floor(itemH / 2);
                    gridX = Math.max(0, Math.min(gridX, MECH_CHASSIS.gridCols - itemW));
                    gridY = Math.max(0, Math.min(gridY, MECH_CHASSIS.gridRows - itemH));

                    return {
                        gridX: gridX,
                        gridY: gridY,
                        valid: false
                    };
                }
            }

            return null;
        }

        function findBestPosition(grid, item, cursorX, cursorY) {
            const itemW = item.gridShape[0].length;
            const itemH = item.gridShape.length;

            // Centered position
            const centerX = cursorX - Math.floor(itemW / 2);
            const centerY = cursorY - Math.floor(itemH / 2);

            // Search in expanding rings around cursor
            const maxRadius = Math.max(MECH_CHASSIS.gridCols, MECH_CHASSIS.gridRows);
            for (let radius = 0; radius <= maxRadius; radius++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        if (radius > 0 && Math.abs(dx) !== radius && Math.abs(dy) !== radius) continue;

                        const testX = centerX + dx;
                        const testY = centerY + dy;

                        // Check bounds
                        if (testX < 0 || testY < 0 ||
                            testX + itemW > MECH_CHASSIS.gridCols ||
                            testY + itemH > MECH_CHASSIS.gridRows) continue;

                        // Check if can place
                        if (grid && grid.canPlaceItem(item, testX, testY)) {
                            return { x: testX, y: testY };
                        }
                    }
                }
            }

            return null;  // No valid position found
        }

        function updateDropHighlight(dropInfo) {
            // Clear all highlights
            document.querySelectorAll('.mech-cell').forEach(el => {
                el.classList.remove('valid-drop', 'invalid-drop');
            });

            if (!dropInfo || !dragState.item) return;

            const gridEl = document.getElementById('unifiedMechGrid');
            if (!gridEl) return;

            const item = dragState.item;
            const shape = item.gridShape;
            const cells = gridEl.querySelectorAll('.mech-cell');

            // Highlight cells that would be covered
            for (let dy = 0; dy < shape.length; dy++) {
                for (let dx = 0; dx < shape[0].length; dx++) {
                    if (shape[dy][dx] === 1) {
                        const cellX = dropInfo.gridX + dx;
                        const cellY = dropInfo.gridY + dy;

                        // Check bounds before calculating index
                        if (cellX < 0 || cellX >= MECH_CHASSIS.gridCols || cellY < 0 || cellY >= MECH_CHASSIS.gridRows) {
                            continue;  // Skip out-of-bounds cells
                        }

                        const cellIdx = cellY * MECH_CHASSIS.gridCols + cellX;

                        if (cellIdx >= 0 && cellIdx < cells.length) {
                            cells[cellIdx].classList.add(dropInfo.valid ? 'valid-drop' : 'invalid-drop');
                        }
                    }
                }
            }
        }

        function placeItemOnGrid(item, gridX, gridY) {
            const instanceId = item.instanceId;
            const itemDef = item;

            // Add to loadout state
            loadoutState.equipment.push({
                instanceId: instanceId,
                itemId: item.id || item.itemId,
                item: item,  // Store full item data
                position: { x: gridX, y: gridY },
                rotation: 0
            });

            // Mark grid cells as occupied
            unifiedGridOccupation.placeItem(item, gridX, gridY, instanceId);

            // Handle special placement effects
            if (itemDef && itemDef.special) {
                // Lock the item so it cannot be moved this round
                if (itemDef.special.locksOnPlace) {
                    lockedItems.add(instanceId);
                }
            }
        }

        function removeItemFromGrid(instanceId) {
            // Find the equipment entry
            const equipment = loadoutState.equipment.find(eq => eq.instanceId === instanceId);

            // Remove from loadout
            const idx = loadoutState.equipment.findIndex(eq => eq.instanceId === instanceId);
            if (idx !== -1) {
                loadoutState.equipment.splice(idx, 1);
            }

            // Clear grid cells
            unifiedGridOccupation.removeItem(instanceId);

            return equipment;  // Return for re-adding to bench
        }

        // Click to remove placed item
        function handlePlacedItemClick(instanceId) {
            // Check if item is locked (e.g., heat sink after placement)
            if (lockedItems.has(instanceId)) {
                return;  // Cannot remove locked items
            }

            const equipment = loadoutState.equipment.find(eq => eq.instanceId === instanceId);
            if (!equipment) return;

            const item = equipment.item || { ...ITEM_DATABASE[equipment.itemId], instanceId };

            // Remove from grid
            removeItemFromGrid(instanceId);

            // Add back to bench
            benchItems.push(item);

            renderBench();
            renderUnifiedGridItems();
            updateStats();
        }

        // ============================================
        // UI RENDERING
        // ============================================
        function renderBench() {
            const benchScroll = document.getElementById('benchScroll');
            const benchEmpty = document.getElementById('benchEmpty');
            if (!benchScroll) return;

            benchScroll.innerHTML = '';

            if (benchItems.length === 0) {
                if (benchEmpty) benchEmpty.style.display = 'block';
                return;
            }

            if (benchEmpty) benchEmpty.style.display = 'none';

            benchItems.forEach(item => {
                const el = document.createElement('div');
                el.className = `bench-item-vertical ${item.category}`;
                el.dataset.instanceId = item.instanceId;

                // Get rarity color for generated items
                const isGenerated = item.isGenerated;
                const rarityColor = isGenerated ? (COMPONENT_GENERATION.rarityColors[item.rarity] || '#00ff88') : '#00ff88';

                // Apply rarity border color
                if (isGenerated) {
                    el.style.borderColor = rarityColor;
                }

                // Build stats string
                let statsStr = '';
                if (item.stats.damage) statsStr += `${item.stats.damage} DMG `;
                if (item.stats.armorBonus) statsStr += `+${item.stats.armorBonus} Armor `;
                if (item.stats.energyDraw < 0) statsStr += `+${-item.stats.energyDraw} Energy `;

                el.innerHTML = `
                    <span class="item-icon">${item.icon}</span>
                    <div class="item-info">
                        <div class="item-name" style="${isGenerated ? `color: ${rarityColor};` : ''}">${item.name}</div>
                        <div class="item-stats">${statsStr || 'W:' + item.stats.weight}</div>
                    </div>
                `;

                // Make draggable
                el.addEventListener('mousedown', (e) => handleDragStart(e, item, 'bench'));
                el.addEventListener('touchstart', (e) => handleDragStart(e, item, 'bench'), { passive: false });

                benchScroll.appendChild(el);
            });
        }

        // Render the unified mech-shaped grid
        function renderUnifiedMechGrid() {
            const container = document.getElementById('unifiedMechGrid');
            if (!container) return;

            container.innerHTML = '';
            container.style.gridTemplateColumns = `repeat(${MECH_CHASSIS.gridCols}, 45px)`;

            // Create cells for the mech grid
            for (let y = 0; y < MECH_CHASSIS.gridRows; y++) {
                for (let x = 0; x < MECH_CHASSIS.gridCols; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'mech-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;

                    // Mark invalid cells (not part of mech shape)
                    if (MECH_CHASSIS.gridShape[y][x] === 0) {
                        cell.classList.add('invalid');
                    }

                    container.appendChild(cell);
                }
            }

            // Store reference
            gridElements.unified = container;
        }

        // Render placed items on the unified grid
        function renderUnifiedGridItems() {
            // Remove old placed items
            document.querySelectorAll('.placed-item-unified').forEach(el => el.remove());

            const container = document.getElementById('unifiedMechGrid');
            if (!container || !unifiedGridOccupation) return;

            const cellSize = 45;
            const gap = 2;

            // Update cell states (occupied highlighting)
            const cells = container.querySelectorAll('.mech-cell');
            cells.forEach(cell => {
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                if (unifiedGridOccupation.isValidCell(x, y)) {
                    cell.classList.toggle('occupied', unifiedGridOccupation.cells[y][x] !== null);
                }
            });

            // Render placed items
            loadoutState.equipment.forEach(eq => {
                const item = eq.item || ITEM_DATABASE[eq.itemId];
                if (!item) return;

                const shape = item.gridShape;
                const w = shape[0].length;
                const h = shape.length;

                const placedEl = document.createElement('div');
                placedEl.className = `placed-item-unified ${item.category}`;
                placedEl.dataset.instanceId = eq.instanceId;
                placedEl.innerHTML = item.icon;

                // Position based on grid cell
                placedEl.style.position = 'absolute';
                placedEl.style.left = `${10 + eq.position.x * (cellSize + gap)}px`;
                placedEl.style.top = `${10 + eq.position.y * (cellSize + gap)}px`;
                placedEl.style.width = `${w * cellSize + (w - 1) * gap}px`;
                placedEl.style.height = `${h * cellSize + (h - 1) * gap}px`;

                // Make draggable (to move or remove)
                placedEl.addEventListener('mousedown', (e) => handleDragStart(e, { ...item, instanceId: eq.instanceId }, 'grid'));
                placedEl.addEventListener('touchstart', (e) => handleDragStart(e, { ...item, instanceId: eq.instanceId }, 'grid'), { passive: false });

                container.appendChild(placedEl);
            });
        }

        // ============================================
        // TAB SWITCHING & MOBILE LAYOUT
        // ============================================
        let currentTab = 'loadout';
        let isMobileLayout = false;

        function switchTab(tabName) {
            currentTab = tabName;

            // Update header title
            const gameTitle = document.getElementById('gameTitle');
            const goToMissionsBtn = document.getElementById('goToMissionsBtn');
            const goToShopBtn = document.getElementById('goToShopBtn');
            const goToBackpackBtn = document.getElementById('goToBackpackBtn');

            // Hide all nav buttons in header by default
            const headerBtns = [goToMissionsBtn, goToShopBtn, goToBackpackBtn];

            if (tabName === 'loadout') {
                gameTitle.textContent = 'Loadout';
                headerBtns.forEach(btn => { if (btn) btn.style.display = ''; });
            } else if (tabName === 'mission') {
                gameTitle.textContent = 'Missions';
                headerBtns.forEach(btn => { if (btn) btn.style.display = 'none'; });
            } else if (tabName === 'shop') {
                gameTitle.textContent = 'Shop';
                headerBtns.forEach(btn => { if (btn) btn.style.display = 'none'; });
            } else if (tabName === 'backpack') {
                gameTitle.textContent = 'Backpack';
                headerBtns.forEach(btn => { if (btn) btn.style.display = 'none'; });
            }

            // Update tab content visibility
            const loadoutTab = document.getElementById('loadoutTab');
            const missionTab = document.getElementById('missionTab');
            const shopTab = document.getElementById('shopTab');
            const backpackTab = document.getElementById('backpackTab');

            const allTabs = [loadoutTab, missionTab, shopTab, backpackTab];
            allTabs.forEach(tab => { if (tab) tab.classList.remove('active'); });

            if (tabName === 'loadout' && loadoutTab) {
                loadoutTab.classList.add('active');
                updateHeaderDisplay();
            } else if (tabName === 'mission' && missionTab) {
                missionTab.classList.add('active');
                renderMissionTab();
            } else if (tabName === 'shop' && shopTab) {
                shopTab.classList.add('active');
                renderShop();
            } else if (tabName === 'backpack' && backpackTab) {
                backpackTab.classList.add('active');
                renderBackpack();
            }
        }

        function checkMobileLayout() {
            // Layout is now consistent across all screen sizes
            // This function is kept for resize handling
            isMobileLayout = window.innerWidth <= 768;
        }

        function startBattleFromMission() {
            if (selectedMission) {
                startBattle();
            }
        }

        // Render missions for mobile tab
        function renderMissionTab() {
            const missionTabList = document.getElementById('missionTabList');
            if (!missionTabList) return;

            missionTabList.innerHTML = '';

            for (const mission of Object.values(MISSIONS)) {
                const card = document.createElement('div');
                card.className = `mission-card ${mission.difficulty.toLowerCase()}`;
                card.dataset.missionId = mission.id;

                if (selectedMission === mission.id) {
                    card.classList.add('selected');
                }

                const enemy = mission.enemyMechs[0];
                let equipmentHTML = '';
                enemy.equipment.forEach(eq => {
                    const item = ITEM_DATABASE[eq.itemId];
                    if (item) {
                        equipmentHTML += `<div>${item.icon} ${item.name}</div>`;
                    }
                });

                card.innerHTML = `
                    <div class="mission-card-header">
                        <span class="mission-name">${mission.name}</span>
                        <span class="mission-difficulty ${mission.difficulty.toLowerCase()}">${mission.difficulty}</span>
                    </div>
                    <div class="mission-desc">${mission.description}</div>
                    <div class="mission-details">
                        <div class="mission-reward">
                            <span>üí∞ ${mission.reward.credits} Credits</span>
                            <span>‚≠ê ${mission.reward.xp} XP</span>
                        </div>
                        <div class="mission-enemy">
                            <div class="mission-enemy-name">‚ö†Ô∏è ${enemy.name}</div>
                            <div>HP: ${enemy.maxHealth} | DMG: ${enemy.stats.damage}</div>
                        </div>
                    </div>
                `;

                card.addEventListener('click', () => {
                    selectMission(mission.id);
                    renderMissionTab();
                });
                missionTabList.appendChild(card);
            }

            // Update continue button state
            const continueBtn = document.getElementById('missionContinueBtn');
            if (continueBtn) {
                continueBtn.disabled = !selectedMission || loadoutState.equipment.length === 0;
            }
        }

        function renderMissions() {
            const missionList = document.getElementById('missionList');
            if (!missionList) return;  // Mission list may not exist in new layout
            missionList.innerHTML = '';

            for (const mission of Object.values(MISSIONS)) {
                const card = document.createElement('div');
                card.className = `mission-card ${mission.difficulty.toLowerCase()}`;
                card.dataset.missionId = mission.id;

                if (selectedMission === mission.id) {
                    card.classList.add('selected');
                }

                // Build enemies info for display
                const enemyCount = mission.enemyMechs.length;
                const avgLevel = mission.averageLevel || mission.enemyMechs[0].level || 1;

                // Build enemy summary for card
                let enemySummary = '';
                if (enemyCount === 1) {
                    const enemy = mission.enemyMechs[0];
                    enemySummary = `<span style="color: #ff6666;">‚öîÔ∏è Lv.${enemy.level} ${enemy.name}</span>`;
                } else {
                    const levels = mission.enemyMechs.map(e => e.level);
                    const minLv = Math.min(...levels);
                    const maxLv = Math.max(...levels);
                    const lvRange = minLv === maxLv ? `Lv.${minLv}` : `Lv.${minLv}-${maxLv}`;
                    enemySummary = `<span style="color: #ff6666;">‚öîÔ∏è ${enemyCount}x Enemies (${lvRange})</span>`;
                }

                // Build detailed enemy tooltip
                let enemiesHTML = '';
                mission.enemyMechs.forEach((enemy, idx) => {
                    let equipmentHTML = '';
                    enemy.equipment.forEach(eq => {
                        const item = ITEM_DATABASE[eq.itemId];
                        if (item) {
                            equipmentHTML += `<div style="font-size: 10px; color: #888;">${item.icon} ${item.name}</div>`;
                        }
                    });

                    // Level color based on level
                    const levelColor = enemy.level <= 2 ? '#88ff88' : enemy.level <= 4 ? '#ffff88' : enemy.level <= 6 ? '#ffaa44' : '#ff6666';

                    enemiesHTML += `
                        <div style="margin-bottom: ${idx < enemyCount - 1 ? '12px' : '0'}; padding-bottom: ${idx < enemyCount - 1 ? '12px' : '0'}; border-bottom: ${idx < enemyCount - 1 ? '1px solid #333' : 'none'};">
                            <div class="enemy-name" style="display: flex; justify-content: space-between; align-items: center;">
                                <span>‚ö†Ô∏è ${enemy.name}</span>
                                <span style="background: ${levelColor}; color: #000; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: bold;">Lv.${enemy.level}</span>
                            </div>
                            <div class="enemy-chassis" style="font-size: 11px; color: #666; margin: 3px 0;">${enemy.chassis}</div>
                            <div class="enemy-stats" style="display: grid; grid-template-columns: 1fr 1fr; gap: 2px; font-size: 11px;">
                                <div>‚ù§Ô∏è ${enemy.maxHealth} HP</div>
                                <div>üí• ${enemy.stats.damage} DMG</div>
                                <div>üõ°Ô∏è ${enemy.stats.armor} ARM</div>
                                <div>‚ö° ${enemy.stats.energy} EN</div>
                            </div>
                            <div class="enemy-equipment" style="margin-top: 5px;">
                                ${equipmentHTML}
                            </div>
                        </div>
                    `;
                });

                card.innerHTML = `
                    <div class="mission-header">
                        <span class="mission-name">${mission.name}</span>
                        <span class="mission-difficulty ${mission.difficulty.toLowerCase()}">${mission.difficulty}</span>
                    </div>
                    <div class="mission-desc">${mission.description}</div>
                    <div class="mission-enemies" style="margin: 8px 0; font-size: 12px;">
                        ${enemySummary}
                    </div>
                    <div class="mission-reward">
                        <span>üí∞ ${mission.reward.credits}</span>
                        <span>‚≠ê ${mission.reward.xp} XP</span>
                    </div>
                    <div class="enemy-tooltip">
                        <div style="font-size: 12px; color: #00aa66; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;">
                            ${enemyCount > 1 ? `${enemyCount} Hostiles Detected` : 'Hostile Detected'}
                        </div>
                        ${enemiesHTML}
                    </div>
                `;

                card.addEventListener('click', () => selectMission(mission.id));
                missionList.appendChild(card);
            }

            // Also update mobile tab if visible
            if (currentTab === 'mission') {
                renderMissionTab();
            }
        }

        function selectMission(missionId) {
            selectedMission = missionId;
            renderMissions();
            updateStats();  // Re-check battle ready state
        }

        // ============================================
        // SHOP RENDERING
        // ============================================
        function renderShop() {
            // Update gold display
            const goldDisplay = document.getElementById('shopGoldDisplay');
            if (goldDisplay) goldDisplay.textContent = playerResources.gold;

            // Render mechs for sale
            const mechsContainer = document.getElementById('shopMechsContainer');
            if (mechsContainer) {
                mechsContainer.innerHTML = '';
                if (shopInventory.mechs.length === 0) {
                    mechsContainer.innerHTML = '<div style="color: #666; font-style: italic;">No mechs available</div>';
                } else {
                    shopInventory.mechs.forEach(mechId => {
                        const mech = MECH_TEMPLATES[mechId];
                        if (!mech) return;
                        const rarityColor = COMPONENT_GENERATION.rarityColors[mech.rarity] || '#aaa';
                        const canAfford = playerResources.gold >= mech.price;

                        const card = document.createElement('div');
                        card.className = 'shop-mech-card';
                        card.style.cssText = `
                            background: rgba(0, 0, 0, 0.5);
                            border: 2px solid ${rarityColor};
                            border-radius: 8px;
                            padding: 15px;
                            width: 200px;
                            cursor: ${canAfford ? 'pointer' : 'not-allowed'};
                            opacity: ${canAfford ? '1' : '0.6'};
                            transition: all 0.2s;
                        `;
                        card.innerHTML = `
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <span style="font-size: 28px;">${mech.icon}</span>
                                <span style="color: #ffcc00; font-weight: bold;">${mech.price}g</span>
                            </div>
                            <div style="font-size: 14px; color: ${rarityColor}; font-weight: bold;">${mech.name}</div>
                            <div style="font-size: 10px; color: #888; text-transform: uppercase; margin: 4px 0;">${mech.class} CLASS</div>
                            <div style="font-size: 11px; color: #aaa; margin-top: 8px;">
                                <div>‚ù§Ô∏è ${mech.baseHP} HP | üõ°Ô∏è ${mech.baseArmor} ARM</div>
                                <div>‚öñÔ∏è ${mech.tonnage}t | üì¶ ${mech.modSpace} slots</div>
                                <div style="color: #00ff88; margin-top: 5px;">${mech.specialDesc}</div>
                            </div>
                        `;

                        if (canAfford) {
                            card.addEventListener('click', () => handleBuyMech(mechId));
                            card.addEventListener('mouseenter', () => { card.style.transform = 'scale(1.02)'; });
                            card.addEventListener('mouseleave', () => { card.style.transform = 'scale(1)'; });
                        }

                        mechsContainer.appendChild(card);
                    });
                }
            }

            // Render weapons for sale
            const weaponsContainer = document.getElementById('shopWeaponsContainer');
            if (weaponsContainer) {
                weaponsContainer.innerHTML = '';
                if (shopInventory.weapons.length === 0) {
                    weaponsContainer.innerHTML = '<div style="color: #666; font-style: italic;">No weapons available</div>';
                } else {
                    shopInventory.weapons.forEach((shopItem, index) => {
                        const item = ITEM_DATABASE[shopItem.itemId];
                        if (!item) return;
                        const rarityColor = COMPONENT_GENERATION.rarityColors[item.rarity] || '#aaa';
                        const canAfford = playerResources.gold >= shopItem.price;
                        const backpackFull = backpack.items.length >= backpack.slots;

                        const card = document.createElement('div');
                        card.className = 'shop-weapon-card';
                        card.style.cssText = `
                            background: rgba(0, 0, 0, 0.5);
                            border: 2px solid ${rarityColor};
                            border-radius: 8px;
                            padding: 12px;
                            width: 160px;
                            cursor: ${canAfford && !backpackFull ? 'pointer' : 'not-allowed'};
                            opacity: ${canAfford && !backpackFull ? '1' : '0.6'};
                            position: relative;
                            transition: all 0.2s;
                        `;

                        const bargainBadge = shopItem.isBargain ?
                            `<div style="position: absolute; top: -8px; left: -8px; background: #ff6600; color: #fff; font-size: 9px; padding: 2px 6px; border-radius: 3px; font-weight: bold;">BARGAIN!</div>` : '';

                        const statsText = buildComponentStatsHTML(item);

                        card.innerHTML = `
                            ${bargainBadge}
                            <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                <span style="font-size: 22px;">${item.icon}</span>
                                <div style="text-align: right;">
                                    ${shopItem.isBargain ? `<div style="font-size: 9px; color: #666; text-decoration: line-through;">${shopItem.originalPrice}g</div>` : ''}
                                    <div style="color: #ffcc00; font-weight: bold; font-size: 14px;">${shopItem.price}g</div>
                                </div>
                            </div>
                            <div style="font-size: 12px; color: ${rarityColor}; font-weight: bold; margin: 6px 0;">${item.name}</div>
                            <div style="font-size: 9px; color: #888;">${item.rarity.toUpperCase()} Lv.${item.level}</div>
                            <div style="font-size: 10px; color: #aaa; margin-top: 5px;">${statsText}</div>
                        `;

                        if (canAfford && !backpackFull) {
                            card.addEventListener('click', () => handleBuyWeapon(index));
                            card.addEventListener('mouseenter', () => { card.style.transform = 'scale(1.02)'; });
                            card.addEventListener('mouseleave', () => { card.style.transform = 'scale(1)'; });
                        }

                        weaponsContainer.appendChild(card);
                    });
                }
            }

            // Render owned mechs
            const ownedContainer = document.getElementById('ownedMechsContainer');
            if (ownedContainer) {
                ownedContainer.innerHTML = '';
                ownedMechs.forEach(mechId => {
                    const mech = MECH_TEMPLATES[mechId];
                    if (!mech) return;
                    const isActive = mechId === activeMechId;
                    const rarityColor = COMPONENT_GENERATION.rarityColors[mech.rarity] || '#aaa';

                    const card = document.createElement('div');
                    card.className = 'owned-mech-card';
                    card.style.cssText = `
                        background: rgba(0, 0, 0, 0.5);
                        border: 2px solid ${isActive ? '#00ff88' : rarityColor};
                        border-radius: 8px;
                        padding: 12px;
                        width: 150px;
                        cursor: pointer;
                        transition: all 0.2s;
                        ${isActive ? 'box-shadow: 0 0 15px rgba(0, 255, 136, 0.4);' : ''}
                    `;
                    card.innerHTML = `
                        <div style="text-align: center;">
                            <div style="font-size: 24px;">${mech.icon}</div>
                            <div style="font-size: 12px; color: ${isActive ? '#00ff88' : rarityColor}; font-weight: bold; margin-top: 5px;">${mech.name}</div>
                            <div style="font-size: 10px; color: #888;">${mech.class}</div>
                            ${isActive ? '<div style="font-size: 10px; color: #00ff88; margin-top: 5px;">‚úì ACTIVE</div>' : '<div style="font-size: 10px; color: #666; margin-top: 5px;">Click to select</div>'}
                        </div>
                    `;

                    if (!isActive) {
                        card.addEventListener('click', () => {
                            activeMechId = mechId;
                            renderShop();
                            updateHeaderDisplay();
                        });
                    }

                    ownedContainer.appendChild(card);
                });
            }
        }

        // ============================================
        // BACKPACK RENDERING
        // ============================================
        function renderBackpack() {
            const slotsDisplay = document.getElementById('backpackSlotsDisplay');
            if (slotsDisplay) slotsDisplay.textContent = `${backpack.items.length}/${backpack.slots}`;

            const container = document.getElementById('backpackItemsContainer');
            const emptyMsg = document.getElementById('backpackEmpty');

            if (!container) return;

            container.innerHTML = '';

            if (backpack.items.length === 0) {
                if (emptyMsg) emptyMsg.style.display = 'block';
                return;
            }

            if (emptyMsg) emptyMsg.style.display = 'none';

            backpack.items.forEach((itemId, index) => {
                const item = ITEM_DATABASE[itemId];
                if (!item) return;

                const rarityColor = COMPONENT_GENERATION.rarityColors[item.rarity] || '#aaa';
                const basePrice = ECONOMY.weaponPrices[item.rarity || 'common'] || 2;
                const sellPrice = Math.floor(basePrice * ECONOMY.sellMultiplier * (item.isHighValue ? 1.5 : 1));

                const card = document.createElement('div');
                card.className = 'backpack-item-card';
                card.style.cssText = `
                    background: rgba(0, 0, 0, 0.5);
                    border: 2px solid ${rarityColor};
                    border-radius: 8px;
                    padding: 12px;
                    width: 160px;
                    position: relative;
                `;

                const highValueBadge = item.isHighValue ?
                    `<div style="position: absolute; top: -8px; left: -8px; background: #ffcc00; color: #000; font-size: 9px; padding: 2px 5px; border-radius: 3px; font-weight: bold;">üí∞</div>` : '';

                const statsText = buildComponentStatsHTML(item);

                card.innerHTML = `
                    ${highValueBadge}
                    <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                        <span style="font-size: 22px;">${item.icon}</span>
                        <div style="font-size: 9px; color: ${rarityColor}; text-transform: uppercase;">${item.rarity}</div>
                    </div>
                    <div style="font-size: 12px; color: ${rarityColor}; font-weight: bold; margin: 6px 0;">${item.name}</div>
                    <div style="font-size: 10px; color: #aaa; margin-bottom: 8px;">${statsText}</div>
                    <div style="display: flex; gap: 6px; justify-content: center;">
                        <button class="equip-btn" style="flex: 1; padding: 6px; background: rgba(0, 255, 136, 0.2); border: 1px solid #00ff88; color: #00ff88; cursor: pointer; border-radius: 4px; font-size: 10px;">Equip</button>
                        <button class="sell-btn" style="padding: 6px 10px; background: rgba(255, 200, 0, 0.2); border: 1px solid #ffcc00; color: #ffcc00; cursor: pointer; border-radius: 4px; font-size: 10px;">${sellPrice}g</button>
                    </div>
                `;

                // Equip button - add to bench (for equipping)
                const equipBtn = card.querySelector('.equip-btn');
                equipBtn.addEventListener('click', () => {
                    // Move from backpack to bench
                    removeFromBackpack(itemId);
                    addItemToBench(itemId);
                    renderBackpack();
                    renderBench();
                    updateHeaderDisplay();
                });

                // Sell button
                const sellBtn = card.querySelector('.sell-btn');
                sellBtn.addEventListener('click', () => {
                    const result = sellItem(itemId);
                    if (result.success) {
                        renderBackpack();
                        updateHeaderDisplay();
                    }
                });

                container.appendChild(card);
            });
        }

        // ============================================
        // HEADER DISPLAY UPDATE
        // ============================================
        function updateHeaderDisplay() {
            const roundNum = document.getElementById('roundNum');
            const goldAmount = document.getElementById('goldAmount');
            const backpackCount = document.getElementById('backpackCount');
            const backpackMax = document.getElementById('backpackMax');

            if (roundNum) roundNum.textContent = gameProgression.round;
            if (goldAmount) goldAmount.textContent = playerResources.gold;
            if (backpackCount) backpackCount.textContent = backpack.items.length;
            if (backpackMax) backpackMax.textContent = backpack.slots;
        }

        // ============================================
        // SHOP HANDLERS
        // ============================================
        function handleBuyMech(mechId) {
            const result = buyMech(mechId);
            if (result.success) {
                renderShop();
                updateHeaderDisplay();
            } else {
                console.log('Failed to buy mech:', result.reason);
            }
        }

        function handleBuyWeapon(shopIndex) {
            const result = buyWeapon(shopIndex);
            if (result.success) {
                renderShop();
                updateHeaderDisplay();
            } else {
                console.log('Failed to buy weapon:', result.reason);
            }
        }

        function handleRefreshShop() {
            const result = refreshShop();
            if (result.success) {
                renderShop();
                updateHeaderDisplay();
            } else {
                console.log('Failed to refresh shop:', result.reason);
            }
        }

        function handleUpgradeBackpack() {
            const result = upgradeBackpack();
            if (result.success) {
                renderBackpack();
                updateHeaderDisplay();
            } else {
                console.log('Failed to upgrade backpack:', result.reason);
            }
        }

        function renderGridOverlays() {
            // Legacy function - gridOverlayContainer no longer exists in new layout
            const container = document.getElementById('gridOverlayContainer');
            if (!container) return;  // Use renderUnifiedMechGrid instead
            container.innerHTML = '';
            gridElements = {};

            // Create legs container for centered leg grids
            const legsContainer = document.createElement('div');
            legsContainer.id = 'legsContainer';
            container.appendChild(legsContainer);

            // Get cell size based on screen width
            let cellSize = 40;
            if (window.innerWidth <= 480) {
                cellSize = 28;
            } else if (window.innerWidth <= 768) {
                cellSize = 32;
            }

            for (const [slotName, slotDef] of Object.entries(MECH_CHASSIS.slots)) {
                const gridEl = document.createElement('div');
                gridEl.className = 'mech-grid-overlay';
                gridEl.dataset.slot = slotName;
                gridEl.style.gridTemplateColumns = `repeat(${slotDef.cols}, ${cellSize}px)`;

                // Add label
                const label = document.createElement('span');
                label.className = 'grid-label';
                label.textContent = slotName.replace(/([A-Z])/g, ' $1').trim();
                gridEl.appendChild(label);

                // Create grid cells
                for (let y = 0; y < slotDef.rows; y++) {
                    for (let x = 0; x < slotDef.cols; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.x = x;
                        cell.dataset.y = y;
                        gridEl.appendChild(cell);
                    }
                }

                // Append legs to legsContainer, others to main container
                if (slotName === 'leftLeg' || slotName === 'rightLeg') {
                    legsContainer.appendChild(gridEl);
                } else {
                    container.appendChild(gridEl);
                }
                gridElements[slotName] = gridEl;
            }
        }

        // Check if two items are adjacent (share an edge) in the unified grid
        function areItemsAdjacent(eq1, eq2) {
            // With unified grid, all items are in the same grid space

            const item1 = ITEM_DATABASE[eq1.itemId];
            const item2 = ITEM_DATABASE[eq2.itemId];
            if (!item1 || !item2) return false;

            // Get all cells occupied by each item
            const cells1 = [];
            const cells2 = [];

            const shape1 = item1.gridShape;
            for (let dy = 0; dy < shape1.length; dy++) {
                for (let dx = 0; dx < shape1[0].length; dx++) {
                    if (shape1[dy][dx] === 1) {
                        cells1.push({ x: eq1.position.x + dx, y: eq1.position.y + dy });
                    }
                }
            }

            const shape2 = item2.gridShape;
            for (let dy = 0; dy < shape2.length; dy++) {
                for (let dx = 0; dx < shape2[0].length; dx++) {
                    if (shape2[dy][dx] === 1) {
                        cells2.push({ x: eq2.position.x + dx, y: eq2.position.y + dy });
                    }
                }
            }

            // Check if any cell from item1 is adjacent to any cell from item2
            for (const c1 of cells1) {
                for (const c2 of cells2) {
                    const dx = Math.abs(c1.x - c2.x);
                    const dy = Math.abs(c1.y - c2.y);
                    // Adjacent means sharing an edge (not diagonal)
                    if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Calculate energy reduction from heat sinks for adjacent items
        function calculateHeatSinkReduction() {
            let totalReduction = 0;
            const heatSinks = loadoutState.equipment.filter(eq => {
                const item = ITEM_DATABASE[eq.itemId];
                return item && item.stats && item.stats.energyReduction;
            });

            // Track remaining energy that can be reduced for each item (to cap at 0)
            const remainingEnergy = new Map();  // instanceId -> remaining energy to reduce

            // For each heat sink, find adjacent items and apply reduction
            for (const heatSink of heatSinks) {
                const heatSinkItem = ITEM_DATABASE[heatSink.itemId];
                const reduction = heatSinkItem.stats.energyReduction || 0;

                for (const eq of loadoutState.equipment) {
                    if (eq.instanceId === heatSink.instanceId) continue;

                    const item = ITEM_DATABASE[eq.itemId];
                    if (!item || !item.stats || !item.stats.energyDraw || item.stats.energyDraw <= 0) continue;

                    if (areItemsAdjacent(heatSink, eq)) {
                        // Initialize remaining energy if not tracked yet
                        if (!remainingEnergy.has(eq.instanceId)) {
                            remainingEnergy.set(eq.instanceId, item.stats.energyDraw);
                        }

                        // Apply reduction up to remaining energy (can't go below 0)
                        const remaining = remainingEnergy.get(eq.instanceId);
                        const actualReduction = Math.min(reduction, remaining);
                        totalReduction += actualReduction;
                        remainingEnergy.set(eq.instanceId, remaining - actualReduction);
                    }
                }
            }
            return totalReduction;
        }

        function updateStats() {
            let totalWeight = 0;
            let energyUsed = 0;      // Positive energyDraw = consumes energy
            let energyProvided = 0;  // Negative energyDraw = provides energy (reactors)
            let totalArmor = 0;
            let accuracyBonus = 0;

            loadoutState.equipment.forEach(eq => {
                const item = ITEM_DATABASE[eq.itemId];
                if (item && item.stats) {
                    totalWeight += item.stats.weight || 0;
                    totalArmor += item.stats.armorBonus || 0;
                    accuracyBonus += item.stats.accuracyBonus || 0;
                    const draw = item.stats.energyDraw || 0;
                    if (draw > 0) {
                        energyUsed += draw;
                    } else {
                        energyProvided += Math.abs(draw);
                    }
                }
            });

            // Apply heat sink energy reduction
            const heatSinkReduction = calculateHeatSinkReduction();
            energyUsed = Math.max(0, energyUsed - heatSinkReduction);

            const maxWeight = MECH_CHASSIS.maxWeight;
            const maxEnergy = MECH_CHASSIS.baseEnergy + energyProvided;  // Reactors increase max energy

            // Calculate HP (base + weight bonus + armor) - doubled for longer battles
            const baseHealth = 200;
            const healthBonus = Math.floor(totalWeight * 1.0);
            const totalHP = baseHealth + healthBonus + totalArmor;

            // Update HP bar
            const hpFill = document.getElementById('hpFill');
            const hpText = document.getElementById('hpText');
            hpFill.style.width = '100%';  // Always full (shows max HP)
            hpText.textContent = totalHP;

            // Update armor display (only show if armor > 0)
            const armorStatItem = document.getElementById('armorStatItem');
            const armorFill = document.getElementById('armorFill');
            const armorText = document.getElementById('armorText');
            if (totalArmor > 0) {
                armorStatItem.style.display = '';
                armorFill.style.width = '100%';
                armorText.textContent = `+${totalArmor}`;
            } else {
                armorStatItem.style.display = 'none';
            }

            // Update accuracy bar (base 60% + bonuses)
            const baseAccuracy = 60;
            const totalAccuracy = Math.min(100, baseAccuracy + accuracyBonus);
            const accuracyFill = document.getElementById('accuracyFill');
            const accuracyText = document.getElementById('accuracyText');
            accuracyFill.style.width = totalAccuracy + '%';
            accuracyText.textContent = `${totalAccuracy}%`;

            // Update weight bar
            const weightFill = document.getElementById('weightFill');
            const weightText = document.getElementById('weightText');
            const weightPercent = Math.min((totalWeight / maxWeight) * 100, 100);
            weightFill.style.width = weightPercent + '%';
            weightText.textContent = `${totalWeight} / ${maxWeight}`;
            weightFill.classList.toggle('over-limit', totalWeight > maxWeight);

            // Update energy bar (energy used vs available energy)
            const energyFill = document.getElementById('energyFill');
            const energyText = document.getElementById('energyText');
            const energyPercent = Math.min((energyUsed / maxEnergy) * 100, 100);
            energyFill.style.width = energyPercent + '%';
            energyText.textContent = `${energyUsed} / ${maxEnergy}`;
            energyFill.classList.toggle('over-limit', energyUsed > maxEnergy);

            // Update pile counts
            updatePileCounts();

            // Check button states
            const hasEquipment = loadoutState.equipment.length > 0;
            const withinLimits = totalWeight <= maxWeight && energyUsed <= maxEnergy;
            const isValid = withinLimits && hasEquipment && selectedMission !== null;

            // Update "Go to Missions" button on loadout screen
            const goToMissionsBtn = document.getElementById('goToMissionsBtn');
            if (goToMissionsBtn) {
                if (!withinLimits) {
                    goToMissionsBtn.textContent = 'Over Limit!';
                    goToMissionsBtn.disabled = true;
                    goToMissionsBtn.classList.add('warning');
                } else {
                    goToMissionsBtn.textContent = 'Go to Missions ‚Üí';
                    goToMissionsBtn.disabled = !hasEquipment;
                    goToMissionsBtn.classList.remove('warning');
                }
            }

            // Update "Continue to Battle" button on mission screen
            const continueBtn = document.getElementById('missionContinueBtn');
            if (continueBtn) {
                if (!withinLimits) {
                    continueBtn.textContent = 'Over Limit!';
                    continueBtn.disabled = true;
                    continueBtn.classList.add('warning');
                } else {
                    continueBtn.textContent = 'Continue to Battle ‚Üí';
                    continueBtn.disabled = !isValid;
                    continueBtn.classList.remove('warning');
                }
            }
        }

        // Update pile count displays (no longer used - no deck system)
        function updatePileCounts() {
            // No deck piles to update
        }

        // Show pile viewer modal (no longer used - no deck system)
        function showPileViewer(pileType) {
            // No deck viewer needed
            return;
            const viewer = document.getElementById('pileViewer');
            if (!viewer) return;
            const title = document.getElementById('pileViewerTitle');
            const cardsContainer = document.getElementById('pileViewerCards');

            const pile = [];
            console.log('[PILE] pile contents:', pile.length, 'cards');
            title.textContent = pileType === 'draw' ? `Draw Pile (${pile.length} cards)` : `Discard Pile (${pile.length} cards)`;

            // Count occurrences of each card
            const cardCounts = {};
            pile.forEach(itemId => {
                cardCounts[itemId] = (cardCounts[itemId] || 0) + 1;
            });

            // Build cards HTML
            cardsContainer.innerHTML = '';
            for (const [itemId, count] of Object.entries(cardCounts)) {
                const item = ITEM_DATABASE[itemId];
                if (!item) continue;

                // Get rarity styling for generated items
                const isGenerated = item.isGenerated;
                const rarityColor = isGenerated ? (COMPONENT_GENERATION.rarityColors[item.rarity] || '#00ff88') : '#00ff88';
                const rarityName = isGenerated ? (item.rarity.charAt(0).toUpperCase() + item.rarity.slice(1)) : '';

                const cardEl = document.createElement('div');
                cardEl.className = 'pile-card';
                if (isGenerated) {
                    cardEl.style.borderColor = rarityColor;
                    cardEl.style.boxShadow = `0 0 8px ${rarityColor}40`;
                }
                cardEl.innerHTML = `
                    <div class="card-icon">${item.icon}</div>
                    <div class="card-name" style="${isGenerated ? `color: ${rarityColor};` : ''}">${item.name}</div>
                    ${isGenerated ? `<div style="font-size: 9px; color: ${rarityColor};">${rarityName} L${item.level}</div>` : ''}
                    ${count > 1 ? `<div class="card-count" style="font-size: 11px; color: #ffcc00;">√ó${count}</div>` : ''}
                `;
                cardsContainer.appendChild(cardEl);
            }

            if (pile.length === 0) {
                cardsContainer.innerHTML = '<div style="color: #666; font-size: 14px;">Empty</div>';
            }

            viewer.classList.add('active');
            console.log('[PILE] Added active class, viewer display:', window.getComputedStyle(viewer).display);
        }

        // Close pile viewer modal
        function closePileViewer() {
            console.log('[PILE] closePileViewer called');
            const viewer = document.getElementById('pileViewer');
            viewer.classList.remove('active');
        }

        // ============================================
        // 3D SCENE - MECHBUILDER VIEW
        // ============================================
        let builderMech = null;
        let outlineMaterial = null;

        function createBuilderScene() {
            // Create orthographic camera for blueprint view
            const aspectRatio = engine.getRenderWidth() / engine.getRenderHeight();
            const orthoSize = 4;

            builderCamera = new BABYLON.ArcRotateCamera('builderCam',
                -Math.PI/2, Math.PI/2.5, 10,
                new BABYLON.Vector3(0, 1.5, 0), scene);
            builderCamera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
            builderCamera.orthoLeft = -orthoSize * aspectRatio;
            builderCamera.orthoRight = orthoSize * aspectRatio;
            builderCamera.orthoTop = orthoSize;
            builderCamera.orthoBottom = -orthoSize;

            // Only attach camera controls on desktop - mobile needs that area for scrolling
            const isMobile = window.innerWidth <= 768 || 'ontouchstart' in window;
            if (!isMobile) {
                builderCamera.attachControl(document.getElementById('renderCanvas'), true);
            }

            // Ambient lighting for builder
            const hemi = new BABYLON.HemisphericLight('builderHemi', new BABYLON.Vector3(0, 1, 0), scene);
            hemi.intensity = 0.8;
            hemi.groundColor = new BABYLON.Color3(0.1, 0.2, 0.15);

            // Create outline/holographic material
            outlineMaterial = new BABYLON.StandardMaterial('outlineMat', scene);
            outlineMaterial.diffuseColor = new BABYLON.Color3(0, 0.4, 0.3);
            outlineMaterial.emissiveColor = new BABYLON.Color3(0, 0.8, 0.5);
            outlineMaterial.specularColor = new BABYLON.Color3(0, 1, 0.7);
            outlineMaterial.alpha = 0.7;
            outlineMaterial.wireframe = false;

            // Create dark background plane
            const bgPlane = BABYLON.MeshBuilder.CreatePlane('bgPlane', { size: 50 }, scene);
            bgPlane.position.z = 5;
            const bgMat = new BABYLON.StandardMaterial('bgMat', scene);
            bgMat.diffuseColor = new BABYLON.Color3(0.02, 0.04, 0.03);
            bgMat.emissiveColor = new BABYLON.Color3(0.01, 0.02, 0.015);
            bgPlane.material = bgMat;

            // Create grid floor for reference
            const gridSize = 10;
            const gridLines = [];
            for (let i = -gridSize; i <= gridSize; i++) {
                gridLines.push([new BABYLON.Vector3(i, 0, -gridSize), new BABYLON.Vector3(i, 0, gridSize)]);
                gridLines.push([new BABYLON.Vector3(-gridSize, 0, i), new BABYLON.Vector3(gridSize, 0, i)]);
            }
            const gridMesh = BABYLON.MeshBuilder.CreateLineSystem('grid', { lines: gridLines }, scene);
            gridMesh.color = new BABYLON.Color3(0, 0.3, 0.2);
            gridMesh.alpha = 0.3;

            // Create the mech model for builder view
            builderMech = createBuilderMechModel();

            scene.activeCamera = builderCamera;
        }

        function createBuilderMechModel() {
            // Create a simplified mech silhouette for the builder
            const mech = new BABYLON.TransformNode('builderMech', scene);

            // Torso (main body)
            const torso = BABYLON.MeshBuilder.CreateBox('torso', {
                width: 1.2, height: 1.0, depth: 0.8
            }, scene);
            torso.position.y = 2.2;
            torso.parent = mech;
            torso.material = outlineMaterial;

            // Torso upper
            const torsoUpper = BABYLON.MeshBuilder.CreateBox('torsoUpper', {
                width: 1.4, height: 0.5, depth: 0.9
            }, scene);
            torsoUpper.position.y = 0.6;
            torsoUpper.parent = torso;
            torsoUpper.material = outlineMaterial;

            // Head/cockpit
            const head = BABYLON.MeshBuilder.CreateBox('head', {
                width: 0.5, height: 0.4, depth: 0.5
            }, scene);
            head.position.y = 0.9;
            head.parent = torso;
            head.material = outlineMaterial;

            // Cockpit glass
            const cockpit = BABYLON.MeshBuilder.CreateBox('cockpit', {
                width: 0.4, height: 0.15, depth: 0.1
            }, scene);
            cockpit.position = new BABYLON.Vector3(0, 0, 0.28);
            cockpit.parent = head;
            const cockpitMat = new BABYLON.StandardMaterial('cockpitMat', scene);
            cockpitMat.diffuseColor = new BABYLON.Color3(0, 0.5, 0.5);
            cockpitMat.emissiveColor = new BABYLON.Color3(0, 0.8, 0.9);
            cockpitMat.alpha = 0.9;
            cockpit.material = cockpitMat;

            // Left Arm
            const leftArm = createBuilderArm('left', -0.9, torso);

            // Right Arm
            const rightArm = createBuilderArm('right', 0.9, torso);

            // Pelvis
            const pelvis = BABYLON.MeshBuilder.CreateBox('pelvis', {
                width: 0.9, height: 0.4, depth: 0.6
            }, scene);
            pelvis.position.y = 1.5;
            pelvis.parent = mech;
            pelvis.material = outlineMaterial;

            // Left Leg
            const leftLeg = createBuilderLeg('left', -0.4, pelvis);

            // Right Leg
            const rightLeg = createBuilderLeg('right', 0.4, pelvis);

            // Add edge rendering for holographic effect
            addEdgeRendering(mech);

            return mech;
        }

        function createBuilderArm(side, xOffset, parent) {
            const arm = new BABYLON.TransformNode(side + 'Arm', scene);
            arm.position.x = xOffset;
            arm.position.y = 0.3;
            arm.parent = parent;

            // Shoulder
            const shoulder = BABYLON.MeshBuilder.CreateSphere(side + 'Shoulder', {
                diameter: 0.4
            }, scene);
            shoulder.parent = arm;
            shoulder.material = outlineMaterial;

            // Upper arm
            const upperArm = BABYLON.MeshBuilder.CreateBox(side + 'UpperArm', {
                width: 0.25, height: 0.6, depth: 0.25
            }, scene);
            upperArm.position.y = -0.4;
            upperArm.parent = arm;
            upperArm.material = outlineMaterial;

            // Lower arm / weapon housing
            const lowerArm = BABYLON.MeshBuilder.CreateBox(side + 'LowerArm', {
                width: 0.35, height: 0.8, depth: 0.4
            }, scene);
            lowerArm.position.y = -1.0;
            lowerArm.parent = arm;
            lowerArm.material = outlineMaterial;

            return arm;
        }

        function createBuilderLeg(side, xOffset, parent) {
            const leg = new BABYLON.TransformNode(side + 'Leg', scene);
            leg.position.x = xOffset;
            leg.position.y = -0.2;
            leg.parent = parent;

            // Hip joint
            const hip = BABYLON.MeshBuilder.CreateSphere(side + 'Hip', {
                diameter: 0.3
            }, scene);
            hip.parent = leg;
            hip.material = outlineMaterial;

            // Upper leg (thigh)
            const upperLeg = BABYLON.MeshBuilder.CreateBox(side + 'UpperLeg', {
                width: 0.25, height: 0.5, depth: 0.3
            }, scene);
            upperLeg.position.y = -0.35;
            upperLeg.rotation.x = 0.3;
            upperLeg.parent = leg;
            upperLeg.material = outlineMaterial;

            // Knee
            const knee = BABYLON.MeshBuilder.CreateSphere(side + 'Knee', {
                diameter: 0.25
            }, scene);
            knee.position.y = -0.6;
            knee.position.z = 0.15;
            knee.parent = leg;
            knee.material = outlineMaterial;

            // Lower leg (shin)
            const lowerLeg = BABYLON.MeshBuilder.CreateBox(side + 'LowerLeg', {
                width: 0.3, height: 0.7, depth: 0.35
            }, scene);
            lowerLeg.position.y = -1.0;
            lowerLeg.position.z = 0.05;
            lowerLeg.rotation.x = -0.2;
            lowerLeg.parent = leg;
            lowerLeg.material = outlineMaterial;

            // Foot
            const foot = BABYLON.MeshBuilder.CreateBox(side + 'Foot', {
                width: 0.35, height: 0.15, depth: 0.5
            }, scene);
            foot.position.y = -1.45;
            foot.position.z = 0.1;
            foot.parent = leg;
            foot.material = outlineMaterial;

            return leg;
        }

        function addEdgeRendering(rootNode) {
            // Add edge rendering to all meshes
            const meshes = rootNode.getChildMeshes();
            meshes.forEach(mesh => {
                mesh.enableEdgesRendering();
                mesh.edgesWidth = 2.0;
                mesh.edgesColor = new BABYLON.Color4(0, 1, 0.6, 1);
            });
        }

        // ============================================
        // PLAYER STATS CALCULATION
        // ============================================
        function calculatePlayerStats() {
            let totalDamage = 0;
            let totalArmor = 0;
            let totalWeight = 0;
            let baseHealth = 100;
            let weapons = [];

            loadoutState.equipment.forEach(eq => {
                const item = ITEM_DATABASE[eq.itemId];
                if (item && item.stats) {
                    totalWeight += item.stats.weight || 0;
                    totalDamage += item.stats.damage || 0;
                    totalArmor += item.stats.armorBonus || 0;
                    if (item.type === 'WEAPON') {
                        // Pass full weapon info for battle simulation
                        weapons.push({
                            itemId: eq.itemId,
                            slot: eq.slot,
                            name: item.name,
                            damage: item.stats.damage || 0,
                            battle: item.battle || {}
                        });
                    }
                }
            });

            const healthBonus = Math.floor(totalWeight * 0.5);
            return {
                maxHealth: baseHealth + healthBonus + totalArmor,
                currentHealth: baseHealth + healthBonus + totalArmor,
                damage: Math.max(20, totalDamage),
                armor: totalArmor,
                weapons: weapons
            };
        }

        // Create battle arena
        function createBattleArena(scene) {
            // Ground
            const ground = BABYLON.MeshBuilder.CreateGround('battleGround', { width: 40, height: 25 }, scene);
            const groundMat = new BABYLON.StandardMaterial('groundMat', scene);
            groundMat.diffuseColor = new BABYLON.Color3(0.25, 0.3, 0.2);
            groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            ground.material = groundMat;
            ground.receiveShadows = true;
            battleGround = ground;

            // Battle lighting
            const battleLight = new BABYLON.DirectionalLight('battleLight', new BABYLON.Vector3(-1, -2, -1), scene);
            battleLight.intensity = 1.2;
            battleLight.position = new BABYLON.Vector3(10, 20, 10);

            const ambientLight = new BABYLON.HemisphericLight('battleAmbient', new BABYLON.Vector3(0, 1, 0), scene);
            ambientLight.intensity = 0.4;

            return ground;
        }

        // Build weapons list from equipment array using ITEM_DATABASE
        function buildWeaponsFromEquipment(equipment) {
            const weapons = [];
            if (!equipment) return weapons;

            equipment.forEach(eq => {
                const item = ITEM_DATABASE[eq.itemId];
                if (item && item.type === 'WEAPON') {
                    weapons.push({
                        itemId: eq.itemId,
                        slot: eq.slot,
                        name: item.name,
                        damage: item.stats.damage || 0,
                        battle: item.battle || {}
                    });
                }
            });
            return weapons;
        }

        function startBattle() {
            if (loadoutState.equipment.length === 0 || !selectedMission) {
                return;
            }

            const mission = MISSIONS[selectedMission];
            const playerStats = calculatePlayerStats();
            const enemy = mission.enemyMechs[0];

            // Save mission info for salvage generation
            lastBattleMission = {
                ...mission,
                averageLevel: mission.averageLevel || Math.round(mission.enemyMechs.reduce((sum, e) => sum + e.level, 0) / mission.enemyMechs.length)
            };

            // Build enemy weapons from their equipment using ITEM_DATABASE
            const enemyWeapons = buildWeaponsFromEquipment(enemy.equipment);

            // Build battle config for the original physics simulation
            const battleConfig = {
                player: {
                    name: MECH_CHASSIS.name,
                    loadout: loadoutState,
                    stats: playerStats
                },
                mission: mission,
                enemy: {
                    ...enemy,
                    // Override stats with calculated values from ITEM_DATABASE
                    weapons: enemyWeapons
                },
                // Pass ITEM_DATABASE for future use (special properties, etc.)
                itemDatabase: ITEM_DATABASE
            };

            // Save to localStorage (battle-arena-old.html reads this)
            localStorage.setItem('battleConfig', JSON.stringify(battleConfig));

            // Hide builder UI and canvas
            document.getElementById('mechBuilderUI').style.display = 'none';
            document.getElementById('renderCanvas').style.display = 'none';

            // Show and load the battle iframe with the original physics simulation
            const battleFrame = document.getElementById('battleFrame');
            battleFrame.style.display = 'block';
            // Add cache-busting parameter to prevent browser caching
            battleFrame.src = 'battle-arena-old.html?t=' + Date.now();

            currentPhase = GamePhase.BATTLE;
        }

        // Listen for messages from battle iframe
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'battleEnd') {
                const result = event.data.result || 'victory';
                const rewards = event.data.rewards || { xp: 0, scrap: 0, components: [] };
                showSalvageScreen(result, rewards);
            }
        });

        // Show salvage screen with rewards
        // Build HTML for component stats display
        function buildComponentStatsHTML(component) {
            const stats = component.stats || {};
            const battle = component.battle || {};
            let statsLines = [];

            // Format stat values
            if (stats.damage) statsLines.push(`DMG: ${stats.damage}`);
            if (stats.armorBonus) statsLines.push(`ARM: +${stats.armorBonus}`);
            if (stats.accuracyBonus) statsLines.push(`ACC: +${stats.accuracyBonus}%`);
            if (stats.weight) statsLines.push(`WT: ${stats.weight}`);
            if (stats.energyDraw > 0) statsLines.push(`EN: ${stats.energyDraw}`);
            if (stats.energyDraw < 0) statsLines.push(`EN: +${Math.abs(stats.energyDraw)}`);
            if (stats.energyReduction) statsLines.push(`COOL: -${stats.energyReduction}`);
            if (stats.heatCapacity) statsLines.push(`HEAT: ${stats.heatCapacity}`);
            if (battle.cooldown && stats.damage) {
                const dps = (stats.damage / (battle.cooldown / 1000)).toFixed(1);
                statsLines.push(`DPS: ${dps}`);
            }
            if (battle.knockback) statsLines.push(`KB: ${battle.knockback}`);

            return statsLines.join(' | ');
        }

        // Build shape preview HTML for component
        function buildShapePreviewHTML(component) {
            const shape = component.gridShape;
            const rarityColor = COMPONENT_GENERATION.rarityColors[component.rarity] || '#aaa';
            let html = '<div style="display: inline-grid; gap: 1px; margin-top: 5px;">';

            for (let row of shape) {
                html += '<div style="display: flex; gap: 1px;">';
                for (let cell of row) {
                    if (cell === 1) {
                        html += `<div style="width: 12px; height: 12px; background: ${rarityColor}; border: 1px solid rgba(255,255,255,0.3);"></div>`;
                    } else {
                        html += '<div style="width: 12px; height: 12px;"></div>';
                    }
                }
                html += '</div>';
            }
            html += '</div>';
            return html;
        }

        function showSalvageScreen(result, rewards) {
            // Hide battle iframe
            const battleFrame = document.getElementById('battleFrame');
            battleFrame.style.display = 'none';
            battleFrame.src = '';

            // Get enemy level from the mission we just fought
            const missionEnemyLevel = lastBattleMission ? lastBattleMission.averageLevel : Math.floor(currentEnemyLevel);

            // Generate salvage options using the mission's enemy level
            const salvageOptions = generateSalvageOptions(result, missionEnemyLevel);

            // Get max picks allowed
            const maxPicks = getSalvagePicks(result);

            // Track selected components (multiple selection support)
            let selectedComponents = [];

            // Award gold for the round
            const goldReward = awardRoundGold(result === 'victory');

            // Update game progression
            if (result === 'victory') {
                gameProgression.wins++;
                gameProgression.round++;
                gameProgression.maxRound = Math.max(gameProgression.maxRound, gameProgression.round);
            } else {
                gameProgression.losses++;
            }

            const isBoss = DIFFICULTY.isBossRound(gameProgression.round - 1);  // Check previous round

            // Create salvage overlay
            const overlay = document.createElement('div');
            overlay.id = 'salvageOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0, 20, 10, 0.95);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-start;
                z-index: 1000;
                font-family: 'Courier New', monospace;
                overflow-y: auto;
                padding: 20px;
            `;

            const resultColor = result === 'victory' ? '#00ff88' : '#ff4444';
            const resultText = result === 'victory' ?
                (isBoss ? 'BOSS DEFEATED!' : 'MISSION COMPLETE') :
                'MISSION FAILED';

            // Calculate sell prices for each salvage option
            function getSellPrice(comp) {
                const basePrice = ECONOMY.weaponPrices[comp.rarity || 'common'] || 2;
                const bonus = comp.isHighValue ? (1 + comp.resaleBonus) : 1;
                return Math.floor(basePrice * ECONOMY.sellMultiplier * bonus);
            }

            // Build salvage options HTML
            let salvageHTML = '';
            if (salvageOptions.length > 0) {
                salvageHTML = `
                    <div style="margin-top: 25px; width: 100%; max-width: 1000px;">
                        <div style="font-size: 16px; color: #00aa66; margin-bottom: 15px; text-align: center; letter-spacing: 2px;">
                            SALVAGEABLE COMPONENTS <span id="pickCounter">(Select up to ${maxPicks})</span>
                        </div>
                        <div id="salvageOptionsContainer" style="display: flex; flex-wrap: wrap; gap: 12px; justify-content: center;">
                            ${salvageOptions.map((comp, index) => {
                                const rarityColor = COMPONENT_GENERATION.rarityColors[comp.rarity] || '#aaa';
                                const rarityName = comp.rarity.charAt(0).toUpperCase() + comp.rarity.slice(1);
                                const statsText = buildComponentStatsHTML(comp);
                                const shapePreview = buildShapePreviewHTML(comp);
                                const sellPrice = getSellPrice(comp);
                                const highValueBadge = comp.isHighValue ?
                                    `<div style="position: absolute; top: -8px; left: -8px; background: #ffcc00; color: #000; font-size: 9px; padding: 2px 5px; border-radius: 3px; font-weight: bold;">üí∞ HIGH VALUE</div>` : '';

                                return `
                                    <div class="salvage-option" data-index="${index}" style="
                                        background: rgba(0, 0, 0, 0.5);
                                        border: 2px solid ${rarityColor};
                                        border-radius: 8px;
                                        padding: 12px;
                                        width: 180px;
                                        cursor: pointer;
                                        transition: all 0.2s;
                                        position: relative;
                                    ">
                                        ${highValueBadge}
                                        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                            <div style="font-size: 22px;">${comp.icon}</div>
                                            <div style="text-align: right;">
                                                <div style="font-size: 9px; color: ${rarityColor}; text-transform: uppercase; letter-spacing: 1px;">${rarityName}</div>
                                                <div style="font-size: 9px; color: #666;">Lv.${comp.level}</div>
                                            </div>
                                        </div>
                                        <div style="font-size: 12px; color: ${rarityColor}; margin: 6px 0; font-weight: bold; line-height: 1.2;">
                                            ${comp.name}
                                        </div>
                                        <div style="font-size: 9px; color: #888; text-transform: uppercase; margin-bottom: 4px;">
                                            ${comp.type}
                                        </div>
                                        <div style="font-size: 10px; color: #aaa; line-height: 1.3;">
                                            ${statsText}
                                        </div>
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 6px; padding-top: 6px; border-top: 1px solid #333;">
                                            ${shapePreview}
                                            <div style="font-size: 10px; color: #ffcc00;">Sell: ${sellPrice}g</div>
                                        </div>
                                        <div class="selection-indicator" style="
                                            position: absolute;
                                            top: -8px; right: -8px;
                                            width: 24px; height: 24px;
                                            background: #00ff88;
                                            border-radius: 50%;
                                            display: none;
                                            align-items: center;
                                            justify-content: center;
                                            font-size: 14px;
                                            color: #000;
                                            font-weight: bold;
                                        ">‚úì</div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            } else {
                salvageHTML = `
                    <div style="margin-top: 25px; color: #666; font-style: italic;">
                        No salvageable components found.
                    </div>
                `;
            }

            overlay.innerHTML = `
                <div style="font-size: 14px; color: #666; letter-spacing: 4px; margin-bottom: 8px;">ROUND ${gameProgression.round - (result === 'victory' ? 1 : 0)} ${isBoss ? '- BOSS' : ''}</div>
                <div style="font-size: 32px; font-weight: bold; color: ${resultColor}; text-shadow: 0 0 20px ${resultColor}; margin-bottom: 15px;">
                    ${resultText}
                </div>
                <div style="background: rgba(0, 0, 0, 0.3); padding: 20px 30px; border-radius: 12px; text-align: center;">
                    <div style="font-size: 16px; color: #aaa; margin-bottom: 12px;">Rewards Collected:</div>
                    <div style="display: flex; gap: 25px; justify-content: center; flex-wrap: wrap;">
                        <div style="text-align: center;">
                            <div style="font-size: 28px; color: #ffcc00;">+${goldReward.total}</div>
                            <div style="font-size: 10px; color: #888;">GOLD</div>
                            <div style="font-size: 9px; color: #666; margin-top: 2px;">
                                ${goldReward.base} base ${goldReward.streak > 0 ? `+ ${goldReward.streak} streak` : ''} ${goldReward.interest > 0 ? `+ ${goldReward.interest} interest` : ''}
                            </div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 28px; color: #ffcc00;">${playerResources.gold}</div>
                            <div style="font-size: 10px; color: #888;">TOTAL GOLD</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 28px; color: #88aaff;">+${rewards.xp}</div>
                            <div style="font-size: 10px; color: #888;">EXPERIENCE</div>
                        </div>
                    </div>
                </div>
                ${salvageHTML}
                <div style="display: flex; gap: 15px; margin-top: 25px; margin-bottom: 20px;">
                    <button id="skipSalvageBtn" style="
                        padding: 10px 25px;
                        font-size: 13px;
                        background: rgba(100, 100, 100, 0.3);
                        border: 2px solid #666;
                        color: #aaa;
                        cursor: pointer;
                        border-radius: 6px;
                        font-family: 'Courier New', monospace;
                        text-transform: uppercase;
                        letter-spacing: 1px;
                    ">Skip Salvage</button>
                    <button id="confirmSalvageBtn" style="
                        padding: 10px 25px;
                        font-size: 13px;
                        background: rgba(0, 255, 136, 0.2);
                        border: 2px solid #00ff88;
                        color: #00ff88;
                        cursor: pointer;
                        border-radius: 6px;
                        font-family: 'Courier New', monospace;
                        text-transform: uppercase;
                        letter-spacing: 1px;
                        opacity: 0.5;
                    " disabled>Take Selected (0/${maxPicks})</button>
                </div>
            `;

            document.body.appendChild(overlay);

            // Update pick counter and button
            function updatePickUI() {
                const counter = document.getElementById('pickCounter');
                const btn = document.getElementById('confirmSalvageBtn');
                if (counter) {
                    counter.textContent = `(${selectedComponents.length}/${maxPicks} selected)`;
                }
                if (btn) {
                    btn.textContent = `Take Selected (${selectedComponents.length}/${maxPicks})`;
                    btn.disabled = selectedComponents.length === 0;
                    btn.style.opacity = selectedComponents.length > 0 ? '1' : '0.5';
                }
            }

            // Handle salvage option selection (multiple)
            const optionElements = overlay.querySelectorAll('.salvage-option');
            optionElements.forEach((el, index) => {
                el.addEventListener('click', () => {
                    const comp = salvageOptions[index];
                    const existingIndex = selectedComponents.indexOf(comp);

                    if (existingIndex > -1) {
                        // Deselect
                        selectedComponents.splice(existingIndex, 1);
                        el.style.transform = 'scale(1)';
                        el.style.boxShadow = 'none';
                        el.querySelector('.selection-indicator').style.display = 'none';
                    } else if (selectedComponents.length < maxPicks) {
                        // Select
                        selectedComponents.push(comp);
                        el.style.transform = 'scale(1.05)';
                        el.style.boxShadow = `0 0 20px ${COMPONENT_GENERATION.rarityColors[comp.rarity]}`;
                        el.querySelector('.selection-indicator').style.display = 'flex';
                    }
                    // If at max picks and clicking unselected, do nothing

                    updatePickUI();
                });

                // Hover effect
                el.addEventListener('mouseenter', () => {
                    if (!selectedComponents.includes(salvageOptions[index])) {
                        el.style.transform = 'scale(1.02)';
                    }
                });
                el.addEventListener('mouseleave', () => {
                    if (!selectedComponents.includes(salvageOptions[index])) {
                        el.style.transform = 'scale(1)';
                    }
                });
            });

            // Handle skip button
            document.getElementById('skipSalvageBtn').addEventListener('click', () => {
                finishSalvage([], rewards, overlay, result);
            });

            // Handle confirm button
            document.getElementById('confirmSalvageBtn').addEventListener('click', () => {
                finishSalvage(selectedComponents, rewards, overlay, result);
            });
        }

        // Complete the salvage process
        function finishSalvage(selectedComponents, rewards, overlay, result) {
            // Apply XP and scrap rewards
            playerResources.xp += rewards.xp;
            playerResources.scrap += rewards.scrap;

            // Handle array of selected components (or empty array)
            const components = Array.isArray(selectedComponents) ? selectedComponents : (selectedComponents ? [selectedComponents] : []);

            // Add each selected component to backpack
            components.forEach(comp => {
                // Register in ITEM_DATABASE so it can be used in gameplay
                registerGeneratedComponent(comp);

                // Add to backpack instead of deck
                const result = addToBackpack(comp.id);
                if (result.success) {
                    console.log(`Salvaged: ${comp.name} (${comp.rarity} Lv.${comp.level})`);
                } else {
                    console.log(`Failed to salvage ${comp.name}: ${result.reason}`);
                }
            });

            // Increase enemy level for progression based on round (using new difficulty system)
            const isVictory = result === 'victory';
            const round = gameProgression.round;

            // Enemy level scales with difficulty multiplier
            currentEnemyLevel = Math.max(1, DIFFICULTY.getMultiplier(round) * 2);

            console.log(`Round ${round}, Difficulty: ${DIFFICULTY.getMultiplier(round).toFixed(2)}, Enemy Level: ${currentEnemyLevel.toFixed(2)}`);

            // Generate new shop inventory for next round
            generateShopInventory();

            // Remove overlay
            overlay.remove();

            // Handle post-battle cleanup
            handlePostBattle();
        }

        // Handle post-battle cleanup
        function handlePostBattle() {
            // Clear localStorage
            localStorage.removeItem('battleConfig');

            // Return all equipped items to bench (persistent items)
            loadoutState.equipment.forEach(eq => {
                const item = eq.item || { ...ITEM_DATABASE[eq.itemId], instanceId: eq.instanceId };
                benchItems.push(item);
            });

            // Clear equipment and grids
            loadoutState.equipment = [];
            initializeGrids();

            // Unlock all locked items
            lockedItems.clear();

            // Clear mission selection
            selectedMission = null;

            // Regenerate missions with new enemy levels (progression!)
            MISSIONS = buildMissions();

            // Show builder UI
            document.getElementById('mechBuilderUI').style.display = 'flex';
            document.getElementById('renderCanvas').style.display = 'block';

            // Switch to loadout tab (not mission)
            switchTab('loadout');

            // Re-render everything
            renderBench();
            renderMissions();
            renderUnifiedMechGrid();
            renderUnifiedGridItems();
            updateStats();

            currentPhase = GamePhase.MECHBUILDER;
        }

        // ============================================
        // ENGINE INITIALIZATION
        // ============================================
        async function initEngine() {
            const canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, {
                preserveDrawingBuffer: true,
                stencil: true,
                antialias: true
            });

            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.02, 0.04, 0.03, 1);

            // Initialize MechBuilder
            createBuilderScene();
            initializeGrids();

            // Initialize starter items on bench (no deck system)
            initializeStarterItems();

            // Render UI
            renderBench();
            renderMissions();
            renderUnifiedMechGrid();
            renderUnifiedGridItems();
            updateStats();

            // Initialize drag and drop
            initDragAndDrop();

            // Go to Missions button
            document.getElementById('goToMissionsBtn').addEventListener('click', function() {
                switchTab('mission');
            });

            // Shop button
            document.getElementById('goToShopBtn').addEventListener('click', function() {
                switchTab('shop');
            });

            // Backpack button
            document.getElementById('goToBackpackBtn').addEventListener('click', function() {
                switchTab('backpack');
            });

            // Initialize shop inventory
            generateShopInventory();
            updateHeaderDisplay();

            // (Deck pile viewers removed - no deck system)

            // Main render loop with delta time for battle updates
            let lastFrameTime = performance.now();
            engine.runRenderLoop(() => {
                const now = performance.now();
                const dt = (now - lastFrameTime) / 1000;
                lastFrameTime = now;

                // Render appropriate scene based on phase
                if (currentPhase === GamePhase.BATTLE && battleScene) {
                    // Update battle mechanics
                    if (battleActive) {
                        updateBattle(dt);
                    }
                    battleScene.render();
                } else if (scene) {
                    scene.render();
                }
            });

            // Handle window resize
            window.addEventListener('resize', () => {
                engine.resize();
                // Check mobile layout and re-render grid on resize
                if (currentPhase === GamePhase.MECHBUILDER) {
                    setTimeout(() => {
                        checkMobileLayout();
                        renderUnifiedMechGrid();
                        renderUnifiedGridItems();
                    }, 100);
                }
            });

            // Handle orientation change for mobile
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    checkMobileLayout();
                    if (currentPhase === GamePhase.MECHBUILDER) {
                        renderUnifiedMechGrid();
                        renderUnifiedGridItems();
                    }
                }, 200);
            });

            // Initial mobile layout check
            checkMobileLayout();

            console.log('MechBuilder initialized!');
        }

        // Start the game
        initEngine();
    </script>
</body>
</html>
