<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mech Autobattler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            background-attachment: fixed;
            color: #eee;
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 10px;
        }

        header {
            background: rgba(0, 0, 0, 0.5);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 2px solid #00ff88;
        }

        h1 {
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin-bottom: 8px;
            font-size: 20px;
        }

        h2 {
            font-size: 18px;
            margin-bottom: 10px;
        }

        h3 {
            font-size: 16px;
        }

        .stats-bar {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 11px;
        }

        .stat {
            font-size: 11px;
        }

        .stat strong {
            color: #00ff88;
        }

        .screen {
            display: none;
        }

        .screen.active {
            display: block;
        }

        /* Battle Screen - MOBILE OPTIMIZED */
        .battle-area {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 15px;
        }

        .combatant {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #444;
        }

        .combatant h2 {
            font-size: 14px;
            margin-bottom: 8px;
        }

        .combatant.player {
            border-color: #00ff88;
        }

        .combatant.monster {
            border-color: #ff4444;
        }

        .abilities-display {
            margin-top: 12px;
            padding: 8px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 6px;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .abilities-display h4 {
            font-size: 11px;
            color: #00ff88;
            margin-bottom: 6px;
        }

        .ability-tag {
            display: inline-block;
            padding: 3px 6px;
            margin: 2px;
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            border-radius: 3px;
            font-size: 9px;
            color: #00ff88;
        }

        .trait-tag {
            display: inline-block;
            padding: 3px 6px;
            margin: 2px;
            background: rgba(255, 170, 0, 0.2);
            border: 1px solid #ffaa00;
            border-radius: 3px;
            font-size: 9px;
            color: #ffaa00;
        }

        .status-effects {
            margin-top: 8px;
            padding: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-size: 10px;
            min-height: 24px;
        }

        .status-effect {
            display: inline-block;
            padding: 2px 5px;
            margin: 2px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            font-size: 9px;
        }

        .status-shield {
            background: rgba(0, 204, 255, 0.3);
            border: 1px solid #00ccff;
            color: #00ccff;
        }

        .status-burn {
            background: rgba(255, 136, 0, 0.3);
            border: 1px solid #ff8800;
            color: #ff8800;
        }

        .status-bleed {
            background: rgba(255, 0, 100, 0.3);
            border: 1px solid #ff0064;
            color: #ff0064;
        }

        .mech-display {
            text-align: center;
        }

        .mech-display h3 {
            font-size: 14px;
        }

        .mech-visual {
            font-size: 40px;
            margin: 8px 0;
        }

        .health-bar {
            background: #333;
            height: 24px;
            border-radius: 12px;
            overflow: hidden;
            margin: 8px 0;
            border: 1px solid #555;
        }

        .health-fill {
            background: linear-gradient(90deg, #ff4444, #ff8844);
            height: 100%;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
        }

        .health-fill.player {
            background: linear-gradient(90deg, #00ff88, #00ccff);
        }

        .combat-log {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #444;
            height: 250px;
            overflow-y: auto;
            font-size: 12px;
        }

        .log-entry {
            padding: 6px;
            margin: 3px 0;
            border-left: 3px solid #444;
            padding-left: 8px;
            animation: slideIn 0.3s ease;
            line-height: 1.4;
        }

        .log-entry.player {
            border-left-color: #00ff88;
        }

        .log-entry.monster {
            border-left-color: #ff4444;
        }

        .log-entry.system {
            border-left-color: #00ccff;
            color: #00ccff;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.05);
            }
        }

        /* Salvage Screen - MOBILE OPTIMIZED */
        .salvage-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 15px 0;
        }

        .salvage-card, .mech-card {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #444;
            cursor: pointer;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .salvage-card:active, .mech-card:active {
            border-color: #00ff88;
            transform: scale(0.98);
            box-shadow: 0 3px 15px rgba(0, 255, 136, 0.3);
        }

        .component-name {
            color: #00ff88;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .component-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin: 10px 0;
            font-size: 11px;
        }

        .stat-item {
            padding: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            text-align: center;
        }

        /* Loadout Screen - MOBILE OPTIMIZED */
        .loadout-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .mech-panel {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00ff88;
        }

        .mech-panel h3 {
            font-size: 14px;
        }

        .mech-slots {
            margin-top: 15px;
        }

        .slot {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            margin: 8px 0;
            border-radius: 6px;
            border: 2px dashed #444;
            min-height: 55px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .slot.filled {
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
        }

        .slot:active {
            background: rgba(0, 255, 136, 0.2);
        }

        .slot-header {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .inventory-panel {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #444;
            max-height: 500px;
            overflow-y: auto;
        }

        .inventory-panel h3 {
            font-size: 16px;
        }

        .inventory-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 12px;
        }

        .inventory-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 6px;
            border: 2px solid #444;
            cursor: pointer;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .inventory-item:active {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.15);
            transform: scale(0.98);
        }

        .inventory-item.selected {
            border-color: #00ccff;
            background: rgba(0, 204, 255, 0.2);
        }

        /* Buttons - MOBILE OPTIMIZED */
        .btn {
            background: linear-gradient(135deg, #00ff88, #00ccff);
            color: #000;
            border: none;
            padding: 16px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 8px 0;
            width: 100%;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .btn:active {
            transform: scale(0.97);
            box-shadow: 0 3px 15px rgba(0, 255, 136, 0.5);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: scale(1);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #666, #888);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff4444, #ff8844);
        }

        /* Resource bars */
        .resource-bars {
            margin: 12px 0;
        }

        .resource-bar {
            margin: 10px 0;
        }

        .resource-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 11px;
        }

        .resource-fill-container {
            background: #333;
            height: 12px;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #555;
        }

        .resource-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .resource-fill.tier {
            background: linear-gradient(90deg, #ff4444, #ff8844);
        }

        .resource-fill.weight {
            background: linear-gradient(90deg, #00ccff, #0088ff);
        }

        .tier-indicator {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 5px;
        }

        .tier-1 { background: #888; }
        .tier-2 { background: #00ff88; color: #000; }
        .tier-3 { background: #00ccff; color: #000; }
        .tier-4 { background: #ff00ff; color: #fff; }
        .tier-5 { background: #ffaa00; color: #000; }

        /* Debug Panel - MOBILE OPTIMIZED */
        .debug-panel {
            position: fixed;
            top: 50px;
            right: 10px;
            background: rgba(0, 0, 0, 0.95);
            padding: 12px;
            border-radius: 6px;
            border: 2px solid #ff00ff;
            font-size: 10px;
            max-width: 250px;
            z-index: 1000;
            max-height: 80vh;
            overflow-y: auto;
        }

        .debug-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #ff00ff;
            color: #000;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 999;
            font-size: 11px;
            font-weight: bold;
            -webkit-tap-highlight-color: transparent;
        }

        /* Scrollbar styling - MOBILE */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        ::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00ccff;
        }

        .warning {
            color: #ff8844;
            font-weight: bold;
        }

        .success {
            color: #00ff88;
            font-weight: bold;
        }

        /* Tablet and larger screens */
        @media (min-width: 768px) {
            .container {
                max-width: 1400px;
                padding: 20px;
            }

            h1 {
                font-size: 28px;
            }

            h2 {
                font-size: 22px;
            }

            .stats-bar {
                display: flex;
                gap: 30px;
            }

            .stat {
                font-size: 14px;
            }

            .battle-area {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 20px;
            }

            .salvage-options {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 20px;
            }

            .loadout-container {
                display: grid;
                grid-template-columns: 400px 1fr;
                gap: 20px;
            }

            .inventory-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            }

            .btn {
                width: auto;
            }

            .btn:hover {
                transform: scale(1.05);
            }

            .salvage-card:hover, .mech-card:hover {
                border-color: #00ff88;
                transform: translateY(-5px);
            }

            .inventory-item:hover {
                border-color: #00ff88;
                background: rgba(0, 255, 136, 0.1);
            }

            .slot:hover {
                background: rgba(0, 255, 136, 0.15);
            }
        }

        /* Physics Canvas Styles */
        #physics-canvas {
            width: 100%;
            max-width: 900px;
            height: 55vh;  /* About 2/3 of viewport height, leaving room for UI */
            max-height: 400px;
            background: linear-gradient(180deg, #1a1a3e 0%, #0d0d1f 100%);
            border: 3px solid #00ff88;
            border-radius: 8px;
            margin: 0 auto 15px;
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3), inset 0 0 50px rgba(0, 0, 0, 0.5);
        }

        #physics-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        #physics-controls button {
            padding: 6px 12px;
            font-size: 11px;
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
        }

        #physics-controls button:hover {
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        #physics-controls button.active {
            background: rgba(0, 255, 136, 0.3);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.7);
        }
    </style>

    <!-- Babylon.js 3D Engine + Havok Physics -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚öîÔ∏è MECH AUTOBATTLER ‚öîÔ∏è</h1>
            <div class="stats-bar">
                <div class="stat"><strong>Round:</strong> <span id="round-num">1</span></div>
                <div class="stat"><strong>Victories:</strong> <span id="victories">0</span></div>
                <div class="stat"><strong>Current Mech:</strong> <span id="current-mech-name">None</span></div>
                <div class="stat"><strong>Inventory:</strong> <span id="inventory-count">0/10</span></div>
            </div>
        </header>

        <!-- Battle Screen -->
        <div id="battle-screen" class="screen">
            <!-- Physics Combat Visualization -->
            <div id="physics-controls">
                <button id="toggle-physics" class="active">üéÆ Physics View</button>
                <button id="toggle-autofire" class="active">üî´ Auto-Fire: ON</button>
                <button id="toggle-speed" class="active">‚ö° Speed: 1x</button>
            </div>
            <canvas id="physics-canvas" width="800" height="450"></canvas>

            <div class="battle-area">
                <div class="combatant player">
                    <h2>ü§ñ YOUR MECH</h2>
                    <div class="mech-display">
                        <div class="mech-visual" id="player-visual">ü§ñ</div>
                        <h3 id="player-name">Loading...</h3>
                        <div class="health-bar">
                            <div class="health-fill player" id="player-health">
                                <span id="player-health-text">100/100</span>
                            </div>
                        </div>
                        <div class="status-effects" id="player-status-effects">
                            <span style="color: #666; font-size: 9px;">No active effects</span>
                        </div>
                        <div id="player-stats" style="font-size: 12px; margin-top: 10px;"></div>
                        <div class="abilities-display" id="player-abilities-display" style="display: none;"></div>
                    </div>
                </div>

                <div class="combatant monster">
                    <h2>üëæ ENEMY</h2>
                    <div class="mech-display">
                        <div class="mech-visual" id="monster-visual">üëæ</div>
                        <h3 id="monster-name">Loading...</h3>
                        <div class="health-bar">
                            <div class="health-fill" id="monster-health">
                                <span id="monster-health-text">100/100</span>
                            </div>
                        </div>
                        <div class="status-effects" id="monster-status-effects">
                            <span style="color: #666; font-size: 9px;">No active effects</span>
                        </div>
                        <div id="monster-stats" style="font-size: 12px; margin-top: 10px;"></div>
                    </div>
                </div>
            </div>

            <div class="combat-log" id="combat-log"></div>

            <div style="text-align: center; margin-top: 20px;">
                <button class="btn" id="start-battle-btn">START BATTLE</button>
            </div>
        </div>

        <!-- Salvage Screen -->
        <div id="salvage-screen" class="screen">
            <h2>üîß SALVAGE SELECTION</h2>
            <p style="margin: 15px 0;">Choose one component to salvage from the battlefield:</p>
            <div class="salvage-options" id="salvage-options"></div>
        </div>

        <!-- Trait Selection Screen -->
        <div id="trait-select-screen" class="screen">
            <h2>‚≠ê MECH UPGRADE AVAILABLE ‚≠ê</h2>
            <p style="margin: 15px 0;">Your mech has proven itself in battle! Choose a permanent trait upgrade:</p>
            <div class="salvage-options" id="trait-options"></div>
        </div>

        <!-- Relic Selection Screen -->
        <div id="relic-select-screen" class="screen">
            <h2>‚ú® RELIC DISCOVERED ‚ú®</h2>
            <p style="margin: 15px 0;" id="relic-screen-desc">Choose a powerful relic to add to your collection:</p>
            <div style="margin-bottom: 15px; padding: 10px; background: rgba(255, 170, 0, 0.1); border: 2px solid #ffaa00; border-radius: 8px; font-size: 13px;">
                <strong>üí° TIP:</strong> Relics are <strong>PERMANENT</strong> and <strong>STACK</strong> with each other! Build synergies for exponential power.
            </div>
            <div class="salvage-options" id="relic-options"></div>
        </div>

        <!-- Item Selection Modal -->
        <div id="item-select-modal" class="screen">
            <h2 id="item-select-title">üì¶ SELECT COMPONENT</h2>
            <p style="margin: 15px 0;" id="item-select-desc">Choose a component to equip:</p>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <button class="btn btn-secondary" onclick="closeItemSelectModal()">‚Üê Back to Loadout</button>
                <button class="btn btn-danger" onclick="unequipSlot()" id="unequip-btn">üóëÔ∏è Unequip Current</button>
            </div>
            <div class="salvage-options" id="item-select-options"></div>
        </div>

        <!-- Loadout Screen -->
        <div id="loadout-screen" class="screen active">
            <h2>‚öôÔ∏è LOADOUT MANAGEMENT</h2>
            <div class="loadout-container">
                <div class="mech-panel">
                    <h3 id="loadout-mech-name">Select a Mech</h3>
                    <div class="mech-visual" style="text-align: center; font-size: 64px; margin: 20px 0;" id="loadout-mech-visual">ü§ñ</div>

                    <div class="resource-bars">
                        <div class="resource-bar">
                            <div class="resource-label">
                                <span>Tier Points:</span>
                                <span id="tier-usage">0/0</span>
                            </div>
                            <div class="resource-fill-container">
                                <div class="resource-fill tier" id="tier-bar"></div>
                            </div>
                        </div>
                        <div class="resource-bar">
                            <div class="resource-label">
                                <span>Weight:</span>
                                <span id="weight-usage">0/0</span>
                            </div>
                            <div class="resource-fill-container">
                                <div class="resource-fill weight" id="weight-bar"></div>
                            </div>
                        </div>
                    </div>

                    <div class="mech-slots" id="mech-slots"></div>

                    <button class="btn" id="ready-battle-btn" style="width: 100%; margin-top: 20px;">READY FOR BATTLE</button>
                </div>

                <div class="inventory-panel">
                    <h3>üì¶ Inventory</h3>
                    <div style="margin-bottom: 10px; padding: 8px; background: rgba(0, 204, 255, 0.1); border: 2px solid #00ccff; border-radius: 6px; font-size: 11px; color: #00ccff;">
                        üí° <strong>TIP:</strong> Click on a <strong>SLOT</strong> to equip items!
                    </div>
                    <button class="btn btn-secondary" id="toggle-abilities-guide" style="width: 100%; margin-bottom: 10px; padding: 8px; font-size: 12px;">
                        üìñ ABILITIES GUIDE
                    </button>
                    <div id="abilities-guide" style="display: none; background: rgba(0, 255, 136, 0.1); border: 2px solid #00ff88; border-radius: 8px; padding: 12px; margin-bottom: 15px; max-height: 300px; overflow-y: auto;">
                        <h4 style="color: #00ff88; margin-bottom: 10px; font-size: 14px;">‚ö° ABILITY REFERENCE</h4>
                        <div id="abilities-reference"></div>
                    </div>
                    <div class="inventory-grid" id="inventory-grid"></div>
                </div>
            </div>
        </div>
    </div>

    <button class="debug-toggle" id="debug-toggle">DEBUG</button>
    <div class="debug-panel" id="debug-panel" style="display: none;"></div>

    <script>
        // ============================================================================
        // GAME DATA STRUCTURES
        // ============================================================================

        const SLOT_TYPES = {
            HEAD: 'head',
            TORSO: 'torso',
            LEFT_ARM: 'leftArm',
            RIGHT_ARM: 'rightArm',
            LEFT_SHOULDER: 'leftShoulder',
            RIGHT_SHOULDER: 'rightShoulder',
            LEGS: 'legs'
        };

        const COMPONENT_TYPES = {
            WEAPON: 'weapon',
            ARMOR: 'armor',
            SYSTEM: 'system'
        };

        const MECH_CLASSES = {
            LIGHT: 'Light',
            MEDIUM: 'Medium',
            HEAVY: 'Heavy'
        };

        const DAMAGE_TYPES = {
            ENERGY: 'energy',
            KINETIC: 'kinetic',
            EXPLOSIVE: 'explosive',
            NONE: 'none'
        };

        // Rarity system with drop rates and visual styling
        const RARITY = {
            COMMON: {
                name: 'Common',
                color: '#888888',
                weight: 50,
                statMultiplier: 1.0
            },
            UNCOMMON: {
                name: 'Uncommon',
                color: '#00ff00',
                weight: 30,
                statMultiplier: 1.2
            },
            RARE: {
                name: 'Rare',
                color: '#4da6ff',
                weight: 15,
                statMultiplier: 1.4
            },
            EPIC: {
                name: 'Epic',
                color: '#a335ee',
                weight: 4,
                statMultiplier: 1.6
            },
            LEGENDARY: {
                name: 'Legendary',
                color: '#ff8000',
                weight: 1,
                statMultiplier: 2.0
            }
        };

        const ABILITIES = {
            // Damage abilities
            CRITICAL_STRIKE: { name: 'Critical Strike', desc: '25% crit chance (2x dmg)', tier: 2 },
            VAMPIRIC: { name: 'Vampiric', desc: 'Heal 25% of damage dealt', tier: 4 },
            ARMOR_PIERCING: { name: 'Armor Piercing', desc: 'Ignore 50% enemy armor', tier: 3 },
            BURN: { name: 'Plasma Burn', desc: 'Deal 5 dmg/turn for 3 turns', tier: 2 },
            BLEED: { name: 'Hemorrhage', desc: 'Crits cause 15 bleed over 5 turns', tier: 3 },

            // Defense abilities
            SHIELD_GEN: { name: 'Energy Shield', desc: 'Start with 50 shield HP', tier: 3 },
            REGENERATION: { name: 'Regeneration', desc: 'Heal 5 HP per turn', tier: 3 },
            REACTIVE: { name: 'Reactive Armor', desc: 'Reflect 25% damage taken', tier: 3 },
            DODGE: { name: 'Dodge Matrix', desc: '20% chance to avoid damage', tier: 3 },

            // Speed abilities
            LIGHTWEIGHT: { name: 'Lightweight Frame', desc: 'Weight doesn\'t affect speed', tier: 2 },
            OVERDRIVE: { name: 'Overdrive', desc: '+50 speed, -20% armor', tier: 3 },
            QUICK_DEPLOY: { name: 'Quick Deploy', desc: 'Always attack first on turn 1', tier: 2 },

            // Special abilities
            EFFICIENT: { name: 'Efficient Design', desc: 'Component costs -1 tier', tier: 3 },
            BERSERKER: { name: 'Berserker', desc: '+1% dmg per 1% HP missing', tier: 3 },
            EXECUTIONER: { name: 'Executioner', desc: '+100% dmg vs enemies <30% HP', tier: 3 },
            DOUBLE_STRIKE: { name: 'Multi-Strike', desc: 'Attack twice at 60% dmg each', tier: 4 },
            OVERCHARGE: { name: 'Overcharge', desc: '+100% dmg, take 10% max HP/attack', tier: 5 }
        };

        const MECH_TRAITS = {
            BERSERKER: {
                name: 'BERSERKER',
                desc: 'Gain +3% damage per 1% HP missing',
                tier: 4,
                icon: 'üí¢'
            },
            CRITICAL_CORE: {
                name: 'CRITICAL CORE',
                desc: 'All attacks have +30% crit chance, crits deal 3x damage',
                tier: 3,
                icon: 'üí•'
            },
            FORTRESS: {
                name: 'FORTRESS',
                desc: 'Armor increased by 100%, speed reduced by 50%',
                tier: 4,
                icon: 'üõ°Ô∏è'
            },
            REGENERATOR: {
                name: 'REGENERATOR',
                desc: 'Regenerate 8% max HP per turn',
                tier: 4,
                icon: 'üíö'
            },
            VAMPIRE: {
                name: 'VAMPIRE',
                desc: 'Heal for 40% of damage dealt, -30% armor',
                tier: 5,
                icon: 'ü©∏'
            },
            LIGHTNING_FAST: {
                name: 'LIGHTNING FAST',
                desc: 'Weight doesn\'t affect speed, +50 base speed',
                tier: 4,
                icon: '‚ö°'
            },
            EFFICIENT: {
                name: 'EFFICIENT',
                desc: 'All components cost -2 tier points (min 1)',
                tier: 5,
                icon: '‚öôÔ∏è'
            },
            SALVAGER: {
                name: 'SALVAGER',
                desc: 'Choose 2 salvage items instead of 1',
                tier: 4,
                icon: 'üîß'
            },
            ENERGY_MASTER: {
                name: 'ENERGY MASTER',
                desc: 'All Energy damage +100%, Energy components cost -1 tier',
                tier: 4,
                icon: '‚öõÔ∏è'
            },
            KINETIC_MASTER: {
                name: 'KINETIC MASTER',
                desc: 'All Kinetic damage +100%, ignore 50% armor',
                tier: 4,
                icon: 'üéØ'
            },
            EXPLOSIVE_MASTER: {
                name: 'EXPLOSIVE MASTER',
                desc: 'All Explosive damage +100%, apply burn effect',
                tier: 4,
                icon: 'üí£'
            },
            OVERCHARGED: {
                name: 'OVERCHARGED',
                desc: '+100% damage, lose 8% max HP per turn',
                tier: 5,
                icon: 'üî•'
            }
        };

        // Relics - Permanent upgrades that stack (with rarity)
        const RELICS = {
            // Damage Type Scaling
            ENERGY_CONDUIT: {
                name: 'Energy Conduit',
                desc: 'Energy damage +50% (stacks!)',
                icon: 'üîã',
                category: 'damage',
                rarity: 'UNCOMMON'
            },
            KINETIC_AMPLIFIER: {
                name: 'Kinetic Amplifier',
                desc: 'Kinetic damage +50%, ignore 25% armor',
                icon: 'üéØ',
                category: 'damage',
                rarity: 'UNCOMMON'
            },
            EXPLOSIVE_CATALYST: {
                name: 'Explosive Catalyst',
                desc: 'Explosive damage +50%, burns spread faster',
                icon: 'üí£',
                category: 'damage',
                rarity: 'UNCOMMON'
            },
            CRITICAL_MASS: {
                name: 'Critical Mass',
                desc: 'Critical chance +10%, crits +50% damage',
                icon: 'üí•',
                category: 'damage',
                rarity: 'RARE'
            },

            // Conversion Mechanics
            MOMENTUM_DRIVE: {
                name: 'Momentum Drive',
                desc: 'Each tier point spent = +2 damage',
                icon: '‚ö°',
                category: 'conversion',
                rarity: 'RARE'
            },
            BLOOD_PACT: {
                name: 'Blood Pact',
                desc: 'Max HP -20%, heal 50% of damage dealt',
                icon: 'ü©∏',
                category: 'conversion',
                rarity: 'EPIC'
            },

            // Investment/Snowball
            HUNTERS_MARK: {
                name: "Hunter's Mark",
                desc: 'Each kill grants +3 permanent damage',
                icon: 'üíÄ',
                category: 'investment',
                rarity: 'EPIC'
            },

            // Game Changers
            PERFECT_AEGIS: {
                name: 'Perfect Aegis',
                desc: 'Shields are 3x more effective',
                icon: 'üõ°Ô∏è',
                category: 'gameChanger',
                rarity: 'RARE'
            },
            CONTAGION: {
                name: 'Contagion',
                desc: 'DoTs deal 2x damage and last 2x longer',
                icon: 'üî•',
                category: 'gameChanger',
                rarity: 'EPIC'
            },
            GLASS_CANNON_CORE: {
                name: 'Glass Cannon Core',
                desc: 'All damage 2x, max HP -50%',
                icon: 'üíé',
                category: 'gameChanger',
                rarity: 'LEGENDARY'
            },
            FORTRESS_PROTOCOL: {
                name: 'Fortress Protocol',
                desc: 'Armor doubled, immune to one-shots',
                icon: 'üè∞',
                category: 'gameChanger',
                rarity: 'RARE'
            },
            VAMPIRIC_ASCENSION: {
                name: 'Vampiric Ascension',
                desc: 'Lifesteal from all damage (25%)',
                icon: 'üßõ',
                category: 'gameChanger',
                rarity: 'RARE'
            },

            // Build-Arounds
            ALL_IN: {
                name: 'All-In',
                desc: 'Abilities trigger twice, cost double tier',
                icon: 'üé≤',
                category: 'buildAround',
                rarity: 'LEGENDARY'
            },
            LAST_STAND: {
                name: 'Last Stand',
                desc: 'Below 30% HP: +200% damage, +50 armor',
                icon: '‚è±Ô∏è',
                category: 'buildAround',
                rarity: 'EPIC'
            },
            SCAVENGER: {
                name: 'Scavenger',
                desc: '+3 inventory slots, always salvage 2',
                icon: 'üîß',
                category: 'buildAround',
                rarity: 'UNCOMMON'
            }
        };

        // Mech Templates
        const MECH_TEMPLATES = {
            SCOUT: {
                name: 'Scout',
                class: MECH_CLASSES.LIGHT,
                tierCapacity: 25,
                baseHP: 80,
                baseArmor: 5,
                visual: 'üèÉ',
                slots: [SLOT_TYPES.HEAD, SLOT_TYPES.TORSO, SLOT_TYPES.LEFT_ARM, SLOT_TYPES.RIGHT_ARM, SLOT_TYPES.LEFT_SHOULDER, SLOT_TYPES.RIGHT_SHOULDER, SLOT_TYPES.LEGS]
            },
            WARRIOR: {
                name: 'Warrior',
                class: MECH_CLASSES.MEDIUM,
                tierCapacity: 38,
                baseHP: 120,
                baseArmor: 10,
                visual: 'ü§ñ',
                slots: [SLOT_TYPES.HEAD, SLOT_TYPES.TORSO, SLOT_TYPES.LEFT_ARM, SLOT_TYPES.RIGHT_ARM, SLOT_TYPES.LEFT_SHOULDER, SLOT_TYPES.RIGHT_SHOULDER, SLOT_TYPES.LEGS]
            },
            TITAN: {
                name: 'Titan',
                class: MECH_CLASSES.HEAVY,
                tierCapacity: 50,
                baseHP: 180,
                baseArmor: 15,
                visual: 'üèãÔ∏è',
                slots: [SLOT_TYPES.HEAD, SLOT_TYPES.TORSO, SLOT_TYPES.LEFT_ARM, SLOT_TYPES.RIGHT_ARM, SLOT_TYPES.LEFT_SHOULDER, SLOT_TYPES.RIGHT_SHOULDER, SLOT_TYPES.LEGS]
            }
        };

        // Component Templates (with rarity system)
        const COMPONENT_TEMPLATES = [
            // ENERGY WEAPONS
            { name: 'Laser Cannon', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_ARM, damage: 25, armor: 0, tier: 2, damageType: DAMAGE_TYPES.ENERGY, abilities: ['CRITICAL_STRIKE'], rarity: 'UNCOMMON' },
            { name: 'Plasma Rifle', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_ARM, damage: 30, armor: 0, tier: 3, damageType: DAMAGE_TYPES.ENERGY, abilities: ['BURN'], rarity: 'UNCOMMON' },
            { name: 'Ion Beam', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.LEFT_ARM, damage: 22, armor: 0, tier: 3, damageType: DAMAGE_TYPES.ENERGY, abilities: ['ARMOR_PIERCING'], rarity: 'UNCOMMON' },

            // KINETIC WEAPONS
            { name: 'Rail Gun', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_ARM, damage: 40, armor: -10, tier: 4, damageType: DAMAGE_TYPES.KINETIC, abilities: ['ARMOR_PIERCING'], rarity: 'RARE' },
            { name: 'Machine Gun', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.LEFT_ARM, damage: 15, armor: 0, tier: 1, damageType: DAMAGE_TYPES.KINETIC, abilities: [], rarity: 'COMMON' },
            { name: 'Autocannon', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_ARM, damage: 28, armor: -5, tier: 3, damageType: DAMAGE_TYPES.KINETIC, abilities: ['BLEED'], rarity: 'UNCOMMON' },

            // EXPLOSIVE WEAPONS
            { name: 'Missile Pod', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.LEFT_SHOULDER, damage: 35, armor: -3, tier: 3, damageType: DAMAGE_TYPES.EXPLOSIVE, abilities: ['BURN'], rarity: 'UNCOMMON' },
            { name: 'Rocket Launcher', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_SHOULDER, damage: 45, armor: -8, tier: 4, damageType: DAMAGE_TYPES.EXPLOSIVE, abilities: ['EXECUTIONER'], rarity: 'RARE' },
            { name: 'Grenade Launcher', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.LEFT_SHOULDER, damage: 30, armor: 0, tier: 2, damageType: DAMAGE_TYPES.EXPLOSIVE, abilities: [], rarity: 'COMMON' },

            // ARMOR
            { name: 'Light Plating', type: COMPONENT_TYPES.ARMOR, slot: SLOT_TYPES.TORSO, damage: 0, armor: 10, tier: 1, damageType: DAMAGE_TYPES.NONE, abilities: [], rarity: 'COMMON' },
            { name: 'Heavy Plating', type: COMPONENT_TYPES.ARMOR, slot: SLOT_TYPES.TORSO, damage: 0, armor: 20, tier: 2, damageType: DAMAGE_TYPES.NONE, abilities: [], rarity: 'COMMON' },
            { name: 'Composite Armor', type: COMPONENT_TYPES.ARMOR, slot: SLOT_TYPES.TORSO, damage: 0, armor: 35, tier: 4, damageType: DAMAGE_TYPES.NONE, abilities: ['REACTIVE'], rarity: 'RARE' },
            { name: 'Reactive Armor', type: COMPONENT_TYPES.ARMOR, slot: SLOT_TYPES.TORSO, damage: 0, armor: 25, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['REACTIVE'], rarity: 'UNCOMMON' },

            // SYSTEMS - Head
            { name: 'Targeting System', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.HEAD, damage: 10, armor: 5, tier: 2, damageType: DAMAGE_TYPES.NONE, abilities: ['CRITICAL_STRIKE'], rarity: 'UNCOMMON' },
            { name: 'Advanced Sensors', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.HEAD, damage: 15, armor: 10, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['EXECUTIONER'], rarity: 'RARE' },

            // SYSTEMS - Legs
            { name: 'Boost System', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.LEGS, damage: 5, armor: 0, tier: 2, damageType: DAMAGE_TYPES.NONE, abilities: [], rarity: 'COMMON' },
            { name: 'Overdrive Boosters', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.LEGS, damage: 8, armor: -5, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: [], rarity: 'UNCOMMON' },
            { name: 'Heavy Servos', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.LEGS, damage: 0, armor: 15, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: [], rarity: 'UNCOMMON' },

            // SYSTEMS - Special
            { name: 'Shield Generator', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 0, armor: 25, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['SHIELD_GEN'], rarity: 'RARE' },
            { name: 'Repair Nanobots', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 0, armor: 15, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['REGENERATION'], rarity: 'RARE' },
            { name: 'Power Core', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 10, armor: 10, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['EFFICIENT'], rarity: 'RARE' },
            { name: 'Vampiric Core', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 15, armor: -10, tier: 4, damageType: DAMAGE_TYPES.NONE, abilities: ['VAMPIRIC'], rarity: 'EPIC' },
            { name: 'Berserker Chip', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.HEAD, damage: 20, armor: -15, tier: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['BERSERKER'], rarity: 'RARE' },
            { name: 'Overcharge Module', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 25, armor: -20, tier: 5, damageType: DAMAGE_TYPES.NONE, abilities: ['OVERCHARGE'], rarity: 'EPIC' }
        ];

        // ============================================================================
        // GAME STATE
        // ============================================================================

        class GameState {
            constructor() {
                this.round = 1;
                this.victories = 0;
                this.currentMech = null;
                this.inventory = [];
                this.currentMonster = null;
                this.battleInProgress = false;
                this.maxInventorySize = 10;
                this.relics = []; // Array of acquired relic keys
                this.permanentDamageBonus = 0; // From Hunter's Mark
                this.componentBattleCount = {}; // Track battles per component ID for Evolution Chamber
            }

            save() {
                localStorage.setItem('mechAutobattler', JSON.stringify({
                    round: this.round,
                    victories: this.victories,
                    currentMech: this.currentMech,
                    inventory: this.inventory,
                    relics: this.relics,
                    permanentDamageBonus: this.permanentDamageBonus,
                    componentBattleCount: this.componentBattleCount
                }));
            }

            load() {
                const saved = localStorage.getItem('mechAutobattler');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.round = data.round || 1;
                    this.victories = data.victories || 0;
                    this.currentMech = data.currentMech;
                    this.inventory = data.inventory || [];
                    this.relics = data.relics || [];
                    this.permanentDamageBonus = data.permanentDamageBonus || 0;
                    this.componentBattleCount = data.componentBattleCount || {};
                    return true;
                }
                return false;
            }

            reset() {
                this.round = 1;
                this.victories = 0;
                this.currentMech = null;
                this.inventory = [];
                localStorage.removeItem('mechAutobattler'); // Clear saved game
            }
        }

        const game = new GameState();

        // ============================================================================
        // PHYSICS ENGINE INITIALIZATION
        // ============================================================================

        let physicsEngine = null;
        let physicsEnabled = true;

        // Initialize physics after DOM is ready
        function initializePhysics() {
            try {
                physicsEngine = new PhysicsEngine('physics-canvas');
                console.log('Physics-driven battle system initialized successfully');
            } catch (error) {
                console.error('Failed to initialize physics:', error);
                physicsEnabled = false;
            }
        }

        // ============================================================================
        // COMPONENT & MECH MANAGEMENT
        // ============================================================================

        function createMech(template, tier = 1) {
            const loadout = {};
            template.slots.forEach(slot => {
                loadout[slot] = null;
            });

            return {
                name: template.name,
                class: template.class,
                tierCapacity: template.tierCapacity,
                baseHP: template.baseHP,
                baseArmor: template.baseArmor,
                visual: template.visual,
                slots: template.slots,
                tier: tier,
                loadout: loadout,
                currentHP: template.baseHP,
                maxHP: template.baseHP,
                traits: []  // Array of acquired traits
            };
        }

        // Helper function to select random rarity based on weights
        function selectWeightedRarity() {
            const rarities = Object.keys(RARITY);
            const totalWeight = rarities.reduce((sum, key) => sum + RARITY[key].weight, 0);
            let random = Math.random() * totalWeight;

            for (const key of rarities) {
                random -= RARITY[key].weight;
                if (random <= 0) {
                    return key;
                }
            }
            return 'COMMON'; // fallback
        }

        function createComponent(template, tier = 1, forcedRarity = null) {
            // Determine rarity - use forced if provided, otherwise weighted random
            const rarityKey = forcedRarity || selectWeightedRarity();
            const rarityData = RARITY[rarityKey];

            const comp = {
                name: template.name,
                type: template.type,
                slot: template.slot,
                damage: template.damage,
                armor: template.armor,
                tier: tier,
                damageType: template.damageType || DAMAGE_TYPES.NONE,
                abilities: template.abilities ? [...template.abilities] : [],
                rarity: rarityKey,
                id: Math.random().toString(36).substr(2, 9),
                seenInSlots: [] // Track which slots this item has been shown in
            };

            // Scale stats with tier
            const tierMultiplier = 1 + ((tier - 1) * 0.3);
            comp.damage = Math.floor(comp.damage * tierMultiplier);
            comp.armor = Math.floor(comp.armor * tierMultiplier);

            // Apply rarity multiplier on top of tier scaling
            comp.damage = Math.floor(comp.damage * rarityData.statMultiplier);
            comp.armor = Math.floor(comp.armor * rarityData.statMultiplier);

            return comp;
        }

        function generateRandomComponents(count, minTier, maxTier) {
            const components = [];
            for (let i = 0; i < count; i++) {
                const template = COMPONENT_TEMPLATES[Math.floor(Math.random() * COMPONENT_TEMPLATES.length)];
                const tier = Math.floor(Math.random() * (maxTier - minTier + 1)) + minTier;
                components.push(createComponent(template, tier));
            }
            return components;
        }

        function generateRandomMechs(count, tier) {
            const mechs = [];
            const templates = Object.values(MECH_TEMPLATES);
            for (let i = 0; i < count; i++) {
                const template = templates[Math.floor(Math.random() * templates.length)];
                mechs.push(createMech(template, tier));
            }
            return mechs;
        }

        function calculateMechStats(mech) {
            let totalDamage = 0;
            let totalArmor = mech.baseArmor;
            let totalTier = 0;

            const traits = mech.traits || [];

            Object.values(mech.loadout).forEach(component => {
                if (component) {
                    totalDamage += component.damage;
                    totalArmor += component.armor;

                    // Apply EFFICIENT trait/ability - reduce tier cost
                    let compTier = component.tier;
                    if (traits.some(t => t.name === 'EFFICIENT')) {
                        compTier = Math.max(1, compTier - 2);
                    } else if (component.abilities && component.abilities.includes('EFFICIENT')) {
                        compTier = Math.max(1, compTier - 1);
                    }

                    // Apply ALL_IN relic - abilities cost double tier
                    if (game.relics && game.relics.includes('ALL_IN') && component.abilities) {
                        component.abilities.forEach(abilityKey => {
                            const ability = ABILITIES[abilityKey];
                            if (ability && abilityKey !== 'EFFICIENT') {
                                compTier += ability.tier; // Adds double (once here, once below)
                            }
                        });
                    }

                    totalTier += compTier;

                    // Add ability tier costs
                    if (component.abilities) {
                        component.abilities.forEach(abilityKey => {
                            const ability = ABILITIES[abilityKey];
                            if (ability && abilityKey !== 'EFFICIENT') {
                                totalTier += ability.tier;
                            }
                        });
                    }
                }
            });

            // Apply FORTRESS trait - double armor
            if (traits.some(t => t.name === 'FORTRESS')) {
                totalArmor *= 2;
            }

            // Apply VAMPIRE trait - reduce armor
            if (traits.some(t => t.name === 'VAMPIRE')) {
                totalArmor = Math.floor(totalArmor * 0.7);
            }

            // Apply FORTRESS_PROTOCOL relic - double armor
            if (game.relics && game.relics.includes('FORTRESS_PROTOCOL')) {
                totalArmor *= 2;
            }

            // Apply MOMENTUM_DRIVE relic - tier ‚Üí damage
            if (game.relics && game.relics.includes('MOMENTUM_DRIVE')) {
                totalDamage += totalTier * 2;
            }

            // Add permanent damage bonus from Hunter's Mark
            if (game.permanentDamageBonus) {
                totalDamage += game.permanentDamageBonus;
            }

            return {
                damage: totalDamage,
                armor: totalArmor,
                tierUsed: totalTier
            };
        }

        function canAttachComponent(mech, component, slotName) {
            // Check slot type matches
            if (component.slot !== slotName) return false;

            // Calculate if adding this would exceed tier limit
            const currentStats = calculateMechStats(mech);
            let newTier = currentStats.tierUsed + component.tier;

            // Add ability tier costs for new component
            if (component.abilities) {
                component.abilities.forEach(abilityKey => {
                    const ability = ABILITIES[abilityKey];
                    if (ability && abilityKey !== 'EFFICIENT') {
                        newTier += ability.tier;
                    }
                });
            }

            // If slot is filled, subtract the old component's contribution
            if (mech.loadout[slotName]) {
                const oldComp = mech.loadout[slotName];
                let oldTier = oldComp.tier;
                if (oldComp.abilities) {
                    oldComp.abilities.forEach(abilityKey => {
                        const ability = ABILITIES[abilityKey];
                        if (ability && abilityKey !== 'EFFICIENT') {
                            oldTier += ability.tier;
                        }
                    });
                }
                newTier -= oldTier;
            }

            // Apply SCAVENGER relic - +3 inventory slots
            let tierCap = mech.tierCapacity;
            if (game.relics && game.relics.includes('SCAVENGER')) {
                tierCap += 10; // Extra tier budget
            }

            if (newTier > tierCap) return false;

            return true;
        }

        function attachComponent(mech, component, slotName) {
            if (!canAttachComponent(mech, component, slotName)) {
                return false;
            }

            // Remove from old slot if it's already attached
            Object.keys(mech.loadout).forEach(key => {
                if (mech.loadout[key]?.id === component.id) {
                    delete mech.loadout[key];
                }
            });

            // Remove old component from slot and return it to inventory
            if (mech.loadout[slotName]) {
                const oldComp = mech.loadout[slotName];
                game.inventory.push(oldComp);
            }

            // Attach new component
            mech.loadout[slotName] = component;

            // Remove from inventory
            const invIndex = game.inventory.findIndex(c => c.id === component.id);
            if (invIndex !== -1) {
                game.inventory.splice(invIndex, 1);
            }

            game.save();
            return true;
        }

        function detachComponent(mech, slotName) {
            if (mech.loadout[slotName]) {
                const component = mech.loadout[slotName];
                game.inventory.push(component);
                delete mech.loadout[slotName];
                game.save();
                return true;
            }
            return false;
        }

        // ============================================================================
        // MONSTER GENERATION
        // ============================================================================

        function generateMonster(round) {
            const difficultyMultiplier = 1 + ((round - 1) * 0.2);
            const isBoss = round % 5 === 0;

            if (isBoss) {
                // Boss fight every 5 rounds
                const bossTypes = [
                    {
                        name: 'FORTRESS TITAN',
                        visual: 'üè∞',
                        hp: 200,
                        damage: 20,
                        armor: 40,
                        special: 'ARMORED',
                        desc: 'Massive armor - Energy weapons recommended!'
                    },
                    {
                        name: 'PLASMA STORM',
                        visual: '‚ö°',
                        hp: 120,
                        damage: 45,
                        armor: 5,
                        special: 'SHIELD_IGNORE',
                        desc: 'Ignores shields and armor!'
                    },
                    {
                        name: 'BERSERKER PRIME',
                        visual: 'üòà',
                        hp: 150,
                        damage: 25,
                        armor: 10,
                        special: 'RAGE',
                        desc: 'Gains damage as HP drops!'
                    },
                    {
                        name: 'MIRROR WRAITH',
                        visual: 'üëª',
                        hp: 100,
                        damage: 30,
                        armor: 10,
                        special: 'REFLECT',
                        desc: 'Reflects 50% of damage taken!'
                    }
                ];

                const boss = bossTypes[Math.floor(Math.random() * bossTypes.length)];
                return {
                    name: boss.name,
                    visual: boss.visual,
                    maxHP: Math.floor(boss.hp * difficultyMultiplier),
                    currentHP: Math.floor(boss.hp * difficultyMultiplier),
                    damage: Math.floor(boss.damage * difficultyMultiplier),
                    armor: Math.floor(boss.armor * difficultyMultiplier),
                    speed: 50 + Math.floor(Math.random() * 30),
                    special: boss.special,
                    isBoss: true,
                    description: boss.desc
                };
            } else {
                // Regular enemies with variety
                const monsterTypes = [
                    { name: 'Scrap Bot', visual: 'ü§ñ', hp: 60, damage: 15, armor: 5, special: null },
                    { name: 'War Drone', visual: 'üëæ', hp: 80, damage: 20, armor: 8, special: 'FAST' },
                    { name: 'Battle Mech', visual: 'ü¶æ', hp: 100, damage: 25, armor: 10, special: null },
                    { name: 'Tank Unit', visual: 'üöõ', hp: 120, damage: 18, armor: 15, special: 'ARMORED' },
                    { name: 'Hunter Killer', visual: 'üíÄ', hp: 70, damage: 35, armor: 5, special: 'CRITICAL' },
                    { name: 'Shield Bot', visual: 'üõ°Ô∏è', hp: 90, damage: 18, armor: 8, special: 'SHIELD' }
                ];

                const baseMonster = monsterTypes[Math.floor(Math.random() * monsterTypes.length)];

                return {
                    name: `${baseMonster.name} Mk.${Math.ceil(round / 2)}`,
                    visual: baseMonster.visual,
                    maxHP: Math.floor(baseMonster.hp * difficultyMultiplier),
                    currentHP: Math.floor(baseMonster.hp * difficultyMultiplier),
                    damage: Math.floor(baseMonster.damage * difficultyMultiplier),
                    armor: Math.floor(baseMonster.armor * difficultyMultiplier),
                    speed: 50 + Math.floor(Math.random() * 30),
                    special: baseMonster.special,
                    isBoss: false
                };
            }
        }

        // ============================================================================
        // BABYLON.JS + HAVOK PHYSICS COMBAT VISUALIZATION SYSTEM
        // ============================================================================

        class PhysicsEngine {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.canvasId = canvasId;

                // Canvas dimensions
                this.width = 800;
                this.height = 450;

                // Animation settings
                this.running = false;
                this.effectsEnabled = true;
                this.timeScale = 1;

                // Babylon.js objects
                this.babylonEngine = null;
                this.scene = null;
                this.camera = null;
                this.havokPlugin = null;
                this.havokInstance = null;

                // Entities
                this.playerMech = null;
                this.enemyMech = null;
                this.terrain = [];
                this.projectiles = [];
                this.particles = [];
                this.laserBeams = [];
                this.damageNumbers = [];

                // Camera shake
                this.cameraShake = { x: 0, y: 0, intensity: 0 };
                this.cameraBasePosition = null;

                // Colors (as Babylon Color3 objects will be created on init)
                this.colors = {
                    player: '#00ff88',
                    enemy: '#ff4444',
                    terrain: '#4a4a6a',
                    explosion: '#ff6600',
                    energy: '#00ccff',
                    kinetic: '#ffaa00',
                    background: '#0d0d1f',
                    sky: '#1a1a3e'
                };

                // Initialize async
                this.initialized = false;
                this.initPromise = this.initBabylon();
            }

            async initBabylon() {
                try {
                    // Create Babylon engine
                    this.babylonEngine = new BABYLON.Engine(this.canvas, true, {
                        preserveDrawingBuffer: true,
                        stencil: true
                    });

                    // Initialize Havok Physics
                    this.havokInstance = await HavokPhysics();
                    console.log('Babylon.js + Havok Physics initialized!');

                    // Create scene
                    this.scene = this.createScene();

                    // Setup render loop
                    this.setupRenderLoop();

                    // Handle resize
                    window.addEventListener('resize', () => {
                        if (this.babylonEngine) {
                            this.babylonEngine.resize();
                        }
                    });

                    this.initialized = true;
                    console.log('Babylon.js Physics Engine fully initialized');
                } catch (error) {
                    console.error('Failed to initialize Babylon.js:', error);
                    // Fallback message on canvas
                    const ctx = this.canvas.getContext('2d');
                    ctx.fillStyle = '#1a1a2e';
                    ctx.fillRect(0, 0, this.width, this.height);
                    ctx.fillStyle = '#ff4444';
                    ctx.font = '16px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('Failed to load 3D engine. Please refresh.', this.width/2, this.height/2);
                }
            }

            createScene() {
                const scene = new BABYLON.Scene(this.babylonEngine);
                scene.clearColor = new BABYLON.Color3(0.05, 0.05, 0.12);

                // Enable Havok physics
                this.havokPlugin = new BABYLON.HavokPlugin(true, this.havokInstance);
                scene.enablePhysics(new BABYLON.Vector3(0, -15, 0), this.havokPlugin);

                // Create isometric-style camera (fixed angle view)
                this.camera = new BABYLON.ArcRotateCamera(
                    'camera',
                    -Math.PI / 2,      // Alpha: horizontal rotation (facing front)
                    Math.PI / 4,       // Beta: vertical angle (45 degrees - good isometric view)
                    18,                // Radius: distance from target
                    new BABYLON.Vector3(0, 3, 0),  // Target point (centered on mechs)
                    scene
                );
                this.camera.attachControl(this.canvas, true); // Enable user rotation for debugging
                this.camera.lowerRadiusLimit = 10;
                this.camera.upperRadiusLimit = 40;
                this.cameraBasePosition = this.camera.position.clone();

                // Lighting
                const hemiLight = new BABYLON.HemisphericLight(
                    'hemiLight',
                    new BABYLON.Vector3(0, 1, 0),
                    scene
                );
                hemiLight.intensity = 0.6;

                const dirLight = new BABYLON.DirectionalLight(
                    'dirLight',
                    new BABYLON.Vector3(-0.5, -1, 0.5),
                    scene
                );
                dirLight.intensity = 0.4;

                // Create terrain
                this.createTerrain();

                return scene;
            }

            createTerrain() {
                if (!this.scene) return;

                // Create ground plane
                const ground = BABYLON.MeshBuilder.CreateGround('ground', {
                    width: 25,
                    height: 12
                }, this.scene);

                const groundMat = new BABYLON.StandardMaterial('groundMat', this.scene);
                groundMat.diffuseColor = this.hexToColor3(this.colors.terrain);
                groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                ground.material = groundMat;

                // Add physics to ground (static)
                new BABYLON.PhysicsAggregate(
                    ground,
                    BABYLON.PhysicsShapeType.BOX,
                    { mass: 0, friction: 0.8, restitution: 0.1 },
                    this.scene
                );

                // Create boundary walls (invisible)
                this.createWalls();

                // Create some destructible terrain blocks
                const blockCount = 10;
                for (let i = 0; i < blockCount; i++) {
                    const x = -8 + (i % 5) * 4 + (Math.random() - 0.5) * 2;
                    const z = -3 + Math.floor(i / 5) * 6 + (Math.random() - 0.5);
                    const y = 0.5 + Math.random() * 0.5;
                    const size = 0.4 + Math.random() * 0.3;

                    const block = BABYLON.MeshBuilder.CreateBox('terrain_' + i, {
                        width: size, height: size, depth: size
                    }, this.scene);
                    block.position = new BABYLON.Vector3(x, y, z);

                    const blockMat = new BABYLON.StandardMaterial('blockMat_' + i, this.scene);
                    blockMat.diffuseColor = this.hexToColor3(this.colors.terrain).scale(0.8 + Math.random() * 0.4);
                    block.material = blockMat;

                    // Add physics
                    const blockAggregate = new BABYLON.PhysicsAggregate(
                        block,
                        BABYLON.PhysicsShapeType.BOX,
                        { mass: 2, friction: 0.6, restitution: 0.3 },
                        this.scene
                    );

                    block.physicsAggregate = blockAggregate;
                    block.isDestructible = true;
                    this.terrain.push(block);
                }
            }

            createWalls() {
                if (!this.scene) return;

                const wallHeight = 6;
                const arenaWidth = 25;
                const arenaDepth = 12;

                const wallMat = new BABYLON.StandardMaterial('wallMat', this.scene);
                wallMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.3);
                wallMat.alpha = 0.2;

                // Left wall
                const leftWall = BABYLON.MeshBuilder.CreateBox('leftWall', {
                    width: 0.5, height: wallHeight, depth: arenaDepth
                }, this.scene);
                leftWall.position = new BABYLON.Vector3(-arenaWidth/2, wallHeight/2, 0);
                leftWall.material = wallMat;
                new BABYLON.PhysicsAggregate(leftWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, this.scene);

                // Right wall
                const rightWall = BABYLON.MeshBuilder.CreateBox('rightWall', {
                    width: 0.5, height: wallHeight, depth: arenaDepth
                }, this.scene);
                rightWall.position = new BABYLON.Vector3(arenaWidth/2, wallHeight/2, 0);
                rightWall.material = wallMat;
                new BABYLON.PhysicsAggregate(rightWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, this.scene);

                // Back wall
                const backWall = BABYLON.MeshBuilder.CreateBox('backWall', {
                    width: arenaWidth, height: wallHeight, depth: 0.5
                }, this.scene);
                backWall.position = new BABYLON.Vector3(0, wallHeight/2, -arenaDepth/2);
                backWall.material = wallMat;
                new BABYLON.PhysicsAggregate(backWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, this.scene);

                // Front wall (mostly invisible)
                const frontWall = BABYLON.MeshBuilder.CreateBox('frontWall', {
                    width: arenaWidth, height: wallHeight, depth: 0.5
                }, this.scene);
                frontWall.position = new BABYLON.Vector3(0, wallHeight/2, arenaDepth/2);
                frontWall.material = wallMat;
                frontWall.visibility = 0.1;
                new BABYLON.PhysicsAggregate(frontWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, this.scene);
            }

            // Helper to convert hex color to Babylon Color3
            hexToColor3(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                if (result) {
                    return new BABYLON.Color3(
                        parseInt(result[1], 16) / 255,
                        parseInt(result[2], 16) / 255,
                        parseInt(result[3], 16) / 255
                    );
                }
                return new BABYLON.Color3(0.5, 0.5, 0.5);
            }

            createMech(type, x, y, isPlayer) {
                if (!this.scene) return null;

                // Convert 2D coordinates to 3D (x stays, y becomes height, z=0)
                // Scale down from pixel coords to 3D world units
                const worldX = (x - 400) / 50;  // Center around 0, scale down
                const worldZ = 0;

                // Size based on mech class
                let scale = 1;
                if (type === 'Light') scale = 0.8;
                if (type === 'Heavy') scale = 1.2;

                // Calculate leg length to ensure mech doesn't spawn in ground
                // Legs extend: hip(-0.65) + upperLeg(-0.4) + lowerLeg(-0.65) + foot(-0.3) + foot half height(-0.06)
                const legLength = 2.06 * scale;  // Distance from torso center to foot bottom
                const headHeight = 1.1 * scale;  // Distance from torso center to head top

                // Physics body height covers from foot bottom to head top
                const physicsHeight = legLength + headHeight;  // Total standing height

                // When physics body lands, its center will be at physicsHeight/2
                // We want torso center to be at legLength above ground
                // So spawn high enough to fall and land properly
                const worldY = 6.0;  // Spawn height - will fall and settle correctly

                const mechName = isPlayer ? 'player' : 'enemy';
                const color = isPlayer ? this.hexToColor3(this.colors.player) : this.hexToColor3(this.colors.enemy);
                const darkColor = color.scale(0.6);

                // Create materials
                const bodyMat = new BABYLON.StandardMaterial(`${mechName}_bodyMat`, this.scene);
                bodyMat.diffuseColor = color;
                bodyMat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                bodyMat.emissiveColor = color.scale(0.15);

                const darkMat = new BABYLON.StandardMaterial(`${mechName}_darkMat`, this.scene);
                darkMat.diffuseColor = darkColor;

                const jointMat = new BABYLON.StandardMaterial(`${mechName}_jointMat`, this.scene);
                jointMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                jointMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);

                // === PHYSICS BODY (invisible, represents full mech standing height) ===
                // This ensures the mech's feet land on the ground, not clip through
                const physicsBody = BABYLON.MeshBuilder.CreateBox(`${mechName}_physicsBody`, {
                    width: 0.8 * scale, height: physicsHeight, depth: 0.5 * scale
                }, this.scene);
                physicsBody.position = new BABYLON.Vector3(worldX, worldY, worldZ);
                physicsBody.visibility = 0;  // Invisible

                // Add physics to the standing body
                const torsoAggregate = new BABYLON.PhysicsAggregate(
                    physicsBody,
                    BABYLON.PhysicsShapeType.BOX,
                    { mass: 40 * scale, friction: 0.8, restitution: 0.1 },
                    this.scene
                );

                // Limit rotation to stay upright
                torsoAggregate.body.setAngularDamping(0.95);

                // === TORSO (Visual, parented to physics body) ===
                const torso = BABYLON.MeshBuilder.CreateBox(`${mechName}_torso`, {
                    width: 1.0 * scale, height: 1.2 * scale, depth: 0.6 * scale
                }, this.scene);
                // Offset torso within physics body so feet align with bottom
                // Physics body center is at middle of physicsHeight
                // Torso should be at (legLength - physicsHeight/2) above physics center
                const torsoOffset = legLength - (physicsHeight / 2);
                torso.position = new BABYLON.Vector3(0, torsoOffset, 0);
                torso.parent = physicsBody;
                torso.material = bodyMat;

                // === HEAD ===
                const head = BABYLON.MeshBuilder.CreateBox(`${mechName}_head`, {
                    width: 0.5 * scale, height: 0.4 * scale, depth: 0.4 * scale
                }, this.scene);
                head.position = new BABYLON.Vector3(0, 0.9 * scale, 0);
                head.parent = torso;
                head.material = bodyMat;

                // Visor (glowing)
                const visor = BABYLON.MeshBuilder.CreateBox(`${mechName}_visor`, {
                    width: 0.4 * scale, height: 0.12 * scale, depth: 0.08 * scale
                }, this.scene);
                visor.position = new BABYLON.Vector3(0, 0.08 * scale, 0.18 * scale);
                visor.parent = head;
                const visorMat = new BABYLON.StandardMaterial(`${mechName}_visorMat`, this.scene);
                visorMat.diffuseColor = new BABYLON.Color3(1, 0.2, 0);
                visorMat.emissiveColor = new BABYLON.Color3(1, 0.2, 0);
                visor.material = visorMat;

                // === ARMS ===
                const createArm = (side) => {
                    const xOffset = side === 'left' ? -0.7 * scale : 0.7 * scale;

                    // Upper arm
                    const upperArm = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}UpperArm`, {
                        width: 0.2 * scale, height: 0.5 * scale, depth: 0.2 * scale
                    }, this.scene);
                    upperArm.position = new BABYLON.Vector3(xOffset, 0.25 * scale, 0);
                    upperArm.parent = torso;
                    upperArm.material = darkMat;

                    // Shoulder joint
                    const shoulder = BABYLON.MeshBuilder.CreateSphere(`${mechName}_${side}Shoulder`, {
                        diameter: 0.25 * scale
                    }, this.scene);
                    shoulder.position = new BABYLON.Vector3(xOffset, 0.5 * scale, 0);
                    shoulder.parent = torso;
                    shoulder.material = jointMat;

                    // Weapon / Lower arm
                    const weapon = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}Weapon`, {
                        width: 0.15 * scale, height: 0.6 * scale, depth: 0.15 * scale
                    }, this.scene);
                    weapon.position = new BABYLON.Vector3(0, -0.55 * scale, 0);
                    weapon.parent = upperArm;
                    weapon.material = jointMat;

                    // Weapon barrel
                    const barrel = BABYLON.MeshBuilder.CreateCylinder(`${mechName}_${side}Barrel`, {
                        height: 0.3 * scale, diameter: 0.1 * scale
                    }, this.scene);
                    barrel.rotation.x = Math.PI / 2;
                    barrel.position = new BABYLON.Vector3(0, -0.2 * scale, 0.18 * scale);
                    barrel.parent = weapon;
                    barrel.material = jointMat;

                    return { upperArm, shoulder, weapon, barrel };
                };

                const leftArm = createArm('left');
                const rightArm = createArm('right');

                // === LEGS ===
                const createLeg = (side) => {
                    const xOffset = side === 'left' ? -0.3 * scale : 0.3 * scale;

                    // Hip joint
                    const hip = BABYLON.MeshBuilder.CreateSphere(`${mechName}_${side}Hip`, {
                        diameter: 0.2 * scale
                    }, this.scene);
                    hip.position = new BABYLON.Vector3(xOffset, -0.65 * scale, 0);
                    hip.parent = torso;
                    hip.material = jointMat;

                    // Upper leg
                    const upperLeg = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}UpperLeg`, {
                        width: 0.25 * scale, height: 0.55 * scale, depth: 0.25 * scale
                    }, this.scene);
                    upperLeg.position = new BABYLON.Vector3(xOffset, -1.05 * scale, 0);
                    upperLeg.parent = torso;
                    upperLeg.material = bodyMat;

                    // Knee joint
                    const knee = BABYLON.MeshBuilder.CreateSphere(`${mechName}_${side}Knee`, {
                        diameter: 0.18 * scale
                    }, this.scene);
                    knee.position = new BABYLON.Vector3(0, -0.35 * scale, 0);
                    knee.parent = upperLeg;
                    knee.material = jointMat;

                    // Lower leg
                    const lowerLeg = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}LowerLeg`, {
                        width: 0.2 * scale, height: 0.5 * scale, depth: 0.2 * scale
                    }, this.scene);
                    lowerLeg.position = new BABYLON.Vector3(0, -0.65 * scale, 0);
                    lowerLeg.parent = upperLeg;
                    lowerLeg.material = darkMat;

                    // Foot
                    const foot = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}Foot`, {
                        width: 0.3 * scale, height: 0.12 * scale, depth: 0.4 * scale
                    }, this.scene);
                    foot.position = new BABYLON.Vector3(0, -0.3 * scale, 0.08 * scale);
                    foot.parent = lowerLeg;
                    foot.material = jointMat;

                    return { hip, upperLeg, knee, lowerLeg, foot };
                };

                const leftLeg = createLeg('left');
                const rightLeg = createLeg('right');

                // === SHOULDER ARMOR ===
                const createShoulderArmor = (side) => {
                    const xOffset = side === 'left' ? -0.65 * scale : 0.65 * scale;
                    const armor = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}ShoulderArmor`, {
                        width: 0.4 * scale, height: 0.28 * scale, depth: 0.5 * scale
                    }, this.scene);
                    armor.position = new BABYLON.Vector3(xOffset, 0.6 * scale, 0);
                    armor.parent = torso;
                    armor.material = bodyMat;
                    return armor;
                };

                createShoulderArmor('left');
                createShoulderArmor('right');

                // Store mech data with compatibility properties for battle system
                const mechData = {
                    // Babylon.js specific
                    physicsBody: physicsBody,  // The physics-enabled mesh
                    torsoMesh: torso,          // Visual torso (for projectile targeting)
                    torsoAggregate: torsoAggregate,
                    head: head,
                    visor: visor,
                    leftArm: leftArm,
                    rightArm: rightArm,
                    leftLeg: leftLeg,
                    rightLeg: rightLeg,

                    // Compatibility with old Matter.js API (use physicsBody for position)
                    torso: {
                        position: {
                            get x() { return physicsBody.position.x * 50 + 400; },  // Convert back to pixel coords
                            get y() { return (5 - physicsBody.position.y) * 50; },
                            set x(val) { physicsBody.position.x = (val - 400) / 50; },
                            set y(val) { physicsBody.position.y = 5 - val / 50; }
                        },
                        angle: 0
                    },

                    // Visual properties
                    color: isPlayer ? this.colors.player : this.colors.enemy,
                    scale: scale,
                    isRagdoll: false,
                    isPlayer: isPlayer,

                    // Methods for position access (use physicsBody)
                    getPosition: () => physicsBody.position.clone(),
                    setPosition: (pos) => {
                        physicsBody.position = pos;
                        torsoAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                        torsoAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());
                    }
                };

                console.log(`Created ${isPlayer ? 'player' : 'enemy'} mech at (${worldX.toFixed(2)}, ${worldY.toFixed(2)})`);
                return mechData;
            }

            fireProjectile(fromMech, toMech, weaponType, damage) {
                if (!this.scene || !fromMech || !toMech) return null;

                // Get 3D positions from mechs (use absolute position since torsoMesh is a child)
                const startPos = fromMech.torsoMesh ? fromMech.torsoMesh.getAbsolutePosition().clone() :
                                 new BABYLON.Vector3((fromMech.torso.position.x - 400) / 50, 2.5, 0);
                const targetPos = toMech.torsoMesh ? toMech.torsoMesh.getAbsolutePosition().clone() :
                                  new BABYLON.Vector3((toMech.torso.position.x - 400) / 50, 2.5, 0);

                // Adjust start position to weapon mount
                startPos.y += 0.3;

                // Handle ENERGY weapons (instant beam)
                if (weaponType === 'ENERGY') {
                    this.createEnergyBeam(startPos, targetPos, damage);
                    if (toMech.battleSystem) {
                        toMech.battleSystem.applyDamageToMech(toMech, damage, 'ENERGY');
                    }
                    this.createImpactEffect(targetPos, weaponType);
                    return null;
                }

                // Create projectile mesh
                const projSize = weaponType === 'EXPLOSIVE' ? 0.15 : 0.08;
                const projectileMesh = BABYLON.MeshBuilder.CreateSphere('projectile_' + Date.now(), {
                    diameter: projSize
                }, this.scene);
                projectileMesh.position = startPos.clone();

                // Projectile material with glow
                const projMat = new BABYLON.StandardMaterial('projMat_' + Date.now(), this.scene);
                const projColor = weaponType === 'EXPLOSIVE' ?
                    this.hexToColor3(this.colors.explosion) : this.hexToColor3(this.colors.kinetic);
                projMat.diffuseColor = projColor;
                projMat.emissiveColor = projColor;
                projectileMesh.material = projMat;

                // Add physics to projectile
                const projAggregate = new BABYLON.PhysicsAggregate(
                    projectileMesh,
                    BABYLON.PhysicsShapeType.SPHERE,
                    { mass: weaponType === 'EXPLOSIVE' ? 1 : 0.3, friction: 0, restitution: 0.3 },
                    this.scene
                );

                // Calculate velocity
                const direction = targetPos.subtract(startPos).normalize();
                const speed = weaponType === 'EXPLOSIVE' ? 12 : 18;
                const velocity = direction.scale(speed);

                // Add arc for explosive
                if (weaponType === 'EXPLOSIVE') {
                    velocity.y += 4;
                }

                projAggregate.body.setLinearVelocity(velocity);

                // Store projectile data
                const projectileData = {
                    mesh: projectileMesh,
                    aggregate: projAggregate,
                    damage: damage,
                    type: weaponType,
                    target: toMech,
                    firedAt: Date.now(),
                    fromPlayer: fromMech.isPlayer
                };

                this.projectiles.push(projectileData);
                return projectileData;
            }

            createEnergyBeam(startPos, endPos, damage) {
                if (!this.scene) return;

                // Create laser beam tube
                const points = [startPos, endPos];
                const laserBeam = BABYLON.MeshBuilder.CreateTube('laser_' + Date.now(), {
                    path: points,
                    radius: 0.06,
                    updatable: false
                }, this.scene);

                // Laser material with glow
                const laserMat = new BABYLON.StandardMaterial('laserMat_' + Date.now(), this.scene);
                const laserColor = this.hexToColor3(this.colors.energy);
                laserMat.diffuseColor = laserColor;
                laserMat.emissiveColor = laserColor;
                laserMat.alpha = 0.9;
                laserBeam.material = laserMat;

                // Store for fadeout
                this.laserBeams.push({
                    mesh: laserBeam,
                    material: laserMat,
                    createdAt: Date.now(),
                    duration: 200
                });

                // Apply visual impact at target
                this.createImpactEffect(endPos, 'ENERGY');
            }

            // Update projectiles each frame (called from render loop)
            updateProjectiles() {
                const now = Date.now();

                this.projectiles = this.projectiles.filter(proj => {
                    // Remove old projectiles (after 5 seconds)
                    if (now - proj.firedAt > 5000) {
                        proj.mesh.dispose();
                        return false;
                    }

                    // Check for collision with target
                    if (proj.target && proj.target.torsoMesh) {
                        const projPos = proj.mesh.position;
                        const targetPos = proj.target.torsoMesh.getAbsolutePosition();
                        const distance = BABYLON.Vector3.Distance(projPos, targetPos);

                        if (distance < 1.2) {
                            // Hit!
                            this.applyPhysicalImpact(proj.target, proj.damage, proj.type);

                            // Apply gameplay damage through battle system
                            if (proj.battleSystem) {
                                proj.battleSystem.applyDamageToMech(proj.target, proj.damage, proj.type);
                            }

                            this.createImpactEffect(projPos.clone(), proj.type);

                            if (proj.type === 'EXPLOSIVE') {
                                this.createExplosion(projPos.clone(), 2);
                            }

                            proj.mesh.dispose();
                            return false;
                        }
                    }

                    // Check if projectile is out of bounds
                    const pos = proj.mesh.position;
                    if (pos.y < -2 || Math.abs(pos.x) > 15 || Math.abs(pos.z) > 8) {
                        if (proj.type === 'EXPLOSIVE') {
                            this.createExplosion(pos.clone(), 1.5);
                        }
                        proj.mesh.dispose();
                        return false;
                    }

                    return true;
                });

                // Update laser beams (fade out)
                this.laserBeams = this.laserBeams.filter(beam => {
                    const age = now - beam.createdAt;
                    if (age > beam.duration) {
                        beam.mesh.dispose();
                        return false;
                    }
                    beam.material.alpha = 0.9 * (1 - age / beam.duration);
                    return true;
                });
            }

            applyPhysicalImpact(mech, damage, type) {
                if (!mech || !mech.torsoAggregate) return;

                // Calculate knockback force
                const forceMag = type === 'EXPLOSIVE' ? 8 :
                                type === 'KINETIC' ? 4 : 2;

                const direction = mech.isPlayer ? -1 : 1;

                // Apply impulse to physics body
                const impulse = new BABYLON.Vector3(
                    direction * forceMag * (1 + Math.random() * 0.3),
                    forceMag * 0.3,
                    (Math.random() - 0.5) * 2
                );

                mech.torsoAggregate.body.applyImpulse(
                    impulse,
                    mech.torsoMesh.getAbsolutePosition()
                );

                // Camera shake
                this.addCameraShake(damage / 15);
            }

            enableRagdoll(mech) {
                if (!mech) return;

                mech.isRagdoll = true;

                // Apply random torque for tumble effect
                if (mech.torsoAggregate) {
                    const randomTorque = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 5,
                        (Math.random() - 0.5) * 3,
                        (Math.random() - 0.5) * 5
                    );
                    mech.torsoAggregate.body.setAngularVelocity(randomTorque);
                }

                // Auto-recover after time
                setTimeout(() => {
                    if (mech.torsoAggregate) {
                        mech.torsoAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());
                    }
                    mech.isRagdoll = false;
                }, 2000);
            }

            createExplosion(positionOrX, radiusOrY, radiusArg) {
                if (!this.scene) return;

                // Handle both old API (x, y, radius) and new API (Vector3, radius)
                let position;
                let radius;
                if (positionOrX instanceof BABYLON.Vector3) {
                    position = positionOrX;
                    radius = radiusOrY / 50; // Scale down from pixel to 3D units
                } else {
                    // Convert old 2D pixel coords to 3D world position
                    const x = (positionOrX - 400) / 50;
                    const y = 2.5; // Fixed height
                    position = new BABYLON.Vector3(x, y, 0);
                    radius = (radiusArg || radiusOrY) / 50; // Scale radius
                }

                // Create particle system for explosion
                const particleSystem = new BABYLON.ParticleSystem('explosion_' + Date.now(), 100, this.scene);

                // Use built-in flare texture
                particleSystem.particleTexture = new BABYLON.Texture('https://assets.babylonjs.com/textures/flare.png', this.scene);

                // Emitter
                particleSystem.emitter = position;
                particleSystem.minEmitBox = new BABYLON.Vector3(-0.2, -0.2, -0.2);
                particleSystem.maxEmitBox = new BABYLON.Vector3(0.2, 0.2, 0.2);

                // Colors
                particleSystem.color1 = new BABYLON.Color4(1, 0.5, 0, 1);
                particleSystem.color2 = new BABYLON.Color4(1, 0.2, 0, 1);
                particleSystem.colorDead = new BABYLON.Color4(0.3, 0.1, 0, 0);

                // Size
                particleSystem.minSize = 0.2 * radius;
                particleSystem.maxSize = 0.5 * radius;

                // Lifetime
                particleSystem.minLifeTime = 0.2;
                particleSystem.maxLifeTime = 0.5;

                // Emission
                particleSystem.emitRate = 500;
                particleSystem.manualEmitCount = 60;

                // Speed
                particleSystem.minEmitPower = 3 * radius;
                particleSystem.maxEmitPower = 6 * radius;
                particleSystem.updateSpeed = 0.02;

                // Direction (spherical)
                particleSystem.direction1 = new BABYLON.Vector3(-1, 1, -1);
                particleSystem.direction2 = new BABYLON.Vector3(1, 1, 1);

                // Gravity
                particleSystem.gravity = new BABYLON.Vector3(0, -8, 0);

                // Start and auto-dispose
                particleSystem.start();
                particleSystem.targetStopDuration = 0.4;
                particleSystem.disposeOnStop = true;

                // Apply force to nearby terrain blocks
                this.terrain.forEach(block => {
                    if (block && block.physicsAggregate) {
                        const dist = BABYLON.Vector3.Distance(block.position, position);
                        if (dist < radius * 2) {
                            const dir = block.position.subtract(position).normalize();
                            const forceMag = Math.max(0, (radius * 2 - dist) / (radius * 2)) * 15;
                            block.physicsAggregate.body.applyImpulse(
                                dir.scale(forceMag),
                                block.position
                            );
                        }
                    }
                });

                this.addCameraShake(radius * 3);
            }

            createImpactEffect(position, type) {
                if (!this.scene) return;

                // Create particle system for impact
                const particleSystem = new BABYLON.ParticleSystem('impact_' + Date.now(), 30, this.scene);

                particleSystem.particleTexture = new BABYLON.Texture('https://assets.babylonjs.com/textures/flare.png', this.scene);

                // Emitter at position
                particleSystem.emitter = position instanceof BABYLON.Vector3 ? position :
                    new BABYLON.Vector3(position.x || 0, position.y || 0, position.z || 0);
                particleSystem.minEmitBox = new BABYLON.Vector3(-0.1, -0.1, -0.1);
                particleSystem.maxEmitBox = new BABYLON.Vector3(0.1, 0.1, 0.1);

                // Colors based on weapon type
                const colorHex = type === 'EXPLOSIVE' ? this.colors.explosion :
                                type === 'KINETIC' ? this.colors.kinetic : this.colors.energy;
                const color = this.hexToColor3(colorHex);

                particleSystem.color1 = new BABYLON.Color4(color.r, color.g, color.b, 1);
                particleSystem.color2 = new BABYLON.Color4(color.r * 0.7, color.g * 0.7, color.b * 0.7, 1);
                particleSystem.colorDead = new BABYLON.Color4(color.r * 0.3, color.g * 0.3, color.b * 0.3, 0);

                // Size
                particleSystem.minSize = 0.05;
                particleSystem.maxSize = 0.15;

                // Lifetime
                particleSystem.minLifeTime = 0.1;
                particleSystem.maxLifeTime = 0.25;

                // Emission
                particleSystem.emitRate = 100;
                particleSystem.manualEmitCount = 20;

                // Speed
                particleSystem.minEmitPower = 1;
                particleSystem.maxEmitPower = 3;
                particleSystem.updateSpeed = 0.02;

                // Direction
                particleSystem.direction1 = new BABYLON.Vector3(-1, 0.5, -1);
                particleSystem.direction2 = new BABYLON.Vector3(1, 1, 1);

                // Gravity
                particleSystem.gravity = new BABYLON.Vector3(0, -5, 0);

                // Start and auto-dispose
                particleSystem.start();
                particleSystem.targetStopDuration = 0.25;
                particleSystem.disposeOnStop = true;

                this.addCameraShake(1.5);
            }

            addCameraShake(intensity) {
                this.cameraShake.intensity += intensity;
            }

            updateCameraShake() {
                if (!this.camera || !this.cameraBasePosition) return;

                if (this.cameraShake.intensity > 0) {
                    // Apply shake to camera target
                    const shakeX = (Math.random() - 0.5) * this.cameraShake.intensity * 0.1;
                    const shakeY = (Math.random() - 0.5) * this.cameraShake.intensity * 0.1;

                    this.camera.target = new BABYLON.Vector3(shakeX, 3 + shakeY, 0);

                    // Decay
                    this.cameraShake.intensity *= 0.92;

                    if (this.cameraShake.intensity < 0.1) {
                        this.cameraShake.intensity = 0;
                        this.camera.target = new BABYLON.Vector3(0, 3, 0);
                    }
                }
            }

            setupRenderLoop() {
                if (!this.babylonEngine) return;

                this.babylonEngine.runRenderLoop(() => {
                    if (this.scene && this.running) {
                        // Update projectiles
                        this.updateProjectiles();

                        // Update camera shake
                        this.updateCameraShake();

                        // Update health bar displays
                        this.updateHealthBarDisplays();

                        // Render scene
                        this.scene.render();
                    } else if (this.scene) {
                        // Still render even when not "running" so scene is visible
                        this.scene.render();
                    }
                });
            }

            updateHealthBarDisplays() {
                // Update floating health bars using Babylon.js GUI or simple meshes
                // For now, health is tracked in the battle system UI
            }

            // Compatibility stubs for old canvas API - Babylon.js handles rendering
            renderBodies(bodies, ctx) {
                // No-op: Babylon.js renders all meshes automatically
            }

            renderMech(mech, ctx) {
                // No-op: 3D mechs are rendered by Babylon.js
            }

            renderMechLegs(mech, ctx, scale, baseColor, darkColor, lightColor) {
                // No-op: 3D mechs are rendered by Babylon.js
            }

            renderMechTorso(mech, ctx, scale, baseColor, darkColor, lightColor) {
                // No-op: 3D mechs are rendered by Babylon.js
            }

            renderMechArms(mech, ctx, scale, baseColor, darkColor, lightColor) {
                // No-op: 3D mechs are rendered by Babylon.js
            }

            renderMechHead(mech, ctx, scale, baseColor, darkColor, lightColor) {
                // No-op: 3D mechs are rendered by Babylon.js
            }

            renderShoulderWeapon(ctx, scale, component, darkColor) {
                // No-op: 3D mechs are rendered by Babylon.js
            }

            renderArmWeapon(ctx, scale, component, lightColor, darkColor) {
                // No-op: 3D mechs are rendered by Babylon.js
            }

            getWeaponColor(component) {
                if (!component || !component.damageType) return '#666';
                switch(component.damageType) {
                    case 'ENERGY': return '#00bfff';
                    case 'KINETIC': return '#808080';
                    case 'EXPLOSIVE': return '#ff6b35';
                    default: return '#666';
                }
            }

            renderParticles(ctx) {
                // No-op: Babylon.js ParticleSystem handles this
            }

            darkenColor(color, factor) {
                const hex = color.replace('#', '');
                const r = Math.max(0, Math.floor(parseInt(hex.substr(0, 2), 16) * factor));
                const g = Math.max(0, Math.floor(parseInt(hex.substr(2, 2), 16) * factor));
                const b = Math.max(0, Math.floor(parseInt(hex.substr(4, 2), 16) * factor));
                return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
            }

            lightenColor(color, factor) {
                const hex = color.replace('#', '');
                const r = Math.min(255, Math.floor(parseInt(hex.substr(0, 2), 16) * factor));
                const g = Math.min(255, Math.floor(parseInt(hex.substr(2, 2), 16) * factor));
                const b = Math.min(255, Math.floor(parseInt(hex.substr(4, 2), 16) * factor));
                return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
            }

            start() {
                this.running = true;
            }

            stop() {
                this.running = false;
            }

            async reset() {
                // Dispose of existing mechs
                if (this.playerMech && this.playerMech.torsoMesh) {
                    this.disposeMech(this.playerMech);
                }
                if (this.enemyMech && this.enemyMech.torsoMesh) {
                    this.disposeMech(this.enemyMech);
                }

                // Clear projectiles
                this.projectiles.forEach(p => {
                    if (p.mesh) p.mesh.dispose();
                });
                this.projectiles = [];

                // Clear laser beams
                this.laserBeams.forEach(b => {
                    if (b.mesh) b.mesh.dispose();
                });
                this.laserBeams = [];

                // Clear terrain blocks
                this.terrain.forEach(block => {
                    if (block && block.dispose) block.dispose();
                });
                this.terrain = [];

                this.playerMech = null;
                this.enemyMech = null;

                // Wait for Babylon to be initialized
                if (!this.initialized) {
                    await this.initPromise;
                }

                // Recreate terrain
                this.createTerrain();
            }

            disposeMech(mech) {
                if (!mech) return;

                // Dispose the main torso (and all children)
                if (mech.torsoMesh) {
                    // Get all child meshes first
                    const children = mech.torsoMesh.getChildMeshes();
                    children.forEach(child => {
                        if (child.material) child.material.dispose();
                        child.dispose();
                    });

                    // Dispose torso material and mesh
                    if (mech.torsoMesh.material) mech.torsoMesh.material.dispose();
                    if (mech.torsoAggregate) {
                        mech.torsoAggregate.dispose();
                    }
                    mech.torsoMesh.dispose();
                }
            }

            setTimeScale(scale) {
                this.timeScale = scale;
                // Havok doesn't have a direct time scale, but we can adjust update frequency
            }
        }
        // ============================================================================
        // PHYSICS BATTLE SYSTEM - Real-time physics-driven combat
        // ============================================================================

        class PhysicsBattleSystem {
            constructor(playerMech, monster, physicsEngine) {
                this.physics = physicsEngine;
                this.playerMechData = JSON.parse(JSON.stringify(playerMech));
                this.monsterData = JSON.parse(JSON.stringify(monster));
                this.log = [];

                // Battle state
                this.isActive = false;
                this.battleResult = null;

                // Combat stats
                this.playerStats = calculateMechStats(this.playerMechData);
                this.playerShield = 0;
                this.monsterShield = 0;
                this.playerDots = [];
                this.monsterDots = [];

                // Abilities and traits
                this.playerAbilities = this.collectAbilities(this.playerMechData);
                this.playerTraits = this.playerMechData.traits || [];

                // Weapon firing
                this.playerFireRate = 0;
                this.enemyFireRate = 0;
                this.lastPlayerShot = 0;
                this.lastEnemyShot = 0;

                // DoT timers
                this.dotInterval = null;
                this.regenInterval = null;

                // Physics mech references
                this.playerPhysMech = null;
                this.enemyPhysMech = null;
            }

            collectAbilities(mech) {
                const abilities = [];
                Object.values(mech.loadout || {}).forEach(comp => {
                    if (comp && comp.abilities) {
                        comp.abilities.forEach(abilityKey => {
                            if (ABILITIES[abilityKey]) {
                                abilities.push(abilityKey);
                            }
                        });
                    }
                });
                return abilities;
            }

            hasAbility(abilityKey) {
                return this.playerAbilities.includes(abilityKey);
            }

            hasTrait(traitName) {
                return this.playerTraits.some(t => t.name === traitName);
            }

            addLog(message, actor = 'system') {
                this.log.push({ message, actor, timestamp: Date.now() });
            }

            async initializeBattle() {
                // Wait for physics engine to reset (may need to initialize Babylon.js)
                await this.physics.reset();

                // Wait for Babylon.js to be ready if needed
                if (this.physics.initPromise && !this.physics.initialized) {
                    await this.physics.initPromise;
                }

                // Create physics mechs
                this.playerPhysMech = this.physics.createMech(
                    this.playerMechData.class,
                    200,
                    300,
                    true
                );

                this.enemyPhysMech = this.physics.createMech(
                    this.monsterData.class || 'Medium',
                    600,
                    300,
                    false
                );

                // Add battle stats to physics mechs
                this.playerPhysMech.currentHP = this.playerMechData.currentHP;
                this.playerPhysMech.maxHP = this.playerMechData.maxHP;
                this.playerPhysMech.stats = this.playerStats;
                this.playerPhysMech.battleSystem = this;
                this.playerPhysMech.isPlayer = true;
                this.playerPhysMech.loadout = this.playerMechData.loadout;
                this.playerPhysMech.mechClass = this.playerMechData.class;

                this.enemyPhysMech.currentHP = this.monsterData.currentHP;
                this.enemyPhysMech.maxHP = this.monsterData.maxHP;
                this.enemyPhysMech.stats = {
                    damage: this.monsterData.damage,
                    armor: this.monsterData.armor,
                    speed: this.monsterData.speed || 50
                };
                this.enemyPhysMech.battleSystem = this;
                this.enemyPhysMech.isPlayer = false;
                this.enemyPhysMech.special = this.monsterData.special;
                this.enemyPhysMech.loadout = this.monsterData.loadout || {};
                this.enemyPhysMech.mechClass = this.monsterData.class || 'Medium';

                // Apply start of battle effects
                this.applyStartOfBattleAbilities();
                this.applyMonsterSpecialInit();

                // Calculate fire rates (attacks per second based on speed)
                this.playerFireRate = 1000 + (100 - this.playerStats.speed) * 20; // Faster mechs shoot more often
                this.enemyFireRate = 1000 + (100 - (this.monsterData.speed || 50)) * 20;

                // Start physics
                this.physics.start();
                this.isActive = true;

                // Start combat loop
                this.startCombatLoop();

                // Start DoT ticking
                this.startDoTLoop();

                // Start regeneration
                if (this.hasAbility('REGENERATION')) {
                    this.startRegenLoop();
                }

                this.addLog('‚öîÔ∏è BATTLE START! ‚öîÔ∏è', 'system');
            }

            applyStartOfBattleAbilities() {
                // Shield Generator
                if (this.hasAbility('SHIELD_GEN')) {
                    let shieldAmount = 50;

                    if (game.relics && game.relics.includes('PERFECT_AEGIS')) {
                        const aegisCount = game.relics.filter(r => r === 'PERFECT_AEGIS').length;
                        const multiplier = Math.pow(3, aegisCount);
                        shieldAmount = Math.floor(shieldAmount * multiplier);
                        this.addLog(`üõ°Ô∏è PERFECT AEGIS: Shield multiplied ${multiplier}x!`, 'player');
                    }

                    this.playerShield = shieldAmount;
                    this.playerPhysMech.shield = shieldAmount;
                    this.addLog(`üõ°Ô∏è ENERGY SHIELD: Activated with ${shieldAmount} shield HP`, 'player');
                }
            }

            applyMonsterSpecialInit() {
                if (this.monsterData.special === 'SHIELD') {
                    this.monsterShield = 40;
                    this.enemyPhysMech.shield = 40;
                    this.addLog('üõ°Ô∏è Enemy activated energy shield! (40 shield)', 'monster');
                }

                if (this.monsterData.isBoss && this.monsterData.description) {
                    this.addLog(`‚ö†Ô∏è BOSS: ${this.monsterData.description}`, 'system');
                }
            }

            startCombatLoop() {
                const combatTick = () => {
                    if (!this.isActive) return;

                    const now = Date.now();

                    // Only fire if auto-fire is enabled
                    if (window.autoFireEnabled !== false) {
                        // Player auto-fire
                        if (now - this.lastPlayerShot > this.playerFireRate && this.playerPhysMech && this.enemyPhysMech) {
                            this.fireWeapon(this.playerPhysMech, this.enemyPhysMech, true);
                            this.lastPlayerShot = now;
                        }

                        // Enemy auto-fire
                        if (now - this.lastEnemyShot > this.enemyFireRate && this.playerPhysMech && this.enemyPhysMech) {
                            this.fireWeapon(this.enemyPhysMech, this.playerPhysMech, false);
                            this.lastEnemyShot = now;
                        }
                    }

                    // Check win conditions
                    this.checkBattleEnd();

                    // Continue loop
                    if (this.isActive) {
                        setTimeout(combatTick, 16); // ~60fps
                    }
                };

                combatTick();
            }

            startDoTLoop() {
                this.dotInterval = setInterval(() => {
                    if (!this.isActive) return;

                    // Apply player DoTs to enemy
                    this.playerDots = this.playerDots.filter(dot => {
                        this.applyDirectDamage(this.enemyPhysMech, dot.damage, false, 'DOT');
                        dot.duration--;
                        if (dot.duration === 0) {
                            this.addLog(`üî• ${dot.type.toUpperCase()} expired`, 'player');
                        }
                        return dot.duration > 0;
                    });

                    // Apply enemy DoTs to player
                    this.monsterDots = this.monsterDots.filter(dot => {
                        this.applyDirectDamage(this.playerPhysMech, dot.damage, false, 'DOT');
                        dot.duration--;
                        return dot.duration > 0;
                    });
                }, 1000);
            }

            startRegenLoop() {
                this.regenInterval = setInterval(() => {
                    if (!this.isActive) return;

                    const healAmount = 5;
                    this.playerPhysMech.currentHP = Math.min(
                        this.playerPhysMech.maxHP,
                        this.playerPhysMech.currentHP + healAmount
                    );
                    this.addLog(`üíö REGENERATION: Healed ${healAmount} HP`, 'player');
                }, 1000);
            }

            getDamageType(mech) {
                // Determine damage type from equipped components
                if (mech.isPlayer) {
                    const components = Object.values(this.playerMechData.loadout || {});
                    const types = components.map(c => c?.damageType).filter(Boolean);

                    if (types.includes('EXPLOSIVE')) return 'EXPLOSIVE';
                    if (types.includes('ENERGY')) return 'ENERGY';
                    return 'KINETIC';
                }
                return Math.random() > 0.5 ? 'KINETIC' : 'EXPLOSIVE';
            }

            fireWeapon(fromMech, toMech, isPlayer) {
                if (!fromMech || !toMech) return;

                const weaponType = this.getDamageType(fromMech);
                const baseDamage = isPlayer ? this.calculatePlayerDamage() : this.calculateEnemyDamage();

                // Create physics projectile with damage attached
                const projectile = this.physics.fireProjectile(fromMech, toMech, weaponType, baseDamage);

                // Store combat data on projectile for collision handling
                if (projectile) {
                    projectile.isPlayer = isPlayer;
                    projectile.fromMech = fromMech;
                    projectile.toMech = toMech;
                    projectile.battleSystem = this;
                }
            }

            calculatePlayerDamage() {
                let baseDamage = this.playerStats.damage;

                // Apply trait bonuses
                const hpPercent = (this.playerPhysMech.currentHP / this.playerPhysMech.maxHP) * 100;

                if (hpPercent < 30 && game.relics && game.relics.includes('LAST_STAND')) {
                    baseDamage *= 3;
                }

                if (this.hasTrait('BERSERKER')) {
                    const hpLostPercent = ((this.playerPhysMech.maxHP - this.playerPhysMech.currentHP) / this.playerPhysMech.maxHP) * 100;
                    const bonus = Math.floor(baseDamage * (hpLostPercent * 0.03));
                    baseDamage += bonus;
                }

                if (this.hasTrait('OVERCHARGED')) {
                    baseDamage *= 2;
                }

                return baseDamage;
            }

            calculateEnemyDamage() {
                let baseDamage = this.monsterData.damage;

                if (this.monsterData.special === 'RAGE') {
                    const hpLostPercent = ((this.enemyPhysMech.maxHP - this.enemyPhysMech.currentHP) / this.enemyPhysMech.maxHP) * 100;
                    const bonus = Math.floor(baseDamage * (hpLostPercent * 0.02));
                    baseDamage += bonus;
                }

                return baseDamage;
            }

            applyDamageToMech(mech, damage, weaponType) {
                const isPlayer = mech.isPlayer;
                const targetArmor = isPlayer ? this.playerStats.armor : this.monsterData.armor;
                let armor = targetArmor;

                // ARMORED enemy - double effective armor
                if (!isPlayer && this.monsterData.special === 'ARMORED') {
                    armor *= 2;
                }

                // Armor reduction (max 70% reduction)
                const armorReduction = Math.min(armor * 0.5, damage * 0.7);
                let actualDamage = Math.max(1, Math.floor(damage - armorReduction));

                // Critical strike check
                let isCrit = false;
                if (isPlayer && this.hasAbility('CRITICAL_STRIKE') && Math.random() < 0.25) {
                    actualDamage *= 2;
                    isCrit = true;
                }

                // Apply to shield first
                const shield = isPlayer ? this.playerShield : this.monsterShield;
                if (shield > 0) {
                    if (shield >= actualDamage) {
                        if (isPlayer) {
                            this.playerShield -= actualDamage;
                            mech.shield = this.playerShield;
                        } else {
                            this.monsterShield -= actualDamage;
                            mech.shield = this.monsterShield;
                        }
                        this.addLog(`üõ°Ô∏è Shield absorbed ${actualDamage} damage!`, isPlayer ? 'player' : 'monster');
                        return;
                    } else {
                        const overflow = actualDamage - shield;
                        this.addLog(`üõ°Ô∏è Shield absorbed ${shield} damage, ${overflow} passed through!`, isPlayer ? 'player' : 'monster');
                        if (isPlayer) {
                            this.playerShield = 0;
                            mech.shield = 0;
                        } else {
                            this.monsterShield = 0;
                            mech.shield = 0;
                        }
                        actualDamage = overflow;
                    }
                }

                // Apply to HP
                this.applyDirectDamage(mech, actualDamage, isCrit, weaponType);

                // Apply DoTs
                if (!isPlayer && this.hasAbility('BURN')) {
                    let burnDamage = 5;
                    let burnDuration = 3;

                    if (game.relics && game.relics.includes('CONTAGION')) {
                        const contagionCount = game.relics.filter(r => r === 'CONTAGION').length;
                        const multiplier = Math.pow(2, contagionCount);
                        burnDamage = Math.floor(burnDamage * multiplier);
                        burnDuration = Math.floor(burnDuration * multiplier);
                    }

                    this.playerDots.push({ type: 'burn', damage: burnDamage, duration: burnDuration });
                    this.addLog(`üî• PLASMA BURN: ${burnDamage} dmg/turn for ${burnDuration} turns`, 'player');
                }

                // Vampiric healing
                if (!isPlayer) {
                    let totalHealPercent = 0;
                    if (this.hasAbility('VAMPIRIC')) totalHealPercent += 0.25;
                    if (this.hasTrait('VAMPIRE')) totalHealPercent += 0.4;
                    if (game.relics && game.relics.includes('VAMPIRIC_ASCENSION')) {
                        totalHealPercent += 0.25 * game.relics.filter(r => r === 'VAMPIRIC_ASCENSION').length;
                    }
                    if (game.relics && game.relics.includes('BLOOD_PACT')) {
                        totalHealPercent += 0.5 * game.relics.filter(r => r === 'BLOOD_PACT').length;
                    }

                    if (totalHealPercent > 0) {
                        const heal = Math.floor(actualDamage * totalHealPercent);
                        this.playerPhysMech.currentHP = Math.min(this.playerPhysMech.maxHP, this.playerPhysMech.currentHP + heal);
                        this.addLog(`ü©∏ VAMPIRIC: Healed ${heal} HP (${Math.floor(totalHealPercent * 100)}%)`, 'player');
                    }
                }
            }

            applyDirectDamage(mech, damage, isCrit, source) {
                mech.currentHP -= damage;
                mech.currentHP = Math.max(0, mech.currentHP);

                const critText = isCrit ? ' üí• CRITICAL HIT!' : '';
                const actor = mech.isPlayer ? 'monster' : 'player';
                const target = mech.isPlayer ? 'Player' : 'Enemy';

                if (source !== 'DOT') {
                    this.addLog(`‚öîÔ∏è ${damage} damage dealt!${critText} (${target}: ${Math.max(0, mech.currentHP)}/${mech.maxHP} HP)`, actor);
                }

                // Heavy damage triggers ragdoll
                if (damage > 50 && !mech.isRagdoll) {
                    this.physics.enableRagdoll(mech);
                }
            }

            checkBattleEnd() {
                if (this.playerPhysMech && this.playerPhysMech.currentHP <= 0) {
                    this.endBattle('defeat');
                } else if (this.enemyPhysMech && this.enemyPhysMech.currentHP <= 0) {
                    this.endBattle('victory');
                }
            }

            endBattle(result) {
                if (this.battleResult) return; // Already ended

                this.isActive = false;
                this.battleResult = result;

                // Clear intervals
                if (this.dotInterval) clearInterval(this.dotInterval);
                if (this.regenInterval) clearInterval(this.regenInterval);

                // Death animation
                if (result === 'victory' && this.enemyPhysMech) {
                    this.physics.enableRagdoll(this.enemyPhysMech);
                    this.physics.createExplosion(
                        this.enemyPhysMech.torso.position.x,
                        this.enemyPhysMech.torso.position.y,
                        120
                    );
                } else if (result === 'defeat' && this.playerPhysMech) {
                    this.physics.enableRagdoll(this.playerPhysMech);
                    this.physics.createExplosion(
                        this.playerPhysMech.torso.position.x,
                        this.playerPhysMech.torso.position.y,
                        120
                    );
                }

                this.addLog(result === 'victory' ? 'üéâ VICTORY!' : 'üíÄ DEFEAT!', 'system');
            }

            getState() {
                return {
                    playerMech: {
                        currentHP: this.playerPhysMech ? this.playerPhysMech.currentHP : 0,
                        maxHP: this.playerPhysMech ? this.playerPhysMech.maxHP : 0
                    },
                    monster: {
                        currentHP: this.enemyPhysMech ? this.enemyPhysMech.currentHP : 0,
                        maxHP: this.enemyPhysMech ? this.enemyPhysMech.maxHP : 0
                    },
                    playerShield: this.playerShield,
                    monsterShield: this.monsterShield,
                    isActive: this.isActive,
                    result: this.battleResult
                };
            }
        }

        // ============================================================================
        // BATTLE SYSTEM
        // ============================================================================

        class BattleSystem {
            constructor(playerMech, monster) {
                this.playerMech = JSON.parse(JSON.stringify(playerMech));
                this.monster = JSON.parse(JSON.stringify(monster));
                this.log = [];
                this.turn = 0;

                // Initialize battle state
                this.playerShield = 0;
                this.monsterShield = 0;
                this.playerDots = []; // {type, damage, duration}
                this.monsterDots = [];

                // Collect all player abilities
                this.playerAbilities = this.collectAbilities(this.playerMech);
                this.playerTraits = this.playerMech.traits || [];

                // Apply start-of-battle abilities
                this.applyStartOfBattleAbilities();

                // Apply monster special abilities
                this.applyMonsterSpecialInit();
            }

            collectAbilities(mech) {
                const abilities = [];
                Object.values(mech.loadout || {}).forEach(comp => {
                    if (comp && comp.abilities) {
                        comp.abilities.forEach(abilityKey => {
                            if (ABILITIES[abilityKey]) {
                                abilities.push(abilityKey);
                            }
                        });
                    }
                });
                return abilities;
            }

            applyStartOfBattleAbilities() {
                // Shield Generator
                if (this.playerAbilities.includes('SHIELD_GEN')) {
                    let shieldAmount = 50;

                    // Perfect Aegis relic - 3x shields
                    if (game.relics && game.relics.includes('PERFECT_AEGIS')) {
                        const aegisCount = game.relics.filter(r => r === 'PERFECT_AEGIS').length;
                        const multiplier = Math.pow(3, aegisCount);
                        shieldAmount = Math.floor(shieldAmount * multiplier);
                        this.addLog(`üõ°Ô∏è PERFECT AEGIS: Shield multiplied ${multiplier}x!`, 'player');
                    }

                    this.playerShield = shieldAmount;
                    this.addLog(`üõ°Ô∏è ENERGY SHIELD: Activated with ${shieldAmount} shield HP`, 'player');
                }
            }

            applyMonsterSpecialInit() {
                if (this.monster.special === 'SHIELD') {
                    this.monsterShield = 40;
                    this.addLog('üõ°Ô∏è Enemy activated energy shield! (40 shield)', 'monster');
                }

                if (this.monster.isBoss && this.monster.description) {
                    this.addLog(`‚ö†Ô∏è BOSS: ${this.monster.description}`, 'system');
                }
            }

            addLog(message, actor = 'system') {
                this.log.push({ message, actor, turn: this.turn });
            }

            hasAbility(abilityKey) {
                return this.playerAbilities.includes(abilityKey);
            }

            hasTrait(traitName) {
                return this.playerTraits.some(t => t.name === traitName);
            }

            calculateDamage(isPlayer, targetArmor) {
                const stats = calculateMechStats(this.playerMech);
                let baseDamage = isPlayer ? stats.damage : this.monster.damage;
                const currentArmor = targetArmor;

                // Enemy special abilities
                if (!isPlayer) {
                    // RAGE - gains damage as HP drops (like Berserker)
                    if (this.monster.special === 'RAGE') {
                        const hpLostPercent = ((this.monster.maxHP - this.monster.currentHP) / this.monster.maxHP) * 100;
                        const bonus = Math.floor(baseDamage * (hpLostPercent * 0.02));
                        if (bonus > 0) {
                            baseDamage += bonus;
                            this.addLog(`üòà RAGE: Enemy gains +${bonus} damage from low HP!`, 'monster');
                        }
                    }
                }

                if (isPlayer) {
                    // Last Stand relic - +200% damage if <30% HP, +50 armor
                    const hpPercent = (this.playerMech.currentHP / this.playerMech.maxHP) * 100;
                    if (game.relics && game.relics.includes('LAST_STAND') && hpPercent < 30) {
                        baseDamage *= 3; // +200% = 3x total
                        this.addLog(`‚è±Ô∏è LAST STAND: Below 30% HP - +200% damage!`, 'player');
                    }

                    // Apply trait bonuses
                    if (this.hasTrait('BERSERKER')) {
                        const hpLostPercent = ((this.playerMech.maxHP - this.playerMech.currentHP) / this.playerMech.maxHP) * 100;
                        const bonus = Math.floor(baseDamage * (hpLostPercent * 0.03));
                        if (bonus > 0) {
                            baseDamage += bonus;
                            this.addLog(`üí¢ BERSERKER TRAIT: +${bonus} damage (+3% per 1% HP lost)`, 'player');
                        }
                    }

                    if (this.hasTrait('OVERCHARGED')) {
                        baseDamage *= 2;
                    }

                    // Apply ability bonuses
                    if (this.hasAbility('BERSERKER')) {
                        const hpLostPercent = ((this.playerMech.maxHP - this.playerMech.currentHP) / this.playerMech.maxHP) * 100;
                        const bonus = Math.floor(baseDamage * (hpLostPercent * 0.01));
                        if (bonus > 0) {
                            baseDamage += bonus;
                            this.addLog(`üí¢ Berserker Chip: +${bonus} damage (+1% per 1% HP lost)`, 'player');
                        }
                    }

                    if (this.hasAbility('OVERCHARGE')) {
                        baseDamage *= 2;
                        const selfDamage = Math.floor(this.playerMech.maxHP * 0.1);
                        this.playerMech.currentHP -= selfDamage;
                        this.addLog(`‚ö° OVERCHARGE: Double damage! Cost: ${selfDamage} HP`, 'player');
                    }

                    // Apply damage type scaling relics
                    const loadoutComponents = Object.values(this.playerMech.loadout).filter(c => c);
                    const damageTypes = loadoutComponents.map(c => c.damageType);

                    // Count Energy damage and apply Energy Conduit
                    const energyCount = damageTypes.filter(t => t === DAMAGE_TYPES.ENERGY).length;
                    if (energyCount > 0 && game.relics) {
                        const conduitCount = game.relics.filter(r => r === 'ENERGY_CONDUIT').length;
                        if (conduitCount > 0) {
                            const multiplier = 1 + (0.5 * conduitCount);
                            const oldDmg = baseDamage;
                            baseDamage = Math.floor(baseDamage * multiplier);
                            this.addLog(`üîã ENERGY CONDUIT x${conduitCount}: ${oldDmg} ‚Üí ${baseDamage} damage`, 'player');
                        }
                    }

                    // Count Kinetic damage and apply Kinetic Amplifier
                    const kineticCount = damageTypes.filter(t => t === DAMAGE_TYPES.KINETIC).length;
                    if (kineticCount > 0 && game.relics) {
                        const amplifierCount = game.relics.filter(r => r === 'KINETIC_AMPLIFIER').length;
                        if (amplifierCount > 0) {
                            const multiplier = 1 + (0.5 * amplifierCount);
                            const oldDmg = baseDamage;
                            baseDamage = Math.floor(baseDamage * multiplier);
                            this.addLog(`üéØ KINETIC AMPLIFIER x${amplifierCount}: ${oldDmg} ‚Üí ${baseDamage} damage`, 'player');
                        }
                    }

                    // Count Explosive damage and apply Explosive Catalyst
                    const explosiveCount = damageTypes.filter(t => t === DAMAGE_TYPES.EXPLOSIVE).length;
                    if (explosiveCount > 0 && game.relics) {
                        const catalystCount = game.relics.filter(r => r === 'EXPLOSIVE_CATALYST').length;
                        if (catalystCount > 0) {
                            const multiplier = 1 + (0.5 * catalystCount);
                            const oldDmg = baseDamage;
                            baseDamage = Math.floor(baseDamage * multiplier);
                            this.addLog(`üí£ EXPLOSIVE CATALYST x${catalystCount}: ${oldDmg} ‚Üí ${baseDamage} damage`, 'player');
                        }
                    }

                    // Glass Cannon Core - 2x all damage (stacks multiplicatively)
                    if (game.relics && game.relics.includes('GLASS_CANNON_CORE')) {
                        const glassCount = game.relics.filter(r => r === 'GLASS_CANNON_CORE').length;
                        const multiplier = Math.pow(2, glassCount);
                        baseDamage = Math.floor(baseDamage * multiplier);
                        this.addLog(`üíé GLASS CANNON CORE: ${multiplier}x damage multiplier!`, 'player');
                    }
                }

                // Critical strike
                let isCrit = false;
                if (isPlayer && (this.hasAbility('CRITICAL_STRIKE') || this.hasTrait('CRITICAL_CORE') || (game.relics && game.relics.includes('CRITICAL_MASS')))) {
                    let critChance = this.hasTrait('CRITICAL_CORE') ? 0.30 : (this.hasAbility('CRITICAL_STRIKE') ? 0.25 : 0);
                    let critMultiplier = this.hasTrait('CRITICAL_CORE') ? 3 : 2;

                    // Critical Mass relic - +10% crit chance, +50% crit damage
                    if (game.relics && game.relics.includes('CRITICAL_MASS')) {
                        const massCount = game.relics.filter(r => r === 'CRITICAL_MASS').length;
                        critChance += 0.10 * massCount;
                        critMultiplier += 0.5 * massCount;
                    }

                    if (Math.random() < critChance) {
                        baseDamage = Math.floor(baseDamage * critMultiplier);
                        isCrit = true;
                    }
                } else if (!isPlayer && this.monster.special === 'CRITICAL') {
                    // Enemy crit ability
                    if (Math.random() < 0.30) {
                        baseDamage *= 2;
                        isCrit = true;
                    }
                }

                // Armor reduction
                let armorToUse = currentArmor;
                if (isPlayer && this.hasAbility('ARMOR_PIERCING')) {
                    armorToUse *= 0.5;
                    this.addLog(`üéØ ARMOR PIERCING: Ignoring 50% of enemy armor`, 'player');
                }

                // Kinetic Amplifier - ignore 25% armor per copy
                if (isPlayer && game.relics) {
                    const amplifierCount = game.relics.filter(r => r === 'KINETIC_AMPLIFIER').length;
                    if (amplifierCount > 0) {
                        const ignorePercent = 0.25 * amplifierCount;
                        armorToUse = Math.floor(armorToUse * (1 - ignorePercent));
                        this.addLog(`üéØ KINETIC AMPLIFIER: Ignoring ${Math.floor(ignorePercent * 100)}% enemy armor`, 'player');
                    }
                }

                // Add Last Stand +50 armor if <30% HP
                let effectiveArmorBonus = 0;
                if (isPlayer && game.relics && game.relics.includes('LAST_STAND')) {
                    const hpPercent = (this.playerMech.currentHP / this.playerMech.maxHP) * 100;
                    if (hpPercent < 30) {
                        effectiveArmorBonus += 50;
                    }
                }

                const damageReduction = Math.min(armorToUse * 0.5, baseDamage * 0.7);
                let finalDamage = Math.max(1, Math.floor(baseDamage - damageReduction));

                // Executioner
                if (isPlayer && this.hasAbility('EXECUTIONER') && this.monster.currentHP < this.monster.maxHP * 0.3) {
                    finalDamage *= 2;
                    this.addLog(`üéØ EXECUTIONER: Target below 30% HP - DOUBLE DAMAGE!`, 'player');
                }

                return { damage: finalDamage, isCrit };
            }

            applyDoTs(target, isPlayer) {
                const dots = isPlayer ? this.playerDots : this.monsterDots;
                let totalDotDamage = 0;

                for (let i = dots.length - 1; i >= 0; i--) {
                    const dot = dots[i];
                    if (target === 'player') {
                        this.playerMech.currentHP -= dot.damage;
                    } else {
                        this.monster.currentHP -= dot.damage;
                    }
                    totalDotDamage += dot.damage;

                    dot.duration--;
                    if (dot.duration <= 0) {
                        dots.splice(i, 1);
                    }
                }

                if (totalDotDamage > 0) {
                    const actor = target === 'player' ? 'monster' : 'player';
                    this.addLog(`üî• DoT damage: ${totalDotDamage}`, actor);
                }
            }

            applyRegeneration() {
                // Regeneration ability
                if (this.hasAbility('REGENERATION')) {
                    const heal = 5;
                    this.playerMech.currentHP = Math.min(this.playerMech.maxHP, this.playerMech.currentHP + heal);
                    this.addLog(`üíö REGENERATION: Healed ${heal} HP`, 'player');
                }

                // Regenerator trait
                if (this.hasTrait('REGENERATOR')) {
                    const heal = Math.floor(this.playerMech.maxHP * 0.08);
                    this.playerMech.currentHP = Math.min(this.playerMech.maxHP, this.playerMech.currentHP + heal);
                    this.addLog(`üíö REGENERATOR TRAIT: Restored ${heal} HP (8% of max HP)`, 'player');
                }
            }

            performAttack(isPlayer) {
                let targetArmor = isPlayer ? this.monster.armor : calculateMechStats(this.playerMech).armor;

                // ARMORED enemy - double effective armor
                if (!isPlayer && this.monster.special === 'ARMORED') {
                    targetArmor *= 2;
                }

                const { damage, isCrit } = this.calculateDamage(isPlayer, targetArmor);

                let actualDamage = damage;

                if (isPlayer) {
                    // Player attacking monster - check monster shield first
                    if (this.monsterShield > 0) {
                        if (this.monsterShield >= actualDamage) {
                            this.monsterShield -= actualDamage;
                            this.addLog(`üõ°Ô∏è Enemy shield absorbed ${actualDamage} damage! (${this.monsterShield} shield left)`, 'player');
                            actualDamage = 0;
                        } else {
                            const overflow = actualDamage - this.monsterShield;
                            this.addLog(`üõ°Ô∏è Enemy shield absorbed ${this.monsterShield} damage, ${overflow} passed through!`, 'player');
                            this.monsterShield = 0;
                            actualDamage = overflow;
                        }
                    }

                    // Apply remaining damage to monster HP
                    if (actualDamage > 0) {
                        this.monster.currentHP -= actualDamage;
                        const critText = isCrit ? ' üí• CRITICAL HIT!' : '';
                        this.addLog(`‚öîÔ∏è Your mech deals ${actualDamage} damage!${critText} (Enemy: ${Math.max(0, this.monster.currentHP)}/${this.monster.maxHP} HP)`, 'player');

                        // REFLECT - Monster reflects damage back
                        if (this.monster.special === 'REFLECT') {
                            const reflected = Math.floor(actualDamage * 0.5);
                            this.playerMech.currentHP -= reflected;
                            this.addLog(`üëª MIRROR WRAITH: Reflected ${reflected} damage back!`, 'monster');
                        }
                    }

                    // Vampiric healing - now stacks from multiple sources!
                    let totalHealPercent = 0;
                    let healSources = [];

                    if (this.hasAbility('VAMPIRIC')) {
                        totalHealPercent += 0.25;
                        healSources.push('Vampiric');
                    }
                    if (this.hasTrait('VAMPIRE')) {
                        totalHealPercent += 0.4;
                        healSources.push('VAMPIRE TRAIT');
                    }
                    if (game.relics && game.relics.includes('VAMPIRIC_ASCENSION')) {
                        const vampCount = game.relics.filter(r => r === 'VAMPIRIC_ASCENSION').length;
                        totalHealPercent += 0.25 * vampCount;
                        healSources.push(`VAMPIRIC ASCENSION x${vampCount}`);
                    }
                    if (game.relics && game.relics.includes('BLOOD_PACT')) {
                        const pactCount = game.relics.filter(r => r === 'BLOOD_PACT').length;
                        totalHealPercent += 0.5 * pactCount;
                        healSources.push(`BLOOD PACT x${pactCount}`);
                    }

                    if (totalHealPercent > 0) {
                        const heal = Math.floor(actualDamage * totalHealPercent);
                        this.playerMech.currentHP = Math.min(this.playerMech.maxHP, this.playerMech.currentHP + heal);
                        this.addLog(`ü©∏ ${healSources.join(' + ')}: Healed ${heal} HP (${Math.floor(totalHealPercent * 100)}% of damage)`, 'player');
                    }

                    // Apply DoTs with Contagion and ALL_IN support
                    if (this.hasAbility('BURN')) {
                        let burnDamage = 5;
                        let burnDuration = 3;
                        let triggers = 1;

                        // ALL_IN relic - abilities trigger twice
                        if (game.relics && game.relics.includes('ALL_IN')) {
                            triggers = 2;
                        }

                        // Contagion relic - 2x DoT damage and duration
                        if (game.relics && game.relics.includes('CONTAGION')) {
                            const contagionCount = game.relics.filter(r => r === 'CONTAGION').length;
                            const multiplier = Math.pow(2, contagionCount);
                            burnDamage = Math.floor(burnDamage * multiplier);
                            burnDuration = Math.floor(burnDuration * multiplier);
                        }

                        for (let i = 0; i < triggers; i++) {
                            this.monsterDots.push({ type: 'burn', damage: burnDamage, duration: burnDuration });
                        }

                        const triggerText = triggers > 1 ? ` x${triggers} (ALL-IN!)` : '';
                        this.addLog(`üî• PLASMA BURN${triggerText}: ${burnDamage} dmg/turn for ${burnDuration} turns`, 'player');
                    }

                    if (isCrit && this.hasAbility('BLEED')) {
                        let bleedDamage = 3;
                        let bleedDuration = 5;
                        let triggers = 1;

                        // ALL_IN relic
                        if (game.relics && game.relics.includes('ALL_IN')) {
                            triggers = 2;
                        }

                        // Contagion relic
                        if (game.relics && game.relics.includes('CONTAGION')) {
                            const contagionCount = game.relics.filter(r => r === 'CONTAGION').length;
                            const multiplier = Math.pow(2, contagionCount);
                            bleedDamage = Math.floor(bleedDamage * multiplier);
                            bleedDuration = Math.floor(bleedDuration * multiplier);
                        }

                        for (let i = 0; i < triggers; i++) {
                            this.monsterDots.push({ type: 'bleed', damage: bleedDamage, duration: bleedDuration });
                        }

                        const triggerText = triggers > 1 ? ` x${triggers} (ALL-IN!)` : '';
                        this.addLog(`ü©∏ HEMORRHAGE${triggerText}: ${bleedDamage} dmg/turn for ${bleedDuration} turns`, 'player');
                    }
                } else {
                    // Monster attacks player
                    const ignoresShield = this.monster.special === 'SHIELD_IGNORE';

                    // Check shield first (unless SHIELD_IGNORE)
                    if (!ignoresShield && this.playerShield > 0) {
                        if (this.playerShield >= actualDamage) {
                            this.playerShield -= actualDamage;
                            this.addLog(`üõ°Ô∏è Shield absorbed ${actualDamage} damage! (${this.playerShield} shield left)`, 'monster');
                            actualDamage = 0;
                        } else {
                            const overflow = actualDamage - this.playerShield;
                            this.addLog(`üõ°Ô∏è Shield absorbed ${this.playerShield} damage, ${overflow} passed through!`, 'monster');
                            this.playerShield = 0;
                            actualDamage = overflow;
                        }
                    } else if (ignoresShield && this.playerShield > 0) {
                        this.addLog(`‚ö° PLASMA STORM: Shields and armor ignored!`, 'monster');
                    }

                    // Apply remaining damage to HP
                    if (actualDamage > 0) {
                        const critText = isCrit ? ' üí• CRIT!' : '';
                        this.playerMech.currentHP -= actualDamage;
                        this.addLog(`üí• ${this.monster.name} deals ${actualDamage} damage!${critText} (${Math.max(0, this.playerMech.currentHP)}/${this.playerMech.maxHP} HP)`, 'monster');

                        // Reactive armor
                        if (this.hasAbility('REACTIVE')) {
                            const reflected = Math.floor(actualDamage * 0.25);
                            this.monster.currentHP -= reflected;
                            this.addLog(`‚ö° REACTIVE ARMOR: Reflected ${reflected} damage (25% of damage taken)`, 'player');
                        }
                    }
                }

                return actualDamage;
            }

            executeTurn() {
                this.turn++;

                // Apply Overcharged trait damage
                if (this.hasTrait('OVERCHARGED')) {
                    const damage = Math.floor(this.playerMech.maxHP * 0.08);
                    this.playerMech.currentHP -= damage;
                    this.addLog(`üî• OVERCHARGED TRAIT: Losing ${damage} HP (8% max HP per turn)`, 'player');
                }

                // Apply regeneration
                this.applyRegeneration();

                // Apply DoTs
                this.applyDoTs('player', true);
                this.applyDoTs('monster', false);

                // Check for deaths from DoTs
                if (this.playerMech.currentHP <= 0) {
                    this.addLog('üíÄ YOUR MECH IS DESTROYED! DEFEAT! üíÄ', 'monster');
                    return 'defeat';
                }
                if (this.monster.currentHP <= 0) {
                    this.addLog('üí• ENEMY DESTROYED! VICTORY! üí•', 'player');
                    return 'victory';
                }

                const playerStats = calculateMechStats(this.playerMech);
                let playerSpeed = playerStats.speed;

                // Apply speed traits
                if (this.hasTrait('LIGHTNING_FAST')) {
                    playerSpeed = 100 + 50;
                }
                if (this.hasTrait('FORTRESS')) {
                    playerSpeed = Math.floor(playerSpeed * 0.5);
                }

                // Determine turn order
                const playerGoesFirst = playerSpeed >= this.monster.speed;

                if (playerGoesFirst) {
                    this.performAttack(true);
                    if (this.monster.currentHP <= 0) {
                        this.addLog('üí• ENEMY DESTROYED! VICTORY! üí•', 'player');
                        return 'victory';
                    }
                    this.performAttack(false);
                    if (this.playerMech.currentHP <= 0) {
                        this.addLog('üíÄ YOUR MECH IS DESTROYED! DEFEAT! üíÄ', 'monster');
                        return 'defeat';
                    }
                } else {
                    this.performAttack(false);
                    if (this.playerMech.currentHP <= 0) {
                        this.addLog('üíÄ YOUR MECH IS DESTROYED! DEFEAT! üíÄ', 'monster');
                        return 'defeat';
                    }
                    this.performAttack(true);
                    if (this.monster.currentHP <= 0) {
                        this.addLog('üí• ENEMY DESTROYED! VICTORY! üí•', 'player');
                        return 'victory';
                    }
                }

                return 'continue';
            }

            getState() {
                return {
                    playerMech: this.playerMech,
                    monster: this.monster,
                    log: this.log,
                    playerShield: this.playerShield
                };
            }
        }

        // ============================================================================
        // UI MANAGEMENT
        // ============================================================================

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        function updateHeader() {
            document.getElementById('round-num').textContent = game.round;
            document.getElementById('victories').textContent = game.victories;
            document.getElementById('current-mech-name').textContent =
                game.currentMech ? `${game.currentMech.name} (T${game.currentMech.tier})` : 'None';

            const invCount = game.inventory.length;
            // Apply SCAVENGER relic +3 inventory
            let invMax = game.maxInventorySize;
            if (game.relics && game.relics.includes('SCAVENGER')) {
                invMax += 3;
            }
            const invText = `${invCount}/${invMax}`;
            const invElement = document.getElementById('inventory-count');
            invElement.textContent = invText;

            // Color code inventory status
            if (invCount >= invMax) {
                invElement.style.color = '#ff4444';
                invElement.style.fontWeight = 'bold';
            } else if (invCount >= invMax - 2) {
                invElement.style.color = '#ffaa00';
            } else {
                invElement.style.color = '';
                invElement.style.fontWeight = '';
            }
        }

        function renderLoadoutScreen() {
            if (!game.currentMech) {
                document.getElementById('loadout-mech-name').textContent = 'No Mech Selected';
                document.getElementById('mech-slots').innerHTML = '<p class="warning">Please select a mech to continue.</p>';
                return;
            }

            const mech = game.currentMech;
            const stats = calculateMechStats(mech);

            // Display mech name with traits
            const traitIcons = (mech.traits || []).map(t => t.icon).join(' ');
            document.getElementById('loadout-mech-name').textContent =
                `${mech.name} (${mech.class}) - Tier ${mech.tier} ${traitIcons}`;
            document.getElementById('loadout-mech-visual').textContent = mech.visual;

            // Update resource bars
            const tierPercent = (stats.tierUsed / mech.tierCapacity) * 100;
            const weightPercent = (stats.weightUsed / mech.weightCapacity) * 100;

            document.getElementById('tier-usage').textContent =
                `${stats.tierUsed}/${mech.tierCapacity}`;
            document.getElementById('tier-bar').style.width = `${Math.min(100, tierPercent)}%`;

            document.getElementById('weight-usage').textContent =
                `${stats.weightUsed}/${mech.weightCapacity}`;
            document.getElementById('weight-bar').style.width = `${Math.min(100, weightPercent)}%`;

            // Render slots
            const slotsHTML = Object.entries(SLOT_TYPES).map(([key, slotName]) => {
                const slot = mech.slots[slotName];
                const component = mech.loadout[slotName];
                const slotLabel = key.replace(/_/g, ' ');

                if (component) {
                    const damageTypeIcon = component.damageType === DAMAGE_TYPES.ENERGY ? '‚öõÔ∏è' :
                                           component.damageType === DAMAGE_TYPES.KINETIC ? 'üéØ' :
                                           component.damageType === DAMAGE_TYPES.EXPLOSIVE ? 'üí£' : '';
                    const abilities = component.abilities || [];
                    const abilityText = abilities.map(abilityKey => {
                        const ability = ABILITIES[abilityKey];
                        return ability ? `
                            <div style="font-size: 9px; color: #00ff88; margin-top: 3px; padding: 3px; background: rgba(0, 255, 136, 0.1); border-radius: 2px;">
                                <strong>‚ú® ${ability.name}</strong><br>
                                <span style="color: #aaa; font-size: 8px;">${ability.desc}</span>
                            </div>
                        ` : '';
                    }).join('');

                    // Rarity styling
                    const rarityData = RARITY[component.rarity] || RARITY.COMMON;

                    return `
                        <div class="slot filled" onclick="handleSlotClick('${slotName}')" style="border-left: 3px solid ${rarityData.color};">
                            <div class="slot-header">
                                <span>${slotLabel}</span>
                                <span class="tier-indicator tier-${component.tier}">T${component.tier}</span>
                                <span style="background: ${rarityData.color}; color: #000; padding: 1px 4px; border-radius: 2px; font-size: 8px; font-weight: bold; margin-left: 4px;">${rarityData.name[0]}</span>
                            </div>
                            <div class="component-name" style="color: ${rarityData.color};">${damageTypeIcon} ${component.name}</div>
                            <div style="font-size: 11px; margin-top: 5px;">
                                ‚öîÔ∏è${component.damage} üõ°Ô∏è${component.armor}
                            </div>
                            ${abilityText}
                        </div>
                    `;
                } else {
                    return `
                        <div class="slot" onclick="handleSlotClick('${slotName}')">
                            <div class="slot-header">
                                <span>${slotLabel}</span>
                                <span style="color: #666;">Empty</span>
                            </div>
                            <div style="font-size: 11px; color: #666;">Click to attach component</div>
                        </div>
                    `;
                }
            }).join('');

            document.getElementById('mech-slots').innerHTML = slotsHTML;

            // Render inventory
            renderInventory();
        }

        function renderInventory() {
            const inventoryGrid = document.getElementById('inventory-grid');

            if (game.inventory.length === 0) {
                inventoryGrid.innerHTML = '<p style="color: #666;">No components in inventory. Win battles to collect salvage!</p>';
                return;
            }

            inventoryGrid.innerHTML = game.inventory.map(comp => {
                const damageTypeIcon = comp.damageType === DAMAGE_TYPES.ENERGY ? '‚öõÔ∏è' :
                                       comp.damageType === DAMAGE_TYPES.KINETIC ? 'üéØ' :
                                       comp.damageType === DAMAGE_TYPES.EXPLOSIVE ? 'üí£' : '';
                const abilities = comp.abilities || [];
                const abilityText = abilities.map(abilityKey => {
                    const ability = ABILITIES[abilityKey];
                    return ability ? `
                        <div style="font-size: 10px; color: #00ff88; margin-top: 5px; padding: 4px; background: rgba(0, 255, 136, 0.1); border-radius: 3px; border-left: 2px solid #00ff88;">
                            <strong>‚ú® ${ability.name}</strong><br>
                            <span style="color: #ccc; font-size: 9px;">${ability.desc}</span>
                        </div>
                    ` : '';
                }).join('');

                // Rarity styling
                const rarityData = RARITY[comp.rarity] || RARITY.COMMON;
                const rarityBadge = `<span style="background: ${rarityData.color}; color: #000; padding: 2px 6px; border-radius: 3px; font-size: 9px; font-weight: bold; margin-left: 5px;">${rarityData.name.toUpperCase()}</span>`;

                return `
                    <div class="inventory-item" style="border-left: 3px solid ${rarityData.color};">
                        <div class="component-name" style="font-size: 14px; color: ${rarityData.color};">
                            ${damageTypeIcon} ${comp.name}
                            ${rarityBadge}
                            <span class="tier-indicator tier-${comp.tier}">T${comp.tier}</span>
                        </div>
                        <div class="component-stats">
                            <div class="stat-item">‚öîÔ∏è DMG: ${comp.damage}</div>
                            <div class="stat-item">üõ°Ô∏è ARM: ${comp.armor}</div>
                        </div>
                        <div style="font-size: 10px; color: #888; margin-top: 5px;">
                            Slot: ${comp.slot.replace(/([A-Z])/g, ' $1').trim()}
                        </div>
                        ${abilityText}
                    </div>
                `;
            }).join('');
        }

        // Global variable to track current slot being equipped
        let currentEquippingSlot = null;

        function handleSlotClick(slotName) {
            if (!game.currentMech) return;

            // Show item selection modal for this slot
            showItemSelectionModal(slotName);
        }

        function showItemSelectionModal(slotName) {
            currentEquippingSlot = slotName;
            const currentComponent = game.currentMech.loadout[slotName];

            // Update modal title
            const slotLabel = slotName.replace(/([A-Z])/g, ' $1').trim().toUpperCase();
            document.getElementById('item-select-title').textContent = `üì¶ SELECT COMPONENT FOR ${slotLabel}`;

            // Show/hide unequip button
            const unequipBtn = document.getElementById('unequip-btn');
            if (currentComponent) {
                unequipBtn.style.display = 'inline-block';
                unequipBtn.textContent = `üóëÔ∏è Unequip ${currentComponent.name}`;
            } else {
                unequipBtn.style.display = 'none';
            }

            // Get all compatible components from inventory
            const compatibleItems = game.inventory.filter(comp => comp.slot === slotName);

            // Sort by rarity (legendary first) then by tier
            const rarityOrder = { LEGENDARY: 0, EPIC: 1, RARE: 2, UNCOMMON: 3, COMMON: 4 };
            compatibleItems.sort((a, b) => {
                const rarityDiff = rarityOrder[a.rarity] - rarityOrder[b.rarity];
                if (rarityDiff !== 0) return rarityDiff;
                return b.tier - a.tier; // Higher tier first
            });

            // Render item options
            renderItemSelectionOptions(compatibleItems, slotName, currentComponent);

            showScreen('item-select-modal');
        }

        function renderItemSelectionOptions(items, slotName, currentComponent) {
            const optionsContainer = document.getElementById('item-select-options');

            if (items.length === 0) {
                optionsContainer.innerHTML = '<p style="color: #666; text-align: center; padding: 40px;">No compatible components in inventory for this slot.</p>';
                return;
            }

            const itemsHTML = items.map(comp => {
                const damageTypeIcon = comp.damageType === DAMAGE_TYPES.ENERGY ? '‚öõÔ∏è' :
                                       comp.damageType === DAMAGE_TYPES.KINETIC ? 'üéØ' :
                                       comp.damageType === DAMAGE_TYPES.EXPLOSIVE ? 'üí£' : '';
                const abilities = comp.abilities || [];
                const abilityText = abilities.map(abilityKey => {
                    const ability = ABILITIES[abilityKey];
                    return ability ? `
                        <div style="font-size: 10px; color: #00ff88; margin-top: 5px; padding: 4px; background: rgba(0, 255, 136, 0.1); border-radius: 3px; border-left: 2px solid #00ff88;">
                            <strong>‚ú® ${ability.name}</strong><br>
                            <span style="color: #ccc; font-size: 9px;">${ability.desc}</span>
                        </div>
                    ` : '';
                }).join('');

                // Rarity styling
                const rarityData = RARITY[comp.rarity] || RARITY.COMMON;
                const rarityBadge = `<span style="background: ${rarityData.color}; color: #000; padding: 2px 6px; border-radius: 3px; font-size: 9px; font-weight: bold; margin-left: 5px;">${rarityData.name.toUpperCase()}</span>`;

                // Check if this item is NEW for this slot
                if (!comp.seenInSlots) comp.seenInSlots = [];
                const isNew = !comp.seenInSlots.includes(slotName);
                const newBadge = isNew ? `<span style="background: #ff00ff; color: #fff; padding: 2px 6px; border-radius: 3px; font-size: 9px; font-weight: bold; margin-left: 5px; animation: pulse 1s infinite;">NEW!</span>` : '';

                // Mark as seen
                if (isNew) {
                    comp.seenInSlots.push(slotName);
                }

                // Check if can equip (tier budget)
                const canEquip = canAttachComponent(game.currentMech, comp, slotName);
                const disabledStyle = !canEquip ? 'opacity: 0.5; filter: grayscale(50%);' : '';
                const cannotEquipWarning = !canEquip ? '<div style="color: #ff4444; font-size: 10px; margin-top: 5px;">‚ö†Ô∏è Not enough tier budget</div>' : '';

                // Check if currently equipped
                const isEquipped = currentComponent && currentComponent.id === comp.id;
                const equippedBadge = isEquipped ? '<div style="color: #00ff88; font-size: 11px; margin-top: 5px;">‚úì Currently Equipped</div>' : '';

                return `
                    <div class="salvage-card" onclick="selectItemForSlot('${comp.id}')" style="border: 2px solid ${rarityData.color}; box-shadow: 0 0 10px ${rarityData.color}50; ${disabledStyle} cursor: ${canEquip ? 'pointer' : 'not-allowed'};">
                        <div class="component-name" style="color: ${rarityData.color};">
                            ${damageTypeIcon} ${comp.name}
                            ${rarityBadge}
                            ${newBadge}
                            <span class="tier-indicator tier-${comp.tier}">Tier ${comp.tier}</span>
                        </div>
                        <div style="margin: 10px 0; color: #888;">${comp.type.toUpperCase()}</div>
                        <div class="component-stats">
                            <div class="stat-item">‚öîÔ∏è Damage: ${comp.damage}</div>
                            <div class="stat-item">üõ°Ô∏è Armor: ${comp.armor}</div>
                        </div>
                        ${abilityText}
                        ${equippedBadge}
                        ${cannotEquipWarning}
                    </div>
                `;
            }).join('');

            optionsContainer.innerHTML = itemsHTML;
        }

        function selectItemForSlot(componentId) {
            if (!currentEquippingSlot) return;

            const component = game.inventory.find(c => c.id === componentId);
            if (!component) return;

            // Check if can attach
            if (!canAttachComponent(game.currentMech, component, currentEquippingSlot)) {
                return; // Silently ignore if can't attach (visual feedback already shown)
            }

            // Attach the component
            attachComponent(game.currentMech, component, currentEquippingSlot);

            // Close modal and refresh loadout
            closeItemSelectModal();
        }

        function unequipSlot() {
            if (!currentEquippingSlot) return;

            const currentComponent = game.currentMech.loadout[currentEquippingSlot];
            if (currentComponent) {
                detachComponent(game.currentMech, currentEquippingSlot);
            }

            closeItemSelectModal();
        }

        function closeItemSelectModal() {
            currentEquippingSlot = null;
            renderLoadoutScreen();
            showScreen('loadout-screen');
        }

        function renderBattleScreen() {
            if (!game.currentMech) {
                alert('No mech selected!');
                return;
            }

            // Reset mech HP
            game.currentMech.currentHP = game.currentMech.maxHP;

            // Generate monster
            game.currentMonster = generateMonster(game.round);

            const stats = calculateMechStats(game.currentMech);

            // Update player display
            document.getElementById('player-visual').textContent = game.currentMech.visual;
            document.getElementById('player-name').textContent = game.currentMech.name;
            document.getElementById('player-stats').innerHTML =
                `‚öîÔ∏è Damage: ${stats.damage} | üõ°Ô∏è Armor: ${stats.armor} | ‚ö° Speed: ${stats.speed}`;
            updateHealthBar('player', game.currentMech.currentHP, game.currentMech.maxHP);

            // Update monster display
            document.getElementById('monster-visual').textContent = game.currentMonster.visual;
            document.getElementById('monster-name').textContent = game.currentMonster.name;
            document.getElementById('monster-stats').innerHTML =
                `‚öîÔ∏è Damage: ${game.currentMonster.damage} | üõ°Ô∏è Armor: ${game.currentMonster.armor} | ‚ö° Speed: ${game.currentMonster.speed}`;
            updateHealthBar('monster', game.currentMonster.currentHP, game.currentMonster.maxHP);

            // Display active abilities and traits
            displayActiveAbilities();

            // Clear status effects
            document.getElementById('player-status-effects').innerHTML = '<span style="color: #666; font-size: 9px;">No active effects</span>';
            document.getElementById('monster-status-effects').innerHTML = '<span style="color: #666; font-size: 9px;">No active effects</span>';

            // Clear combat log
            document.getElementById('combat-log').innerHTML = '';

            showScreen('battle-screen');
        }

        function displayActiveAbilities() {
            const abilitiesDiv = document.getElementById('player-abilities-display');

            // Collect all abilities
            const abilities = [];
            Object.values(game.currentMech.loadout || {}).forEach(comp => {
                if (comp && comp.abilities) {
                    comp.abilities.forEach(abilityKey => {
                        if (ABILITIES[abilityKey] && !abilities.includes(abilityKey)) {
                            abilities.push(abilityKey);
                        }
                    });
                }
            });

            // Collect traits
            const traits = game.currentMech.traits || [];

            if (abilities.length === 0 && traits.length === 0) {
                abilitiesDiv.style.display = 'none';
                return;
            }

            let html = '<h4>‚ö° ACTIVE EFFECTS</h4>';

            if (traits.length > 0) {
                html += '<div style="margin-bottom: 5px;">';
                traits.forEach(trait => {
                    html += `<span class="trait-tag" title="${trait.desc}">${trait.icon} ${trait.name}</span>`;
                });
                html += '</div>';
            }

            if (abilities.length > 0) {
                html += '<div>';
                abilities.forEach(abilityKey => {
                    const ability = ABILITIES[abilityKey];
                    html += `<span class="ability-tag" title="${ability.desc}">‚ú® ${ability.name}</span>`;
                });
                html += '</div>';
            }

            abilitiesDiv.innerHTML = html;
            abilitiesDiv.style.display = 'block';
        }

        function updateStatusEffects(playerShield, playerDots, monsterDots) {
            // Update player status effects
            const playerStatusDiv = document.getElementById('player-status-effects');
            let playerEffects = [];

            if (playerShield > 0) {
                playerEffects.push(`<span class="status-effect status-shield">üõ°Ô∏è Shield: ${playerShield}</span>`);
            }

            if (playerEffects.length === 0) {
                playerStatusDiv.innerHTML = '<span style="color: #666; font-size: 9px;">No active effects</span>';
            } else {
                playerStatusDiv.innerHTML = playerEffects.join('');
            }

            // Update monster status effects
            const monsterStatusDiv = document.getElementById('monster-status-effects');
            let monsterEffects = [];

            monsterDots.forEach(dot => {
                if (dot.type === 'burn') {
                    monsterEffects.push(`<span class="status-effect status-burn">üî• Burn: ${dot.damage}x${dot.duration}</span>`);
                } else if (dot.type === 'bleed') {
                    monsterEffects.push(`<span class="status-effect status-bleed">ü©∏ Bleed: ${dot.damage}x${dot.duration}</span>`);
                }
            });

            if (monsterEffects.length === 0) {
                monsterStatusDiv.innerHTML = '<span style="color: #666; font-size: 9px;">No active effects</span>';
            } else {
                monsterStatusDiv.innerHTML = monsterEffects.join('');
            }
        }

        function updateHealthBar(actor, current, max) {
            const percent = (current / max) * 100;
            const fill = document.getElementById(`${actor}-health`);
            const text = document.getElementById(`${actor}-health-text`);

            fill.style.width = `${Math.max(0, percent)}%`;
            text.textContent = `${Math.max(0, current)}/${max}`;
        }

        function addCombatLog(message, actor) {
            const log = document.getElementById('combat-log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${actor}`;
            entry.textContent = message;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        async function startBattle() {
            if (!game.currentMech || !game.currentMonster) return;

            document.getElementById('start-battle-btn').disabled = true;

            // Create physics-driven battle system
            const battle = new PhysicsBattleSystem(game.currentMech, game.currentMonster, physicsEngine);

            // Initialize battle (starts physics and auto-combat)
            await battle.initializeBattle();

            addCombatLog('‚öîÔ∏è BATTLE START! ‚öîÔ∏è', 'system');

            // Track displayed logs
            let lastLogIndex = 0;

            // Real-time battle loop - polls physics state
            while (battle.isActive) {
                await new Promise(resolve => setTimeout(resolve, 100)); // Poll at 10Hz

                const state = battle.getState();

                // Update displays with real-time physics state
                updateHealthBar('player', state.playerMech.currentHP, state.playerMech.maxHP);
                updateHealthBar('monster', state.monster.currentHP, state.monster.maxHP);

                // Update status effects
                updateStatusEffects(state.playerShield, battle.playerDots, battle.monsterDots);

                // Show new log entries
                while (lastLogIndex < battle.log.length) {
                    const logEntry = battle.log[lastLogIndex];
                    addCombatLog(logEntry.message, logEntry.actor);
                    lastLogIndex++;
                }
            }

            // Battle ended - get result
            const result = battle.battleResult;

            await new Promise(resolve => setTimeout(resolve, 2000));

            if (result === 'victory') {
                game.victories++;

                // Apply Hunter's Mark relic - permanent damage per kill
                if (game.relics && game.relics.includes('HUNTERS_MARK')) {
                    const markCount = game.relics.filter(r => r === 'HUNTERS_MARK').length;
                    const bonusDmg = 3 * markCount;
                    game.permanentDamageBonus += bonusDmg;
                    addCombatLog(`üíÄ HUNTER'S MARK: +${bonusDmg} permanent damage (Total: +${game.permanentDamageBonus})`, 'player');
                }

                game.round++;
                game.save();

                const previousRound = game.round - 1;
                const isBossRound = previousRound % 5 === 0 && previousRound > 0;
                const isRelicRound = previousRound % 3 === 0 && previousRound > 0 && !isBossRound;

                // Boss rounds: Trait + Relic (boss reward)
                if (isBossRound) {
                    // Store that we need to show relic after trait
                    window.showRelicAfterTrait = true;
                    showTraitSelectionScreen();
                }
                // Relic rounds (every 3, but not bosses): Relic only
                else if (isRelicRound) {
                    showRelicSelectionScreen(false);
                }
                // Normal rounds: Salvage
                else {
                    showSalvageScreen();
                }
            } else {
                // Defeat - game over
                addCombatLog('', 'system');
                addCombatLog('GAME OVER! Starting new game...', 'system');
                await new Promise(resolve => setTimeout(resolve, 3000));
                game.reset();
                initializeGame();
            }

            document.getElementById('start-battle-btn').disabled = false;
            updateHeader();
        }

        function showSalvageScreen() {
            const tierLevel = Math.floor(game.round / 5) + 1;
            const salvageOptions = generateRandomComponents(3, tierLevel, tierLevel + 1);

            // Check if player has SALVAGER trait or SCAVENGER relic
            const hasSalvagerTrait = game.currentMech && game.currentMech.traits &&
                                     game.currentMech.traits.some(t => t.name === 'SALVAGER');
            const hasScavengerRelic = game.relics && game.relics.includes('SCAVENGER');
            const hasSalvager = hasSalvagerTrait || hasScavengerRelic;

            const titleText = hasSalvager ?
                (hasScavengerRelic && hasSalvagerTrait ?
                    'Choose TWO components to salvage (SCAVENGER relic + SALVAGER trait active!):' :
                    hasScavengerRelic ?
                        'Choose TWO components to salvage (SCAVENGER relic active!):' :
                        'Choose TWO components to salvage (SALVAGER trait active!):') :
                'Choose one component to salvage from the battlefield:';

            document.querySelector('#salvage-screen p').textContent = titleText;

            const optionsHTML = salvageOptions.map((comp, index) => {
                const damageTypeIcon = comp.damageType === DAMAGE_TYPES.ENERGY ? '‚öõÔ∏è' :
                                       comp.damageType === DAMAGE_TYPES.KINETIC ? 'üéØ' :
                                       comp.damageType === DAMAGE_TYPES.EXPLOSIVE ? 'üí£' : '';
                const abilities = comp.abilities || [];
                const abilityText = abilities.map(abilityKey => {
                    const ability = ABILITIES[abilityKey];
                    return ability ? `
                        <div style="font-size: 10px; color: #00ff88; margin-top: 5px; padding: 4px; background: rgba(0, 255, 136, 0.1); border-radius: 3px; border-left: 2px solid #00ff88;">
                            <strong>‚ú® ${ability.name}</strong><br>
                            <span style="color: #ccc; font-size: 9px;">${ability.desc}</span>
                        </div>
                    ` : '';
                }).join('');

                // Rarity styling
                const rarityData = RARITY[comp.rarity] || RARITY.COMMON;
                const rarityBadge = `<span style="background: ${rarityData.color}; color: #000; padding: 2px 6px; border-radius: 3px; font-size: 9px; font-weight: bold; margin-left: 5px;">${rarityData.name.toUpperCase()}</span>`;

                return `
                    <div class="salvage-card" onclick="selectSalvage(${index})" style="border: 2px solid ${rarityData.color}; box-shadow: 0 0 10px ${rarityData.color}50;">
                        <div class="component-name" style="color: ${rarityData.color};">
                            ${damageTypeIcon} ${comp.name}
                            ${rarityBadge}
                            <span class="tier-indicator tier-${comp.tier}">Tier ${comp.tier}</span>
                        </div>
                        <div style="margin: 10px 0; color: #888;">${comp.type.toUpperCase()}</div>
                        <div class="component-stats">
                            <div class="stat-item">‚öîÔ∏è Damage: ${comp.damage}</div>
                            <div class="stat-item">üõ°Ô∏è Armor: ${comp.armor}</div>
                            <div class="stat-item" style="grid-column: 1 / -1;">
                                üìç Slot: ${comp.slot.replace(/([A-Z])/g, ' $1').trim()}
                            </div>
                        </div>
                        ${abilityText}
                    </div>
                `;
            }).join('');

            document.getElementById('salvage-options').innerHTML = optionsHTML;

            // Store options temporarily
            window.currentSalvageOptions = salvageOptions;
            window.salvageSelections = [];
            window.salvageLimit = hasSalvager ? 2 : 1;

            showScreen('salvage-screen');
        }

        function selectSalvage(index) {
            const component = window.currentSalvageOptions[index];
            window.salvageSelections = window.salvageSelections || [];

            if (window.salvageSelections.includes(index)) {
                // Already selected, deselect
                window.salvageSelections = window.salvageSelections.filter(i => i !== index);
            } else {
                window.salvageSelections.push(index);
            }

            // Visual feedback - highlight selected
            document.querySelectorAll('#salvage-options .salvage-card').forEach((card, i) => {
                if (window.salvageSelections.includes(i)) {
                    card.style.borderColor = '#00ff88';
                    card.style.transform = 'scale(0.95)';
                } else {
                    card.style.borderColor = '#444';
                    card.style.transform = 'scale(1)';
                }
            });

            // If reached limit, auto-confirm
            if (window.salvageSelections.length >= window.salvageLimit) {
                setTimeout(() => {
                    // Check if inventory is full
                    const selectedComponents = window.salvageSelections.map(idx => window.currentSalvageOptions[idx]);

                    // Calculate actual max inventory (including SCAVENGER relic bonus)
                    let actualMaxInventory = game.maxInventorySize;
                    if (game.relics && game.relics.includes('SCAVENGER')) {
                        actualMaxInventory += 3;
                    }

                    if (game.inventory.length + selectedComponents.length > actualMaxInventory) {
                        // Inventory would overflow - need to drop items
                        const overflow = (game.inventory.length + selectedComponents.length) - actualMaxInventory;
                        showInventoryManagementScreen(selectedComponents, overflow, actualMaxInventory);
                    } else {
                        // Inventory has space
                        selectedComponents.forEach(comp => game.inventory.push(comp));
                        game.save();
                        updateHeader();
                        renderLoadoutScreen();
                        showScreen('loadout-screen');
                    }
                }, 300);
            }
        }

        function showInventoryManagementScreen(newComponents, mustDrop, maxInventory = null) {
            const actualMax = maxInventory || game.maxInventorySize;
            const message = `‚ö†Ô∏è INVENTORY FULL! (${game.inventory.length + newComponents.length}/${actualMax})\n\nYou must DROP ${mustDrop} component(s) to make room for your salvage.`;

            if (!confirm(message + '\n\nOK = Choose what to drop\nCancel = Skip salvage')) {
                // Skip salvage
                updateHeader();
                renderLoadoutScreen();
                showScreen('loadout-screen');
                return;
            }

            // Show inventory management UI
            window.pendingNewComponents = newComponents;
            window.mustDropCount = mustDrop;
            window.selectedForDrop = [];

            alert('Select ' + mustDrop + ' component(s) from your inventory to drop, then proceed to loadout screen.');

            // Add new components to temporary holding
            game.inventory.push(...newComponents);
            game.save();
            updateHeader();
            renderLoadoutScreen();
            showScreen('loadout-screen');

            // Add drop mode UI hint
            const inventoryPanel = document.querySelector('.inventory-panel h3');
            if (inventoryPanel) {
                inventoryPanel.innerHTML = `üì¶ Inventory <span style="color: #ff4444; font-size: 12px;">(MUST DROP ${mustDrop} ITEMS - Click to drop)</span>`;
            }
        }

        function showTraitSelectionScreen() {
            // Generate 3 random trait options
            const allTraits = Object.values(MECH_TRAITS);
            const availableTraits = allTraits.filter(trait =>
                !game.currentMech.traits.some(t => t.name === trait.name)
            );

            const traitOptions = [];
            for (let i = 0; i < 3 && availableTraits.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * availableTraits.length);
                traitOptions.push(availableTraits.splice(randomIndex, 1)[0]);
            }

            const traitsHTML = traitOptions.map((trait, index) => `
                <div class="mech-card" onclick="selectTrait(${index})" style="border-color: #ffaa00;">
                    <div style="font-size: 48px; text-align: center; margin: 15px 0;">${trait.icon}</div>
                    <div class="component-name" style="color: #ffaa00;">
                        ${trait.name}
                        <span class="tier-indicator tier-${trait.tier}">T${trait.tier}</span>
                    </div>
                    <div style="margin: 15px 0; color: #ccc; font-size: 13px; line-height: 1.5;">
                        ${trait.desc}
                    </div>
                    <div style="margin-top: 15px; padding: 10px; background: rgba(255,170,0,0.2); border-radius: 5px; font-size: 11px;">
                        This trait is permanent and will transform your playstyle!
                    </div>
                </div>
            `).join('');

            document.getElementById('trait-options').innerHTML = traitsHTML;
            window.currentTraitOptions = traitOptions;

            showScreen('trait-select-screen');
        }

        function selectTrait(index) {
            const trait = window.currentTraitOptions[index];

            if (!game.currentMech.traits) {
                game.currentMech.traits = [];
            }

            game.currentMech.traits.push(trait);
            game.save();

            alert(`${trait.icon} Trait Acquired: ${trait.name}!\n\n${trait.desc}`);

            // Check if we should show relic selection (after boss)
            if (window.showRelicAfterTrait) {
                window.showRelicAfterTrait = false;
                showRelicSelectionScreen(true); // true = boss reward
            } else {
                updateHeader();
                renderLoadoutScreen();
                showScreen('loadout-screen');
            }
        }

        function showRelicSelectionScreen(isBossReward = false) {
            // Generate 3 random relic options using weighted rarity selection
            const allRelics = Object.entries(RELICS);
            const availableRelics = allRelics.filter(([key, relic]) =>
                // Allow duplicates for stacking (except unique ones like Scavenger)
                key !== 'SCAVENGER' || !game.relics.includes(key)
            );

            // Select relics using weighted rarity
            const relicOptions = [];
            const attempts = [];

            for (let i = 0; i < 3 && availableRelics.length > 0; i++) {
                // Select a rarity using weighted random
                const targetRarity = selectWeightedRarity();

                // Find relics of this rarity
                const relicsOfRarity = availableRelics.filter(([key, relic]) => relic.rarity === targetRarity);

                let selectedRelic;
                if (relicsOfRarity.length > 0) {
                    // Pick random from this rarity
                    const randomIndex = Math.floor(Math.random() * relicsOfRarity.length);
                    const [key, relic] = relicsOfRarity[randomIndex];
                    selectedRelic = { key, ...relic };
                } else {
                    // Fallback to any available relic if no relics of target rarity
                    const randomIndex = Math.floor(Math.random() * availableRelics.length);
                    const [key, relic] = availableRelics[randomIndex];
                    selectedRelic = { key, ...relic };
                }

                relicOptions.push(selectedRelic);

                // Remove selected relic from pool temporarily for this selection
                const indexToRemove = availableRelics.findIndex(([k, r]) => k === selectedRelic.key);
                const removedRelic = availableRelics.splice(indexToRemove, 1)[0];

                // Only permanently remove if it's a unique relic
                if (selectedRelic.key !== 'SCAVENGER' && selectedRelic.key !== 'GLASS_CANNON_CORE') {
                    // For stackable relics, add it back for next iteration
                    attempts.push(removedRelic);
                }
            }

            // Restore non-unique relics to pool
            availableRelics.push(...attempts);

            // Update description based on context
            const descText = isBossReward ?
                'üèÜ BOSS DEFEATED! Choose a powerful relic as your reward:' :
                'You\'ve survived 3 more rounds! Choose a relic to enhance your build:';
            document.getElementById('relic-screen-desc').textContent = descText;

            const relicsHTML = relicOptions.map((relic, index) => {
                const count = game.relics.filter(r => r === relic.key).length;
                const stackText = count > 0 ? `<div style="color: #ffaa00; font-size: 11px; margin-top: 5px;">‚≠ê You have ${count} copy! Effects stack!</div>` : '';

                // Rarity styling
                const rarityData = RARITY[relic.rarity] || RARITY.COMMON;
                const rarityBadge = `<span style="background: ${rarityData.color}; color: #000; padding: 3px 8px; border-radius: 4px; font-size: 10px; font-weight: bold; margin-top: 8px; display: inline-block;">${rarityData.name.toUpperCase()}</span>`;

                return `
                    <div class="mech-card" onclick="selectRelic(${index})" style="border: 3px solid ${rarityData.color}; box-shadow: 0 0 15px ${rarityData.color}60;">
                        <div style="font-size: 48px; text-align: center; margin: 15px 0;">${relic.icon}</div>
                        <div class="component-name" style="color: ${rarityData.color};">
                            ${relic.name}
                        </div>
                        ${rarityBadge}
                        <div style="margin: 15px 0; color: #ccc; font-size: 13px; line-height: 1.5;">
                            ${relic.desc}
                        </div>
                        ${stackText}
                        <div style="margin-top: 15px; padding: 10px; background: rgba(0,204,255,0.2); border-radius: 5px; font-size: 10px; color: #00ccff;">
                            ${relic.category === 'damage' ? '‚öîÔ∏è SCALING' :
                              relic.category === 'conversion' ? '‚ö° CONVERSION' :
                              relic.category === 'investment' ? 'üìà INVESTMENT' :
                              relic.category === 'gameChanger' ? 'üíé GAME CHANGER' : 'üé≤ BUILD-AROUND'}
                        </div>
                    </div>
                `;
            }).join('');

            document.getElementById('relic-options').innerHTML = relicsHTML;
            window.currentRelicOptions = relicOptions;

            showScreen('relic-select-screen');
        }

        function selectRelic(index) {
            const relic = window.currentRelicOptions[index];

            if (!game.relics) {
                game.relics = [];
            }

            game.relics.push(relic.key);

            // Apply immediate effects
            if (relic.key === 'SCAVENGER') {
                // Increase max inventory
                updateHeader();
            } else if (relic.key === 'GLASS_CANNON_CORE') {
                // Reduce max HP by 50%
                game.currentMech.maxHP = Math.floor(game.currentMech.maxHP * 0.5);
                game.currentMech.currentHP = Math.min(game.currentMech.currentHP, game.currentMech.maxHP);
            } else if (relic.key === 'BLOOD_PACT') {
                // Reduce max HP by 20%
                game.currentMech.maxHP = Math.floor(game.currentMech.maxHP * 0.8);
                game.currentMech.currentHP = Math.min(game.currentMech.currentHP, game.currentMech.maxHP);
            }

            game.save();

            const count = game.relics.filter(r => r === relic.key).length;
            const stackMsg = count > 1 ? `\n\n‚ú® You now have ${count} copies! Effects stack!` : '';
            alert(`${relic.icon} Relic Acquired: ${relic.name}!\n\n${relic.desc}${stackMsg}`);

            updateHeader();
            renderLoadoutScreen();
            showScreen('loadout-screen');
        }

        // ============================================================================
        // INITIALIZATION
        // ============================================================================

        function initializeGame() {
            // Initialize physics engine
            initializePhysics();

            // Try to load saved game
            if (!game.load()) {
                // New game - choose starting mech
                const startingMechs = [
                    createMech(MECH_TEMPLATES.SCOUT, 1),
                    createMech(MECH_TEMPLATES.WARRIOR, 1),
                    createMech(MECH_TEMPLATES.TITAN, 1)
                ];

                // Add some starter components
                game.inventory = generateRandomComponents(6, 1, 2);

                const choice = confirm('Welcome to Mech Autobattler!\n\nChoose your starting mech:\n\nOK = Scout (Fast, Light)\nCancel = Warrior (Balanced)\n\n(Heavy Titan also available)');

                if (choice) {
                    game.currentMech = startingMechs[0];
                } else {
                    const choice2 = confirm('Warrior (Balanced) or Titan (Heavy)?\n\nOK = Warrior\nCancel = Titan');
                    game.currentMech = choice2 ? startingMechs[1] : startingMechs[2];
                }

                game.save();
            }

            updateHeader();
            renderLoadoutScreen();
        }

        // ============================================================================
        // EVENT LISTENERS
        // ============================================================================

        document.getElementById('ready-battle-btn').addEventListener('click', () => {
            if (!game.currentMech) {
                alert('No mech selected!');
                return;
            }
            renderBattleScreen();
        });

        document.getElementById('start-battle-btn').addEventListener('click', startBattle);

        // Physics controls
        document.getElementById('toggle-physics').addEventListener('click', function() {
            physicsEnabled = !physicsEnabled;
            this.classList.toggle('active');
            if (physicsEngine) {
                const canvas = document.getElementById('physics-canvas');
                canvas.style.display = physicsEnabled ? 'block' : 'none';
            }
        });

        // Auto-fire toggle
        let autoFireEnabled = true;
        document.getElementById('toggle-autofire').addEventListener('click', function() {
            autoFireEnabled = !autoFireEnabled;
            this.classList.toggle('active');
            this.textContent = autoFireEnabled ? 'üî´ Auto-Fire: ON' : 'üî´ Auto-Fire: OFF';
            // Store in global for battle system to check
            window.autoFireEnabled = autoFireEnabled;
        });
        window.autoFireEnabled = true;

        // Speed toggle (cycles through 1x, 2x, 4x)
        let currentSpeedIndex = 0;
        const speeds = [1, 2, 4];
        document.getElementById('toggle-speed').addEventListener('click', function() {
            currentSpeedIndex = (currentSpeedIndex + 1) % speeds.length;
            const speed = speeds[currentSpeedIndex];
            if (physicsEngine) physicsEngine.setTimeScale(speed);
            this.textContent = `‚ö° Speed: ${speed}x`;
        });

        // Abilities guide toggle
        document.getElementById('toggle-abilities-guide').addEventListener('click', () => {
            const guide = document.getElementById('abilities-guide');
            if (guide.style.display === 'none') {
                guide.style.display = 'block';
                populateAbilitiesGuide();
            } else {
                guide.style.display = 'none';
            }
        });

        function populateAbilitiesGuide() {
            const referenceDiv = document.getElementById('abilities-reference');

            let html = '<div style="font-size: 11px; line-height: 1.6;">';

            // Group abilities by category
            const damageAbilities = ['CRITICAL_STRIKE', 'ARMOR_PIERCING', 'BURN', 'BLEED', 'EXECUTIONER', 'DOUBLE_STRIKE', 'OVERCHARGE'];
            const defenseAbilities = ['SHIELD_GEN', 'REGENERATION', 'REACTIVE', 'DODGE'];
            const utilityAbilities = ['VAMPIRIC', 'BERSERKER', 'LIGHTWEIGHT', 'OVERDRIVE', 'QUICK_DEPLOY', 'EFFICIENT'];

            html += '<div style="margin-bottom: 12px;"><strong style="color: #ff8844; font-size: 12px;">‚öîÔ∏è DAMAGE ABILITIES</strong></div>';
            damageAbilities.forEach(key => {
                const ability = ABILITIES[key];
                if (ability) {
                    html += `
                        <div style="margin-bottom: 8px; padding: 6px; background: rgba(255, 136, 68, 0.1); border-left: 3px solid #ff8844; border-radius: 3px;">
                            <strong style="color: #ff8844;">${ability.name}</strong> <span style="color: #666; font-size: 9px;">(Tier ${ability.tier})</span><br>
                            <span style="color: #ccc; font-size: 10px;">${ability.desc}</span>
                        </div>
                    `;
                }
            });

            html += '<div style="margin: 12px 0;"><strong style="color: #00ccff; font-size: 12px;">üõ°Ô∏è DEFENSE ABILITIES</strong></div>';
            defenseAbilities.forEach(key => {
                const ability = ABILITIES[key];
                if (ability) {
                    html += `
                        <div style="margin-bottom: 8px; padding: 6px; background: rgba(0, 204, 255, 0.1); border-left: 3px solid #00ccff; border-radius: 3px;">
                            <strong style="color: #00ccff;">${ability.name}</strong> <span style="color: #666; font-size: 9px;">(Tier ${ability.tier})</span><br>
                            <span style="color: #ccc; font-size: 10px;">${ability.desc}</span>
                        </div>
                    `;
                }
            });

            html += '<div style="margin: 12px 0;"><strong style="color: #ffaa00; font-size: 12px;">‚ö° UTILITY ABILITIES</strong></div>';
            utilityAbilities.forEach(key => {
                const ability = ABILITIES[key];
                if (ability) {
                    html += `
                        <div style="margin-bottom: 8px; padding: 6px; background: rgba(255, 170, 0, 0.1); border-left: 3px solid #ffaa00; border-radius: 3px;">
                            <strong style="color: #ffaa00;">${ability.name}</strong> <span style="color: #666; font-size: 9px;">(Tier ${ability.tier})</span><br>
                            <span style="color: #ccc; font-size: 10px;">${ability.desc}</span>
                        </div>
                    `;
                }
            });

            html += '</div>';
            referenceDiv.innerHTML = html;
        }

        // Debug panel
        document.getElementById('debug-toggle').addEventListener('click', () => {
            const panel = document.getElementById('debug-panel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        });

        function updateDebugPanel() {
            const panel = document.getElementById('debug-panel');
            const stats = game.currentMech ? calculateMechStats(game.currentMech) : null;

            panel.innerHTML = `
                <h4 style="color: #ff00ff;">DEBUG INFO</h4>
                <div style="margin-bottom: 10px; padding: 5px; background: rgba(255,0,255,0.2); border-radius: 4px; font-size: 10px;">
                    <strong>Version:</strong> 3.3.0 - INVENTORY OVERHAUL
                </div>
                <div style="margin: 10px 0;">
                    <strong>Round:</strong> ${game.round}<br>
                    <strong>Victories:</strong> ${game.victories}<br>
                    <strong>Inventory:</strong> ${game.inventory.length} items<br>
                    ${stats ? `
                        <strong>Mech Stats:</strong><br>
                        - Damage: ${stats.damage}<br>
                        - Armor: ${stats.armor}<br>
                        - Speed: ${stats.speed}<br>
                        - Tier: ${stats.tierUsed}/${game.currentMech.tierCapacity}<br>
                        - Weight: ${stats.weightUsed}/${game.currentMech.weightCapacity}
                    ` : '<em>No mech selected</em>'}
                </div>
                <button class="btn btn-danger" onclick="if(confirm('Reset game?')) { game.reset(); initializeGame(); }" style="width: 100%; padding: 8px; font-size: 12px;">
                    RESET GAME
                </button>
            `;
        }

        // Update debug panel every second
        setInterval(updateDebugPanel, 1000);

        // ============================================================================
        // START GAME
        // ============================================================================

        initializeGame();
    </script>
</body>
</html>
