<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mech Autobattler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            background-attachment: fixed;
            color: #eee;
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 10px;
        }

        header {
            background: rgba(0, 0, 0, 0.5);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 2px solid #00ff88;
        }

        h1 {
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin-bottom: 8px;
            font-size: 20px;
        }

        h2 {
            font-size: 18px;
            margin-bottom: 10px;
        }

        h3 {
            font-size: 16px;
        }

        .stats-bar {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 11px;
        }

        .stat {
            font-size: 11px;
        }

        .stat strong {
            color: #00ff88;
        }

        .screen {
            display: none;
        }

        .screen.active {
            display: block;
        }

        /* Battle Screen - MOBILE OPTIMIZED */
        .battle-area {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 15px;
        }

        .combatant {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #444;
        }

        .combatant h2 {
            font-size: 14px;
            margin-bottom: 8px;
        }

        .combatant.player {
            border-color: #00ff88;
        }

        .combatant.monster {
            border-color: #ff4444;
        }

        .mech-display {
            text-align: center;
        }

        .mech-display h3 {
            font-size: 14px;
        }

        .mech-visual {
            font-size: 40px;
            margin: 8px 0;
        }

        .health-bar {
            background: #333;
            height: 24px;
            border-radius: 12px;
            overflow: hidden;
            margin: 8px 0;
            border: 1px solid #555;
        }

        .health-fill {
            background: linear-gradient(90deg, #ff4444, #ff8844);
            height: 100%;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
        }

        .health-fill.player {
            background: linear-gradient(90deg, #00ff88, #00ccff);
        }

        .combat-log {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #444;
            height: 250px;
            overflow-y: auto;
            font-size: 12px;
        }

        .log-entry {
            padding: 6px;
            margin: 3px 0;
            border-left: 3px solid #444;
            padding-left: 8px;
            animation: slideIn 0.3s ease;
            line-height: 1.4;
        }

        .log-entry.player {
            border-left-color: #00ff88;
        }

        .log-entry.monster {
            border-left-color: #ff4444;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Salvage Screen - MOBILE OPTIMIZED */
        .salvage-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 15px 0;
        }

        .salvage-card, .mech-card {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #444;
            cursor: pointer;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .salvage-card:active, .mech-card:active {
            border-color: #00ff88;
            transform: scale(0.98);
            box-shadow: 0 3px 15px rgba(0, 255, 136, 0.3);
        }

        .component-name {
            color: #00ff88;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .component-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin: 10px 0;
            font-size: 11px;
        }

        .stat-item {
            padding: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            text-align: center;
        }

        /* Loadout Screen - MOBILE OPTIMIZED */
        .loadout-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .mech-panel {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00ff88;
        }

        .mech-panel h3 {
            font-size: 14px;
        }

        .mech-slots {
            margin-top: 15px;
        }

        .slot {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            margin: 8px 0;
            border-radius: 6px;
            border: 2px dashed #444;
            min-height: 55px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .slot.filled {
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
        }

        .slot:active {
            background: rgba(0, 255, 136, 0.2);
        }

        .slot-header {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .inventory-panel {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #444;
            max-height: 500px;
            overflow-y: auto;
        }

        .inventory-panel h3 {
            font-size: 16px;
        }

        .inventory-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 12px;
        }

        .inventory-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 6px;
            border: 2px solid #444;
            cursor: pointer;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .inventory-item:active {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.15);
            transform: scale(0.98);
        }

        .inventory-item.selected {
            border-color: #00ccff;
            background: rgba(0, 204, 255, 0.2);
        }

        /* Buttons - MOBILE OPTIMIZED */
        .btn {
            background: linear-gradient(135deg, #00ff88, #00ccff);
            color: #000;
            border: none;
            padding: 16px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 8px 0;
            width: 100%;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .btn:active {
            transform: scale(0.97);
            box-shadow: 0 3px 15px rgba(0, 255, 136, 0.5);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: scale(1);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #666, #888);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff4444, #ff8844);
        }

        /* Resource bars */
        .resource-bars {
            margin: 12px 0;
        }

        .resource-bar {
            margin: 10px 0;
        }

        .resource-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 11px;
        }

        .resource-fill-container {
            background: #333;
            height: 12px;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #555;
        }

        .resource-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .resource-fill.tier {
            background: linear-gradient(90deg, #ff4444, #ff8844);
        }

        .resource-fill.weight {
            background: linear-gradient(90deg, #00ccff, #0088ff);
        }

        .tier-indicator {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 5px;
        }

        .tier-1 { background: #888; }
        .tier-2 { background: #00ff88; color: #000; }
        .tier-3 { background: #00ccff; color: #000; }
        .tier-4 { background: #ff00ff; color: #fff; }
        .tier-5 { background: #ffaa00; color: #000; }

        /* Debug Panel - MOBILE OPTIMIZED */
        .debug-panel {
            position: fixed;
            top: 50px;
            right: 10px;
            background: rgba(0, 0, 0, 0.95);
            padding: 12px;
            border-radius: 6px;
            border: 2px solid #ff00ff;
            font-size: 10px;
            max-width: 250px;
            z-index: 1000;
            max-height: 80vh;
            overflow-y: auto;
        }

        .debug-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #ff00ff;
            color: #000;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 999;
            font-size: 11px;
            font-weight: bold;
            -webkit-tap-highlight-color: transparent;
        }

        /* Scrollbar styling - MOBILE */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        ::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00ccff;
        }

        .warning {
            color: #ff8844;
            font-weight: bold;
        }

        .success {
            color: #00ff88;
            font-weight: bold;
        }

        /* Tablet and larger screens */
        @media (min-width: 768px) {
            .container {
                max-width: 1400px;
                padding: 20px;
            }

            h1 {
                font-size: 28px;
            }

            h2 {
                font-size: 22px;
            }

            .stats-bar {
                display: flex;
                gap: 30px;
            }

            .stat {
                font-size: 14px;
            }

            .battle-area {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 20px;
            }

            .salvage-options {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 20px;
            }

            .loadout-container {
                display: grid;
                grid-template-columns: 400px 1fr;
                gap: 20px;
            }

            .inventory-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            }

            .btn {
                width: auto;
            }

            .btn:hover {
                transform: scale(1.05);
            }

            .salvage-card:hover, .mech-card:hover {
                border-color: #00ff88;
                transform: translateY(-5px);
            }

            .inventory-item:hover {
                border-color: #00ff88;
                background: rgba(0, 255, 136, 0.1);
            }

            .slot:hover {
                background: rgba(0, 255, 136, 0.15);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚öîÔ∏è MECH AUTOBATTLER ‚öîÔ∏è</h1>
            <div class="stats-bar">
                <div class="stat"><strong>Round:</strong> <span id="round-num">1</span></div>
                <div class="stat"><strong>Victories:</strong> <span id="victories">0</span></div>
                <div class="stat"><strong>Current Mech:</strong> <span id="current-mech-name">None</span></div>
                <div class="stat"><strong>Inventory:</strong> <span id="inventory-count">0</span> components</div>
            </div>
        </header>

        <!-- Battle Screen -->
        <div id="battle-screen" class="screen">
            <div class="battle-area">
                <div class="combatant player">
                    <h2>ü§ñ YOUR MECH</h2>
                    <div class="mech-display">
                        <div class="mech-visual" id="player-visual">ü§ñ</div>
                        <h3 id="player-name">Loading...</h3>
                        <div class="health-bar">
                            <div class="health-fill player" id="player-health">
                                <span id="player-health-text">100/100</span>
                            </div>
                        </div>
                        <div id="player-stats" style="font-size: 12px; margin-top: 10px;"></div>
                    </div>
                </div>

                <div class="combatant monster">
                    <h2>üëæ ENEMY</h2>
                    <div class="mech-display">
                        <div class="mech-visual" id="monster-visual">üëæ</div>
                        <h3 id="monster-name">Loading...</h3>
                        <div class="health-bar">
                            <div class="health-fill" id="monster-health">
                                <span id="monster-health-text">100/100</span>
                            </div>
                        </div>
                        <div id="monster-stats" style="font-size: 12px; margin-top: 10px;"></div>
                    </div>
                </div>
            </div>

            <div class="combat-log" id="combat-log"></div>

            <div style="text-align: center; margin-top: 20px;">
                <button class="btn" id="start-battle-btn">START BATTLE</button>
            </div>
        </div>

        <!-- Salvage Screen -->
        <div id="salvage-screen" class="screen">
            <h2>üîß SALVAGE SELECTION</h2>
            <p style="margin: 15px 0;">Choose one component to salvage from the battlefield:</p>
            <div class="salvage-options" id="salvage-options"></div>
        </div>

        <!-- Trait Selection Screen -->
        <div id="trait-select-screen" class="screen">
            <h2>‚≠ê MECH UPGRADE AVAILABLE ‚≠ê</h2>
            <p style="margin: 15px 0;">Your mech has proven itself in battle! Choose a permanent trait upgrade:</p>
            <div class="salvage-options" id="trait-options"></div>
        </div>

        <!-- Loadout Screen -->
        <div id="loadout-screen" class="screen active">
            <h2>‚öôÔ∏è LOADOUT MANAGEMENT</h2>
            <div class="loadout-container">
                <div class="mech-panel">
                    <h3 id="loadout-mech-name">Select a Mech</h3>
                    <div class="mech-visual" style="text-align: center; font-size: 64px; margin: 20px 0;" id="loadout-mech-visual">ü§ñ</div>

                    <div class="resource-bars">
                        <div class="resource-bar">
                            <div class="resource-label">
                                <span>Tier Points:</span>
                                <span id="tier-usage">0/0</span>
                            </div>
                            <div class="resource-fill-container">
                                <div class="resource-fill tier" id="tier-bar"></div>
                            </div>
                        </div>
                        <div class="resource-bar">
                            <div class="resource-label">
                                <span>Weight:</span>
                                <span id="weight-usage">0/0</span>
                            </div>
                            <div class="resource-fill-container">
                                <div class="resource-fill weight" id="weight-bar"></div>
                            </div>
                        </div>
                    </div>

                    <div class="mech-slots" id="mech-slots"></div>

                    <button class="btn" id="ready-battle-btn" style="width: 100%; margin-top: 20px;">READY FOR BATTLE</button>
                </div>

                <div class="inventory-panel">
                    <h3>üì¶ Inventory</h3>
                    <div class="inventory-grid" id="inventory-grid"></div>
                </div>
            </div>
        </div>
    </div>

    <button class="debug-toggle" id="debug-toggle">DEBUG</button>
    <div class="debug-panel" id="debug-panel" style="display: none;"></div>

    <script>
        // ============================================================================
        // GAME DATA STRUCTURES
        // ============================================================================

        const SLOT_TYPES = {
            HEAD: 'head',
            TORSO: 'torso',
            LEFT_ARM: 'leftArm',
            RIGHT_ARM: 'rightArm',
            LEFT_SHOULDER: 'leftShoulder',
            RIGHT_SHOULDER: 'rightShoulder',
            LEGS: 'legs'
        };

        const COMPONENT_TYPES = {
            WEAPON: 'weapon',
            ARMOR: 'armor',
            SYSTEM: 'system'
        };

        const MECH_CLASSES = {
            LIGHT: 'Light',
            MEDIUM: 'Medium',
            HEAVY: 'Heavy'
        };

        const DAMAGE_TYPES = {
            ENERGY: 'energy',
            KINETIC: 'kinetic',
            EXPLOSIVE: 'explosive',
            NONE: 'none'
        };

        const ABILITIES = {
            // Damage abilities
            CRITICAL_STRIKE: { name: 'Critical Strike', desc: '25% crit chance (2x dmg)', tier: 2 },
            VAMPIRIC: { name: 'Vampiric', desc: 'Heal 25% of damage dealt', tier: 4 },
            ARMOR_PIERCING: { name: 'Armor Piercing', desc: 'Ignore 50% enemy armor', tier: 3 },
            BURN: { name: 'Plasma Burn', desc: 'Deal 5 dmg/turn for 3 turns', tier: 2 },
            BLEED: { name: 'Hemorrhage', desc: 'Crits cause 15 bleed over 5 turns', tier: 3 },

            // Defense abilities
            SHIELD_GEN: { name: 'Energy Shield', desc: 'Start with 50 shield HP', tier: 3 },
            REGENERATION: { name: 'Regeneration', desc: 'Heal 5 HP per turn', tier: 3 },
            REACTIVE: { name: 'Reactive Armor', desc: 'Reflect 25% damage taken', tier: 3 },
            DODGE: { name: 'Dodge Matrix', desc: '20% chance to avoid damage', tier: 3 },

            // Speed abilities
            LIGHTWEIGHT: { name: 'Lightweight Frame', desc: 'Weight doesn\'t affect speed', tier: 2 },
            OVERDRIVE: { name: 'Overdrive', desc: '+50 speed, -20% armor', tier: 3 },
            QUICK_DEPLOY: { name: 'Quick Deploy', desc: 'Always attack first on turn 1', tier: 2 },

            // Special abilities
            EFFICIENT: { name: 'Efficient Design', desc: 'Component costs -1 tier', tier: 3 },
            BERSERKER: { name: 'Berserker', desc: '+1% dmg per 1% HP missing', tier: 3 },
            EXECUTIONER: { name: 'Executioner', desc: '+100% dmg vs enemies <30% HP', tier: 3 },
            DOUBLE_STRIKE: { name: 'Multi-Strike', desc: 'Attack twice at 60% dmg each', tier: 4 },
            OVERCHARGE: { name: 'Overcharge', desc: '+100% dmg, take 10% max HP/attack', tier: 5 }
        };

        const MECH_TRAITS = {
            BERSERKER: {
                name: 'BERSERKER',
                desc: 'Gain +3% damage per 1% HP missing',
                tier: 4,
                icon: 'üí¢'
            },
            CRITICAL_CORE: {
                name: 'CRITICAL CORE',
                desc: 'All attacks have +30% crit chance, crits deal 3x damage',
                tier: 3,
                icon: 'üí•'
            },
            FORTRESS: {
                name: 'FORTRESS',
                desc: 'Armor increased by 100%, speed reduced by 50%',
                tier: 4,
                icon: 'üõ°Ô∏è'
            },
            REGENERATOR: {
                name: 'REGENERATOR',
                desc: 'Regenerate 8% max HP per turn',
                tier: 4,
                icon: 'üíö'
            },
            VAMPIRE: {
                name: 'VAMPIRE',
                desc: 'Heal for 40% of damage dealt, -30% armor',
                tier: 5,
                icon: 'ü©∏'
            },
            LIGHTNING_FAST: {
                name: 'LIGHTNING FAST',
                desc: 'Weight doesn\'t affect speed, +50 base speed',
                tier: 4,
                icon: '‚ö°'
            },
            EFFICIENT: {
                name: 'EFFICIENT',
                desc: 'All components cost -2 tier points (min 1)',
                tier: 5,
                icon: '‚öôÔ∏è'
            },
            SALVAGER: {
                name: 'SALVAGER',
                desc: 'Choose 2 salvage items instead of 1',
                tier: 4,
                icon: 'üîß'
            },
            ENERGY_MASTER: {
                name: 'ENERGY MASTER',
                desc: 'All Energy damage +100%, Energy components cost -1 tier',
                tier: 4,
                icon: '‚öõÔ∏è'
            },
            KINETIC_MASTER: {
                name: 'KINETIC MASTER',
                desc: 'All Kinetic damage +100%, ignore 50% armor',
                tier: 4,
                icon: 'üéØ'
            },
            EXPLOSIVE_MASTER: {
                name: 'EXPLOSIVE MASTER',
                desc: 'All Explosive damage +100%, apply burn effect',
                tier: 4,
                icon: 'üí£'
            },
            OVERCHARGED: {
                name: 'OVERCHARGED',
                desc: '+100% damage, lose 8% max HP per turn',
                tier: 5,
                icon: 'üî•'
            }
        };

        // Mech Templates
        const MECH_TEMPLATES = {
            SCOUT: {
                name: 'Scout',
                class: MECH_CLASSES.LIGHT,
                tierCapacity: 50,
                weightCapacity: 100,
                baseHP: 80,
                baseArmor: 5,
                visual: 'üèÉ',
                slots: {
                    [SLOT_TYPES.HEAD]: { capacity: 1 },
                    [SLOT_TYPES.TORSO]: { capacity: 2 },
                    [SLOT_TYPES.LEFT_ARM]: { capacity: 2 },
                    [SLOT_TYPES.RIGHT_ARM]: { capacity: 2 },
                    [SLOT_TYPES.LEFT_SHOULDER]: { capacity: 1 },
                    [SLOT_TYPES.RIGHT_SHOULDER]: { capacity: 1 },
                    [SLOT_TYPES.LEGS]: { capacity: 2 }
                }
            },
            WARRIOR: {
                name: 'Warrior',
                class: MECH_CLASSES.MEDIUM,
                tierCapacity: 75,
                weightCapacity: 150,
                baseHP: 120,
                baseArmor: 10,
                visual: 'ü§ñ',
                slots: {
                    [SLOT_TYPES.HEAD]: { capacity: 2 },
                    [SLOT_TYPES.TORSO]: { capacity: 3 },
                    [SLOT_TYPES.LEFT_ARM]: { capacity: 3 },
                    [SLOT_TYPES.RIGHT_ARM]: { capacity: 3 },
                    [SLOT_TYPES.LEFT_SHOULDER]: { capacity: 2 },
                    [SLOT_TYPES.RIGHT_SHOULDER]: { capacity: 2 },
                    [SLOT_TYPES.LEGS]: { capacity: 2 }
                }
            },
            TITAN: {
                name: 'Titan',
                class: MECH_CLASSES.HEAVY,
                tierCapacity: 100,
                weightCapacity: 200,
                baseHP: 180,
                baseArmor: 15,
                visual: 'üèãÔ∏è',
                slots: {
                    [SLOT_TYPES.HEAD]: { capacity: 2 },
                    [SLOT_TYPES.TORSO]: { capacity: 4 },
                    [SLOT_TYPES.LEFT_ARM]: { capacity: 4 },
                    [SLOT_TYPES.RIGHT_ARM]: { capacity: 4 },
                    [SLOT_TYPES.LEFT_SHOULDER]: { capacity: 3 },
                    [SLOT_TYPES.RIGHT_SHOULDER]: { capacity: 3 },
                    [SLOT_TYPES.LEGS]: { capacity: 3 }
                }
            }
        };

        // Component Templates
        const COMPONENT_TEMPLATES = [
            // ENERGY WEAPONS
            { name: 'Laser Cannon', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_ARM, damage: 25, armor: 0, tier: 2, weight: 15, size: 2, damageType: DAMAGE_TYPES.ENERGY, abilities: ['CRITICAL_STRIKE'] },
            { name: 'Plasma Rifle', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_ARM, damage: 30, armor: 0, tier: 3, weight: 20, size: 2, damageType: DAMAGE_TYPES.ENERGY, abilities: ['BURN'] },
            { name: 'Ion Beam', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.LEFT_ARM, damage: 22, armor: 0, tier: 3, weight: 18, size: 2, damageType: DAMAGE_TYPES.ENERGY, abilities: ['ARMOR_PIERCING'] },

            // KINETIC WEAPONS
            { name: 'Rail Gun', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_ARM, damage: 40, armor: 0, tier: 4, weight: 30, size: 3, damageType: DAMAGE_TYPES.KINETIC, abilities: ['ARMOR_PIERCING'] },
            { name: 'Machine Gun', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.LEFT_ARM, damage: 15, armor: 0, tier: 1, weight: 10, size: 1, damageType: DAMAGE_TYPES.KINETIC, abilities: [] },
            { name: 'Autocannon', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_ARM, damage: 28, armor: 0, tier: 3, weight: 25, size: 2, damageType: DAMAGE_TYPES.KINETIC, abilities: ['BLEED'] },

            // EXPLOSIVE WEAPONS
            { name: 'Missile Pod', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.LEFT_SHOULDER, damage: 35, armor: 0, tier: 3, weight: 25, size: 2, damageType: DAMAGE_TYPES.EXPLOSIVE, abilities: ['BURN'] },
            { name: 'Rocket Launcher', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.RIGHT_SHOULDER, damage: 45, armor: 0, tier: 4, weight: 35, size: 3, damageType: DAMAGE_TYPES.EXPLOSIVE, abilities: ['EXECUTIONER'] },
            { name: 'Grenade Launcher', type: COMPONENT_TYPES.WEAPON, slot: SLOT_TYPES.LEFT_SHOULDER, damage: 30, armor: 0, tier: 2, weight: 20, size: 2, damageType: DAMAGE_TYPES.EXPLOSIVE, abilities: [] },

            // ARMOR
            { name: 'Light Plating', type: COMPONENT_TYPES.ARMOR, slot: SLOT_TYPES.TORSO, damage: 0, armor: 10, tier: 1, weight: 15, size: 1, damageType: DAMAGE_TYPES.NONE, abilities: [] },
            { name: 'Heavy Plating', type: COMPONENT_TYPES.ARMOR, slot: SLOT_TYPES.TORSO, damage: 0, armor: 20, tier: 2, weight: 30, size: 2, damageType: DAMAGE_TYPES.NONE, abilities: [] },
            { name: 'Composite Armor', type: COMPONENT_TYPES.ARMOR, slot: SLOT_TYPES.TORSO, damage: 0, armor: 35, tier: 4, weight: 40, size: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['REACTIVE'] },
            { name: 'Reactive Armor', type: COMPONENT_TYPES.ARMOR, slot: SLOT_TYPES.TORSO, damage: 0, armor: 25, tier: 3, weight: 35, size: 2, damageType: DAMAGE_TYPES.NONE, abilities: ['REACTIVE'] },

            // SYSTEMS - Head
            { name: 'Targeting System', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.HEAD, damage: 10, armor: 5, tier: 2, weight: 10, size: 1, damageType: DAMAGE_TYPES.NONE, abilities: ['CRITICAL_STRIKE'] },
            { name: 'Advanced Sensors', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.HEAD, damage: 15, armor: 10, tier: 3, weight: 15, size: 2, damageType: DAMAGE_TYPES.NONE, abilities: ['EXECUTIONER'] },

            // SYSTEMS - Legs
            { name: 'Boost System', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.LEGS, damage: 5, armor: 0, tier: 2, weight: 20, size: 1, damageType: DAMAGE_TYPES.NONE, abilities: ['LIGHTWEIGHT'] },
            { name: 'Overdrive Boosters', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.LEGS, damage: 8, armor: 0, tier: 3, weight: 15, size: 2, damageType: DAMAGE_TYPES.NONE, abilities: ['OVERDRIVE'] },
            { name: 'Heavy Servos', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.LEGS, damage: 0, armor: 15, tier: 3, weight: 35, size: 2, damageType: DAMAGE_TYPES.NONE, abilities: [] },

            // SYSTEMS - Special
            { name: 'Shield Generator', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 0, armor: 25, tier: 3, weight: 25, size: 2, damageType: DAMAGE_TYPES.NONE, abilities: ['SHIELD_GEN'] },
            { name: 'Repair Nanobots', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 0, armor: 15, tier: 3, weight: 20, size: 2, damageType: DAMAGE_TYPES.NONE, abilities: ['REGENERATION'] },
            { name: 'Power Core', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 10, armor: 10, tier: 3, weight: 30, size: 2, damageType: DAMAGE_TYPES.NONE, abilities: ['EFFICIENT'] },
            { name: 'Vampiric Core', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 15, armor: 0, tier: 4, weight: 25, size: 2, damageType: DAMAGE_TYPES.NONE, abilities: ['VAMPIRIC'] },
            { name: 'Berserker Chip', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.HEAD, damage: 20, armor: 0, tier: 3, weight: 10, size: 1, damageType: DAMAGE_TYPES.NONE, abilities: ['BERSERKER'] },
            { name: 'Overcharge Module', type: COMPONENT_TYPES.SYSTEM, slot: SLOT_TYPES.TORSO, damage: 25, armor: 0, tier: 5, weight: 20, size: 3, damageType: DAMAGE_TYPES.NONE, abilities: ['OVERCHARGE'] }
        ];

        // ============================================================================
        // GAME STATE
        // ============================================================================

        class GameState {
            constructor() {
                this.round = 1;
                this.victories = 0;
                this.currentMech = null;
                this.inventory = [];
                this.currentMonster = null;
                this.battleInProgress = false;
            }

            save() {
                localStorage.setItem('mechAutobattler', JSON.stringify({
                    round: this.round,
                    victories: this.victories,
                    currentMech: this.currentMech,
                    inventory: this.inventory
                }));
            }

            load() {
                const saved = localStorage.getItem('mechAutobattler');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.round = data.round || 1;
                    this.victories = data.victories || 0;
                    this.currentMech = data.currentMech;
                    this.inventory = data.inventory || [];
                    return true;
                }
                return false;
            }

            reset() {
                this.round = 1;
                this.victories = 0;
                this.currentMech = null;
                this.inventory = [];
                this.save();
            }
        }

        const game = new GameState();

        // ============================================================================
        // COMPONENT & MECH MANAGEMENT
        // ============================================================================

        function createMech(template, tier = 1) {
            return {
                ...JSON.parse(JSON.stringify(template)),
                tier: tier,
                loadout: {},
                currentHP: template.baseHP,
                maxHP: template.baseHP,
                traits: []  // Array of acquired traits
            };
        }

        function createComponent(template, tier = 1) {
            const comp = { ...template };
            comp.tier = tier;
            comp.id = Math.random().toString(36).substr(2, 9);

            // Ensure abilities and damageType are copied properly
            comp.abilities = template.abilities ? [...template.abilities] : [];
            comp.damageType = template.damageType || DAMAGE_TYPES.NONE;

            // Scale stats with tier
            const tierMultiplier = 1 + ((tier - 1) * 0.3);
            comp.damage = Math.floor(comp.damage * tierMultiplier);
            comp.armor = Math.floor(comp.armor * tierMultiplier);

            return comp;
        }

        function generateRandomComponents(count, minTier, maxTier) {
            const components = [];
            for (let i = 0; i < count; i++) {
                const template = COMPONENT_TEMPLATES[Math.floor(Math.random() * COMPONENT_TEMPLATES.length)];
                const tier = Math.floor(Math.random() * (maxTier - minTier + 1)) + minTier;
                components.push(createComponent(template, tier));
            }
            return components;
        }

        function generateRandomMechs(count, tier) {
            const mechs = [];
            const templates = Object.values(MECH_TEMPLATES);
            for (let i = 0; i < count; i++) {
                const template = templates[Math.floor(Math.random() * templates.length)];
                mechs.push(createMech(template, tier));
            }
            return mechs;
        }

        function calculateMechStats(mech) {
            let totalDamage = 0;
            let totalArmor = mech.baseArmor;
            let totalTier = 0;
            let totalWeight = 0;

            const traits = mech.traits || [];

            Object.values(mech.loadout).forEach(component => {
                if (component) {
                    totalDamage += component.damage;
                    totalArmor += component.armor;

                    // Apply EFFICIENT trait/ability - reduce tier cost
                    let compTier = component.tier;
                    if (traits.some(t => t.name === 'EFFICIENT')) {
                        compTier = Math.max(1, compTier - 2);
                    } else if (component.abilities && component.abilities.includes('EFFICIENT')) {
                        compTier = Math.max(1, compTier - 1);
                    }

                    totalTier += compTier;
                    totalWeight += component.weight;
                }
            });

            // Apply FORTRESS trait - double armor
            if (traits.some(t => t.name === 'FORTRESS')) {
                totalArmor *= 2;
            }

            // Apply VAMPIRE trait - reduce armor
            if (traits.some(t => t.name === 'VAMPIRE')) {
                totalArmor = Math.floor(totalArmor * 0.7);
            }

            return {
                damage: totalDamage,
                armor: totalArmor,
                tierUsed: totalTier,
                weightUsed: totalWeight,
                speed: Math.max(1, 100 - Math.floor(totalWeight / 2))
            };
        }

        function canAttachComponent(mech, component, slotName) {
            if (component.slot !== slotName) return false;

            const slot = mech.slots[slotName];
            if (component.size > slot.capacity) return false;

            // Calculate if adding this would exceed limits
            const currentStats = calculateMechStats(mech);
            const newTier = currentStats.tierUsed + component.tier;
            const newWeight = currentStats.weightUsed + component.weight;

            // If slot is filled, subtract the old component's contribution
            if (mech.loadout[slotName]) {
                const oldComp = mech.loadout[slotName];
                newTier -= oldComp.tier;
                newWeight -= oldComp.weight;
            }

            if (newTier > mech.tierCapacity) return false;
            if (newWeight > mech.weightCapacity) return false;

            return true;
        }

        function attachComponent(mech, component, slotName) {
            if (!canAttachComponent(mech, component, slotName)) {
                return false;
            }

            // Remove from old slot if it's already attached
            Object.keys(mech.loadout).forEach(key => {
                if (mech.loadout[key]?.id === component.id) {
                    delete mech.loadout[key];
                }
            });

            // Remove old component from slot and return it to inventory
            if (mech.loadout[slotName]) {
                const oldComp = mech.loadout[slotName];
                game.inventory.push(oldComp);
            }

            // Attach new component
            mech.loadout[slotName] = component;

            // Remove from inventory
            const invIndex = game.inventory.findIndex(c => c.id === component.id);
            if (invIndex !== -1) {
                game.inventory.splice(invIndex, 1);
            }

            game.save();
            return true;
        }

        function detachComponent(mech, slotName) {
            if (mech.loadout[slotName]) {
                const component = mech.loadout[slotName];
                game.inventory.push(component);
                delete mech.loadout[slotName];
                game.save();
                return true;
            }
            return false;
        }

        // ============================================================================
        // MONSTER GENERATION
        // ============================================================================

        function generateMonster(round) {
            const difficultyMultiplier = 1 + ((round - 1) * 0.2);

            const monsterTypes = [
                { name: 'Scrap Bot', visual: 'ü§ñ', hp: 60, damage: 15, armor: 5 },
                { name: 'War Drone', visual: 'üëæ', hp: 80, damage: 20, armor: 8 },
                { name: 'Battle Mech', visual: 'ü¶æ', hp: 100, damage: 25, armor: 10 },
                { name: 'Tank Unit', visual: 'üöõ', hp: 120, damage: 18, armor: 15 },
                { name: 'Hunter Killer', visual: 'üíÄ', hp: 70, damage: 35, armor: 5 }
            ];

            const baseMonster = monsterTypes[Math.floor(Math.random() * monsterTypes.length)];

            return {
                name: `${baseMonster.name} Mk.${Math.ceil(round / 2)}`,
                visual: baseMonster.visual,
                maxHP: Math.floor(baseMonster.hp * difficultyMultiplier),
                currentHP: Math.floor(baseMonster.hp * difficultyMultiplier),
                damage: Math.floor(baseMonster.damage * difficultyMultiplier),
                armor: Math.floor(baseMonster.armor * difficultyMultiplier),
                speed: 50 + Math.floor(Math.random() * 30)
            };
        }

        // ============================================================================
        // BATTLE SYSTEM
        // ============================================================================

        class BattleSystem {
            constructor(playerMech, monster) {
                this.playerMech = JSON.parse(JSON.stringify(playerMech));
                this.monster = JSON.parse(JSON.stringify(monster));
                this.log = [];
                this.turn = 0;

                // Initialize battle state
                this.playerShield = 0;
                this.playerDots = []; // {type, damage, duration}
                this.monsterDots = [];

                // Collect all player abilities
                this.playerAbilities = this.collectAbilities(this.playerMech);
                this.playerTraits = this.playerMech.traits || [];

                // Apply start-of-battle abilities
                this.applyStartOfBattleAbilities();
            }

            collectAbilities(mech) {
                const abilities = [];
                Object.values(mech.loadout || {}).forEach(comp => {
                    if (comp && comp.abilities) {
                        comp.abilities.forEach(abilityKey => {
                            if (ABILITIES[abilityKey]) {
                                abilities.push(abilityKey);
                            }
                        });
                    }
                });
                return abilities;
            }

            applyStartOfBattleAbilities() {
                // Shield Generator
                if (this.playerAbilities.includes('SHIELD_GEN')) {
                    this.playerShield = 50;
                    this.addLog('üõ°Ô∏è Energy Shield activated! (50 shield)', 'player');
                }
            }

            addLog(message, actor = 'system') {
                this.log.push({ message, actor, turn: this.turn });
            }

            hasAbility(abilityKey) {
                return this.playerAbilities.includes(abilityKey);
            }

            hasTrait(traitName) {
                return this.playerTraits.some(t => t.name === traitName);
            }

            calculateDamage(isPlayer, targetArmor) {
                const stats = calculateMechStats(this.playerMech);
                let baseDamage = isPlayer ? stats.damage : this.monster.damage;
                const currentArmor = targetArmor;

                if (isPlayer) {
                    // Apply trait bonuses
                    if (this.hasTrait('BERSERKER')) {
                        const hpLostPercent = ((this.playerMech.maxHP - this.playerMech.currentHP) / this.playerMech.maxHP) * 100;
                        const bonus = Math.floor(baseDamage * (hpLostPercent * 0.03));
                        if (bonus > 0) {
                            baseDamage += bonus;
                            this.addLog(`üí¢ Berserker bonus: +${bonus} dmg`, 'player');
                        }
                    }

                    if (this.hasTrait('OVERCHARGED')) {
                        baseDamage *= 2;
                    }

                    // Apply ability bonuses
                    if (this.hasAbility('BERSERKER')) {
                        const hpLostPercent = ((this.playerMech.maxHP - this.playerMech.currentHP) / this.playerMech.maxHP) * 100;
                        const bonus = Math.floor(baseDamage * (hpLostPercent * 0.01));
                        baseDamage += bonus;
                    }

                    if (this.hasAbility('OVERCHARGE')) {
                        baseDamage *= 2;
                        const selfDamage = Math.floor(this.playerMech.maxHP * 0.1);
                        this.playerMech.currentHP -= selfDamage;
                        this.addLog(`‚ö° Overcharge! +100% dmg, -${selfDamage} HP`, 'player');
                    }
                }

                // Critical strike
                let isCrit = false;
                if (isPlayer && (this.hasAbility('CRITICAL_STRIKE') || this.hasTrait('CRITICAL_CORE'))) {
                    const critChance = this.hasTrait('CRITICAL_CORE') ? 0.30 : 0.25;
                    const critMultiplier = this.hasTrait('CRITICAL_CORE') ? 3 : 2;

                    if (Math.random() < critChance) {
                        baseDamage *= critMultiplier;
                        isCrit = true;
                    }
                }

                // Armor reduction
                let armorToUse = currentArmor;
                if (isPlayer && this.hasAbility('ARMOR_PIERCING')) {
                    armorToUse *= 0.5;
                }

                const damageReduction = Math.min(armorToUse * 0.5, baseDamage * 0.7);
                let finalDamage = Math.max(1, Math.floor(baseDamage - damageReduction));

                // Executioner
                if (isPlayer && this.hasAbility('EXECUTIONER') && this.monster.currentHP < this.monster.maxHP * 0.3) {
                    finalDamage *= 2;
                    this.addLog(`üéØ Executioner! Double damage on low HP target!`, 'player');
                }

                return { damage: finalDamage, isCrit };
            }

            applyDoTs(target, isPlayer) {
                const dots = isPlayer ? this.playerDots : this.monsterDots;
                let totalDotDamage = 0;

                for (let i = dots.length - 1; i >= 0; i--) {
                    const dot = dots[i];
                    if (target === 'player') {
                        this.playerMech.currentHP -= dot.damage;
                    } else {
                        this.monster.currentHP -= dot.damage;
                    }
                    totalDotDamage += dot.damage;

                    dot.duration--;
                    if (dot.duration <= 0) {
                        dots.splice(i, 1);
                    }
                }

                if (totalDotDamage > 0) {
                    const actor = target === 'player' ? 'monster' : 'player';
                    this.addLog(`üî• DoT damage: ${totalDotDamage}`, actor);
                }
            }

            applyRegeneration() {
                // Regeneration ability
                if (this.hasAbility('REGENERATION')) {
                    const heal = 5;
                    this.playerMech.currentHP = Math.min(this.playerMech.maxHP, this.playerMech.currentHP + heal);
                    this.addLog(`üíö Regenerated ${heal} HP`, 'player');
                }

                // Regenerator trait
                if (this.hasTrait('REGENERATOR')) {
                    const heal = Math.floor(this.playerMech.maxHP * 0.08);
                    this.playerMech.currentHP = Math.min(this.playerMech.maxHP, this.playerMech.currentHP + heal);
                    this.addLog(`üíö Regenerator: +${heal} HP`, 'player');
                }
            }

            performAttack(isPlayer) {
                const targetArmor = isPlayer ? this.monster.armor : calculateMechStats(this.playerMech).armor;
                const { damage, isCrit } = this.calculateDamage(isPlayer, targetArmor);

                let actualDamage = damage;

                if (isPlayer) {
                    // Apply to monster
                    this.monster.currentHP -= actualDamage;
                    const critText = isCrit ? ' üí• CRIT!' : '';
                    this.addLog(`‚öîÔ∏è Your mech deals ${actualDamage} damage!${critText} (${Math.max(0, this.monster.currentHP)}/${this.monster.maxHP} HP)`, 'player');

                    // Vampiric healing
                    if (this.hasAbility('VAMPIRIC') || this.hasTrait('VAMPIRE')) {
                        const healPercent = this.hasTrait('VAMPIRE') ? 0.4 : 0.25;
                        const heal = Math.floor(actualDamage * healPercent);
                        this.playerMech.currentHP = Math.min(this.playerMech.maxHP, this.playerMech.currentHP + heal);
                        this.addLog(`ü©∏ Vampiric: healed ${heal} HP`, 'player');
                    }

                    // Apply DoTs
                    if (this.hasAbility('BURN')) {
                        this.monsterDots.push({ type: 'burn', damage: 5, duration: 3 });
                        this.addLog(`üî• Applied Burn effect!`, 'player');
                    }

                    if (isCrit && this.hasAbility('BLEED')) {
                        this.monsterDots.push({ type: 'bleed', damage: 3, duration: 5 });
                        this.addLog(`ü©∏ Critical Bleed applied!`, 'player');
                    }
                } else {
                    // Monster attacks player - check shield first
                    if (this.playerShield > 0) {
                        if (this.playerShield >= actualDamage) {
                            this.playerShield -= actualDamage;
                            this.addLog(`üõ°Ô∏è Shield absorbed ${actualDamage} damage! (${this.playerShield} shield left)`, 'monster');
                            actualDamage = 0;
                        } else {
                            const overflow = actualDamage - this.playerShield;
                            this.addLog(`üõ°Ô∏è Shield absorbed ${this.playerShield} damage, ${overflow} passed through!`, 'monster');
                            this.playerShield = 0;
                            actualDamage = overflow;
                        }
                    }

                    // Apply remaining damage to HP
                    if (actualDamage > 0) {
                        this.playerMech.currentHP -= actualDamage;
                        this.addLog(`üí• ${this.monster.name} deals ${actualDamage} damage! (${Math.max(0, this.playerMech.currentHP)}/${this.playerMech.maxHP} HP)`, 'monster');

                        // Reactive armor
                        if (this.hasAbility('REACTIVE')) {
                            const reflected = Math.floor(actualDamage * 0.25);
                            this.monster.currentHP -= reflected;
                            this.addLog(`‚ö° Reactive Armor: ${reflected} damage reflected!`, 'player');
                        }
                    }
                }

                return actualDamage;
            }

            executeTurn() {
                this.turn++;

                // Apply Overcharged trait damage
                if (this.hasTrait('OVERCHARGED')) {
                    const damage = Math.floor(this.playerMech.maxHP * 0.08);
                    this.playerMech.currentHP -= damage;
                    this.addLog(`üî• Overcharged: -${damage} HP`, 'player');
                }

                // Apply regeneration
                this.applyRegeneration();

                // Apply DoTs
                this.applyDoTs('player', true);
                this.applyDoTs('monster', false);

                // Check for deaths from DoTs
                if (this.playerMech.currentHP <= 0) {
                    this.addLog('üíÄ YOUR MECH IS DESTROYED! DEFEAT! üíÄ', 'monster');
                    return 'defeat';
                }
                if (this.monster.currentHP <= 0) {
                    this.addLog('üí• ENEMY DESTROYED! VICTORY! üí•', 'player');
                    return 'victory';
                }

                const playerStats = calculateMechStats(this.playerMech);
                let playerSpeed = playerStats.speed;

                // Apply speed traits
                if (this.hasTrait('LIGHTNING_FAST')) {
                    playerSpeed = 100 + 50;
                }
                if (this.hasTrait('FORTRESS')) {
                    playerSpeed = Math.floor(playerSpeed * 0.5);
                }

                // Determine turn order
                const playerGoesFirst = playerSpeed >= this.monster.speed;

                if (playerGoesFirst) {
                    this.performAttack(true);
                    if (this.monster.currentHP <= 0) {
                        this.addLog('üí• ENEMY DESTROYED! VICTORY! üí•', 'player');
                        return 'victory';
                    }
                    this.performAttack(false);
                    if (this.playerMech.currentHP <= 0) {
                        this.addLog('üíÄ YOUR MECH IS DESTROYED! DEFEAT! üíÄ', 'monster');
                        return 'defeat';
                    }
                } else {
                    this.performAttack(false);
                    if (this.playerMech.currentHP <= 0) {
                        this.addLog('üíÄ YOUR MECH IS DESTROYED! DEFEAT! üíÄ', 'monster');
                        return 'defeat';
                    }
                    this.performAttack(true);
                    if (this.monster.currentHP <= 0) {
                        this.addLog('üí• ENEMY DESTROYED! VICTORY! üí•', 'player');
                        return 'victory';
                    }
                }

                return 'continue';
            }

            getState() {
                return {
                    playerMech: this.playerMech,
                    monster: this.monster,
                    log: this.log,
                    playerShield: this.playerShield
                };
            }
        }

        // ============================================================================
        // UI MANAGEMENT
        // ============================================================================

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        function updateHeader() {
            document.getElementById('round-num').textContent = game.round;
            document.getElementById('victories').textContent = game.victories;
            document.getElementById('current-mech-name').textContent =
                game.currentMech ? `${game.currentMech.name} (T${game.currentMech.tier})` : 'None';
            document.getElementById('inventory-count').textContent = game.inventory.length;
        }

        function renderLoadoutScreen() {
            if (!game.currentMech) {
                document.getElementById('loadout-mech-name').textContent = 'No Mech Selected';
                document.getElementById('mech-slots').innerHTML = '<p class="warning">Please select a mech to continue.</p>';
                return;
            }

            const mech = game.currentMech;
            const stats = calculateMechStats(mech);

            // Display mech name with traits
            const traitIcons = (mech.traits || []).map(t => t.icon).join(' ');
            document.getElementById('loadout-mech-name').textContent =
                `${mech.name} (${mech.class}) - Tier ${mech.tier} ${traitIcons}`;
            document.getElementById('loadout-mech-visual').textContent = mech.visual;

            // Update resource bars
            const tierPercent = (stats.tierUsed / mech.tierCapacity) * 100;
            const weightPercent = (stats.weightUsed / mech.weightCapacity) * 100;

            document.getElementById('tier-usage').textContent =
                `${stats.tierUsed}/${mech.tierCapacity}`;
            document.getElementById('tier-bar').style.width = `${Math.min(100, tierPercent)}%`;

            document.getElementById('weight-usage').textContent =
                `${stats.weightUsed}/${mech.weightCapacity}`;
            document.getElementById('weight-bar').style.width = `${Math.min(100, weightPercent)}%`;

            // Render slots
            const slotsHTML = Object.entries(SLOT_TYPES).map(([key, slotName]) => {
                const slot = mech.slots[slotName];
                const component = mech.loadout[slotName];
                const slotLabel = key.replace(/_/g, ' ');

                if (component) {
                    const damageTypeIcon = component.damageType === DAMAGE_TYPES.ENERGY ? '‚öõÔ∏è' :
                                           component.damageType === DAMAGE_TYPES.KINETIC ? 'üéØ' :
                                           component.damageType === DAMAGE_TYPES.EXPLOSIVE ? 'üí£' : '';
                    const abilities = component.abilities || [];
                    const abilityText = abilities.map(abilityKey => {
                        const ability = ABILITIES[abilityKey];
                        return ability ? `<div style="font-size: 9px; color: #00ff88; margin-top: 2px;">‚ú® ${ability.name}</div>` : '';
                    }).join('');

                    return `
                        <div class="slot filled" onclick="handleSlotClick('${slotName}')">
                            <div class="slot-header">
                                <span>${slotLabel}</span>
                                <span class="tier-indicator tier-${component.tier}">T${component.tier}</span>
                            </div>
                            <div class="component-name">${damageTypeIcon} ${component.name}</div>
                            <div style="font-size: 11px; margin-top: 5px;">
                                ‚öîÔ∏è${component.damage} üõ°Ô∏è${component.armor} ‚öñÔ∏è${component.weight} üìè${component.size}/${slot.capacity}
                            </div>
                            ${abilityText}
                        </div>
                    `;
                } else {
                    return `
                        <div class="slot" onclick="handleSlotClick('${slotName}')">
                            <div class="slot-header">
                                <span>${slotLabel}</span>
                                <span style="color: #666;">Empty (Cap: ${slot.capacity})</span>
                            </div>
                            <div style="font-size: 11px; color: #666;">Click to attach component</div>
                        </div>
                    `;
                }
            }).join('');

            document.getElementById('mech-slots').innerHTML = slotsHTML;

            // Render inventory
            renderInventory();
        }

        let selectedInventoryItem = null;

        function renderInventory() {
            const inventoryGrid = document.getElementById('inventory-grid');

            if (game.inventory.length === 0) {
                inventoryGrid.innerHTML = '<p style="color: #666;">No components in inventory. Win battles to collect salvage!</p>';
                return;
            }

            inventoryGrid.innerHTML = game.inventory.map(comp => {
                const damageTypeIcon = comp.damageType === DAMAGE_TYPES.ENERGY ? '‚öõÔ∏è' :
                                       comp.damageType === DAMAGE_TYPES.KINETIC ? 'üéØ' :
                                       comp.damageType === DAMAGE_TYPES.EXPLOSIVE ? 'üí£' : '';
                const abilities = comp.abilities || [];
                const abilityText = abilities.map(abilityKey => {
                    const ability = ABILITIES[abilityKey];
                    return ability ? `<div style="font-size: 10px; color: #00ff88; margin-top: 3px;">‚ú® ${ability.name}</div>` : '';
                }).join('');

                return `
                    <div class="inventory-item ${selectedInventoryItem?.id === comp.id ? 'selected' : ''}"
                         onclick="selectInventoryItem('${comp.id}')">
                        <div class="component-name" style="font-size: 14px;">
                            ${damageTypeIcon} ${comp.name}
                            <span class="tier-indicator tier-${comp.tier}">T${comp.tier}</span>
                        </div>
                        <div class="component-stats">
                            <div class="stat-item">‚öîÔ∏è ${comp.damage}</div>
                            <div class="stat-item">üõ°Ô∏è ${comp.armor}</div>
                            <div class="stat-item">‚öñÔ∏è ${comp.weight}</div>
                            <div class="stat-item">üìè ${comp.size}</div>
                        </div>
                        <div style="font-size: 10px; color: #888; margin-top: 5px;">
                            Slot: ${comp.slot.replace(/([A-Z])/g, ' $1').trim()}
                        </div>
                        ${abilityText}
                    </div>
                `;
            }).join('');
        }

        function selectInventoryItem(componentId) {
            const component = game.inventory.find(c => c.id === componentId);
            if (component) {
                selectedInventoryItem = component;
                renderInventory();
            }
        }

        function handleSlotClick(slotName) {
            if (!game.currentMech) return;

            const currentComponent = game.currentMech.loadout[slotName];

            // If slot is filled, detach
            if (currentComponent) {
                if (confirm(`Detach ${currentComponent.name}?`)) {
                    detachComponent(game.currentMech, slotName);
                    selectedInventoryItem = null;
                    renderLoadoutScreen();
                }
                return;
            }

            // If slot is empty and we have a selected item, try to attach
            if (selectedInventoryItem) {
                if (canAttachComponent(game.currentMech, selectedInventoryItem, slotName)) {
                    attachComponent(game.currentMech, selectedInventoryItem, slotName);
                    selectedInventoryItem = null;
                    renderLoadoutScreen();
                } else {
                    alert('Cannot attach this component here. Check slot type, size, tier points, and weight limits.');
                }
            } else {
                alert('Please select a component from inventory first.');
            }
        }

        function renderBattleScreen() {
            if (!game.currentMech) {
                alert('No mech selected!');
                return;
            }

            // Reset mech HP
            game.currentMech.currentHP = game.currentMech.maxHP;

            // Generate monster
            game.currentMonster = generateMonster(game.round);

            const stats = calculateMechStats(game.currentMech);

            // Update player display
            document.getElementById('player-visual').textContent = game.currentMech.visual;
            document.getElementById('player-name').textContent = game.currentMech.name;
            document.getElementById('player-stats').innerHTML =
                `‚öîÔ∏è Damage: ${stats.damage} | üõ°Ô∏è Armor: ${stats.armor} | ‚ö° Speed: ${stats.speed}`;
            updateHealthBar('player', game.currentMech.currentHP, game.currentMech.maxHP);

            // Update monster display
            document.getElementById('monster-visual').textContent = game.currentMonster.visual;
            document.getElementById('monster-name').textContent = game.currentMonster.name;
            document.getElementById('monster-stats').innerHTML =
                `‚öîÔ∏è Damage: ${game.currentMonster.damage} | üõ°Ô∏è Armor: ${game.currentMonster.armor} | ‚ö° Speed: ${game.currentMonster.speed}`;
            updateHealthBar('monster', game.currentMonster.currentHP, game.currentMonster.maxHP);

            // Clear combat log
            document.getElementById('combat-log').innerHTML = '';

            showScreen('battle-screen');
        }

        function updateHealthBar(actor, current, max) {
            const percent = (current / max) * 100;
            const fill = document.getElementById(`${actor}-health`);
            const text = document.getElementById(`${actor}-health-text`);

            fill.style.width = `${Math.max(0, percent)}%`;
            text.textContent = `${Math.max(0, current)}/${max}`;
        }

        function addCombatLog(message, actor) {
            const log = document.getElementById('combat-log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${actor}`;
            entry.textContent = message;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        async function startBattle() {
            if (!game.currentMech || !game.currentMonster) return;

            document.getElementById('start-battle-btn').disabled = true;

            const battle = new BattleSystem(game.currentMech, game.currentMonster);

            addCombatLog('‚öîÔ∏è BATTLE START! ‚öîÔ∏è', 'system');

            let result = 'continue';

            while (result === 'continue') {
                await new Promise(resolve => setTimeout(resolve, 1000));

                result = battle.executeTurn();
                const state = battle.getState();

                // Update displays
                updateHealthBar('player', state.playerMech.currentHP, state.playerMech.maxHP);
                updateHealthBar('monster', state.monster.currentHP, state.monster.maxHP);

                // Add latest log entries
                if (battle.log.length > 0) {
                    const latestLog = battle.log[battle.log.length - 1];
                    addCombatLog(latestLog.message, latestLog.actor);

                    if (battle.log.length > 1 && battle.log[battle.log.length - 2].turn === battle.turn) {
                        const secondLog = battle.log[battle.log.length - 2];
                        addCombatLog(secondLog.message, secondLog.actor);
                    }
                }
            }

            await new Promise(resolve => setTimeout(resolve, 1500));

            if (result === 'victory') {
                game.victories++;
                game.round++;
                game.save();

                // Check if round 5, 10, 15, etc. - Show trait selection
                if ((game.round - 1) % 5 === 0 && game.round > 1) {
                    showTraitSelectionScreen();
                } else {
                    showSalvageScreen();
                }
            } else {
                // Defeat - game over
                addCombatLog('', 'system');
                addCombatLog('GAME OVER! Starting new game...', 'system');
                await new Promise(resolve => setTimeout(resolve, 3000));
                game.reset();
                initializeGame();
            }

            document.getElementById('start-battle-btn').disabled = false;
            updateHeader();
        }

        function showSalvageScreen() {
            const tierLevel = Math.floor(game.round / 5) + 1;
            const salvageOptions = generateRandomComponents(3, tierLevel, tierLevel + 1);

            // Check if player has SALVAGER trait
            const hasSalvager = game.currentMech && game.currentMech.traits &&
                                game.currentMech.traits.some(t => t.name === 'SALVAGER');

            const titleText = hasSalvager ?
                'Choose TWO components to salvage (SALVAGER trait active!):' :
                'Choose one component to salvage from the battlefield:';

            document.querySelector('#salvage-screen p').textContent = titleText;

            const optionsHTML = salvageOptions.map((comp, index) => {
                const damageTypeIcon = comp.damageType === DAMAGE_TYPES.ENERGY ? '‚öõÔ∏è' :
                                       comp.damageType === DAMAGE_TYPES.KINETIC ? 'üéØ' :
                                       comp.damageType === DAMAGE_TYPES.EXPLOSIVE ? 'üí£' : '';
                const abilities = comp.abilities || [];
                const abilityText = abilities.map(abilityKey => {
                    const ability = ABILITIES[abilityKey];
                    return ability ? `<div style="font-size: 10px; color: #00ff88; margin-top: 3px;">‚ú® ${ability.name}</div>` : '';
                }).join('');

                return `
                    <div class="salvage-card" onclick="selectSalvage(${index})">
                        <div class="component-name">
                            ${damageTypeIcon} ${comp.name}
                            <span class="tier-indicator tier-${comp.tier}">Tier ${comp.tier}</span>
                        </div>
                        <div style="margin: 10px 0; color: #888;">${comp.type.toUpperCase()}</div>
                        <div class="component-stats">
                            <div class="stat-item">‚öîÔ∏è Damage: ${comp.damage}</div>
                            <div class="stat-item">üõ°Ô∏è Armor: ${comp.armor}</div>
                            <div class="stat-item">‚öñÔ∏è Weight: ${comp.weight}</div>
                            <div class="stat-item">üìè Size: ${comp.size}</div>
                            <div class="stat-item" style="grid-column: 1 / -1;">
                                üìç Slot: ${comp.slot.replace(/([A-Z])/g, ' $1').trim()}
                            </div>
                        </div>
                        ${abilityText}
                    </div>
                `;
            }).join('');

            document.getElementById('salvage-options').innerHTML = optionsHTML;

            // Store options temporarily
            window.currentSalvageOptions = salvageOptions;
            window.salvageSelections = [];
            window.salvageLimit = hasSalvager ? 2 : 1;

            showScreen('salvage-screen');
        }

        function selectSalvage(index) {
            const component = window.currentSalvageOptions[index];
            window.salvageSelections = window.salvageSelections || [];

            if (window.salvageSelections.includes(index)) {
                // Already selected, deselect
                window.salvageSelections = window.salvageSelections.filter(i => i !== index);
            } else {
                window.salvageSelections.push(index);
            }

            // Visual feedback - highlight selected
            document.querySelectorAll('#salvage-options .salvage-card').forEach((card, i) => {
                if (window.salvageSelections.includes(i)) {
                    card.style.borderColor = '#00ff88';
                    card.style.transform = 'scale(0.95)';
                } else {
                    card.style.borderColor = '#444';
                    card.style.transform = 'scale(1)';
                }
            });

            // If reached limit, auto-confirm
            if (window.salvageSelections.length >= window.salvageLimit) {
                setTimeout(() => {
                    window.salvageSelections.forEach(idx => {
                        game.inventory.push(window.currentSalvageOptions[idx]);
                    });
                    game.save();
                    updateHeader();
                    renderLoadoutScreen();
                    showScreen('loadout-screen');
                }, 300);
            }
        }

        function showTraitSelectionScreen() {
            // Generate 3 random trait options
            const allTraits = Object.values(MECH_TRAITS);
            const availableTraits = allTraits.filter(trait =>
                !game.currentMech.traits.some(t => t.name === trait.name)
            );

            const traitOptions = [];
            for (let i = 0; i < 3 && availableTraits.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * availableTraits.length);
                traitOptions.push(availableTraits.splice(randomIndex, 1)[0]);
            }

            const traitsHTML = traitOptions.map((trait, index) => `
                <div class="mech-card" onclick="selectTrait(${index})" style="border-color: #ffaa00;">
                    <div style="font-size: 48px; text-align: center; margin: 15px 0;">${trait.icon}</div>
                    <div class="component-name" style="color: #ffaa00;">
                        ${trait.name}
                        <span class="tier-indicator tier-${trait.tier}">T${trait.tier}</span>
                    </div>
                    <div style="margin: 15px 0; color: #ccc; font-size: 13px; line-height: 1.5;">
                        ${trait.desc}
                    </div>
                    <div style="margin-top: 15px; padding: 10px; background: rgba(255,170,0,0.2); border-radius: 5px; font-size: 11px;">
                        This trait is permanent and will transform your playstyle!
                    </div>
                </div>
            `).join('');

            document.getElementById('trait-options').innerHTML = traitsHTML;
            window.currentTraitOptions = traitOptions;

            showScreen('trait-select-screen');
        }

        function selectTrait(index) {
            const trait = window.currentTraitOptions[index];

            if (!game.currentMech.traits) {
                game.currentMech.traits = [];
            }

            game.currentMech.traits.push(trait);
            game.save();

            alert(`${trait.icon} Trait Acquired: ${trait.name}!\n\n${trait.desc}`);

            updateHeader();
            renderLoadoutScreen();
            showScreen('loadout-screen');
        }

        // ============================================================================
        // INITIALIZATION
        // ============================================================================

        function initializeGame() {
            // Try to load saved game
            if (!game.load()) {
                // New game - choose starting mech
                const startingMechs = [
                    createMech(MECH_TEMPLATES.SCOUT, 1),
                    createMech(MECH_TEMPLATES.WARRIOR, 1),
                    createMech(MECH_TEMPLATES.TITAN, 1)
                ];

                // Add some starter components
                game.inventory = generateRandomComponents(6, 1, 2);

                const choice = confirm('Welcome to Mech Autobattler!\n\nChoose your starting mech:\n\nOK = Scout (Fast, Light)\nCancel = Warrior (Balanced)\n\n(Heavy Titan also available)');

                if (choice) {
                    game.currentMech = startingMechs[0];
                } else {
                    const choice2 = confirm('Warrior (Balanced) or Titan (Heavy)?\n\nOK = Warrior\nCancel = Titan');
                    game.currentMech = choice2 ? startingMechs[1] : startingMechs[2];
                }

                game.save();
            }

            updateHeader();
            renderLoadoutScreen();
        }

        // ============================================================================
        // EVENT LISTENERS
        // ============================================================================

        document.getElementById('ready-battle-btn').addEventListener('click', () => {
            if (!game.currentMech) {
                alert('No mech selected!');
                return;
            }
            renderBattleScreen();
        });

        document.getElementById('start-battle-btn').addEventListener('click', startBattle);

        // Debug panel
        document.getElementById('debug-toggle').addEventListener('click', () => {
            const panel = document.getElementById('debug-panel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        });

        function updateDebugPanel() {
            const panel = document.getElementById('debug-panel');
            const stats = game.currentMech ? calculateMechStats(game.currentMech) : null;

            panel.innerHTML = `
                <h4 style="color: #ff00ff;">DEBUG INFO</h4>
                <div style="margin: 10px 0;">
                    <strong>Round:</strong> ${game.round}<br>
                    <strong>Victories:</strong> ${game.victories}<br>
                    <strong>Inventory:</strong> ${game.inventory.length} items<br>
                    ${stats ? `
                        <strong>Mech Stats:</strong><br>
                        - Damage: ${stats.damage}<br>
                        - Armor: ${stats.armor}<br>
                        - Speed: ${stats.speed}<br>
                        - Tier: ${stats.tierUsed}/${game.currentMech.tierCapacity}<br>
                        - Weight: ${stats.weightUsed}/${game.currentMech.weightCapacity}
                    ` : '<em>No mech selected</em>'}
                </div>
                <button class="btn btn-danger" onclick="if(confirm('Reset game?')) { game.reset(); initializeGame(); }" style="width: 100%; padding: 8px; font-size: 12px;">
                    RESET GAME
                </button>
            `;
        }

        // Update debug panel every second
        setInterval(updateDebugPanel, 1000);

        // ============================================================================
        // START GAME
        // ============================================================================

        initializeGame();
    </script>
</body>
</html>
