<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BattleTech Arena - AI Combat</title>
    <style>
        body {
            margin: 0;
            padding: 15px;
            background: #1a1a2e;
            font-family: monospace;
            color: #00ff88;
            overflow-x: hidden;
        }
        #renderCanvas {
            width: 100%;
            max-width: 1000px;
            height: 55vh;
            max-height: 450px;
            display: block;
            margin: 0 auto;
            border: 3px solid #00ff88;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            touch-action: none;
        }
        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin: 8px 0;
            font-size: 1.3em;
        }
        #status {
            max-width: 1000px;
            margin: 10px auto;
            padding: 8px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #00ff88;
            border-radius: 8px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        #logs {
            flex: 1;
            min-width: 200px;
            max-height: 100px;
            overflow-y: auto;
            font-size: 10px;
        }
        #mechStatus {
            flex: 1;
            min-width: 280px;
            display: flex;
            gap: 10px;
        }
        .mech-info {
            flex: 1;
            padding: 5px;
            border: 1px solid #00ff88;
            border-radius: 4px;
            font-size: 11px;
        }
        .mech-info.enemy { border-color: #ff4444; }
        .log { margin: 1px 0; padding: 1px 3px; }
        .log.info { color: #00ff88; }
        .log.warn { color: #ffaa00; }
        .log.error { color: #ff4444; }
        #controls {
            text-align: center;
            margin: 8px 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 4px;
        }
        button {
            padding: 6px 12px;
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            border-radius: 5px;
            font-family: monospace;
            font-size: 11px;
        }
        button:hover, button:active {
            background: rgba(0, 255, 136, 0.4);
        }
        button.red {
            border-color: #ff4444;
            color: #ff4444;
            background: rgba(255, 68, 68, 0.2);
        }
        .hp-bar {
            height: 10px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin: 2px 0;
        }
        .hp-fill {
            height: 100%;
            transition: width 0.3s;
        }
        .hp-fill.player { background: linear-gradient(90deg, #00aa55, #00ff88); }
        .hp-fill.enemy { background: linear-gradient(90deg, #aa2222, #ff4444); }
        #polyCount {
            text-align: center;
            font-size: 10px;
            color: #888;
            margin-top: 5px;
        }
        #debugPanel {
            max-width: 1000px;
            margin: 10px auto;
            padding: 8px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #ff8800;
            border-radius: 8px;
            font-size: 10px;
        }
        #debugPanel .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        #debugPanel .title { color: #ff8800; font-weight: bold; }
        #debugLogs {
            max-height: 150px;
            overflow-y: auto;
            font-family: monospace;
            white-space: pre;
            color: #aaa;
            line-height: 1.3;
        }
        #debugLogs .dbg-ai { color: #88ff88; }
        #debugLogs .dbg-phys { color: #88ffff; }
        #debugLogs .dbg-torso { color: #ff88ff; }
        #debugLogs .dbg-err { color: #ff4444; }
        #debugLogs .dbg-warn { color: #ffaa00; }
        .copy-btn {
            padding: 3px 8px;
            font-size: 10px;
            background: rgba(255, 136, 0, 0.3);
            border: 1px solid #ff8800;
            color: #ff8800;
            cursor: pointer;
            border-radius: 3px;
        }
        .copy-btn:hover { background: rgba(255, 136, 0, 0.5); }

        /* Countdown overlay styles */
        #countdownOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            pointer-events: none;
        }
        #countdownOverlay.hidden {
            display: none;
        }
        #countdownText {
            font-size: 150px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 40px #00ff88, 0 0 80px #00ff88, 0 0 120px rgba(0, 255, 136, 0.5);
            animation: countdownPulse 0.5s ease-out;
            font-family: monospace;
        }
        #countdownText.fight {
            color: #ff4444;
            text-shadow: 0 0 40px #ff4444, 0 0 80px #ff4444, 0 0 120px rgba(255, 68, 68, 0.5);
            font-size: 120px;
            letter-spacing: 20px;
        }
        @keyframes countdownPulse {
            0% {
                transform: scale(2);
                opacity: 0;
            }
            50% {
                transform: scale(1.1);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        @keyframes fightShake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); }
            20%, 40%, 60%, 80% { transform: translateX(10px); }
        }
        #countdownText.fight {
            animation: countdownPulse 0.3s ease-out, fightShake 0.5s ease-out 0.3s;
        }
    </style>
</head>
<body>
    <h1>BattleTech Arena <span id="version" style="font-size: 0.6em; color: #888;">v10.17-ground</span></h1>
    <div id="controls">
        <button id="autoFireBtn" onclick="toggleAutoFire()" style="background: rgba(255, 200, 0, 0.3); border-color: #ffcc00; color: #ffcc00;">AI Battle: OFF</button>
        <button id="cinematicBtn" onclick="toggleCinematicCamera()">Cinematic: OFF</button>
        <button onclick="resetScene()">Reset</button>
        <button id="returnToLoadoutBtn" onclick="returnToLoadout()" style="background: rgba(0, 255, 136, 0.3); border-color: #00ff88; color: #00ff88;">Return to Loadout</button>
    </div>
    <canvas id="renderCanvas"></canvas>

    <!-- Countdown overlay -->
    <div id="countdownOverlay" class="hidden">
        <div id="countdownText">3</div>
    </div>

    <div id="polyCount">Triangles: <span id="triCount">0</span></div>
    <div id="status">
        <div id="logs"></div>
        <div id="mechStatus">
            <div class="mech-info player">
                <strong style="color: #00ff88;">TIMBER WOLF (Mad Cat)</strong>
                <div class="hp-bar"><div class="hp-fill player" id="playerHP" style="width: 100%"></div></div>
                <div id="playerHPText">HP: 150/150</div>
                <div id="playerState">Idle</div>
            </div>
            <div class="mech-info enemy">
                <strong style="color: #ff4444;">DIRE WOLF (Daishi)</strong>
                <div class="hp-bar"><div class="hp-fill enemy" id="enemyHP" style="width: 100%"></div></div>
                <div id="enemyHPText">HP: 200/200</div>
                <div id="enemyState">Idle</div>
            </div>
        </div>
    </div>

    <div id="debugPanel">
        <div class="header">
            <span class="title">DIAGNOSTIC LOGS</span>
            <button class="copy-btn" onclick="copyDebugLogs()">Copy Logs</button>
        </div>
        <div id="debugLogs"></div>
    </div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>

    <script>
        // Logging
        const logs = [];
        function log(msg, type = 'info') {
            console.log(msg);
            logs.push({ msg, type });
            const logsDiv = document.getElementById('logs');
            if (logsDiv) {
                logsDiv.innerHTML = logs.slice(-10).map(l =>
                    `<div class="log ${l.type}">${l.msg}</div>`
                ).join('');
            }
        }

        // Debug logging system
        const debugLogs = [];
        let lastDebugTime = 0;
        const DEBUG_INTERVAL = 0.5; // Log every 0.5 seconds to avoid spam

        function dbg(msg, category = '') {
            const ts = gameTime.toFixed(2);
            const entry = `[${ts}] ${msg}`;
            debugLogs.push({ msg: entry, cat: category });
            if (debugLogs.length > 100) debugLogs.shift(); // Keep last 100 entries
            updateDebugPanel();
        }

        function updateDebugPanel() {
            const el = document.getElementById('debugLogs');
            if (el) {
                el.innerHTML = debugLogs.slice(-30).map(l => {
                    const cls = l.cat ? `dbg-${l.cat}` : '';
                    return `<span class="${cls}">${l.msg}</span>`;
                }).join('\n');
                el.scrollTop = el.scrollHeight;
            }
        }

        function copyDebugLogs() {
            const text = debugLogs.map(l => l.msg).join('\n');
            navigator.clipboard.writeText(text).then(() => {
                log('Logs copied to clipboard!', 'info');
            }).catch(err => {
                // Fallback for browsers without clipboard API
                const ta = document.createElement('textarea');
                ta.value = text;
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                document.body.removeChild(ta);
                log('Logs copied!', 'info');
            });
        }

        log('Initializing Mad Cat Physics Test...');

        // Globals
        let engine, scene, camera, havokInstance, havokPlugin;
        let playerMechs = [];  // Array of player team mechs
        let enemyMechs = [];   // Array of enemy team mechs
        let allMechs = [];     // Combined array for iteration
        let projectiles = [];
        let beams = [];
        let gameTime = 0;
        let autoFireEnabled = false;
        let autoFireInterval = null;
        let battleEnded = false;  // Flag to stop AI loops when battle is over

        // Cinematic camera system
        let cinematicEnabled = false;
        let cinematicState = {
            mode: 'orbit',           // 'orbit', 'track', 'action', 'sweep'
            target: null,            // Current mech being focused
            orbitAngle: 0,           // Current orbit angle
            orbitHeight: 8,          // Camera height
            orbitRadius: 12,         // Distance from target
            transitionTime: 0,       // Time in current mode
            modeDuration: 4,         // Seconds before mode change
            actionTarget: null,      // Mech that just fired/took damage
            actionTime: 0,           // When action occurred
            sweepPhase: 0            // Phase of panoramic sweep
        };

        // Weapon cooldowns per mech (keyed by mech name)
        const mechCooldowns = {};
        const COOLDOWN_TIMES = { erlaser: 2000, lrm: 3500, ac: 1500, hatchet: 1800 };

        // Helper to get alive mechs
        function getAliveMechs(team) {
            const mechs = team === 'player' ? playerMechs : enemyMechs;
            return mechs.filter(m => m && m.currentHP > 0 && !m.isDestroyed);
        }

        // Helper to find a new target for a mech
        function findNewTarget(mech) {
            const enemies = mech.isPlayer ? enemyMechs : playerMechs;
            const aliveEnemies = enemies.filter(e => e && e.currentHP > 0 && !e.isDestroyed);
            if (aliveEnemies.length === 0) return null;
            // Find closest enemy
            const myPos = mech.pelvis.getAbsolutePosition();
            let closest = null;
            let closestDist = Infinity;
            for (const enemy of aliveEnemies) {
                const dist = BABYLON.Vector3.Distance(myPos, enemy.pelvis.getAbsolutePosition());
                if (dist < closestDist) {
                    closestDist = dist;
                    closest = enemy;
                }
            }
            return closest;
        }

        // AI Configuration
        const AI_CONFIG = {
            idealRange: 10,         // Optimal combat distance
            minRange: 6,            // Too close - back up
            maxRange: 13,           // Too far - close in (slightly less than starting distance)
            edgeBoundary: 14,       // X position to start avoiding edges (ground is Â±20)
            edgeForce: 80,          // Force to push away from edges
            moveForce: 150,         // Normal movement force (increased significantly)
            strafeForce: 60,        // Lateral movement force (increased significantly)
            decisionInterval: 0.2,  // How often AI makes decisions (faster for responsiveness)
            strafeChance: 0.6,      // Higher chance to strafe at optimal range for more dynamic combat
            strafeDuration: 1.5     // How long to strafe before reconsidering
        };

        // Weapons
        const WEAPONS = {
            erlaser: {
                name: 'ER Large Laser',
                damage: 14,
                knockback: 8,
                recoil: 0.2,
                isBeam: true,
                beamDuration: 180,
                color: new BABYLON.Color3(0.2, 1, 0.3)
            },
            lrm: {
                name: 'LRM-20',
                damage: 18,
                knockback: 12,
                recoil: 0.15,
                projectileSpeed: 38,  // Faster missiles
                isCluster: true,
                clusterCount: 8,
                color: new BABYLON.Color3(1, 0.5, 0.1)
            },
            ac: {
                name: 'UAC/5',
                damage: 12,
                knockback: 22,  // Still good impact
                recoil: 0.12,
                projectileSpeed: 45,  // Faster rounds
                projectileSize: 0.1,
                color: new BABYLON.Color3(1, 0.9, 0.3)
            },
            hatchet: {
                name: 'Hatchet',
                damage: 25,
                knockback: 40,  // Huge knockback
                recoil: 0.3,
                isMelee: true,
                range: 3.5,  // Must be very close
                color: new BABYLON.Color3(1, 0.3, 0.1)
            }
        };

        // ============================================
        // HYBRID STATE MACHINE - Mech States
        // Phase 1: WALKING (Kinematic/ANIMATED) - Perfect control
        // Phase 2: FLINCH (Kinematic + additive animation)
        // Phase 3: RAGDOLL (Dynamic) - Physics takes over
        // Phase 4: RECOVERING (Blend back to kinematic)
        // ============================================
        const MechState = {
            WALKING: 'walking',     // Kinematic mode - controlled movement
            RAGDOLL: 'ragdoll',     // Dynamic mode - physics simulation
            RECOVERING: 'recovering' // Transitioning from ragdoll back to walking
        };

        // Stability and impact thresholds
        const STABILITY_CONFIG = {
            maxStability: 100,           // Full stability value
            flinchThreshold: 15,         // Knockback below this = flinch only
            knockdownThreshold: 35,      // Knockback above this = ragdoll
            stabilityRecoveryRate: 25,   // Stability recovered per second
            ragdollSettleVelocity: 0.3,  // Velocity threshold for ragdoll settle
            ragdollSettleTime: 0.5,      // Time at low velocity before recovery starts
            recoveryBlendTime: 0.4,      // Time to blend from ragdoll to standing
            mechAngularDamping: 0.85,    // Mechs are stiff, not floppy
            mechLinearDamping: 0.3       // Some resistance to sliding
        };

        // Arena bounds - HARD limits for kinematic movement
        const ARENA_BOUNDS = {
            minX: -18,
            maxX: 18,
            minZ: -8,
            maxZ: 8
        };

        // ============================================
        // SHADOW & QUALITY CONFIGURATION
        // Mobile-optimized shadow system with adaptive quality
        // ============================================
        const SHADOW_CONFIG = {
            enabled: true,                    // Master shadow toggle
            mapSize: 1024,                    // Shadow map resolution (512/1024/2048)
            blurKernel: 32,                   // Blur kernel size for soft shadows
            darkness: 0.35,                   // Shadow darkness (0=black, 1=invisible)
        };

        // Detect mobile and adjust quality
        function detectMobileAndSetQuality() {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isLowPower = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4;
            const canvas = document.getElementById('renderCanvas');
            const isSmallScreen = canvas && (canvas.width < 800 || canvas.height < 600);

            if (isMobile || isLowPower || isSmallScreen) {
                // Mobile/low-end settings
                SHADOW_CONFIG.mapSize = 512;
                SHADOW_CONFIG.blurKernel = 16;
                log('[SHADOWS] Mobile mode (512px)');
            } else {
                // Desktop settings
                SHADOW_CONFIG.mapSize = 1024;
                SHADOW_CONFIG.blurKernel = 32;
                log('[SHADOWS] Desktop mode (1024px)');
            }
        }

        // Global shadow generator reference
        let shadowGenerator = null;

        // Helper to add mesh as shadow caster (call after creating important meshes)
        function addShadowCaster(mesh, includeChildren = false) {
            if (shadowGenerator && mesh) {
                shadowGenerator.addShadowCaster(mesh, includeChildren);
            }
        }

        // Configure shadow casters for all mechs
        // For performance, we only add key body parts instead of all 30-40 meshes per mech
        function configureMechShadows(mechs, shadowGen) {
            if (!shadowGen || !mechs) return;

            let casterCount = 0;

            mechs.forEach(mech => {
                if (!mech || !mech.pelvis) return;

                // Use getDescendants() which gets ALL descendants recursively
                // This is more reliable than manual recursion
                const allNodes = mech.pelvis.getDescendants(false);
                allNodes.unshift(mech.pelvis); // Include pelvis itself

                allNodes.forEach(node => {
                    // Only add actual meshes (have getBoundingInfo)
                    if (node && typeof node.getBoundingInfo === 'function') {
                        shadowGen.addShadowCaster(node);
                        casterCount++;
                    }
                });
            });

            log(`[SHADOWS] ${casterCount} casters from ${mechs.length} mechs`);
        }

        // Colors
        const COLORS = {
            playerPrimary: new BABYLON.Color3(0.15, 0.35, 0.2),
            playerSecondary: new BABYLON.Color3(0.25, 0.45, 0.3),
            playerAccent: new BABYLON.Color3(0.7, 0.6, 0.1),
            enemyPrimary: new BABYLON.Color3(0.4, 0.12, 0.12),
            enemySecondary: new BABYLON.Color3(0.5, 0.18, 0.18),
            enemyAccent: new BABYLON.Color3(0.25, 0.25, 0.3),
            metal: new BABYLON.Color3(0.35, 0.35, 0.4),
            darkMetal: new BABYLON.Color3(0.12, 0.12, 0.15),
            chrome: new BABYLON.Color3(0.6, 0.6, 0.65),
            cockpit: new BABYLON.Color3(0.1, 0.9, 0.95),
            thruster: new BABYLON.Color3(1, 0.4, 0.1),
            ground: new BABYLON.Color3(0.22, 0.2, 0.18)
        };

        // Texture URLs from Babylon.js assets
        const TEXTURE_URLS = {
            // Ground textures
            grass: 'https://i.imgur.com/c3l8U9o.png',  // Better tiling grass texture
            grassNormal: 'https://playground.babylonjs.com/textures/grassn.png',
            rock: 'https://playground.babylonjs.com/textures/rock.png',
            rockNormal: 'https://playground.babylonjs.com/textures/rockn.png',
            // Metal textures
            metal: 'https://playground.babylonjs.com/textures/floor.png',
            metalNormal: 'https://playground.babylonjs.com/textures/floorNormal.png',
            rustMetal: 'https://assets.babylonjs.com/textures/rustediron2_basecolor.png',
            rustMetalNormal: 'https://assets.babylonjs.com/textures/rustediron2_normal.png',
            // Detail textures
            crate: 'https://playground.babylonjs.com/textures/crate.png',
            wood: 'https://playground.babylonjs.com/textures/wood.jpg',
            // Misc
            distortion: 'https://playground.babylonjs.com/textures/distortion.png',
            // Sky
            skybox: 'https://playground.babylonjs.com/textures/skybox'
        };

        // Global texture cache
        let TEXTURES = {};

        async function initEngine() {
            const canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

            // Detect device capabilities and adjust shadow quality
            detectMobileAndSetQuality();

            try {
                havokInstance = await HavokPhysics();
                log('Havok initialized');
            } catch (e) {
                log('Havok failed: ' + e.message, 'error');
                return;
            }

            scene = createScene();

            let lastTime = performance.now();
            let frameCount = 0;
            engine.runRenderLoop(() => {
                if (scene) {
                    try {
                        const now = performance.now();
                        const dt = (now - lastTime) / 1000;
                        lastTime = now;
                        gameTime += dt;
                        frameCount++;

                        // Log frame start occasionally
                        if (frameCount % 60 === 0) {
                            console.log(`[FRAME ${frameCount}] t=${gameTime.toFixed(2)}`);
                        }

                        // Always update projectiles and beams (so they don't freeze)
                        updateProjectiles(dt);
                        updateBeams();

                        // Only run AI/mech logic if battle hasn't ended
                        if (!battleEnded) {
                            updateMechs(dt);
                            checkBattleEnd();
                        } else {
                            // Still update destroyed mech physics during death animation
                            allMechs.forEach(mech => {
                                if (mech && mech.isDestroyed) {
                                    // Keep feet horizontal even when falling
                                    const body = mech.pelvisAggregate.body;
                                    const quat = body.transformNode.rotationQuaternion;
                                    if (quat && mech.leftLeg.footGroup) {
                                        const euler = quat.toEulerAngles();
                                        mech.leftLeg.footGroup.rotation.x = -euler.x;
                                        mech.rightLeg.footGroup.rotation.x = -euler.x;
                                        mech.leftLeg.footGroup.rotation.z = -euler.z * 0.5;
                                        mech.rightLeg.footGroup.rotation.z = -euler.z * 0.5;
                                    }
                                }
                            });
                        }
                        updateUI();
                        updateCinematicCamera(dt);

                        // Update debug timer AFTER all subsystems have had a chance to log
                        if (gameTime - lastDebugTime > DEBUG_INTERVAL) {
                            lastDebugTime = gameTime;
                        }
                        scene.render();
                    } catch (e) {
                        console.error('[RENDER LOOP ERROR]', e);
                        log(`[RENDER ERROR] ${e.message}`, 'error');
                    }
                }
            });

            window.addEventListener('resize', () => engine.resize());
            log('Scene ready!');

            // Log initial mech state for debugging and start countdown
            setTimeout(() => {
                const motionTypes = ['STATIC', 'ANIMATED', 'DYNAMIC'];
                dbg(`Created ${playerMechs.length} player mechs and ${enemyMechs.length} enemy mechs`, 'ai');
                allMechs.forEach(mech => {
                    if (!mech) return;
                    const pos = mech.pelvis.getAbsolutePosition();
                    const body = mech.pelvisAggregate.body;
                    const side = mech.isPlayer ? 'P' : 'E';
                    dbg(`${side} ${mech.name}: pos=(${pos.x.toFixed(1)},${pos.y.toFixed(1)},${pos.z.toFixed(1)}) HP=${mech.maxHP}`, 'ai');
                });
                // Start countdown and then begin battle
                startCountdown();
            }, 500);
        }

        // Countdown animation before battle starts
        function startCountdown() {
            const overlay = document.getElementById('countdownOverlay');
            const text = document.getElementById('countdownText');

            overlay.classList.remove('hidden');

            const sequence = ['3', '2', '1', 'FIGHT!'];
            let index = 0;

            function showNext() {
                if (index < sequence.length) {
                    text.textContent = sequence[index];
                    text.className = '';  // Reset classes

                    if (sequence[index] === 'FIGHT!') {
                        text.classList.add('fight');
                    }

                    // Force reflow to restart animation
                    void text.offsetWidth;
                    text.style.animation = 'none';
                    void text.offsetWidth;
                    text.style.animation = '';

                    index++;

                    if (index < sequence.length) {
                        setTimeout(showNext, 800);
                    } else {
                        // After "FIGHT!", wait a moment then start battle and hide overlay
                        setTimeout(() => {
                            overlay.classList.add('hidden');
                            // Auto-start the AI battle
                            if (!autoFireEnabled) {
                                toggleAutoFire();
                            }
                        }, 600);
                    }
                }
            }

            showNext();
        }

        function createScene() {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.5, 0.6, 0.75);  // Sky blue fallback

            havokPlugin = new BABYLON.HavokPlugin(true, havokInstance);
            scene.enablePhysics(new BABYLON.Vector3(0, -18, 0), havokPlugin);

            // Load textures
            TEXTURES.grass = new BABYLON.Texture(TEXTURE_URLS.grass, scene);
            TEXTURES.grass.uScale = 8;
            TEXTURES.grass.vScale = 4;
            TEXTURES.grassNormal = new BABYLON.Texture(TEXTURE_URLS.grassNormal, scene);
            TEXTURES.grassNormal.uScale = 8;
            TEXTURES.grassNormal.vScale = 4;

            TEXTURES.rock = new BABYLON.Texture(TEXTURE_URLS.rock, scene);
            TEXTURES.rock.uScale = 2;
            TEXTURES.rock.vScale = 2;
            TEXTURES.rockNormal = new BABYLON.Texture(TEXTURE_URLS.rockNormal, scene);
            TEXTURES.rockNormal.uScale = 2;
            TEXTURES.rockNormal.vScale = 2;

            TEXTURES.metal = new BABYLON.Texture(TEXTURE_URLS.metal, scene);
            TEXTURES.metal.uScale = 4;
            TEXTURES.metal.vScale = 4;

            TEXTURES.rustMetal = new BABYLON.Texture(TEXTURE_URLS.rustMetal, scene);
            TEXTURES.rustMetal.uScale = 2;
            TEXTURES.rustMetal.vScale = 2;
            TEXTURES.rustMetalNormal = new BABYLON.Texture(TEXTURE_URLS.rustMetalNormal, scene);
            TEXTURES.rustMetalNormal.uScale = 2;
            TEXTURES.rustMetalNormal.vScale = 2;

            // Camera - zoomed out to show all mechs
            camera = new BABYLON.ArcRotateCamera('cam', -Math.PI/2, Math.PI/3.5, 32,
                new BABYLON.Vector3(0, 2, 0), scene);
            camera.attachControl(document.getElementById('renderCanvas'), true);
            camera.lowerRadiusLimit = 15;
            camera.upperRadiusLimit = 120;
            camera.wheelPrecision = 30;

            // ============================================
            // LIGHTING + SHADOWS (v10.7 - Texture test)
            // ============================================

            // ============================================
            // v10.14: FULL SCENE WITH MECH SHADOWS
            // ============================================

            // Ambient light
            const hemi = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0, 1, 0), scene);
            hemi.intensity = 0.5;
            hemi.groundColor = new BABYLON.Color3(0.2, 0.2, 0.2);

            // DirectionalLight for shadows - positioned to cover entire arena
            const sunLight = new BABYLON.DirectionalLight('sunLight', new BABYLON.Vector3(-1, -2, -1), scene);
            sunLight.position = new BABYLON.Vector3(0, 30, 0);  // Centered above arena
            sunLight.intensity = 1.5;

            // Expand shadow frustum to cover all mechs
            sunLight.shadowMinZ = 1;
            sunLight.shadowMaxZ = 60;
            sunLight.shadowFrustumSize = 50;  // Fixed frustum size to cover arena

            // Shadow generator with PCF filtering
            if (SHADOW_CONFIG.enabled) {
                shadowGenerator = new BABYLON.ShadowGenerator(SHADOW_CONFIG.mapSize, sunLight);
                shadowGenerator.bias = 0.0005;
                shadowGenerator.normalBias = 0.005;
                shadowGenerator.usePercentageCloserFiltering = true;
                shadowGenerator.filteringQuality = BABYLON.ShadowGenerator.QUALITY_MEDIUM;
                log(`[v10.16] Shadows: PCF, frustum=50, ${SHADOW_CONFIG.mapSize}px`);
            }

            // Fog
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
            scene.fogDensity = 0.006;
            scene.fogColor = new BABYLON.Color3(0.55, 0.65, 0.75);

            // Create ground and walls
            createGround(scene, shadowGenerator);
            createWalls(scene);

            // Check for battle config from MechBuilder
            const battleConfigStr = localStorage.getItem('battleConfig');
            let battleConfig = null;
            let itemDatabase = null; // ITEM_DATABASE from loadout screen for special properties
            if (battleConfigStr) {
                try {
                    battleConfig = JSON.parse(battleConfigStr);
                    itemDatabase = battleConfig.itemDatabase || null;
                    console.log('Loaded battle config:', battleConfig);
                    console.log('Item database available:', !!itemDatabase);
                } catch(e) {
                    console.error('Failed to parse battle config:', e);
                }
            }

            // Create mechs based on config or default
            if (battleConfig) {
                // Create player mech based on loadout
                const playerMech = createMadCatMech(scene, -7, 0, true);
                // Apply player stats from loadout
                if (battleConfig.player && battleConfig.player.stats) {
                    playerMech.maxHP = battleConfig.player.stats.maxHealth || playerMech.maxHP;
                    playerMech.currentHP = playerMech.maxHP;
                    // Store loadout damage for weapon calculations
                    // Loadout damage is total damage from all equipped weapons
                    playerMech.loadoutDamage = battleConfig.player.stats.damage || 0;
                    playerMech.loadoutWeapons = battleConfig.player.stats.weapons || [];
                    console.log('Player loadout damage:', playerMech.loadoutDamage, 'weapons:', playerMech.loadoutWeapons);
                }
                playerMechs = [playerMech];

                // Create enemy mech based on mission difficulty
                const enemyRisk = battleConfig.mission?.risk || 1;
                let enemyMech;
                if (enemyRisk >= 3) {
                    enemyMech = createDireWolfMech(scene, 7, 0, false);
                } else if (enemyRisk >= 2) {
                    enemyMech = createMadCatMech(scene, 7, 0, false);
                } else {
                    enemyMech = createCommandoMech(scene, 7, 0, false);
                }
                // Apply enemy stats from config
                if (battleConfig.enemy) {
                    if (battleConfig.enemy.maxHealth) {
                        enemyMech.maxHP = battleConfig.enemy.maxHealth;
                        enemyMech.currentHP = enemyMech.maxHP;
                    }
                    // Use weapons from ITEM_DATABASE (passed via battleConfig)
                    enemyMech.loadoutWeapons = battleConfig.enemy.weapons || [];
                    console.log('Enemy weapons from ITEM_DATABASE:', enemyMech.loadoutWeapons);
                }
                enemyMechs = [enemyMech];

                // Update UI with mission info
                setTimeout(() => {
                    const missionName = battleConfig.mission?.name || 'Battle';
                    document.querySelector('.mech-info.player strong').textContent = battleConfig.player?.name || 'PLAYER';
                    document.querySelector('.mech-info.enemy strong').textContent = battleConfig.enemy?.name || 'ENEMY';
                }, 100);
            } else {
                // Default: full battle with multiple mechs
                playerMechs = [
                    createMadCatMech(scene, -7, 0, true),
                    createHatchetmanMech(scene, -14, 2, true),
                    createCatapultMech(scene, -10, 4, true),
                    createCommandoMech(scene, -10, -3, true)
                ];
                enemyMechs = [
                    createDireWolfMech(scene, 7, 0, false),
                    createHatchetmanMech(scene, 14, -2, false),
                    createCatapultMech(scene, 10, 4, false),
                    createCommandoMech(scene, 10, -3, false)
                ];
            }
            allMechs = [...playerMechs, ...enemyMechs];
            allMechs.forEach(mech => {
                mechCooldowns[mech.name + '_' + (mech.isPlayer ? 'p' : 'e')] = { erlaser: 0, lrm: 0, ac: 0, hatchet: 0 };
            });

            // Add mech shadows
            if (shadowGenerator) {
                configureMechShadows(allMechs, shadowGenerator);
            }

            return scene;
        }

        function createGround(scene, shadowGen) {
            // === SKYBOX ===
            const skybox = BABYLON.MeshBuilder.CreateBox('skyBox', { size: 1000 }, scene);
            const skyboxMaterial = new BABYLON.StandardMaterial('skyBoxMat', scene);
            skyboxMaterial.backFaceCulling = false;
            skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(TEXTURE_URLS.skybox, scene);
            skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
            skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
            skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            skybox.material = skyboxMaterial;
            skybox.receiveShadows = false;

            // ================================================================
            // === ARENA GROUND - Tiled Texture + Macro Variation ===
            // ================================================================
            // Using better grass texture with macro noise overlay to break tiling
            // Combined with vertex colors for battle zone variation
            // ================================================================

            const ground = BABYLON.MeshBuilder.CreateGround('ground', {
                width: 40, height: 20, subdivisions: 32
            }, scene);

            // === TILED GRASS + MACRO VARIATION ===
            const mat = new BABYLON.StandardMaterial('groundMat', scene);

            // Tiled grass texture
            const groundTex = new BABYLON.Texture(TEXTURE_URLS.grass, scene);
            groundTex.uScale = 10;
            groundTex.vScale = 5;
            mat.diffuseTexture = groundTex;
            mat.diffuseColor = new BABYLON.Color3(0.85, 0.9, 0.75);
            mat.specularColor = new BABYLON.Color3(0.05, 0.05, 0.04);
            mat.specularPower = 16;

            ground.material = mat;

            // Vertex colors for battle zone darkening + macro variation
            applyGroundVertexColors(ground);

            new BABYLON.PhysicsAggregate(ground, BABYLON.PhysicsShapeType.BOX,
                { mass: 0, friction: 1.0, restitution: 0.05 }, scene);

            if (shadowGen) {
                ground.receiveShadows = true;
            }

            // ================================================================
            // === THIN INSTANCE DEBRIS SCATTER ===
            // ================================================================
            createDebrisScatter(scene, shadowGen);

            // ================================================================
            // === EXTENDED HORIZON GROUND ===
            // ================================================================
            const horizonGround = BABYLON.MeshBuilder.CreateGround('horizonGround', {
                width: 800, height: 800, subdivisions: 8
            }, scene);
            horizonGround.position.y = -0.1;

            const horizonMat = new BABYLON.StandardMaterial('horizonMat', scene);
            const horizonTex = new BABYLON.Texture(TEXTURE_URLS.grass, scene);
            horizonTex.uScale = 100;
            horizonTex.vScale = 100;
            horizonMat.diffuseTexture = horizonTex;
            horizonMat.diffuseColor = new BABYLON.Color3(0.7, 0.75, 0.6);
            horizonMat.specularColor = new BABYLON.Color3(0, 0, 0);
            horizonMat.fogEnabled = true;

            horizonGround.material = horizonMat;
            horizonGround.receiveShadows = false;

            // Vertex colors for horizon
            applyGroundVertexColors(horizonGround, true);

            // === DISTANT MOUNTAINS ===
            createMountains(scene);

            // === ARENA ROCKS (larger, decorative) ===
            const rockMat = new BABYLON.StandardMaterial('rockMat', scene);
            rockMat.diffuseTexture = TEXTURES.rock;
            rockMat.bumpTexture = TEXTURES.rockNormal;
            rockMat.bumpTexture.level = 1.0;
            rockMat.diffuseColor = new BABYLON.Color3(0.6, 0.55, 0.5);
            rockMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            for (let i = 0; i < 6; i++) {
                const rock = BABYLON.MeshBuilder.CreateBox('rock' + i, {
                    width: 0.6 + Math.random() * 0.8,
                    height: 0.2 + Math.random() * 0.4,
                    depth: 0.6 + Math.random() * 0.8
                }, scene);
                rock.position = new BABYLON.Vector3((Math.random() - 0.5) * 25, 0.15, (Math.random() - 0.5) * 10);
                rock.rotation.y = Math.random() * Math.PI;
                rock.material = rockMat;
                new BABYLON.PhysicsAggregate(rock, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);
            }

            log('[GROUND] New grass texture + vertex colors');
        }

        // ================================================================
        // === ORGANIC GROUND TEXTURE (Full Color, No Tiling) ===
        // ================================================================
        // Creates a natural-looking ground texture with grass colors
        // Spans entire ground - NO TILING means no repeating patterns
        // Uses multiple layers of organic blobs for natural variation

        function createOrganicGroundTexture(scene, size) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Base: mid-tone earthy green
            ctx.fillStyle = '#4a6b3a';
            ctx.fillRect(0, 0, size, size);

            // Layer 1: Large color variation blobs (the "fields")
            // These create broad areas of different grass shades
            for (let i = 0; i < 35; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const radius = size * 0.08 + Math.random() * size * 0.2;

                // Random grass/earth colors
                const colorType = Math.random();
                let r, g, b;
                if (colorType < 0.4) {
                    // Darker green (shadow/lush)
                    r = 50 + Math.random() * 30;
                    g = 80 + Math.random() * 40;
                    b = 40 + Math.random() * 25;
                } else if (colorType < 0.7) {
                    // Lighter green (sun/dry)
                    r = 90 + Math.random() * 40;
                    g = 120 + Math.random() * 40;
                    b = 60 + Math.random() * 30;
                } else if (colorType < 0.85) {
                    // Yellow-green (dead grass)
                    r = 110 + Math.random() * 40;
                    g = 115 + Math.random() * 35;
                    b = 50 + Math.random() * 30;
                } else {
                    // Brown/dirt patches
                    r = 100 + Math.random() * 40;
                    g = 80 + Math.random() * 30;
                    b = 50 + Math.random() * 25;
                }

                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.9)`);
                gradient.addColorStop(0.4, `rgba(${r}, ${g}, ${b}, 0.5)`);
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Layer 2: Medium patches for more detail
            for (let i = 0; i < 80; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const radius = size * 0.02 + Math.random() * size * 0.08;

                const r = 60 + Math.random() * 70;
                const g = 85 + Math.random() * 60;
                const b = 40 + Math.random() * 40;

                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.7)`);
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Layer 3: Fine pixel noise for texture
            const imageData = ctx.getImageData(0, 0, size, size);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 25;
                data[i] = Math.max(0, Math.min(255, data[i] + noise));
                data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise * 1.1));
                data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise * 0.7));
            }
            ctx.putImageData(imageData, 0, 0);

            // Layer 4: Scattered dirt/bare patches
            ctx.globalAlpha = 0.6;
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const radius = size * 0.01 + Math.random() * size * 0.04;

                ctx.fillStyle = `rgb(${90 + Math.random() * 50}, ${70 + Math.random() * 40}, ${45 + Math.random() * 30})`;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;

            // Layer 5: Subtle highlight streaks (sun/wind patterns)
            ctx.globalAlpha = 0.2;
            for (let i = 0; i < 12; i++) {
                const startX = Math.random() * size;
                const startY = Math.random() * size;
                const length = size * 0.1 + Math.random() * size * 0.25;
                const angle = Math.random() * Math.PI * 2;

                ctx.strokeStyle = `rgb(${130 + Math.random() * 50}, ${145 + Math.random() * 40}, ${80 + Math.random() * 40})`;
                ctx.lineWidth = 10 + Math.random() * 30;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.quadraticCurveTo(
                    startX + Math.cos(angle) * length * 0.5 + (Math.random() - 0.5) * 30,
                    startY + Math.sin(angle) * length * 0.5 + (Math.random() - 0.5) * 30,
                    startX + Math.cos(angle) * length,
                    startY + Math.sin(angle) * length
                );
                ctx.stroke();
            }
            ctx.globalAlpha = 1.0;

            // Create Babylon texture
            const texture = new BABYLON.DynamicTexture('organicGround', canvas, scene, false);
            texture.update();

            return texture;
        }

        // ================================================================
        // === VERTEX COLORS (Darken Battle Zone) ===
        // ================================================================
        // Paints ground mesh vertices based on distance from center
        // Center = darker (scorched battle zone), edges = lighter
        // This is FREE on GPU and breaks repetition pattern

        function applyGroundVertexColors(ground, isHorizon = false) {
            const positions = ground.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            if (!positions) return;

            const vertexCount = positions.length / 3;
            const colors = new Float32Array(vertexCount * 4);  // RGBA

            // Ground dimensions (from mesh)
            const boundingInfo = ground.getBoundingInfo();
            const halfWidth = (boundingInfo.maximum.x - boundingInfo.minimum.x) / 2;
            const halfDepth = (boundingInfo.maximum.z - boundingInfo.minimum.z) / 2;

            for (let i = 0; i < vertexCount; i++) {
                const x = positions[i * 3];
                const z = positions[i * 3 + 2];

                // Normalized distance from center (0 = center, 1 = edge)
                const distX = Math.abs(x) / halfWidth;
                const distZ = Math.abs(z) / halfDepth;
                const dist = Math.sqrt(distX * distX + distZ * distZ) / Math.sqrt(2);

                // Add random variation to break uniformity
                const noise = (Math.random() - 0.5) * 0.15;

                if (isHorizon) {
                    // Horizon: slight variation, generally uniform
                    const brightness = 0.85 + noise * 0.5;
                    colors[i * 4] = brightness;
                    colors[i * 4 + 1] = brightness + 0.02;
                    colors[i * 4 + 2] = brightness - 0.02;
                    colors[i * 4 + 3] = 1.0;
                } else {
                    // Arena: darken center (battle zone), lighter edges
                    // Center brightness ~0.7, edge brightness ~1.0
                    const centerDarkness = 0.7;
                    const brightness = centerDarkness + (1.0 - centerDarkness) * dist + noise;

                    // Slight color variation (more brown in center, more green at edges)
                    colors[i * 4] = Math.max(0.5, Math.min(1.0, brightness + 0.03));      // R
                    colors[i * 4 + 1] = Math.max(0.5, Math.min(1.0, brightness + 0.01));  // G
                    colors[i * 4 + 2] = Math.max(0.4, Math.min(0.95, brightness - 0.05)); // B
                    colors[i * 4 + 3] = 1.0;  // A
                }
            }

            ground.setVerticesData(BABYLON.VertexBuffer.ColorKind, colors);

            // Enable vertex colors in material
            if (ground.material) {
                ground.material.useVertexColors = true;
            }
        }

        // ================================================================
        // === THIN INSTANCE DEBRIS SCATTER ===
        // ================================================================
        // Creates hundreds of small debris items with the cost of ~1 draw call
        // This is the "Cover-Up" technique that hides ground tiling

        function createDebrisScatter(scene, shadowGen) {
            // === SMALL ROCKS/PEBBLES ===
            // Larger base size so they're visible
            const pebble = BABYLON.MeshBuilder.CreateBox('pebble', {
                width: 0.25, height: 0.12, depth: 0.2
            }, scene);
            pebble.isVisible = false;  // Template is invisible

            // Use textured material for visible rocks
            const debrisMat = new BABYLON.StandardMaterial('debrisMat', scene);
            debrisMat.diffuseTexture = new BABYLON.Texture(TEXTURE_URLS.rock, scene);
            debrisMat.diffuseColor = new BABYLON.Color3(0.55, 0.5, 0.45);
            debrisMat.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);
            pebble.material = debrisMat;

            // Create transformation matrices for each debris piece
            const debrisCount = 150;  // Moderate count
            const matrices = [];

            for (let i = 0; i < debrisCount; i++) {
                // Random position across arena (40x20)
                const x = (Math.random() - 0.5) * 36;
                const z = (Math.random() - 0.5) * 16;
                const y = 0.04;  // Sit on ground

                // Larger scale variation (0.8x to 2.5x) so some are very visible
                const scale = 0.8 + Math.random() * 1.7;

                // Random Y rotation
                const rotY = Math.random() * Math.PI * 2;
                // Slight tilt for natural look
                const rotX = (Math.random() - 0.5) * 0.3;
                const rotZ = (Math.random() - 0.5) * 0.3;

                // Build transformation matrix
                const matrix = BABYLON.Matrix.Compose(
                    new BABYLON.Vector3(scale, scale * (0.4 + Math.random() * 0.4), scale),
                    BABYLON.Quaternion.RotationYawPitchRoll(rotY, rotX, rotZ),
                    new BABYLON.Vector3(x, y, z)
                );
                matrices.push(matrix);
            }

            // Add all instances at once (single draw call)
            pebble.thinInstanceAdd(matrices);
            pebble.thinInstanceEnablePicking = false;

            log(`[DEBRIS] ${debrisCount} rock instances`);

            // === GRASS TUFTS / DEAD VEGETATION ===
            // Small vertical boxes to simulate grass clumps
            const grassTuft = BABYLON.MeshBuilder.CreateBox('grassTuft', {
                width: 0.08, height: 0.2, depth: 0.08
            }, scene);
            grassTuft.isVisible = false;

            const grassMat = new BABYLON.StandardMaterial('grassMat', scene);
            grassMat.diffuseColor = new BABYLON.Color3(0.45, 0.55, 0.3);  // Yellow-green dead grass
            grassMat.specularColor = new BABYLON.Color3(0, 0, 0);
            grassTuft.material = grassMat;

            const grassMatrices = [];
            for (let i = 0; i < 120; i++) {
                const x = (Math.random() - 0.5) * 38;
                const z = (Math.random() - 0.5) * 18;
                const scale = 0.6 + Math.random() * 1.0;
                const rotY = Math.random() * Math.PI * 2;

                const matrix = BABYLON.Matrix.Compose(
                    new BABYLON.Vector3(scale, scale * (0.8 + Math.random() * 0.8), scale),
                    BABYLON.Quaternion.RotationYawPitchRoll(rotY, 0, 0),
                    new BABYLON.Vector3(x, 0.08, z)
                );
                grassMatrices.push(matrix);
            }

            grassTuft.thinInstanceAdd(grassMatrices);
            grassTuft.thinInstanceEnablePicking = false;

            // === Dirt/mud patches using decal-style flat planes ===
            createDirtPatches(scene);
        }

        // ================================================================
        // === DIRT PATCHES - Texture Splatting Lite ===
        // ================================================================
        // Overlays dirt texture patches on the ground to simulate paths/wear
        // This is a lightweight alternative to full terrain splatting

        function createDirtPatches(scene) {
            // Create a flat plane for dirt patches - LARGE for high camera visibility
            const dirtPatch = BABYLON.MeshBuilder.CreateGround('dirtPatch', {
                width: 1, height: 1
            }, scene);
            dirtPatch.isVisible = false;

            // Dirt material - more visible brown/tan color
            const dirtMat = new BABYLON.StandardMaterial('dirtMat', scene);
            const dirtTex = new BABYLON.Texture(TEXTURE_URLS.rock, scene);
            dirtTex.uScale = 0.5;  // Low tiling so texture is visible
            dirtTex.vScale = 0.5;
            dirtMat.diffuseTexture = dirtTex;
            dirtMat.diffuseColor = new BABYLON.Color3(0.6, 0.5, 0.38);  // Tan/brown dirt
            dirtMat.specularColor = new BABYLON.Color3(0, 0, 0);
            dirtMat.alpha = 0.55;  // Semi-transparent for blending
            dirtPatch.material = dirtMat;

            const patchMatrices = [];

            // LARGE battle lane patches - visible from high camera
            // Center horizontal strip where mechs fight
            for (let i = 0; i < 8; i++) {
                const x = -15 + i * 4 + (Math.random() - 0.5) * 3;
                const z = (Math.random() - 0.5) * 5;
                // MUCH larger scale: 5-10 units instead of 2-3
                const scale = 5 + Math.random() * 5;
                const rotY = Math.random() * Math.PI;

                const matrix = BABYLON.Matrix.Compose(
                    new BABYLON.Vector3(scale, 1, scale * (0.5 + Math.random() * 0.5)),
                    BABYLON.Quaternion.RotationYawPitchRoll(rotY, 0, 0),
                    new BABYLON.Vector3(x, 0.03, z)  // Above noise overlay
                );
                patchMatrices.push(matrix);
            }

            // Large scattered patches covering more ground
            for (let i = 0; i < 12; i++) {
                const x = (Math.random() - 0.5) * 35;
                const z = (Math.random() - 0.5) * 16;
                // Large patches: 4-9 units
                const scale = 4 + Math.random() * 5;
                const rotY = Math.random() * Math.PI;

                const matrix = BABYLON.Matrix.Compose(
                    new BABYLON.Vector3(scale, 1, scale * (0.7 + Math.random() * 0.3)),
                    BABYLON.Quaternion.RotationYawPitchRoll(rotY, 0, 0),
                    new BABYLON.Vector3(x, 0.03, z)
                );
                patchMatrices.push(matrix);
            }

            dirtPatch.thinInstanceAdd(patchMatrices);
            dirtPatch.thinInstanceEnablePicking = false;

            log('[DIRT] 20 large patches for ground variation');
        }

        function createMountains(scene) {
            // Mountain material - dark silhouette that blends with fog
            const mountainMat = new BABYLON.StandardMaterial('mountainMat', scene);
            mountainMat.diffuseColor = new BABYLON.Color3(0.15, 0.18, 0.22);
            mountainMat.specularColor = new BABYLON.Color3(0, 0, 0);
            mountainMat.emissiveColor = new BABYLON.Color3(0.03, 0.04, 0.05);
            mountainMat.fogEnabled = true;

            // Create mountain ranges around the arena
            const mountainRanges = [
                { angle: 0, distance: 150, count: 8 },        // Front
                { angle: Math.PI, distance: 150, count: 8 },  // Back
                { angle: Math.PI/2, distance: 120, count: 6 },  // Right
                { angle: -Math.PI/2, distance: 120, count: 6 }, // Left
                // Corner fills
                { angle: Math.PI/4, distance: 140, count: 4 },
                { angle: 3*Math.PI/4, distance: 140, count: 4 },
                { angle: -Math.PI/4, distance: 140, count: 4 },
                { angle: -3*Math.PI/4, distance: 140, count: 4 }
            ];

            mountainRanges.forEach((range, rangeIdx) => {
                for (let i = 0; i < range.count; i++) {
                    // Randomize position along the range
                    const spreadAngle = (i / range.count - 0.5) * 0.8;
                    const finalAngle = range.angle + spreadAngle;
                    const dist = range.distance + (Math.random() - 0.5) * 40;

                    const x = Math.sin(finalAngle) * dist;
                    const z = Math.cos(finalAngle) * dist;

                    // Create jagged mountain peak using merged cones
                    const baseHeight = 25 + Math.random() * 35;
                    const baseWidth = 20 + Math.random() * 25;

                    // Main peak
                    const peak = BABYLON.MeshBuilder.CreateCylinder('mountain_' + rangeIdx + '_' + i, {
                        diameterTop: 0,
                        diameterBottom: baseWidth,
                        height: baseHeight,
                        tessellation: 6  // Hexagonal for more angular look
                    }, scene);
                    peak.position = new BABYLON.Vector3(x, baseHeight / 2 - 5, z);
                    peak.rotation.y = Math.random() * Math.PI;
                    peak.material = mountainMat;

                    // Secondary peaks for more interesting silhouette
                    if (Math.random() > 0.3) {
                        const secondaryHeight = baseHeight * (0.5 + Math.random() * 0.3);
                        const secondary = BABYLON.MeshBuilder.CreateCylinder('mountain_sec_' + rangeIdx + '_' + i, {
                            diameterTop: 0,
                            diameterBottom: baseWidth * 0.6,
                            height: secondaryHeight,
                            tessellation: 5
                        }, scene);
                        secondary.position = new BABYLON.Vector3(
                            x + (Math.random() - 0.5) * baseWidth * 0.4,
                            secondaryHeight / 2 - 5,
                            z + (Math.random() - 0.5) * baseWidth * 0.4
                        );
                        secondary.rotation.y = Math.random() * Math.PI;
                        secondary.material = mountainMat;
                    }
                }
            });

            // Add some very distant large mountains for depth
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const dist = 280 + Math.random() * 50;
                const x = Math.sin(angle) * dist;
                const z = Math.cos(angle) * dist;
                const height = 60 + Math.random() * 40;
                const width = 50 + Math.random() * 30;

                const farMountain = BABYLON.MeshBuilder.CreateCylinder('farMountain_' + i, {
                    diameterTop: 0,
                    diameterBottom: width,
                    height: height,
                    tessellation: 6
                }, scene);
                farMountain.position = new BABYLON.Vector3(x, height / 2 - 10, z);
                farMountain.material = mountainMat;
            }
        }

        function createWalls(scene) {
            // Invisible walls - physics only, no rendering
            const walls = [
                { p: [-20, 5, 0], s: [1, 10, 20] },
                { p: [20, 5, 0], s: [1, 10, 20] },
                { p: [0, 5, 10], s: [40, 10, 1] },
                { p: [0, 5, -10], s: [40, 10, 1] }
            ];
            walls.forEach((w, i) => {
                const wall = BABYLON.MeshBuilder.CreateBox('wall' + i, { width: w.s[0], height: w.s[1], depth: w.s[2] }, scene);
                wall.position = new BABYLON.Vector3(...w.p);
                wall.isVisible = false;  // Invisible but still has physics
                new BABYLON.PhysicsAggregate(wall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);
            });
        }

        // ============================================
        // SHARED DIGITIGRADE LEG SYSTEM
        // Creates proper "lightning bolt" legs for all mechs
        // Short thin thigh (back-angled) â knee â long thick shin (forward-angled)
        // ============================================
        function createDigitigradeLeg(config) {
            const { scene, name, side, parent, scale, bulk, hipOffset, materials } = config;
            const { primaryMat, secondaryMat, darkMat, metalMat } = materials;
            const xOff = side === 'left' ? -1 : 1;
            const b = bulk || 1.0;  // Bulk multiplier for thickness

            // === HIP JOINT ===
            const hip = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Hip', {
                diameter: 0.32 * scale * b
            }, scene);
            hip.position = new BABYLON.Vector3(
                xOff * (hipOffset?.x || 0.7) * scale,
                (hipOffset?.y || -0.25) * scale,
                (hipOffset?.z || 0) * scale
            );
            hip.parent = parent;
            hip.material = metalMat;

            // Leg group for animation
            const legGroup = new BABYLON.TransformNode(name + '_' + side + 'LegGroup', scene);
            legGroup.position = hip.position.clone();
            legGroup.parent = parent;

            // === UPPER LEG (THIGH) - SHORT and THIN, angled BACKWARD ===
            const thighHeight = 0.5 * scale;  // SHORT thigh
            const upperLeg = new BABYLON.TransformNode(name + '_' + side + 'UpperLeg', scene);
            upperLeg.parent = legGroup;
            upperLeg.rotation.x = 0.5;  // Less forward = more back-angled appearance

            // Thin thigh mesh
            const upperLegMesh = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'UpperLegMesh', {
                width: 0.22 * scale * b,   // THIN
                height: thighHeight,
                depth: 0.24 * scale * b    // THIN
            }, scene);
            upperLegMesh.position = new BABYLON.Vector3(0, -thighHeight / 2, 0);
            upperLegMesh.parent = upperLeg;
            upperLegMesh.material = primaryMat;

            // Small thigh armor plate
            const thighArmor = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ThighArmor', {
                width: 0.26 * scale * b,
                height: 0.35 * scale,
                depth: 0.08 * scale
            }, scene);
            thighArmor.position = new BABYLON.Vector3(0, -thighHeight / 2, 0.14 * scale * b);
            thighArmor.parent = upperLeg;
            thighArmor.material = secondaryMat;

            // === KNEE JOINT - at bottom of thigh ===
            const knee = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Knee', {
                diameter: 0.3 * scale * b
            }, scene);
            knee.position = new BABYLON.Vector3(0, -thighHeight, 0);
            knee.parent = upperLeg;
            knee.material = metalMat;

            // Knee cap (pointing forward)
            const kneeCap = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'KneeCap', {
                width: 0.22 * scale * b,
                height: 0.2 * scale,
                depth: 0.14 * scale
            }, scene);
            kneeCap.position = new BABYLON.Vector3(0, 0, 0.18 * scale * b);
            kneeCap.parent = knee;
            kneeCap.material = secondaryMat;

            // === LOWER LEG (SHIN/CALF) - LONG and THICK, angled FORWARD ===
            const shinHeight = 1.2 * scale;  // LONG shin
            const lowerLeg = new BABYLON.TransformNode(name + '_' + side + 'LowerLeg', scene);
            lowerLeg.parent = knee;
            lowerLeg.rotation.x = -0.4;  // Less backward = more forward angle

            // Thick shin mesh
            const lowerLegMesh = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'LowerLegMesh', {
                width: 0.42 * scale * b,   // THICK
                height: shinHeight,
                depth: 0.48 * scale * b    // THICK
            }, scene);
            lowerLegMesh.position = new BABYLON.Vector3(0, -shinHeight / 2, 0);
            lowerLegMesh.parent = lowerLeg;
            lowerLegMesh.material = primaryMat;

            // Large calf bulge (rear actuator housing)
            const calfBulge = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'CalfBulge', {
                width: 0.38 * scale * b,
                height: 0.6 * scale,
                depth: 0.2 * scale
            }, scene);
            calfBulge.position = new BABYLON.Vector3(0, -shinHeight * 0.3, -0.32 * scale * b);
            calfBulge.parent = lowerLeg;
            calfBulge.material = secondaryMat;

            // Shin armor (front)
            const shinArmor = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ShinArmor', {
                width: 0.38 * scale * b,
                height: 0.8 * scale,
                depth: 0.1 * scale
            }, scene);
            shinArmor.position = new BABYLON.Vector3(0, -shinHeight * 0.35, 0.28 * scale * b);
            shinArmor.parent = lowerLeg;
            shinArmor.material = secondaryMat;

            // === ANKLE JOINT ===
            const ankle = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Ankle', {
                diameter: 0.26 * scale * b
            }, scene);
            ankle.position = new BABYLON.Vector3(0, -shinHeight, 0);
            ankle.parent = lowerLeg;
            ankle.material = metalMat;

            // Foot group for independent rotation
            const footGroup = new BABYLON.TransformNode(name + '_' + side + 'FootGroup', scene);
            footGroup.position = new BABYLON.Vector3(0, -0.1 * scale, 0);
            footGroup.parent = ankle;

            // === FOOT - THICK, tapered towards ends ===
            // Main foot body - chunky
            const foot = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Foot', {
                width: 0.5 * scale * b,
                height: 0.18 * scale,   // THICK
                depth: 0.4 * scale
            }, scene);
            foot.position = new BABYLON.Vector3(0, 0, 0.08 * scale);
            foot.parent = footGroup;
            foot.material = darkMat;

            // Foot armor top - chunky
            const footArmor = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'FootArmor', {
                width: 0.45 * scale * b,
                height: 0.1 * scale,
                depth: 0.35 * scale
            }, scene);
            footArmor.position = new BABYLON.Vector3(0, 0.1 * scale, 0);
            footArmor.parent = foot;
            footArmor.material = primaryMat;

            // Front toes - TAPERED (wide at base, narrow at tip)
            const toeL = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ToeL', {
                width: 0.14 * scale * b,
                height: 0.12 * scale,  // Thick
                depth: 0.35 * scale
            }, scene);
            toeL.position = new BABYLON.Vector3(-0.14 * scale * b, -0.02 * scale, 0.32 * scale);
            toeL.rotation.y = 0.25;
            toeL.parent = foot;
            toeL.material = primaryMat;

            // Toe tip L (tapered - smaller)
            const toeTipL = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ToeTipL', {
                width: 0.08 * scale * b,
                height: 0.08 * scale,
                depth: 0.15 * scale
            }, scene);
            toeTipL.position = new BABYLON.Vector3(0, -0.02 * scale, 0.22 * scale);
            toeTipL.parent = toeL;
            toeTipL.material = darkMat;

            const toeR = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ToeR', {
                width: 0.14 * scale * b,
                height: 0.12 * scale,  // Thick
                depth: 0.35 * scale
            }, scene);
            toeR.position = new BABYLON.Vector3(0.14 * scale * b, -0.02 * scale, 0.32 * scale);
            toeR.rotation.y = -0.25;
            toeR.parent = foot;
            toeR.material = primaryMat;

            // Toe tip R (tapered - smaller)
            const toeTipR = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ToeTipR', {
                width: 0.08 * scale * b,
                height: 0.08 * scale,
                depth: 0.15 * scale
            }, scene);
            toeTipR.position = new BABYLON.Vector3(0, -0.02 * scale, 0.22 * scale);
            toeTipR.parent = toeR;
            toeTipR.material = darkMat;

            // Rear heel spur - chunky
            const heel = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Heel', {
                width: 0.2 * scale * b,
                height: 0.1 * scale,
                depth: 0.25 * scale
            }, scene);
            heel.position = new BABYLON.Vector3(0, -0.02 * scale, -0.28 * scale);
            heel.rotation.x = 0.2;
            heel.parent = foot;
            heel.material = darkMat;

            return {
                hip, legGroup, upperLeg, knee, lowerLeg, ankle, foot, footGroup,
                thighArmor, kneeCap, calfBulge, shinArmor
            };
        }

        // ============================================
        // MAD CAT (Timber Wolf) - Highly Detailed
        // ============================================
        function createMadCatMech(scene, xPos, zPos, isPlayer) {
            const name = isPlayer ? 'player' : 'enemy';
            const primary = isPlayer ? COLORS.playerPrimary : COLORS.enemyPrimary;
            const secondary = isPlayer ? COLORS.playerSecondary : COLORS.enemySecondary;
            const accent = isPlayer ? COLORS.playerAccent : COLORS.enemyAccent;

            // Materials with textures
            const primaryMat = new BABYLON.StandardMaterial(name + '_primary', scene);
            primaryMat.diffuseTexture = TEXTURES.rustMetal.clone();
            primaryMat.diffuseTexture.uScale = 3;
            primaryMat.diffuseTexture.vScale = 3;
            primaryMat.diffuseColor = primary.scale(1.5);  // Tint the texture
            primaryMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            primaryMat.bumpTexture.uScale = 3;
            primaryMat.bumpTexture.vScale = 3;
            primaryMat.bumpTexture.level = 0.6;
            primaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            primaryMat.specularPower = 32;

            const secondaryMat = new BABYLON.StandardMaterial(name + '_secondary', scene);
            secondaryMat.diffuseTexture = TEXTURES.metal.clone();
            secondaryMat.diffuseTexture.uScale = 2;
            secondaryMat.diffuseTexture.vScale = 2;
            secondaryMat.diffuseColor = secondary.scale(1.3);
            secondaryMat.specularColor = new BABYLON.Color3(0.15, 0.15, 0.15);

            const accentMat = new BABYLON.StandardMaterial(name + '_accent', scene);
            accentMat.diffuseColor = accent;
            accentMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.3);
            accentMat.specularPower = 48;

            const metalMat = new BABYLON.StandardMaterial(name + '_metal', scene);
            metalMat.diffuseTexture = TEXTURES.rustMetal.clone();
            metalMat.diffuseTexture.uScale = 4;
            metalMat.diffuseTexture.vScale = 4;
            metalMat.diffuseColor = COLORS.metal.scale(1.2);
            metalMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            metalMat.bumpTexture.uScale = 4;
            metalMat.bumpTexture.vScale = 4;
            metalMat.bumpTexture.level = 0.5;
            metalMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            metalMat.specularPower = 64;

            const darkMat = new BABYLON.StandardMaterial(name + '_dark', scene);
            darkMat.diffuseColor = COLORS.darkMetal;
            darkMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            const cockpitMat = new BABYLON.StandardMaterial(name + '_cockpit', scene);
            cockpitMat.diffuseColor = COLORS.cockpit;
            cockpitMat.emissiveColor = COLORS.cockpit.scale(0.6);
            cockpitMat.alpha = 0.8;

            const chromeMat = new BABYLON.StandardMaterial(name + '_chrome', scene);
            chromeMat.diffuseColor = COLORS.chrome;
            chromeMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.9);
            chromeMat.specularPower = 128;

            // === PELVIS / CENTER (Physics body) - Wide stance for stability ===
            const pelvis = BABYLON.MeshBuilder.CreateBox(name + '_pelvis', {
                width: 1.8, height: 0.5, depth: 0.9  // Wider pelvis
            }, scene);
            pelvis.position = new BABYLON.Vector3(xPos, 3.5, zPos);  // Spawn height
            pelvis.material = darkMat;

            // Create a taller collision shape to represent the full mech standing height
            // The visual legs extend ~3 units below pelvis, so we use a tall box offset downward
            const pelvisShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -1.5, 0),  // Center offset (shift down to cover legs)
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(1.8, 3.5, 0.9),  // Full standing height
                scene
            );
            // HYBRID ARCHITECTURE: Start in ANIMATED (kinematic) mode for perfect walking control
            // Switch to DYNAMIC only when ragdolling from heavy impacts
            const pelvisBody = new BABYLON.PhysicsBody(pelvis, BABYLON.PhysicsMotionType.ANIMATED, false, scene);
            pelvisBody.shape = pelvisShape;
            pelvisBody.setMassProperties({ mass: 75 });
            // High angular damping for stiff mech feel (robots aren't floppy)
            pelvisBody.setAngularDamping(STABILITY_CONFIG.mechAngularDamping);
            pelvisBody.setLinearDamping(STABILITY_CONFIG.mechLinearDamping);

            // Set friction and restitution on the shape
            pelvisShape.material = { friction: 0.3, restitution: 0.05 };

            const pelvisAgg = { body: pelvisBody, shape: pelvisShape };  // Compatibility wrapper

            // === TORSO - Mad Cat Style with Conical Front ===
            const torsoCore = BABYLON.MeshBuilder.CreateBox(name + '_torsoCore', {
                width: 1.6, height: 1.2, depth: 1.1
            }, scene);
            torsoCore.position.y = 0.75;
            torsoCore.parent = pelvis;
            torsoCore.material = primaryMat;

            // Torso upper section (wider for missile racks)
            const torsoUpper = BABYLON.MeshBuilder.CreateBox(name + '_torsoUpper', {
                width: 1.8, height: 0.55, depth: 0.95
            }, scene);
            torsoUpper.position.y = 0.8;
            torsoUpper.parent = torsoCore;
            torsoUpper.material = secondaryMat;

            // === DISTINCTIVE CONICAL FRONT (Mad Cat "Bird Beak") ===
            // Main nose cone pointing forward
            const noseCone = BABYLON.MeshBuilder.CreateCylinder(name + '_noseCone', {
                height: 0.9, diameterTop: 0.15, diameterBottom: 0.7, tessellation: 8
            }, scene);
            noseCone.rotation.x = Math.PI / 2;
            noseCone.position = new BABYLON.Vector3(0, 0.15, 0.75);
            noseCone.parent = torsoCore;
            noseCone.material = primaryMat;

            // Nose cone tip (darker)
            const noseTip = BABYLON.MeshBuilder.CreateCylinder(name + '_noseTip', {
                height: 0.25, diameterTop: 0.08, diameterBottom: 0.18, tessellation: 8
            }, scene);
            noseTip.rotation.x = Math.PI / 2;
            noseTip.position = new BABYLON.Vector3(0, 0.15, 1.15);
            noseTip.parent = torsoCore;
            noseTip.material = darkMat;

            // Laser ports on nose (glowing)
            for (let i = 0; i < 2; i++) {
                const laserPort = BABYLON.MeshBuilder.CreateCylinder(name + '_laserPort' + i, {
                    height: 0.15, diameter: 0.12, tessellation: 12
                }, scene);
                laserPort.rotation.x = Math.PI / 2;
                laserPort.position = new BABYLON.Vector3((i - 0.5) * 0.25, 0.15, 1.22);
                laserPort.parent = torsoCore;
                const laserMat = new BABYLON.StandardMaterial(name + '_laserMat' + i, scene);
                laserMat.emissiveColor = isPlayer ? new BABYLON.Color3(0, 0.8, 1) : new BABYLON.Color3(1, 0.3, 0.1);
                laserPort.material = laserMat;
            }

            // Side chest plates (angled to form the cone shape)
            const chestLeft = BABYLON.MeshBuilder.CreateBox(name + '_chestL', {
                width: 0.5, height: 0.85, depth: 0.55
            }, scene);
            chestLeft.position = new BABYLON.Vector3(-0.5, 0.1, 0.4);
            chestLeft.rotation.x = -0.15;
            chestLeft.rotation.y = 0.35;
            chestLeft.parent = torsoCore;
            chestLeft.material = primaryMat;

            const chestRight = chestLeft.clone(name + '_chestR');
            chestRight.position.x = 0.5;
            chestRight.rotation.y = -0.35;
            chestRight.parent = torsoCore;

            // Side intake vents (decorative)
            for (let side = -1; side <= 1; side += 2) {
                const intake = BABYLON.MeshBuilder.CreateBox(name + '_intake' + side, {
                    width: 0.08, height: 0.4, depth: 0.35
                }, scene);
                intake.position = new BABYLON.Vector3(side * 0.65, 0.2, 0.25);
                intake.parent = torsoCore;
                intake.material = darkMat;

                // Vent slats
                for (let j = 0; j < 4; j++) {
                    const slat = BABYLON.MeshBuilder.CreateBox(name + '_slat' + side + j, {
                        width: 0.1, height: 0.03, depth: 0.3
                    }, scene);
                    slat.position = new BABYLON.Vector3(side * 0.02, (j - 1.5) * 0.09, 0);
                    slat.parent = intake;
                    slat.material = metalMat;
                }
            }

            // Center chest armor ridge
            const chestRidge = BABYLON.MeshBuilder.CreateBox(name + '_chestRidge', {
                width: 0.15, height: 0.7, depth: 0.5
            }, scene);
            chestRidge.position = new BABYLON.Vector3(0, 0.15, 0.35);
            chestRidge.parent = torsoCore;
            chestRidge.material = accentMat;

            // Lower chest detail
            const chestLower = BABYLON.MeshBuilder.CreateBox(name + '_chestLower', {
                width: 0.8, height: 0.25, depth: 0.4
            }, scene);
            chestLower.position = new BABYLON.Vector3(0, -0.35, 0.45);
            chestLower.parent = torsoCore;
            chestLower.material = secondaryMat;

            // Reactor housing (back) - larger
            const reactor = BABYLON.MeshBuilder.CreateBox(name + '_reactor', {
                width: 1.1, height: 0.9, depth: 0.6
            }, scene);
            reactor.position = new BABYLON.Vector3(0, 0.25, -0.7);
            reactor.parent = torsoCore;
            reactor.material = darkMat;

            // Heat sink fins (more prominent)
            for (let i = 0; i < 5; i++) {
                const fin = BABYLON.MeshBuilder.CreateBox(name + '_fin' + i, {
                    width: 0.06, height: 0.6, depth: 0.45
                }, scene);
                fin.position = new BABYLON.Vector3((i - 2) * 0.2, 0.05, 0.15);
                fin.parent = reactor;
                fin.material = metalMat;
            }

            // Exhaust vents (glowing)
            for (let i = 0; i < 3; i++) {
                const vent = BABYLON.MeshBuilder.CreateCylinder(name + '_vent' + i, {
                    height: 0.18, diameter: 0.2, tessellation: 12
                }, scene);
                vent.position = new BABYLON.Vector3((i - 1) * 0.32, -0.32, 0.32);
                vent.rotation.x = Math.PI / 2;
                vent.parent = reactor;
                const ventMat = new BABYLON.StandardMaterial(name + '_ventMat' + i, scene);
                ventMat.emissiveColor = COLORS.thruster.scale(0.5);
                vent.material = ventMat;
            }

            // === COCKPIT / HEAD - Detailed ===
            const headBase = BABYLON.MeshBuilder.CreateBox(name + '_headBase', {
                width: 0.6, height: 0.35, depth: 0.5
            }, scene);
            headBase.position = new BABYLON.Vector3(0, 0.55, 0.25);
            headBase.parent = torsoUpper;
            headBase.material = primaryMat;

            // Cockpit canopy (angled)
            const canopy = BABYLON.MeshBuilder.CreateBox(name + '_canopy', {
                width: 0.45, height: 0.25, depth: 0.35
            }, scene);
            canopy.position = new BABYLON.Vector3(0, 0.15, 0.15);
            canopy.rotation.x = -0.4;
            canopy.parent = headBase;
            canopy.material = cockpitMat;

            // Cockpit frame
            const frame1 = BABYLON.MeshBuilder.CreateBox(name + '_frame1', {
                width: 0.5, height: 0.04, depth: 0.3
            }, scene);
            frame1.position = new BABYLON.Vector3(0, 0.28, 0.1);
            frame1.rotation.x = -0.4;
            frame1.parent = headBase;
            frame1.material = darkMat;

            // Sensor pod on top
            const sensor = BABYLON.MeshBuilder.CreateCylinder(name + '_sensor', {
                height: 0.15, diameter: 0.12
            }, scene);
            sensor.position = new BABYLON.Vector3(0, 0.3, -0.1);
            sensor.parent = headBase;
            sensor.material = chromeMat;

            // Antenna
            const antenna = BABYLON.MeshBuilder.CreateCylinder(name + '_antenna', {
                height: 0.35, diameter: 0.04
            }, scene);
            antenna.position = new BABYLON.Vector3(0.2, 0.35, -0.1);
            antenna.parent = headBase;
            antenna.material = metalMat;

            // Chin sensor
            const chin = BABYLON.MeshBuilder.CreateBox(name + '_chin', {
                width: 0.2, height: 0.12, depth: 0.15
            }, scene);
            chin.position = new BABYLON.Vector3(0, -0.15, 0.25);
            chin.parent = headBase;
            chin.material = darkMat;

            // === GIANT SHOULDER MISSILE RACKS (LRM-20 Style) ===
            function createMissilePod(side) {
                const xOff = side === 'left' ? -1 : 1;
                const pod = new BABYLON.TransformNode(name + '_' + side + 'Pod', scene);
                pod.parent = torsoUpper;
                pod.position = new BABYLON.Vector3(xOff * 1.1, 0.5, -0.15);
                // Angle pods slightly outward for intimidating look
                pod.rotation.z = xOff * -0.15;

                // Main pod housing (much larger)
                const podBase = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodBase', {
                    width: 0.75, height: 0.85, depth: 1.0
                }, scene);
                podBase.parent = pod;
                podBase.material = primaryMat;

                // Angled front face plate
                const podFront = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodFront', {
                    width: 0.7, height: 0.8, depth: 0.15
                }, scene);
                podFront.position = new BABYLON.Vector3(0, 0, 0.5);
                podFront.rotation.x = -0.1;
                podFront.parent = podBase;
                podFront.material = secondaryMat;

                // Missile tubes (5x4 grid = 20 missiles per rack)
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 5; col++) {
                        const tube = BABYLON.MeshBuilder.CreateCylinder(name + '_tube_' + side + row + col, {
                            height: 0.2, diameter: 0.11, tessellation: 8
                        }, scene);
                        tube.rotation.x = Math.PI / 2;
                        tube.position = new BABYLON.Vector3(
                            (col - 2) * 0.13,
                            (row - 1.5) * 0.16,
                            0.55
                        );
                        tube.parent = podBase;
                        tube.material = darkMat;

                        // Missile tip visible in each tube
                        const missileTip = BABYLON.MeshBuilder.CreateCylinder(name + '_missile_' + side + row + col, {
                            height: 0.08, diameterTop: 0.02, diameterBottom: 0.07, tessellation: 6
                        }, scene);
                        missileTip.rotation.x = Math.PI / 2;
                        missileTip.position = new BABYLON.Vector3(
                            (col - 2) * 0.13,
                            (row - 1.5) * 0.16,
                            0.62
                        );
                        missileTip.parent = podBase;
                        missileTip.material = metalMat;
                    }
                }

                // Armored top with angular shape
                const podTop = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodTop', {
                    width: 0.72, height: 0.15, depth: 0.95
                }, scene);
                podTop.position.y = 0.48;
                podTop.parent = podBase;
                podTop.material = secondaryMat;

                // Top ridge
                const topRidge = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'TopRidge', {
                    width: 0.2, height: 0.12, depth: 0.85
                }, scene);
                topRidge.position = new BABYLON.Vector3(0, 0.58, 0);
                topRidge.parent = podBase;
                topRidge.material = accentMat;

                // Outer side armor panel
                const podSideOuter = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodSideO', {
                    width: 0.12, height: 0.75, depth: 0.9
                }, scene);
                podSideOuter.position.x = xOff * 0.4;
                podSideOuter.parent = podBase;
                podSideOuter.material = primaryMat;

                // Inner side armor panel
                const podSideInner = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodSideI', {
                    width: 0.1, height: 0.6, depth: 0.8
                }, scene);
                podSideInner.position.x = xOff * -0.38;
                podSideInner.parent = podBase;
                podSideInner.material = secondaryMat;

                // Bottom armor
                const podBottom = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodBottom', {
                    width: 0.65, height: 0.1, depth: 0.85
                }, scene);
                podBottom.position.y = -0.45;
                podBottom.parent = podBase;
                podBottom.material = darkMat;

                // Mounting strut connecting to torso
                const strut = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Strut', {
                    width: 0.2, height: 0.35, depth: 0.3
                }, scene);
                strut.position = new BABYLON.Vector3(xOff * -0.35, -0.25, 0);
                strut.parent = podBase;
                strut.material = metalMat;

                // Hydraulic actuator
                const actuator = BABYLON.MeshBuilder.CreateCylinder(name + '_' + side + 'Actuator', {
                    height: 0.4, diameter: 0.1, tessellation: 8
                }, scene);
                actuator.position = new BABYLON.Vector3(xOff * -0.28, -0.15, -0.25);
                actuator.rotation.x = 0.3;
                actuator.parent = podBase;
                actuator.material = chromeMat;

                // Warning stripes on side
                for (let i = 0; i < 3; i++) {
                    const stripe = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Stripe' + i, {
                        width: 0.13, height: 0.08, depth: 0.25
                    }, scene);
                    stripe.position = new BABYLON.Vector3(xOff * 0.405, 0.2 - i * 0.25, 0.2);
                    stripe.parent = podBase;
                    const stripeMat = new BABYLON.StandardMaterial(name + '_stripeMat' + side + i, scene);
                    stripeMat.diffuseColor = i % 2 === 0 ?
                        new BABYLON.Color3(0.9, 0.7, 0) : new BABYLON.Color3(0.1, 0.1, 0.1);
                    stripe.material = stripeMat;
                }

                return pod;
            }

            const leftPod = createMissilePod('left');
            const rightPod = createMissilePod('right');

            // === ARMS (Large Laser Pods) ===
            function createArm(side) {
                const xOff = side === 'left' ? -1 : 1;
                const armGroup = new BABYLON.TransformNode(name + '_' + side + 'Arm', scene);
                armGroup.parent = torsoCore;
                armGroup.position = new BABYLON.Vector3(xOff * 0.95, 0.1, 0);

                // Shoulder joint
                const shoulderJoint = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'ShoulderJ', {
                    diameter: 0.32
                }, scene);
                shoulderJoint.parent = armGroup;
                shoulderJoint.material = chromeMat;

                // Upper arm
                const upperArm = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'UpperArm', {
                    width: 0.28, height: 0.55, depth: 0.28
                }, scene);
                upperArm.position = new BABYLON.Vector3(xOff * 0.15, -0.35, 0);
                upperArm.parent = armGroup;
                upperArm.material = primaryMat;

                // Upper arm detail
                const upperDetail = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'UpperDetail', {
                    width: 0.32, height: 0.2, depth: 0.15
                }, scene);
                upperDetail.position = new BABYLON.Vector3(xOff * 0.05, 0, 0.15);
                upperDetail.parent = upperArm;
                upperDetail.material = secondaryMat;

                // Elbow
                const elbow = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Elbow', {
                    diameter: 0.22
                }, scene);
                elbow.position = new BABYLON.Vector3(0, -0.35, 0);
                elbow.parent = upperArm;
                elbow.material = metalMat;

                // Lower arm / weapon pod
                const weaponPod = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'WeaponPod', {
                    width: 0.45, height: 0.75, depth: 0.4
                }, scene);
                weaponPod.position = new BABYLON.Vector3(0, -0.75, 0);
                weaponPod.parent = upperArm;
                weaponPod.material = primaryMat;

                // Weapon pod front plate
                const podFront = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodFront', {
                    width: 0.4, height: 0.5, depth: 0.1
                }, scene);
                podFront.position.z = 0.22;
                podFront.parent = weaponPod;
                podFront.material = secondaryMat;

                // ER Large Laser barrels (2 per arm)
                for (let i = 0; i < 2; i++) {
                    const laserBarrel = BABYLON.MeshBuilder.CreateCylinder(name + '_laser_' + side + i, {
                        height: 0.7, diameter: 0.12
                    }, scene);
                    laserBarrel.rotation.x = Math.PI / 2;
                    laserBarrel.position = new BABYLON.Vector3((i - 0.5) * 0.15, -0.1, 0.5);
                    laserBarrel.parent = weaponPod;
                    laserBarrel.material = chromeMat;

                    // Barrel tip
                    const tip = BABYLON.MeshBuilder.CreateCylinder(name + '_laserTip_' + side + i, {
                        height: 0.08, diameter: 0.15
                    }, scene);
                    tip.rotation.x = Math.PI / 2;
                    tip.position.z = 0.38;
                    tip.parent = laserBarrel;
                    tip.material = darkMat;
                }

                // Weapon pod side detail
                const podSideL = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodSideL', {
                    width: 0.08, height: 0.5, depth: 0.3
                }, scene);
                podSideL.position = new BABYLON.Vector3(-0.22, 0, 0);
                podSideL.parent = weaponPod;
                podSideL.material = accentMat;

                const podSideR = podSideL.clone(name + '_' + side + 'PodSideR');
                podSideR.position.x = 0.22;
                podSideR.parent = weaponPod;

                return { armGroup, upperArm, weaponPod };
            }

            const leftArm = createArm('left');
            const rightArm = createArm('right');

            // === LEGS - Using shared digitigrade system ===
            const legMaterials = { primaryMat, secondaryMat, darkMat, metalMat };
            const leftLeg = createDigitigradeLeg({
                scene, name, side: 'left', parent: pelvis, scale: 1.0,
                bulk: 1.1,  // Slightly heavier for assault mech
                hipOffset: { x: 0.8, y: -0.3, z: -0.1 },
                materials: legMaterials
            });
            const rightLeg = createDigitigradeLeg({
                scene, name, side: 'right', parent: pelvis, scale: 1.0,
                bulk: 1.1,
                hipOffset: { x: 0.8, y: -0.3, z: -0.1 },
                materials: legMaterials
            });
            // Build mech data
            return {
                name: 'TIMBER WOLF',
                pelvis, pelvisAggregate: pelvisAgg,
                torso: torsoCore, head: headBase, cockpit: canopy,
                leftArm, rightArm, leftLeg, rightLeg,
                leftPod, rightPod,
                isPlayer, scale: 1.0,
                standingHeight: 2.5,  // Pelvis Y for feet to touch ground
                optimalRange: 10,      // Ideal combat distance for this mech
                stats: { maxHP: 150, mass: 75 },
                currentHP: 150, maxHP: 150,
                isWalking: false, walkCycle: 0, walkSpeed: 2.8,
                walkDirection: isPlayer ? 1 : -1,
                impactRecovery: 0, impactDirection: new BABYLON.Vector3(0,0,0),
                staggerTime: 0, recoilRecovery: 0, lastFiredArm: 'right',
                torsoTwist: 0, targetTorsoTwist: 0,
                // HYBRID STATE MACHINE properties
                mechState: MechState.WALKING,
                stability: STABILITY_CONFIG.maxStability,
                ragdollSettleTimer: 0,
                recoveryTimer: 0,
                destroyedTimer: 0,
                lastKinematicVelocity: new BABYLON.Vector3(0, 0, 0),
                flinchIntensity: 0,
                // AI state
                ai: {
                    enabled: false,
                    state: 'idle',        // idle, advancing, retreating, optimal, strafing
                    target: null,         // Current target mech
                    lastDecision: 0,
                    strafeDir: 0,         // -1 left, 0 none, 1 right
                    strafeEndTime: 0
                }
            };
        }

        // ============================================
        // DIRE WOLF (Daishi) - Even More Detailed, Heavier
        // ============================================
        function createDireWolfMech(scene, xPos, zPos, isPlayer) {
            const name = isPlayer ? 'player' : 'enemy';
            const primary = isPlayer ? COLORS.playerPrimary : COLORS.enemyPrimary;
            const secondary = isPlayer ? COLORS.playerSecondary : COLORS.enemySecondary;
            const accent = isPlayer ? COLORS.playerAccent : COLORS.enemyAccent;

            // Materials with textures
            const primaryMat = new BABYLON.StandardMaterial(name + '_primary', scene);
            primaryMat.diffuseTexture = TEXTURES.rustMetal.clone();
            primaryMat.diffuseTexture.uScale = 3;
            primaryMat.diffuseTexture.vScale = 3;
            primaryMat.diffuseColor = primary.scale(1.5);
            primaryMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            primaryMat.bumpTexture.uScale = 3;
            primaryMat.bumpTexture.vScale = 3;
            primaryMat.bumpTexture.level = 0.6;
            primaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            primaryMat.specularPower = 32;

            const secondaryMat = new BABYLON.StandardMaterial(name + '_secondary', scene);
            secondaryMat.diffuseTexture = TEXTURES.metal.clone();
            secondaryMat.diffuseTexture.uScale = 2;
            secondaryMat.diffuseTexture.vScale = 2;
            secondaryMat.diffuseColor = secondary.scale(1.3);
            secondaryMat.specularColor = new BABYLON.Color3(0.15, 0.15, 0.15);

            const accentMat = new BABYLON.StandardMaterial(name + '_accent', scene);
            accentMat.diffuseColor = accent;
            accentMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.3);
            accentMat.specularPower = 48;

            const metalMat = new BABYLON.StandardMaterial(name + '_metal', scene);
            metalMat.diffuseTexture = TEXTURES.rustMetal.clone();
            metalMat.diffuseTexture.uScale = 4;
            metalMat.diffuseTexture.vScale = 4;
            metalMat.diffuseColor = COLORS.metal.scale(1.2);
            metalMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            metalMat.bumpTexture.uScale = 4;
            metalMat.bumpTexture.vScale = 4;
            metalMat.bumpTexture.level = 0.5;
            metalMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            metalMat.specularPower = 64;

            const darkMat = new BABYLON.StandardMaterial(name + '_dark', scene);
            darkMat.diffuseColor = COLORS.darkMetal;
            darkMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            const cockpitMat = new BABYLON.StandardMaterial(name + '_cockpit', scene);
            cockpitMat.diffuseColor = COLORS.cockpit;
            cockpitMat.emissiveColor = COLORS.cockpit.scale(0.5);
            cockpitMat.alpha = 0.8;

            const chromeMat = new BABYLON.StandardMaterial(name + '_chrome', scene);
            chromeMat.diffuseColor = COLORS.chrome;
            chromeMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.9);
            chromeMat.specularPower = 128;

            const scale = 1.15; // Bigger mech

            // === PELVIS - Wide stance for stability ===
            const pelvis = BABYLON.MeshBuilder.CreateBox(name + '_pelvis', {
                width: 2.0 * scale, height: 0.55 * scale, depth: 1.0 * scale  // Wider pelvis
            }, scene);
            pelvis.position = new BABYLON.Vector3(xPos, 3.8, zPos);  // Spawn height
            pelvis.material = darkMat;

            // Create a taller collision shape to represent the full mech standing height
            // Dire Wolf is bigger (scale 1.15), legs extend ~3.5 units below pelvis
            const pelvisShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -1.7 * scale, 0),  // Center offset (shift down to cover legs)
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(2.0 * scale, 4.0 * scale, 1.0 * scale),  // Full standing height
                scene
            );
            // HYBRID ARCHITECTURE: Start in ANIMATED (kinematic) mode for perfect walking control
            const pelvisBody = new BABYLON.PhysicsBody(pelvis, BABYLON.PhysicsMotionType.ANIMATED, false, scene);
            pelvisBody.shape = pelvisShape;
            pelvisBody.setMassProperties({ mass: 100 });
            pelvisBody.setAngularDamping(STABILITY_CONFIG.mechAngularDamping);
            pelvisBody.setLinearDamping(STABILITY_CONFIG.mechLinearDamping);

            // Set friction and restitution on the shape
            pelvisShape.material = { friction: 0.3, restitution: 0.05 };

            const pelvisAgg = { body: pelvisBody, shape: pelvisShape };  // Compatibility wrapper

            // === MASSIVE TORSO - Dire Wolf Style with Angular Front ===
            const torsoCore = BABYLON.MeshBuilder.CreateBox(name + '_torsoCore', {
                width: 1.9 * scale, height: 1.4 * scale, depth: 1.3 * scale
            }, scene);
            torsoCore.position.y = 0.85 * scale;
            torsoCore.parent = pelvis;
            torsoCore.material = primaryMat;

            // Upper torso (wider for weapon pods)
            const torsoUpper = BABYLON.MeshBuilder.CreateBox(name + '_torsoUpper', {
                width: 2.0 * scale, height: 0.65 * scale, depth: 1.1 * scale
            }, scene);
            torsoUpper.position.y = 0.9 * scale;
            torsoUpper.parent = torsoCore;
            torsoUpper.material = secondaryMat;

            // === DISTINCTIVE ANGULAR FRONT (Dire Wolf "Fortress" style) ===
            // Main angular nose section
            const noseCone = BABYLON.MeshBuilder.CreateCylinder(name + '_noseCone', {
                height: 1.1 * scale, diameterTop: 0.2 * scale, diameterBottom: 0.85 * scale, tessellation: 6
            }, scene);
            noseCone.rotation.x = Math.PI / 2;
            noseCone.position = new BABYLON.Vector3(0, 0.1 * scale, 0.85 * scale);
            noseCone.parent = torsoCore;
            noseCone.material = primaryMat;

            // Nose armor tip
            const noseTip = BABYLON.MeshBuilder.CreateCylinder(name + '_noseTip', {
                height: 0.3 * scale, diameterTop: 0.1 * scale, diameterBottom: 0.25 * scale, tessellation: 6
            }, scene);
            noseTip.rotation.x = Math.PI / 2;
            noseTip.position = new BABYLON.Vector3(0, 0.1 * scale, 1.35 * scale);
            noseTip.parent = torsoCore;
            noseTip.material = darkMat;

            // Heavy laser array on nose (4 barrels)
            for (let i = 0; i < 4; i++) {
                const laserBarrel = BABYLON.MeshBuilder.CreateCylinder(name + '_laserBarrel' + i, {
                    height: 0.25 * scale, diameter: 0.1 * scale, tessellation: 12
                }, scene);
                laserBarrel.rotation.x = Math.PI / 2;
                const angle = (i / 4) * Math.PI * 2;
                laserBarrel.position = new BABYLON.Vector3(
                    Math.cos(angle) * 0.18 * scale,
                    0.1 * scale + Math.sin(angle) * 0.18 * scale,
                    1.45 * scale
                );
                laserBarrel.parent = torsoCore;
                const barrelMat = new BABYLON.StandardMaterial(name + '_barrelMat' + i, scene);
                barrelMat.emissiveColor = isPlayer ? new BABYLON.Color3(0, 0.8, 1) : new BABYLON.Color3(1, 0.2, 0.1);
                laserBarrel.material = barrelMat;
            }

            // Side chest plates (angled for angular look)
            for (let side = -1; side <= 1; side += 2) {
                const chestPlate = BABYLON.MeshBuilder.CreateBox(name + '_chestPlate' + side, {
                    width: 0.6 * scale, height: 0.95 * scale, depth: 0.6 * scale
                }, scene);
                chestPlate.position = new BABYLON.Vector3(side * 0.6 * scale, 0.05 * scale, 0.45 * scale);
                chestPlate.rotation.y = side * 0.4;
                chestPlate.parent = torsoCore;
                chestPlate.material = primaryMat;

                // Armor detail on chest plates
                const plateDetail = BABYLON.MeshBuilder.CreateBox(name + '_plateDetail' + side, {
                    width: 0.5 * scale, height: 0.6 * scale, depth: 0.12 * scale
                }, scene);
                plateDetail.position = new BABYLON.Vector3(0, 0, 0.32 * scale);
                plateDetail.parent = chestPlate;
                plateDetail.material = secondaryMat;
            }

            // Side torso panels (larger)
            for (let side = -1; side <= 1; side += 2) {
                const sidePanel = BABYLON.MeshBuilder.CreateBox(name + '_sidePanel' + side, {
                    width: 0.18 * scale, height: 1.0 * scale, depth: 0.9 * scale
                }, scene);
                sidePanel.position = new BABYLON.Vector3(side * 0.95 * scale, 0.15 * scale, 0);
                sidePanel.parent = torsoCore;
                sidePanel.material = secondaryMat;

                // Vent grilles
                for (let j = 0; j < 3; j++) {
                    const grille = BABYLON.MeshBuilder.CreateBox(name + '_grille' + side + j, {
                        width: 0.2 * scale, height: 0.05 * scale, depth: 0.4 * scale
                    }, scene);
                    grille.position = new BABYLON.Vector3(side * 0.02, (j - 1) * 0.2 * scale, 0.1 * scale);
                    grille.parent = sidePanel;
                    grille.material = darkMat;
                }
            }

            // Center chest ridge
            const chestRidge = BABYLON.MeshBuilder.CreateBox(name + '_chestRidge', {
                width: 0.2 * scale, height: 0.8 * scale, depth: 0.55 * scale
            }, scene);
            chestRidge.position = new BABYLON.Vector3(0, 0.1 * scale, 0.4 * scale);
            chestRidge.parent = torsoCore;
            chestRidge.material = accentMat;

            // Large reactor (back)
            const reactor = BABYLON.MeshBuilder.CreateBox(name + '_reactor', {
                width: 1.3 * scale, height: 1.1 * scale, depth: 0.7 * scale
            }, scene);
            reactor.position = new BABYLON.Vector3(0, 0.3 * scale, -0.85 * scale);
            reactor.parent = torsoCore;
            reactor.material = darkMat;

            // Reactor pipes
            for (let i = 0; i < 4; i++) {
                const pipe = BABYLON.MeshBuilder.CreateCylinder(name + '_pipe' + i, {
                    height: 0.9 * scale, diameter: 0.14 * scale
                }, scene);
                pipe.position = new BABYLON.Vector3((i - 1.5) * 0.28 * scale, 0.15 * scale, 0);
                pipe.rotation.x = 0.15;
                pipe.parent = reactor;
                pipe.material = chromeMat;
            }

            // Exhaust array (larger)
            for (let i = 0; i < 4; i++) {
                const exhaust = BABYLON.MeshBuilder.CreateCylinder(name + '_exhaust' + i, {
                    height: 0.22 * scale, diameter: 0.18 * scale, tessellation: 12
                }, scene);
                exhaust.rotation.x = Math.PI / 2;
                exhaust.position = new BABYLON.Vector3((i - 1.5) * 0.28 * scale, -0.4 * scale, 0.38 * scale);
                exhaust.parent = reactor;
                const exMat = new BABYLON.StandardMaterial(name + '_exMat' + i, scene);
                exMat.emissiveColor = COLORS.thruster.scale(0.4);
                exhaust.material = exMat;
            }

            // === HEAD (Smaller, bunker-style) ===
            const headBase = BABYLON.MeshBuilder.CreateBox(name + '_headBase', {
                width: 0.55 * scale, height: 0.35 * scale, depth: 0.45 * scale
            }, scene);
            headBase.position = new BABYLON.Vector3(0, 0.55 * scale, 0.2 * scale);
            headBase.parent = torsoUpper;
            headBase.material = primaryMat;

            const canopy = BABYLON.MeshBuilder.CreateBox(name + '_canopy', {
                width: 0.4 * scale, height: 0.18 * scale, depth: 0.25 * scale
            }, scene);
            canopy.position = new BABYLON.Vector3(0, 0.1 * scale, 0.15 * scale);
            canopy.rotation.x = -0.35;
            canopy.parent = headBase;
            canopy.material = cockpitMat;

            // Sensor array
            for (let i = 0; i < 2; i++) {
                const sens = BABYLON.MeshBuilder.CreateCylinder(name + '_sens' + i, {
                    height: 0.12 * scale, diameter: 0.08 * scale
                }, scene);
                sens.position = new BABYLON.Vector3((i - 0.5) * 0.2 * scale, 0.22 * scale, 0);
                sens.parent = headBase;
                sens.material = chromeMat;
            }

            // === MASSIVE SHOULDER WEAPON PODS ===
            function createWeaponPod(side) {
                const xOff = side === 'left' ? -1 : 1;
                const pod = new BABYLON.TransformNode(name + '_' + side + 'WeaponPod', scene);
                pod.parent = torsoUpper;
                pod.position = new BABYLON.Vector3(xOff * 1.1 * scale, 0.2 * scale, 0);

                // Main pod body
                const podBody = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodBody', {
                    width: 0.7 * scale, height: 0.65 * scale, depth: 0.9 * scale
                }, scene);
                podBody.parent = pod;
                podBody.material = primaryMat;

                // Pod top armor
                const podTop = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodTop', {
                    width: 0.65 * scale, height: 0.15 * scale, depth: 0.85 * scale
                }, scene);
                podTop.position.y = 0.38 * scale;
                podTop.parent = podBody;
                podTop.material = secondaryMat;

                // Missile tubes (5x4)
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 5; c++) {
                        const tube = BABYLON.MeshBuilder.CreateCylinder(name + '_mtube' + side + r + c, {
                            height: 0.1 * scale, diameter: 0.07 * scale
                        }, scene);
                        tube.rotation.x = Math.PI / 2;
                        tube.position = new BABYLON.Vector3(
                            (c - 2) * 0.11 * scale,
                            (r - 1.5) * 0.11 * scale,
                            0.48 * scale
                        );
                        tube.parent = podBody;
                        tube.material = darkMat;
                    }
                }

                // Side weapon (autocannon or laser)
                const sideGun = BABYLON.MeshBuilder.CreateCylinder(name + '_' + side + 'SideGun', {
                    height: 0.8 * scale, diameter: 0.15 * scale
                }, scene);
                sideGun.rotation.x = Math.PI / 2;
                sideGun.position = new BABYLON.Vector3(xOff * 0.32 * scale, -0.15 * scale, 0.55 * scale);
                sideGun.parent = podBody;
                sideGun.material = chromeMat;

                return pod;
            }

            const leftPod = createWeaponPod('left');
            const rightPod = createWeaponPod('right');

            // === ARMS (Heavy weapon mounts) ===
            function createArm(side) {
                const xOff = side === 'left' ? -1 : 1;
                const armGroup = new BABYLON.TransformNode(name + '_' + side + 'Arm', scene);
                armGroup.parent = torsoCore;
                armGroup.position = new BABYLON.Vector3(xOff * 1.1 * scale, 0, 0);

                const shoulder = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Shoulder', {
                    diameter: 0.35 * scale
                }, scene);
                shoulder.parent = armGroup;
                shoulder.material = chromeMat;

                const upperArm = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'UpperArm', {
                    width: 0.32 * scale, height: 0.6 * scale, depth: 0.32 * scale
                }, scene);
                upperArm.position = new BABYLON.Vector3(xOff * 0.12 * scale, -0.38 * scale, 0);
                upperArm.parent = armGroup;
                upperArm.material = primaryMat;

                const elbow = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Elbow', {
                    diameter: 0.25 * scale
                }, scene);
                elbow.position.y = -0.38 * scale;
                elbow.parent = upperArm;
                elbow.material = metalMat;

                // Massive weapon pod
                const weaponPod = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ArmWeapon', {
                    width: 0.5 * scale, height: 0.85 * scale, depth: 0.45 * scale
                }, scene);
                weaponPod.position = new BABYLON.Vector3(0, -0.8 * scale, 0);
                weaponPod.parent = upperArm;
                weaponPod.material = primaryMat;

                // Quad laser barrels
                for (let r = 0; r < 2; r++) {
                    for (let c = 0; c < 2; c++) {
                        const barrel = BABYLON.MeshBuilder.CreateCylinder(name + '_barrel' + side + r + c, {
                            height: 0.75 * scale, diameter: 0.1 * scale
                        }, scene);
                        barrel.rotation.x = Math.PI / 2;
                        barrel.position = new BABYLON.Vector3(
                            (c - 0.5) * 0.15 * scale,
                            -0.15 * scale + r * 0.2 * scale,
                            0.55 * scale
                        );
                        barrel.parent = weaponPod;
                        barrel.material = chromeMat;
                    }
                }

                return { armGroup, upperArm, weaponPod };
            }

            const leftArm = createArm('left');
            const rightArm = createArm('right');

            // === LEGS - Using shared digitigrade system ===
            const legMaterials = { primaryMat, secondaryMat, darkMat, metalMat };
            const leftLeg = createDigitigradeLeg({
                scene, name, side: 'left', parent: pelvis, scale,
                bulk: 1.2,  // Extra heavy for assault mech
                hipOffset: { x: 0.9, y: -0.32, z: -0.1 },
                materials: legMaterials
            });
            const rightLeg = createDigitigradeLeg({
                scene, name, side: 'right', parent: pelvis, scale,
                bulk: 1.2,
                hipOffset: { x: 0.9, y: -0.32, z: -0.1 },
                materials: legMaterials
            });

            return {
                name: 'DIRE WOLF',
                pelvis, pelvisAggregate: pelvisAgg,
                torso: torsoCore, head: headBase, cockpit: canopy,
                leftArm, rightArm, leftLeg, rightLeg,
                leftPod, rightPod,
                isPlayer, scale,
                standingHeight: 3.2,   // Pelvis Y for feet to touch ground
                optimalRange: 12,       // Heavier mech prefers longer range
                stats: { maxHP: 200, mass: 100 },
                currentHP: 200, maxHP: 200,
                isWalking: false, walkCycle: 0, walkSpeed: 2.2,
                walkDirection: isPlayer ? 1 : -1,
                impactRecovery: 0, impactDirection: new BABYLON.Vector3(0,0,0),
                staggerTime: 0, recoilRecovery: 0, lastFiredArm: 'right',
                torsoTwist: 0, targetTorsoTwist: 0,
                // HYBRID STATE MACHINE properties
                mechState: MechState.WALKING,
                stability: STABILITY_CONFIG.maxStability,
                ragdollSettleTimer: 0,
                recoveryTimer: 0,
                destroyedTimer: 0,
                lastKinematicVelocity: new BABYLON.Vector3(0, 0, 0),
                flinchIntensity: 0,
                // AI state
                ai: {
                    enabled: false,
                    state: 'idle',        // idle, advancing, retreating, optimal, strafing
                    target: null,         // Current target mech
                    lastDecision: 0,
                    strafeDir: 0,         // -1 left, 0 none, 1 right
                    strafeEndTime: 0
                }
            };
        }

        // ============================================
        // COMMANDO - Light Scout Mech
        // ============================================
        function createCommandoMech(scene, xPos, zPos, isPlayer) {
            const name = (isPlayer ? 'player' : 'enemy') + '_commando_' + Math.random().toString(36).substr(2, 4);
            const primary = isPlayer ? COLORS.playerPrimary : COLORS.enemyPrimary;
            const secondary = isPlayer ? COLORS.playerSecondary : COLORS.enemySecondary;
            const scale = 0.7;  // Smaller mech

            // Materials with textures
            const primaryMat = new BABYLON.StandardMaterial(name + '_primary', scene);
            primaryMat.diffuseTexture = TEXTURES.rustMetal.clone();
            primaryMat.diffuseTexture.uScale = 2;
            primaryMat.diffuseTexture.vScale = 2;
            primaryMat.diffuseColor = primary.scale(1.4);
            primaryMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            primaryMat.bumpTexture.uScale = 2;
            primaryMat.bumpTexture.vScale = 2;
            primaryMat.bumpTexture.level = 0.5;
            primaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            primaryMat.specularPower = 32;

            const secondaryMat = new BABYLON.StandardMaterial(name + '_secondary', scene);
            secondaryMat.diffuseTexture = TEXTURES.metal.clone();
            secondaryMat.diffuseTexture.uScale = 2;
            secondaryMat.diffuseTexture.vScale = 2;
            secondaryMat.diffuseColor = secondary.scale(1.2);
            secondaryMat.specularColor = new BABYLON.Color3(0.15, 0.15, 0.15);

            const darkMat = new BABYLON.StandardMaterial(name + '_dark', scene);
            darkMat.diffuseColor = COLORS.darkMetal;
            darkMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            const metalMat = new BABYLON.StandardMaterial(name + '_metal', scene);
            metalMat.diffuseTexture = TEXTURES.rustMetal.clone();
            metalMat.diffuseTexture.uScale = 3;
            metalMat.diffuseTexture.vScale = 3;
            metalMat.diffuseColor = COLORS.metal.scale(1.2);
            metalMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            metalMat.bumpTexture.uScale = 3;
            metalMat.bumpTexture.vScale = 3;
            metalMat.bumpTexture.level = 0.4;
            metalMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
            metalMat.specularPower = 48;

            // Pelvis - smaller
            const pelvis = BABYLON.MeshBuilder.CreateBox(name + '_pelvis', {
                width: 1.2 * scale, height: 0.4 * scale, depth: 0.7 * scale
            }, scene);
            pelvis.position = new BABYLON.Vector3(xPos, 3.0, zPos);
            pelvis.material = darkMat;

            const pelvisShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -1.2, 0),
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(1.2 * scale, 2.8, 0.7 * scale),
                scene
            );
            // HYBRID ARCHITECTURE: Start in ANIMATED (kinematic) mode for perfect walking control
            const pelvisBody = new BABYLON.PhysicsBody(pelvis, BABYLON.PhysicsMotionType.ANIMATED, false, scene);
            pelvisBody.shape = pelvisShape;
            pelvisBody.setMassProperties({ mass: 40 });
            pelvisBody.setAngularDamping(STABILITY_CONFIG.mechAngularDamping);
            pelvisBody.setLinearDamping(STABILITY_CONFIG.mechLinearDamping);
            pelvisShape.material = { friction: 0.3, restitution: 0.05 };
            const pelvisAgg = { body: pelvisBody, shape: pelvisShape };

            // Torso - compact, angular
            const torsoCore = BABYLON.MeshBuilder.CreateBox(name + '_torso', {
                width: 1.0 * scale, height: 1.2 * scale, depth: 0.8 * scale
            }, scene);
            torsoCore.position.y = 0.8 * scale;
            torsoCore.parent = pelvis;
            torsoCore.material = primaryMat;

            // Head - small sensor dome
            const headBase = BABYLON.MeshBuilder.CreateCylinder(name + '_head', {
                diameter: 0.5 * scale, height: 0.4 * scale
            }, scene);
            headBase.position.y = 0.9 * scale;
            headBase.parent = torsoCore;
            headBase.material = secondaryMat;

            const canopy = BABYLON.MeshBuilder.CreateSphere(name + '_canopy', {
                diameter: 0.35 * scale
            }, scene);
            canopy.position.y = 0.15 * scale;
            canopy.parent = headBase;
            canopy.material = new BABYLON.StandardMaterial(name + '_cockpit', scene);
            canopy.material.diffuseColor = COLORS.cockpit;
            canopy.material.emissiveColor = COLORS.cockpit.scale(0.5);
            canopy.material.alpha = 0.8;

            // Arms - simple laser mounts
            function createArm(side) {
                const sign = side === 'left' ? -1 : 1;
                const shoulder = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Shoulder', {
                    width: 0.25 * scale, height: 0.3 * scale, depth: 0.25 * scale
                }, scene);
                shoulder.position = new BABYLON.Vector3(sign * 0.55 * scale, 0.5 * scale, 0);
                shoulder.parent = torsoCore;
                shoulder.material = secondaryMat;

                const arm = BABYLON.MeshBuilder.CreateCylinder(name + '_' + side + 'Arm', {
                    diameter: 0.18 * scale, height: 0.8 * scale
                }, scene);
                arm.rotation.z = sign * 0.2;
                arm.position = new BABYLON.Vector3(sign * 0.15 * scale, -0.4 * scale, 0);
                arm.parent = shoulder;
                arm.material = metalMat;

                // Weapon pod at end of arm (required for firing)
                const weaponPod = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'WeaponPod', {
                    width: 0.12 * scale, height: 0.2 * scale, depth: 0.15 * scale
                }, scene);
                weaponPod.position = new BABYLON.Vector3(0, -0.45 * scale, 0);
                weaponPod.parent = arm;
                weaponPod.material = darkMat;

                return { shoulder, arm, weaponPod };
            }

            const leftArm = createArm('left');
            const rightArm = createArm('right');

            // Simple missile pod on shoulder
            const leftPod = BABYLON.MeshBuilder.CreateBox(name + '_leftPod', {
                width: 0.2 * scale, height: 0.15 * scale, depth: 0.3 * scale
            }, scene);
            leftPod.position = new BABYLON.Vector3(-0.5 * scale, 0.85 * scale, 0.1 * scale);
            leftPod.parent = torsoCore;
            leftPod.material = darkMat;

            const rightPod = BABYLON.MeshBuilder.CreateBox(name + '_rightPod', {
                width: 0.2 * scale, height: 0.15 * scale, depth: 0.3 * scale
            }, scene);
            rightPod.position = new BABYLON.Vector3(0.5 * scale, 0.85 * scale, 0.1 * scale);
            rightPod.parent = torsoCore;
            rightPod.material = darkMat;

            // Legs - using shared digitigrade system
            const legMaterials = { primaryMat, secondaryMat, darkMat, metalMat };
            const leftLeg = createDigitigradeLeg({
                scene, name, side: 'left', parent: pelvis, scale,
                bulk: 0.9,  // Slightly slimmer for light mech
                hipOffset: { x: 0.55, y: -0.18, z: 0 },
                materials: legMaterials
            });
            const rightLeg = createDigitigradeLeg({
                scene, name, side: 'right', parent: pelvis, scale,
                bulk: 0.9,
                hipOffset: { x: 0.55, y: -0.18, z: 0 },
                materials: legMaterials
            });

            return {
                name: 'COMMANDO',
                pelvis, pelvisAggregate: pelvisAgg,
                torso: torsoCore, head: headBase, cockpit: canopy,
                leftArm, rightArm, leftLeg, rightLeg,
                leftPod, rightPod,
                isPlayer, scale,
                standingHeight: 1.9,    // Pelvis Y for feet to touch ground
                optimalRange: 8,        // Light mech prefers closer range, fast hit and run
                stats: { maxHP: 80, mass: 40 },
                currentHP: 80, maxHP: 80,
                isWalking: false, walkCycle: 0, walkSpeed: 3.5,
                walkDirection: isPlayer ? 1 : -1,
                impactRecovery: 0, impactDirection: new BABYLON.Vector3(0,0,0),
                staggerTime: 0, recoilRecovery: 0, lastFiredArm: 'right',
                torsoTwist: 0, targetTorsoTwist: 0,
                // HYBRID STATE MACHINE properties
                mechState: MechState.WALKING,
                stability: STABILITY_CONFIG.maxStability,
                ragdollSettleTimer: 0,
                recoveryTimer: 0,
                destroyedTimer: 0,
                lastKinematicVelocity: new BABYLON.Vector3(0, 0, 0),
                flinchIntensity: 0,
                ai: {
                    enabled: false,
                    state: 'idle',
                    target: null,
                    lastDecision: 0,
                    strafeDir: 0,
                    strafeEndTime: 0
                }
            };
        }

        // ============================================
        // CATAPULT - Medium Support Mech
        // ============================================
        function createCatapultMech(scene, xPos, zPos, isPlayer) {
            const name = (isPlayer ? 'player' : 'enemy') + '_catapult_' + Math.random().toString(36).substr(2, 4);
            const primary = isPlayer ? COLORS.playerPrimary : COLORS.enemyPrimary;
            const secondary = isPlayer ? COLORS.playerSecondary : COLORS.enemySecondary;
            const scale = 0.85;

            // Materials with textures
            const primaryMat = new BABYLON.StandardMaterial(name + '_primary', scene);
            primaryMat.diffuseTexture = TEXTURES.rustMetal.clone();
            primaryMat.diffuseTexture.uScale = 2.5;
            primaryMat.diffuseTexture.vScale = 2.5;
            primaryMat.diffuseColor = primary.scale(1.3);
            primaryMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            primaryMat.bumpTexture.uScale = 2.5;
            primaryMat.bumpTexture.vScale = 2.5;
            primaryMat.bumpTexture.level = 0.55;
            primaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            primaryMat.specularPower = 32;

            const secondaryMat = new BABYLON.StandardMaterial(name + '_secondary', scene);
            secondaryMat.diffuseTexture = TEXTURES.metal.clone();
            secondaryMat.diffuseTexture.uScale = 2;
            secondaryMat.diffuseTexture.vScale = 2;
            secondaryMat.diffuseColor = secondary.scale(1.2);
            secondaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);

            const darkMat = new BABYLON.StandardMaterial(name + '_dark', scene);
            darkMat.diffuseColor = COLORS.darkMetal;
            darkMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            const metalMat = new BABYLON.StandardMaterial(name + '_metal', scene);
            metalMat.diffuseTexture = TEXTURES.rustMetal.clone();
            metalMat.diffuseTexture.uScale = 3;
            metalMat.diffuseTexture.vScale = 3;
            metalMat.diffuseColor = COLORS.metal.scale(1.2);
            metalMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            metalMat.bumpTexture.uScale = 3;
            metalMat.bumpTexture.vScale = 3;
            metalMat.bumpTexture.level = 0.45;
            metalMat.specularColor = new BABYLON.Color3(0.45, 0.45, 0.45);
            metalMat.specularPower = 56;

            // Pelvis
            const pelvis = BABYLON.MeshBuilder.CreateBox(name + '_pelvis', {
                width: 1.5 * scale, height: 0.45 * scale, depth: 0.8 * scale
            }, scene);
            pelvis.position = new BABYLON.Vector3(xPos, 3.2, zPos);
            pelvis.material = darkMat;

            const pelvisShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -1.3, 0),
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(1.5 * scale, 3.0, 0.8 * scale),
                scene
            );
            // HYBRID ARCHITECTURE: Start in ANIMATED (kinematic) mode for perfect walking control
            const pelvisBody = new BABYLON.PhysicsBody(pelvis, BABYLON.PhysicsMotionType.ANIMATED, false, scene);
            pelvisBody.shape = pelvisShape;
            pelvisBody.setMassProperties({ mass: 60 });
            pelvisBody.setAngularDamping(STABILITY_CONFIG.mechAngularDamping);
            pelvisBody.setLinearDamping(STABILITY_CONFIG.mechLinearDamping);
            pelvisShape.material = { friction: 0.3, restitution: 0.05 };
            const pelvisAgg = { body: pelvisBody, shape: pelvisShape };

            // Torso - boxy with rounded top
            const torsoCore = BABYLON.MeshBuilder.CreateBox(name + '_torso', {
                width: 1.3 * scale, height: 1.0 * scale, depth: 0.9 * scale
            }, scene);
            torsoCore.position.y = 0.7 * scale;
            torsoCore.parent = pelvis;
            torsoCore.material = primaryMat;

            // Head - sensor array
            const headBase = BABYLON.MeshBuilder.CreateBox(name + '_head', {
                width: 0.5 * scale, height: 0.35 * scale, depth: 0.4 * scale
            }, scene);
            headBase.position.y = 0.7 * scale;
            headBase.parent = torsoCore;
            headBase.material = secondaryMat;

            const canopy = BABYLON.MeshBuilder.CreateBox(name + '_canopy', {
                width: 0.35 * scale, height: 0.2 * scale, depth: 0.25 * scale
            }, scene);
            canopy.position = new BABYLON.Vector3(0, 0.1 * scale, 0.1 * scale);
            canopy.parent = headBase;
            canopy.material = new BABYLON.StandardMaterial(name + '_cockpit', scene);
            canopy.material.diffuseColor = COLORS.cockpit;
            canopy.material.emissiveColor = COLORS.cockpit.scale(0.5);
            canopy.material.alpha = 0.8;

            // Large missile pods on shoulders (Catapult's signature)
            const leftPod = BABYLON.MeshBuilder.CreateCylinder(name + '_leftPod', {
                diameter: 0.5 * scale, height: 0.9 * scale
            }, scene);
            leftPod.rotation.x = Math.PI / 2;
            leftPod.position = new BABYLON.Vector3(-0.85 * scale, 0.6 * scale, 0.2 * scale);
            leftPod.parent = torsoCore;
            leftPod.material = secondaryMat;

            const rightPod = BABYLON.MeshBuilder.CreateCylinder(name + '_rightPod', {
                diameter: 0.5 * scale, height: 0.9 * scale
            }, scene);
            rightPod.rotation.x = Math.PI / 2;
            rightPod.position = new BABYLON.Vector3(0.85 * scale, 0.6 * scale, 0.2 * scale);
            rightPod.parent = torsoCore;
            rightPod.material = secondaryMat;

            // Arms - smaller, laser focused
            function createArm(side) {
                const sign = side === 'left' ? -1 : 1;
                const shoulder = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Shoulder', {
                    diameter: 0.3 * scale
                }, scene);
                shoulder.position = new BABYLON.Vector3(sign * 0.6 * scale, 0.2 * scale, 0);
                shoulder.parent = torsoCore;
                shoulder.material = metalMat;

                const arm = BABYLON.MeshBuilder.CreateCylinder(name + '_' + side + 'Arm', {
                    diameter: 0.15 * scale, height: 0.7 * scale
                }, scene);
                arm.rotation.z = sign * 0.3;
                arm.position = new BABYLON.Vector3(sign * 0.2 * scale, -0.35 * scale, 0);
                arm.parent = shoulder;
                arm.material = primaryMat;

                // Weapon pod at end of arm (required for firing)
                const weaponPod = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'WeaponPod', {
                    width: 0.12 * scale, height: 0.18 * scale, depth: 0.14 * scale
                }, scene);
                weaponPod.position = new BABYLON.Vector3(0, -0.4 * scale, 0);
                weaponPod.parent = arm;
                weaponPod.material = darkMat;

                return { shoulder, arm, weaponPod };
            }

            const leftArm = createArm('left');
            const rightArm = createArm('right');

            // Legs - using shared digitigrade system
            const legMaterials = { primaryMat, secondaryMat, darkMat, metalMat };
            const leftLeg = createDigitigradeLeg({
                scene, name, side: 'left', parent: pelvis, scale,
                bulk: 1.0,  // Standard bulk for medium mech
                hipOffset: { x: 0.65, y: -0.22, z: 0 },
                materials: legMaterials
            });
            const rightLeg = createDigitigradeLeg({
                scene, name, side: 'right', parent: pelvis, scale,
                bulk: 1.0,
                hipOffset: { x: 0.65, y: -0.22, z: 0 },
                materials: legMaterials
            });

            return {
                name: 'CATAPULT',
                pelvis, pelvisAggregate: pelvisAgg,
                torso: torsoCore, head: headBase, cockpit: canopy,
                leftArm, rightArm, leftLeg, rightLeg,
                leftPod, rightPod,
                isPlayer, scale,
                standingHeight: 2.1,    // Pelvis Y for feet to touch ground
                optimalRange: 14,       // Missile boat prefers long range
                stats: { maxHP: 120, mass: 60 },
                currentHP: 120, maxHP: 120,
                isWalking: false, walkCycle: 0, walkSpeed: 2.5,
                walkDirection: isPlayer ? 1 : -1,
                impactRecovery: 0, impactDirection: new BABYLON.Vector3(0,0,0),
                staggerTime: 0, recoilRecovery: 0, lastFiredArm: 'right',
                torsoTwist: 0, targetTorsoTwist: 0,
                // HYBRID STATE MACHINE properties
                mechState: MechState.WALKING,
                stability: STABILITY_CONFIG.maxStability,
                ragdollSettleTimer: 0,
                recoveryTimer: 0,
                destroyedTimer: 0,
                lastKinematicVelocity: new BABYLON.Vector3(0, 0, 0),
                flinchIntensity: 0,
                ai: {
                    enabled: false,
                    state: 'idle',
                    target: null,
                    lastDecision: 0,
                    strafeDir: 0,
                    strafeEndTime: 0
                }
            };
        }

        // ============================================
        // HATCHETMAN - Melee specialist mech
        // ============================================
        function createHatchetmanMech(scene, xPos, zPos, isPlayer) {
            const name = (isPlayer ? 'player' : 'enemy') + '_hatchetman_' + Math.random().toString(36).substr(2, 4);
            const primary = isPlayer ? COLORS.playerPrimary : COLORS.enemyPrimary;
            const secondary = isPlayer ? COLORS.playerSecondary : COLORS.enemySecondary;
            const scale = 0.8;  // Medium mech

            // Materials with textures
            const primaryMat = new BABYLON.StandardMaterial(name + '_primary', scene);
            primaryMat.diffuseTexture = TEXTURES.rustMetal.clone();
            primaryMat.diffuseTexture.uScale = 2.5;
            primaryMat.diffuseTexture.vScale = 2.5;
            primaryMat.diffuseColor = primary.scale(1.3);
            primaryMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            primaryMat.bumpTexture.uScale = 2.5;
            primaryMat.bumpTexture.vScale = 2.5;
            primaryMat.bumpTexture.level = 0.6;
            primaryMat.specularColor = new BABYLON.Color3(0.25, 0.25, 0.25);
            primaryMat.specularPower = 32;

            const secondaryMat = new BABYLON.StandardMaterial(name + '_secondary', scene);
            secondaryMat.diffuseTexture = TEXTURES.metal.clone();
            secondaryMat.diffuseTexture.uScale = 2;
            secondaryMat.diffuseTexture.vScale = 2;
            secondaryMat.diffuseColor = secondary.scale(1.2);
            secondaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);

            const darkMat = new BABYLON.StandardMaterial(name + '_dark', scene);
            darkMat.diffuseColor = COLORS.darkMetal;
            darkMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            const metalMat = new BABYLON.StandardMaterial(name + '_metal', scene);
            metalMat.diffuseTexture = TEXTURES.rustMetal.clone();
            metalMat.diffuseTexture.uScale = 3;
            metalMat.diffuseTexture.vScale = 3;
            metalMat.diffuseColor = COLORS.metal.scale(1.2);
            metalMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            metalMat.bumpTexture.uScale = 3;
            metalMat.bumpTexture.vScale = 3;
            metalMat.bumpTexture.level = 0.5;
            metalMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
            metalMat.specularPower = 48;

            // Hatchet blade material - bright and shiny
            const bladeMat = new BABYLON.StandardMaterial(name + '_blade', scene);
            bladeMat.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.75);
            bladeMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.9);
            bladeMat.specularPower = 128;
            bladeMat.emissiveColor = new BABYLON.Color3(0.1, 0.05, 0.0);

            // Pelvis - sturdy build
            const pelvis = BABYLON.MeshBuilder.CreateBox(name + '_pelvis', {
                width: 1.4 * scale, height: 0.5 * scale, depth: 0.85 * scale
            }, scene);
            pelvis.position = new BABYLON.Vector3(xPos, 3.0, zPos);
            pelvis.material = darkMat;

            const pelvisShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -1.2, 0),
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(1.4 * scale, 2.9, 0.85 * scale),
                scene
            );
            // HYBRID ARCHITECTURE: Start in ANIMATED (kinematic) mode for perfect walking control
            const pelvisBody = new BABYLON.PhysicsBody(pelvis, BABYLON.PhysicsMotionType.ANIMATED, false, scene);
            pelvisBody.shape = pelvisShape;
            pelvisBody.setMassProperties({ mass: 50 });
            pelvisBody.setAngularDamping(STABILITY_CONFIG.mechAngularDamping);
            pelvisBody.setLinearDamping(STABILITY_CONFIG.mechLinearDamping);
            pelvisShape.material = { friction: 0.3, restitution: 0.05 };
            const pelvisAgg = { body: pelvisBody, shape: pelvisShape };

            // Torso - hunched forward, aggressive stance
            const torsoCore = BABYLON.MeshBuilder.CreateBox(name + '_torso', {
                width: 1.2 * scale, height: 1.1 * scale, depth: 0.9 * scale
            }, scene);
            torsoCore.position.y = 0.75 * scale;
            torsoCore.rotation.x = 0.15;  // Slight forward lean
            torsoCore.parent = pelvis;
            torsoCore.material = primaryMat;

            // Head - angular, aggressive
            const headBase = BABYLON.MeshBuilder.CreateBox(name + '_head', {
                width: 0.45 * scale, height: 0.4 * scale, depth: 0.5 * scale
            }, scene);
            headBase.position = new BABYLON.Vector3(0, 0.75 * scale, 0.1 * scale);
            headBase.parent = torsoCore;
            headBase.material = secondaryMat;

            const canopy = BABYLON.MeshBuilder.CreateBox(name + '_canopy', {
                width: 0.3 * scale, height: 0.2 * scale, depth: 0.25 * scale
            }, scene);
            canopy.position = new BABYLON.Vector3(0, 0.1 * scale, 0.15 * scale);
            canopy.parent = headBase;
            canopy.material = new BABYLON.StandardMaterial(name + '_cockpit', scene);
            canopy.material.diffuseColor = COLORS.cockpit;
            canopy.material.emissiveColor = COLORS.cockpit.scale(0.5);
            canopy.material.alpha = 0.8;

            // Right arm - normal weapon arm with laser
            function createWeaponArm() {
                const shoulder = BABYLON.MeshBuilder.CreateSphere(name + '_rightShoulder', {
                    diameter: 0.35 * scale
                }, scene);
                shoulder.position = new BABYLON.Vector3(0.65 * scale, 0.35 * scale, 0);
                shoulder.parent = torsoCore;
                shoulder.material = metalMat;

                const arm = BABYLON.MeshBuilder.CreateCylinder(name + '_rightArm', {
                    diameter: 0.2 * scale, height: 0.75 * scale
                }, scene);
                arm.rotation.z = 0.25;
                arm.position = new BABYLON.Vector3(0.15 * scale, -0.4 * scale, 0);
                arm.parent = shoulder;
                arm.material = primaryMat;

                const weaponPod = BABYLON.MeshBuilder.CreateBox(name + '_rightWeaponPod', {
                    width: 0.15 * scale, height: 0.2 * scale, depth: 0.18 * scale
                }, scene);
                weaponPod.position = new BABYLON.Vector3(0, -0.45 * scale, 0);
                weaponPod.parent = arm;
                weaponPod.material = darkMat;

                return { shoulder, arm, weaponPod };
            }

            // Left arm - THE HATCHET ARM
            function createHatchetArm() {
                const shoulder = BABYLON.MeshBuilder.CreateSphere(name + '_leftShoulder', {
                    diameter: 0.4 * scale
                }, scene);
                shoulder.position = new BABYLON.Vector3(-0.65 * scale, 0.35 * scale, 0);
                shoulder.parent = torsoCore;
                shoulder.material = metalMat;

                // Beefier arm for the hatchet
                const arm = BABYLON.MeshBuilder.CreateCylinder(name + '_leftArm', {
                    diameterTop: 0.25 * scale, diameterBottom: 0.2 * scale, height: 0.8 * scale
                }, scene);
                arm.rotation.z = -0.3;
                arm.position = new BABYLON.Vector3(-0.18 * scale, -0.42 * scale, 0);
                arm.parent = shoulder;
                arm.material = primaryMat;

                // Hatchet handle
                const handle = BABYLON.MeshBuilder.CreateCylinder(name + '_hatchetHandle', {
                    diameter: 0.08 * scale, height: 0.6 * scale
                }, scene);
                handle.position = new BABYLON.Vector3(0, -0.55 * scale, 0);
                handle.parent = arm;
                handle.material = darkMat;

                // Hatchet head - large axe blade
                const bladeMain = BABYLON.MeshBuilder.CreateBox(name + '_hatchetBlade', {
                    width: 0.08 * scale, height: 0.5 * scale, depth: 0.35 * scale
                }, scene);
                bladeMain.position = new BABYLON.Vector3(0, -0.25 * scale, 0.2 * scale);
                bladeMain.parent = handle;
                bladeMain.material = bladeMat;

                // Blade edge (tapered)
                const bladeEdge = BABYLON.MeshBuilder.CreateBox(name + '_bladeEdge', {
                    width: 0.04 * scale, height: 0.45 * scale, depth: 0.1 * scale
                }, scene);
                bladeEdge.position = new BABYLON.Vector3(0, 0, 0.2 * scale);
                bladeEdge.parent = bladeMain;
                bladeEdge.material = bladeMat;

                // WeaponPod at hatchet for melee hit detection
                const weaponPod = BABYLON.MeshBuilder.CreateBox(name + '_leftWeaponPod', {
                    width: 0.1 * scale, height: 0.1 * scale, depth: 0.1 * scale
                }, scene);
                weaponPod.position = new BABYLON.Vector3(0, -0.35 * scale, 0.25 * scale);
                weaponPod.parent = handle;
                weaponPod.material = darkMat;
                weaponPod.visibility = 0;  // Invisible, just for hit detection

                return { shoulder, arm, handle, bladeMain, weaponPod };
            }

            const rightArm = createWeaponArm();
            const leftArm = createHatchetArm();

            // Small shoulder pods for backup weapons
            const leftPod = BABYLON.MeshBuilder.CreateBox(name + '_leftPod', {
                width: 0.2 * scale, height: 0.15 * scale, depth: 0.25 * scale
            }, scene);
            leftPod.position = new BABYLON.Vector3(-0.55 * scale, 0.8 * scale, 0.1 * scale);
            leftPod.parent = torsoCore;
            leftPod.material = darkMat;

            const rightPod = BABYLON.MeshBuilder.CreateBox(name + '_rightPod', {
                width: 0.2 * scale, height: 0.15 * scale, depth: 0.25 * scale
            }, scene);
            rightPod.position = new BABYLON.Vector3(0.55 * scale, 0.8 * scale, 0.1 * scale);
            rightPod.parent = torsoCore;
            rightPod.material = darkMat;

            // Legs - using shared digitigrade system (fast melee mech)
            const legMaterials = { primaryMat, secondaryMat, darkMat, metalMat };
            const leftLeg = createDigitigradeLeg({
                scene, name, side: 'left', parent: pelvis, scale,
                bulk: 0.95,  // Slightly lean for speed
                hipOffset: { x: 0.6, y: -0.2, z: 0 },
                materials: legMaterials
            });
            const rightLeg = createDigitigradeLeg({
                scene, name, side: 'right', parent: pelvis, scale,
                bulk: 0.95,
                hipOffset: { x: 0.6, y: -0.2, z: 0 },
                materials: legMaterials
            });

            return {
                name: 'HATCHETMAN',
                pelvis, pelvisAggregate: pelvisAgg,
                torso: torsoCore, head: headBase, cockpit: canopy,
                leftArm, rightArm, leftLeg, rightLeg,
                leftPod, rightPod,
                isPlayer, scale,
                standingHeight: 1.95,   // Pelvis Y for feet to touch ground
                optimalRange: 3,        // Melee mech wants to be in your face
                stats: { maxHP: 90, mass: 50 },
                currentHP: 90, maxHP: 90,
                isWalking: false, walkCycle: 0, walkSpeed: 3.2,  // Faster than average
                walkDirection: isPlayer ? 1 : -1,
                impactRecovery: 0, impactDirection: new BABYLON.Vector3(0,0,0),
                staggerTime: 0, recoilRecovery: 0, lastFiredArm: 'right',
                torsoTwist: 0, targetTorsoTwist: 0,
                isMelee: true,  // Flag for melee AI behavior
                // HYBRID STATE MACHINE properties
                mechState: MechState.WALKING,
                stability: STABILITY_CONFIG.maxStability,
                ragdollSettleTimer: 0,
                recoveryTimer: 0,
                destroyedTimer: 0,
                lastKinematicVelocity: new BABYLON.Vector3(0, 0, 0),
                flinchIntensity: 0,
                ai: {
                    enabled: false,
                    state: 'idle',
                    target: null,
                    lastDecision: 0,
                    strafeDir: 0,
                    strafeEndTime: 0
                }
            };
        }

        // ============================================
        // ANIMATION & PHYSICS
        // ============================================
        // Handle mech-to-mech collisions - push apart based on mass
        // HYBRID ARCHITECTURE: For kinematic mechs, directly adjust positions
        function updateMechCollisions() {
            const minDist = 2.5;  // Minimum distance between mech centers
            for (let i = 0; i < allMechs.length; i++) {
                const mechA = allMechs[i];
                if (!mechA || mechA.isDestroyed) continue;

                for (let j = i + 1; j < allMechs.length; j++) {
                    const mechB = allMechs[j];
                    if (!mechB || mechB.isDestroyed) continue;

                    const posA = mechA.pelvis.getAbsolutePosition();
                    const posB = mechB.pelvis.getAbsolutePosition();

                    const diff = posB.subtract(posA);
                    diff.y = 0;  // Only consider horizontal distance
                    const dist = diff.length();

                    if (dist < minDist && dist > 0.01) {
                        // Mechs are overlapping - push them apart
                        const pushDir = diff.normalize();
                        const overlap = minDist - dist;

                        // Calculate push ratio based on mass (lighter mech moves more)
                        const massA = mechA.stats.mass || 75;
                        const massB = mechB.stats.mass || 75;
                        const totalMass = massA + massB;
                        const ratioA = massB / totalMass;
                        const ratioB = massA / totalMass;

                        // HYBRID: Handle differently based on mech states
                        // Kinematic mechs get position adjustments, dynamic get impulses
                        if (mechA.mechState === MechState.WALKING) {
                            // Directly adjust position for kinematic mech
                            const pushA = pushDir.scale(-overlap * ratioA * 0.5);
                            mechA.pelvis.position.addInPlace(pushA);
                        } else if (mechA.mechState === MechState.RAGDOLL) {
                            // Apply impulse for dynamic mech
                            const impulseA = pushDir.scale(-overlap * 15 * ratioA);
                            mechA.pelvisAggregate.body.applyImpulse(impulseA, posA);
                        }

                        if (mechB.mechState === MechState.WALKING) {
                            const pushB = pushDir.scale(overlap * ratioB * 0.5);
                            mechB.pelvis.position.addInPlace(pushB);
                        } else if (mechB.mechState === MechState.RAGDOLL) {
                            const impulseB = pushDir.scale(overlap * 15 * ratioB);
                            mechB.pelvisAggregate.body.applyImpulse(impulseB, posB);
                        }
                    }
                }
            }
        }

        function updateMechs(dt) {
            updateMechCollisions();  // Handle mech-to-mech collisions first
            allMechs.forEach(mech => {
                if (!mech || mech.isDestroyed) return;

                // HYBRID STATE MACHINE - Route to appropriate update based on state
                switch (mech.mechState) {
                    case MechState.WALKING:
                        // Perfect kinematic control - no physics fighting us
                        updateAI(mech, dt);
                        updateWalkingKinematic(mech, dt);
                        updateFlinch(mech, dt);
                        updateRecoil(mech, dt);
                        updateTorsoTrack(mech, dt);
                        recoverStability(mech, dt);
                        break;

                    case MechState.RAGDOLL:
                        // Physics takes over - just check if we've settled
                        updateRagdoll(mech, dt);
                        break;

                    case MechState.RECOVERING:
                        // Blending from ragdoll back to standing
                        updateRecovery(mech, dt);
                        break;
                }
            });
        }

        // ============================================
        // PHASE 1: KINEMATIC WALKING (ANIMATED Mode)
        // Perfect control - mech is an unstoppable force
        // ============================================
        function updateWalkingKinematic(mech, dt) {
            const body = mech.pelvisAggregate.body;
            const myPos = mech.pelvis.getAbsolutePosition();

            // Handle body rotation toward target (from AI)
            const yawError = mech.ai.desiredYawError || 0;
            const maxRotationSpeed = 2.0;  // rad/s - mechs turn deliberately
            const rotationThreshold = 0.05;  // ~3 degrees
            let yawVelocity = 0;

            if (Math.abs(yawError) > rotationThreshold) {
                // Rate-limited rotation
                yawVelocity = Math.sign(yawError) * Math.min(Math.abs(yawError) * 3, maxRotationSpeed);
            }

            // === SMOOTH STRAFE RAMPING ===
            // Gradually transition strafe amount instead of snapping
            if (!mech.currentStrafeAmount) mech.currentStrafeAmount = 0;
            const targetStrafe = mech.ai.strafeAmount || 0;
            const strafeRampSpeed = 2.0;  // How fast strafe ramps up/down
            if (Math.abs(targetStrafe - mech.currentStrafeAmount) > 0.01) {
                mech.currentStrafeAmount += Math.sign(targetStrafe - mech.currentStrafeAmount) * strafeRampSpeed * dt;
                // Clamp to target
                if ((targetStrafe > 0 && mech.currentStrafeAmount > targetStrafe) ||
                    (targetStrafe < 0 && mech.currentStrafeAmount < targetStrafe) ||
                    (targetStrafe === 0 && Math.abs(mech.currentStrafeAmount) < 0.05)) {
                    mech.currentStrafeAmount = targetStrafe;
                }
            }

            if (!mech.isWalking) {
                // When not walking, stay in place but still rotate toward target
                // Still need ground-seeking even when stationary
                const targetY = mech.standingHeight || 3.0;
                const heightError = targetY - myPos.y;
                const groundSeekSpeed = 8.0;
                body.setLinearVelocity(new BABYLON.Vector3(0, heightError * groundSeekSpeed, 0));
                body.setAngularVelocity(new BABYLON.Vector3(0, yawVelocity, 0));
                dampLegs(mech, dt);
                mech.lastKinematicVelocity.setAll(0);
                return;
            }

            // Walk cycle speed tied to movement - heavier mechs have slower cycles
            mech.walkCycle += dt * mech.walkSpeed * 1.6;
            const cycle = mech.walkCycle;

            const leftPhase = Math.sin(cycle);
            const rightPhase = Math.sin(cycle + Math.PI);

            animateLeg(mech.leftLeg, leftPhase, mech.scale);
            animateLeg(mech.rightLeg, rightPhase, mech.scale);

            // Body bob - pronounced dip on each footfall for grounded feel
            const bobPhase = Math.abs(Math.sin(cycle));
            const bob = (1 - bobPhase) * 0.06 * mech.scale;  // Increased bob

            // Hip sway for weight transfer - side to side with each step
            const hipSway = Math.sin(cycle) * 0.02;

            // Get pelvis facing direction
            const quat = body.transformNode.rotationQuaternion;
            let forwardDir = new BABYLON.Vector3(1, 0, 0);
            let rightDir = new BABYLON.Vector3(0, 0, 1);
            if (quat) {
                const rotMatrix = new BABYLON.Matrix();
                quat.toRotationMatrix(rotMatrix);
                forwardDir = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(1, 0, 0), rotMatrix);
                forwardDir.y = 0;
                forwardDir.normalize();
                rightDir = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(0, 0, 1), rotMatrix);
                rightDir.y = 0;
                rightDir.normalize();
            }

            // KINEMATIC MODE: Set velocity directly instead of applying forces
            // Slightly reduced speed for heavier, more grounded feel
            const walkSpeed = 3.0 * mech.scale;  // Units per second
            const strafeSpeed = 1.8 * mech.scale;  // Strafe is slower than walking

            // Calculate velocity from walk direction and strafe (using smoothed strafe)
            let velocity = forwardDir.scale(mech.walkDirection * walkSpeed);
            velocity.addInPlace(rightDir.scale(mech.currentStrafeAmount * strafeSpeed));

            // === GROUND-SEEKING FOR KINEMATIC MODE ===
            // In ANIMATED mode, gravity doesn't apply, so we need to manually seek ground level
            const targetY = mech.standingHeight || 3.0;  // Fallback if not defined
            const heightError = targetY - myPos.y;
            const groundSeekSpeed = 8.0;  // How fast we correct height
            // Apply ground-seeking with bob effect on top
            velocity.y = heightError * groundSeekSpeed - bob * 2;

            // === HARD BOUNDARY CLAMPING ===
            // If we're at or past the boundary, zero velocity in that direction
            const boundaryMargin = 0.5;
            if (myPos.x <= ARENA_BOUNDS.minX + boundaryMargin) {
                // At left edge - only allow movement toward center (positive X)
                if (velocity.x < 0) velocity.x = 0;
            } else if (myPos.x >= ARENA_BOUNDS.maxX - boundaryMargin) {
                // At right edge - only allow movement toward center (negative X)
                if (velocity.x > 0) velocity.x = 0;
            }
            if (myPos.z <= ARENA_BOUNDS.minZ + boundaryMargin) {
                // At back edge - only allow movement toward center (positive Z)
                if (velocity.z < 0) velocity.z = 0;
            } else if (myPos.z >= ARENA_BOUNDS.maxZ - boundaryMargin) {
                // At front edge - only allow movement toward center (negative Z)
                if (velocity.z > 0) velocity.z = 0;
            }

            // Store velocity for ragdoll inheritance
            mech.lastKinematicVelocity = velocity.clone();

            // Set the kinematic body velocity
            body.setLinearVelocity(velocity);

            // Apply body rotation - combines target tracking with visual motion
            // Rock = forward/back tilt, sway = side-to-side tilt, hipSway = rolling motion
            const sway = Math.sin(cycle) * 0.02;  // Side-to-side lean with each step
            const rock = Math.sin(cycle * 2) * 0.01;  // Subtle double-frequency rock

            // In ANIMATED mode, set angular velocity for rotation + visual feel
            // Add hipSway for rolling weight transfer motion
            body.setAngularVelocity(new BABYLON.Vector3(rock + hipSway, yawVelocity, sway));
        }

        function animateLeg(leg, phase, scale) {
            // Lightning bolt digitigrade animation - matched to new geometry
            // Base rotations: upperLeg = 0.5, lowerLeg = -0.4

            // Upper leg swings forward/back from hip - more pronounced for grounded feel
            const swing = phase * 0.35;  // Increased swing for visible stepping
            leg.upperLeg.rotation.x = 0.5 + swing;

            // Lower leg bends more during lift phase (phase > 0 = leg lifting)
            const liftPhase = Math.max(0, phase);
            const plantPhase = Math.max(0, -phase);

            // Knee bends more during lift, straightens during plant - exaggerated
            const kneeBend = liftPhase * 0.5;  // More pronounced bend when lifting
            leg.lowerLeg.rotation.x = -0.4 - kneeBend + plantPhase * 0.15;

            // Foot tilts up during lift, plants flat during ground contact
            const footLift = liftPhase * 0.4;  // Toe points up more when lifting
            const footPlant = plantPhase * 0.2;  // More tilt when planting
            leg.foot.rotation.x = 0.1 - footLift + footPlant;
        }

        function dampLegs(mech, dt) {
            const d = 3 * dt;
            [mech.leftLeg, mech.rightLeg].forEach(leg => {
                // Return to lightning bolt digitigrade stance (matches new geometry)
                leg.upperLeg.rotation.x = BABYLON.Scalar.Lerp(leg.upperLeg.rotation.x, 0.5, d);
                leg.lowerLeg.rotation.x = BABYLON.Scalar.Lerp(leg.lowerLeg.rotation.x, -0.4, d);
                leg.foot.rotation.x = BABYLON.Scalar.Lerp(leg.foot.rotation.x, 0.1, d);
            });
        }

        // ============================================
        // PHASE 2: FLINCH SYSTEM (Additive Animation)
        // Small hits - mech keeps walking but jerks visually
        // ============================================
        function updateFlinch(mech, dt) {
            // Decay flinch intensity
            if (mech.flinchIntensity > 0) {
                mech.flinchIntensity -= dt * 3.0;  // Quick recovery
                if (mech.flinchIntensity < 0) mech.flinchIntensity = 0;

                // Apply additive animation to torso
                const tilt = mech.flinchIntensity * 0.35;
                mech.torso.rotation.x = mech.impactDirection.z * tilt;
                mech.torso.rotation.z = -mech.impactDirection.x * tilt;
            } else {
                // Return torso to neutral
                mech.torso.rotation.x = BABYLON.Scalar.Lerp(mech.torso.rotation.x, 0, dt * 5);
                mech.torso.rotation.z = BABYLON.Scalar.Lerp(mech.torso.rotation.z, 0, dt * 5);
            }

            // Handle stagger (brief pause in walking)
            if (mech.staggerTime > 0) {
                mech.staggerTime -= dt;
                mech.isWalking = false;
            }
        }

        // Stability recovery - regenerate stability over time
        function recoverStability(mech, dt) {
            if (mech.stability < STABILITY_CONFIG.maxStability) {
                mech.stability += STABILITY_CONFIG.stabilityRecoveryRate * dt;
                if (mech.stability > STABILITY_CONFIG.maxStability) {
                    mech.stability = STABILITY_CONFIG.maxStability;
                }
            }
        }

        // ============================================
        // PHASE 3: RAGDOLL MODE (Dynamic Physics)
        // Heavy hits - physics takes over completely
        // ============================================
        function triggerRagdoll(mech, hitForce) {
            if (mech.mechState === MechState.RAGDOLL) return;  // Already ragdolling

            dbg(`${mech.isPlayer ? 'P' : 'E'} ${mech.name}: RAGDOLL triggered!`, 'warn');

            mech.mechState = MechState.RAGDOLL;
            mech.ragdollSettleTimer = 0;
            mech.isWalking = false;

            const body = mech.pelvisAggregate.body;
            const pos = mech.pelvis.getAbsolutePosition();

            // 1. Switch from ANIMATED to DYNAMIC - physics now controls us
            body.setMotionType(BABYLON.PhysicsMotionType.DYNAMIC);

            // 2. Set proper mass and reduce damping for ragdoll physics
            body.setMassProperties({ mass: mech.stats.mass || 75 });
            body.setLinearDamping(0.1);
            body.setAngularDamping(0.2);

            // 3. CRITICAL: Inherit velocity from animation to avoid dead-fish effect
            const inheritedVel = mech.lastKinematicVelocity || new BABYLON.Vector3(0, 0, 0);
            body.setLinearVelocity(inheritedVel);

            // 4. Apply knockback force - throw mech backwards from strike
            // Scale force by mass for consistent knockback across mech sizes
            const massScale = 75 / (mech.stats.mass || 75);
            const scaledHitForce = hitForce.scale(massScale * 2.5);

            // Add significant upward component to lift mech off ground
            scaledHitForce.y = Math.max(scaledHitForce.y, hitForce.length() * 0.5);

            body.applyImpulse(scaledHitForce, pos);

            // 5. Strong angular impulse for dramatic spin/tumble
            const hitDir = hitForce.normalizeToNew();
            body.applyAngularImpulse(new BABYLON.Vector3(
                hitDir.z * hitForce.length() * 0.3,  // Pitch based on Z hit direction
                (Math.random() - 0.5) * hitForce.length() * 0.1,  // Random yaw spin
                -hitDir.x * hitForce.length() * 0.3  // Roll based on X hit direction
            ));

            // 6. DRAMATIC LIMB FLINGING - arms and legs fly outward on impact
            flingLimbs(mech, hitForce);

            // 7. Shake camera - mechs are HEAVY
            const shakeIntensity = Math.min(1.0, hitForce.length() / 50);
            triggerCameraShake(shakeIntensity, 0.5 + shakeIntensity * 0.3);

            // 8. Spawn impact sparks
            createImpactSparks(pos, hitDir);
        }

        // Dramatic limb animation when ragdolling
        function flingLimbs(mech, hitForce) {
            const hitDir = hitForce.normalizeToNew();
            const intensity = Math.min(1.5, hitForce.length() / 30);

            // Arms fling outward and back
            if (mech.leftArm && mech.leftArm.rotation) {
                const leftArmFling = () => {
                    let t = 0;
                    const startRot = mech.leftArm.rotation.clone();
                    const flingInterval = setInterval(() => {
                        t += 0.05;
                        if (t >= 1 || mech.mechState !== MechState.RAGDOLL) {
                            clearInterval(flingInterval);
                            return;
                        }
                        // Fling arm outward and back with easing
                        const ease = Math.sin(t * Math.PI);
                        mech.leftArm.rotation.z = startRot.z - intensity * 1.2 * ease;  // Out to side
                        mech.leftArm.rotation.x = startRot.x + intensity * 0.8 * ease;  // Back
                        mech.leftArm.rotation.y = startRot.y + (hitDir.x * 0.5 + 0.3) * ease;  // Twist from impact
                    }, 16);
                };
                leftArmFling();
            }

            if (mech.rightArm && mech.rightArm.rotation) {
                const rightArmFling = () => {
                    let t = 0;
                    const startRot = mech.rightArm.rotation.clone();
                    const flingInterval = setInterval(() => {
                        t += 0.05;
                        if (t >= 1 || mech.mechState !== MechState.RAGDOLL) {
                            clearInterval(flingInterval);
                            return;
                        }
                        const ease = Math.sin(t * Math.PI);
                        mech.rightArm.rotation.z = startRot.z + intensity * 1.2 * ease;  // Out to side (opposite)
                        mech.rightArm.rotation.x = startRot.x + intensity * 0.8 * ease;  // Back
                        mech.rightArm.rotation.y = startRot.y - (hitDir.x * 0.5 + 0.3) * ease;  // Twist from impact
                    }, 16);
                };
                rightArmFling();
            }

            // Legs kick outward on big hits
            if (intensity > 0.8) {
                if (mech.leftLeg && mech.leftLeg.upperLeg) {
                    const leftLegKick = () => {
                        let t = 0;
                        const startRot = mech.leftLeg.upperLeg.rotation.x;
                        const flingInterval = setInterval(() => {
                            t += 0.04;
                            if (t >= 1 || mech.mechState !== MechState.RAGDOLL) {
                                clearInterval(flingInterval);
                                return;
                            }
                            const ease = Math.sin(t * Math.PI);
                            mech.leftLeg.upperLeg.rotation.x = startRot - intensity * 0.6 * ease;
                        }, 16);
                    };
                    leftLegKick();
                }

                if (mech.rightLeg && mech.rightLeg.upperLeg) {
                    const rightLegKick = () => {
                        let t = 0;
                        const startRot = mech.rightLeg.upperLeg.rotation.x;
                        const flingInterval = setInterval(() => {
                            t += 0.04;
                            if (t >= 1 || mech.mechState !== MechState.RAGDOLL) {
                                clearInterval(flingInterval);
                                return;
                            }
                            const ease = Math.sin(t * Math.PI);
                            mech.rightLeg.upperLeg.rotation.x = startRot - intensity * 0.6 * ease;
                        }, 16);
                    };
                    rightLegKick();
                }
            }
        }

        // Extra chaotic limb movement for destruction - more extreme than regular ragdoll
        function destroyedLimbChaos(mech) {
            // Arms flail wildly
            if (mech.leftArm) {
                let t = 0;
                const chaosInterval = setInterval(() => {
                    t += 0.03;
                    if (t >= 2.0 || !mech.leftArm) {
                        clearInterval(chaosInterval);
                        return;
                    }
                    // Wild oscillating movement
                    const chaos = Math.sin(t * 8) * Math.exp(-t * 0.8);
                    mech.leftArm.rotation.z = -1.5 + chaos * 1.0;
                    mech.leftArm.rotation.x = 0.5 + chaos * 0.8;
                }, 16);
            }

            if (mech.rightArm) {
                let t = 0;
                const chaosInterval = setInterval(() => {
                    t += 0.03;
                    if (t >= 2.0 || !mech.rightArm) {
                        clearInterval(chaosInterval);
                        return;
                    }
                    const chaos = Math.sin(t * 8 + 1) * Math.exp(-t * 0.8);
                    mech.rightArm.rotation.z = 1.5 - chaos * 1.0;
                    mech.rightArm.rotation.x = 0.5 + chaos * 0.8;
                }, 16);
            }

            // Legs kick wildly
            if (mech.leftLeg && mech.leftLeg.upperLeg) {
                let t = 0;
                const chaosInterval = setInterval(() => {
                    t += 0.03;
                    if (t >= 2.0 || !mech.leftLeg) {
                        clearInterval(chaosInterval);
                        return;
                    }
                    const chaos = Math.sin(t * 6) * Math.exp(-t * 1.0);
                    mech.leftLeg.upperLeg.rotation.x = 0.5 - chaos * 0.8;
                    if (mech.leftLeg.lowerLeg) {
                        mech.leftLeg.lowerLeg.rotation.x = -0.4 - Math.abs(chaos) * 0.5;
                    }
                }, 16);
            }

            if (mech.rightLeg && mech.rightLeg.upperLeg) {
                let t = 0;
                const chaosInterval = setInterval(() => {
                    t += 0.03;
                    if (t >= 2.0 || !mech.rightLeg) {
                        clearInterval(chaosInterval);
                        return;
                    }
                    const chaos = Math.sin(t * 6 + 2) * Math.exp(-t * 1.0);
                    mech.rightLeg.upperLeg.rotation.x = 0.5 - chaos * 0.8;
                    if (mech.rightLeg.lowerLeg) {
                        mech.rightLeg.lowerLeg.rotation.x = -0.4 - Math.abs(chaos) * 0.5;
                    }
                }, 16);
            }

            // Torso twist
            if (mech.torso) {
                let t = 0;
                const torsoInterval = setInterval(() => {
                    t += 0.03;
                    if (t >= 1.5 || !mech.torso) {
                        clearInterval(torsoInterval);
                        return;
                    }
                    const chaos = Math.sin(t * 10) * Math.exp(-t * 1.5);
                    mech.torso.rotation.y = chaos * 0.4;
                    mech.torso.rotation.x = -Math.abs(chaos) * 0.3;  // Slump forward
                }, 16);
            }
        }

        function updateRagdoll(mech, dt) {
            const body = mech.pelvisAggregate.body;
            const velocity = body.getLinearVelocity();
            const speed = velocity.length();

            // Handle destroyed mechs differently - they don't recover, but need friction
            if (mech.isDestroyed) {
                mech.destroyedTimer += dt;

                // After dramatic phase (1.5s), gradually ramp up friction to stop sliding
                const dramaticPhase = 1.5;
                const frictionRampTime = 2.0;  // Time to ramp from low to high friction

                if (mech.destroyedTimer > dramaticPhase) {
                    const frictionT = Math.min(1.0, (mech.destroyedTimer - dramaticPhase) / frictionRampTime);
                    // Ramp linear damping from 0.05 to 0.8 for strong friction
                    const targetLinearDamping = 0.05 + frictionT * 0.75;
                    // Ramp angular damping from 0.1 to 0.9
                    const targetAngularDamping = 0.1 + frictionT * 0.8;

                    body.setLinearDamping(targetLinearDamping);
                    body.setAngularDamping(targetAngularDamping);
                }

                // Keep feet somewhat level during ragdoll for visual consistency
                const quat = body.transformNode.rotationQuaternion;
                if (quat && mech.leftLeg.footGroup) {
                    const euler = quat.toEulerAngles();
                    mech.leftLeg.footGroup.rotation.x = -euler.x * 0.5;
                    mech.rightLeg.footGroup.rotation.x = -euler.x * 0.5;
                }
                return;  // Destroyed mechs don't recover
            }

            // Check if mech has settled (low velocity)
            if (speed < STABILITY_CONFIG.ragdollSettleVelocity) {
                mech.ragdollSettleTimer += dt;

                // If settled for long enough, start recovery
                if (mech.ragdollSettleTimer > STABILITY_CONFIG.ragdollSettleTime) {
                    startRecovery(mech);
                }
            } else {
                // Still moving - reset settle timer
                mech.ragdollSettleTimer = 0;
            }

            // Keep feet somewhat level during ragdoll for visual consistency
            const quat = body.transformNode.rotationQuaternion;
            if (quat && mech.leftLeg.footGroup) {
                const euler = quat.toEulerAngles();
                mech.leftLeg.footGroup.rotation.x = -euler.x * 0.5;
                mech.rightLeg.footGroup.rotation.x = -euler.x * 0.5;
            }
        }

        // ============================================
        // PHASE 4: RECOVERY (Ragdoll â Standing)
        // ============================================
        function startRecovery(mech) {
            dbg(`${mech.isPlayer ? 'P' : 'E'} ${mech.name}: Starting RECOVERY`, 'ai');

            mech.mechState = MechState.RECOVERING;
            mech.recoveryTimer = 0;

            const body = mech.pelvisAggregate.body;

            // Detect orientation - are we face up or face down?
            const quat = body.transformNode.rotationQuaternion;
            const euler = quat ? quat.toEulerAngles() : new BABYLON.Vector3(0, 0, 0);

            // Check if face down (torso pointing to ground)
            const forward = new BABYLON.Vector3(0, 0, 1);
            if (quat) {
                const rotMatrix = new BABYLON.Matrix();
                quat.toRotationMatrix(rotMatrix);
                forward.copyFrom(BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(0, 1, 0), rotMatrix));
            }
            mech.isFaceDown = forward.y < 0;

            // Stop all motion before recovery
            body.setLinearVelocity(new BABYLON.Vector3(0, 0, 0));
            body.setAngularVelocity(new BABYLON.Vector3(0, 0, 0));
        }

        function updateRecovery(mech, dt) {
            mech.recoveryTimer += dt;
            const body = mech.pelvisAggregate.body;
            const pos = mech.pelvis.getAbsolutePosition();
            const quat = body.transformNode.rotationQuaternion;
            const euler = quat ? quat.toEulerAngles() : new BABYLON.Vector3(0, 0, 0);

            const blendTime = STABILITY_CONFIG.recoveryBlendTime;

            if (mech.recoveryTimer < blendTime) {
                // Phase 1: Blend rotation to upright
                const t = mech.recoveryTimer / blendTime;
                const easeT = t * t * (3 - 2 * t);  // Smoothstep for nice easing

                // Blend to upright (keep Y rotation for facing)
                const targetQuat = BABYLON.Quaternion.FromEulerAngles(0, euler.y, 0);
                const blendedQuat = BABYLON.Quaternion.Slerp(quat, targetQuat, easeT);
                body.transformNode.rotationQuaternion = blendedQuat;

                // Also lift to standing height
                const standingY = 3.5 * mech.scale;
                const targetY = Math.max(pos.y, standingY);
                mech.pelvis.position.y = BABYLON.Scalar.Lerp(pos.y, targetY, easeT);

                // Reset leg positions during blend
                dampLegs(mech, dt * 3);

            } else if (mech.recoveryTimer < blendTime + 0.3) {
                // Phase 2: Switch back to kinematic and stabilize
                if (body.getMotionType() !== BABYLON.PhysicsMotionType.ANIMATED) {
                    body.setMotionType(BABYLON.PhysicsMotionType.ANIMATED);
                    body.setLinearVelocity(new BABYLON.Vector3(0, 0, 0));
                    body.setAngularVelocity(new BABYLON.Vector3(0, 0, 0));

                    // Make sure we're upright
                    body.transformNode.rotationQuaternion = BABYLON.Quaternion.FromEulerAngles(0, euler.y, 0);

                    dbg(`${mech.isPlayer ? 'P' : 'E'} ${mech.name}: Switched back to ANIMATED`, 'ai');
                }

            } else {
                // Phase 3: Recovery complete - back to walking state
                mech.mechState = MechState.WALKING;
                mech.stability = STABILITY_CONFIG.maxStability * 0.5;  // Partial stability after recovery

                dbg(`${mech.isPlayer ? 'P' : 'E'} ${mech.name}: RECOVERED! Back to WALKING`, 'ai');
            }
        }

        // ============================================
        // CAMERA SHAKE & EFFECTS
        // ============================================
        function triggerCameraShake(intensity, duration) {
            if (!camera) return;

            const originalPos = camera.position.clone();
            let shakeTime = 0;
            const shakeInterval = setInterval(() => {
                shakeTime += 30;
                if (shakeTime > duration * 1000) {
                    clearInterval(shakeInterval);
                    camera.position = originalPos;
                } else {
                    const remaining = 1 - (shakeTime / (duration * 1000));
                    const shake = intensity * remaining;
                    camera.position = originalPos.add(new BABYLON.Vector3(
                        (Math.random() - 0.5) * shake,
                        (Math.random() - 0.5) * shake * 0.5,
                        (Math.random() - 0.5) * shake
                    ));
                }
            }, 30);
        }

        function createImpactSparks(position, direction) {
            // Create spark particles at impact point
            for (let i = 0; i < 8; i++) {
                const spark = BABYLON.MeshBuilder.CreateSphere('spark', { diameter: 0.08 }, scene);
                spark.position = position.clone();

                const sparkMat = new BABYLON.StandardMaterial('sparkMat', scene);
                sparkMat.emissiveColor = new BABYLON.Color3(1, 0.7, 0.2);
                sparkMat.disableLighting = true;
                spark.material = sparkMat;

                // Random velocity with bias in impact direction
                const vel = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 5 + direction.x * 3,
                    Math.random() * 4 + 1,
                    (Math.random() - 0.5) * 5 + direction.z * 3
                );

                let age = 0;
                const sparkUpdate = setInterval(() => {
                    age += 30;
                    if (age > 500) {
                        clearInterval(sparkUpdate);
                        spark.dispose();
                        return;
                    }

                    spark.position.addInPlace(vel.scale(0.03));
                    vel.y -= 0.3;  // Gravity
                    sparkMat.alpha = 1 - (age / 500);
                }, 30);
            }
        }

        function updateRecoil(mech, dt) {
            if (mech.recoilRecovery <= 0) return;
            mech.recoilRecovery -= dt * 4.5;
            if (mech.recoilRecovery < 0) mech.recoilRecovery = 0;

            const arm = mech.lastFiredArm === 'left' ? mech.leftArm : mech.rightArm;
            // Handle different arm structures: armGroup (Mad Cat, Dire Wolf) or shoulder (others)
            const armNode = arm.armGroup || arm.shoulder;
            if (armNode) {
                armNode.rotation.x = -mech.recoilRecovery * 0.45;
            }
            mech.torso.rotation.x = Math.max(mech.torso.rotation.x, -mech.recoilRecovery * 0.08);
        }

        function updateTorsoTrack(mech, dt) {
            const name = mech.isPlayer ? 'P' : 'E';
            const shouldLog = gameTime - lastDebugTime > DEBUG_INTERVAL;

            // Diagnostic: Check if mech object is valid
            if (!mech) {
                if (shouldLog) dbg(`${name}: updateTorsoTrack - mech is null/undefined!`, 'warn');
                return;
            }
            if (!mech.torso) {
                if (shouldLog) dbg(`${name}: updateTorsoTrack - mech.torso is null/undefined!`, 'warn');
                return;
            }
            if (!mech.pelvis) {
                if (shouldLog) dbg(`${name}: updateTorsoTrack - mech.pelvis is null/undefined!`, 'warn');
                return;
            }

            // Get or find target
            let target = mech.ai.target;
            if (!target || target.currentHP <= 0 || target.isDestroyed) {
                target = findNewTarget(mech);
                mech.ai.target = target;
            }

            // Diagnostic: Check target validity
            if (!target) {
                if (shouldLog) dbg(`${name}: updateTorsoTrack - no valid target found`, 'warn');
                return;
            }
            if (!target.pelvis) {
                if (shouldLog) dbg(`${name}: updateTorsoTrack - target.pelvis is null/undefined!`, 'warn');
                return;
            }

            const myPos = mech.pelvis.getAbsolutePosition();
            const targetPos = target.pelvis.getAbsolutePosition();
            const dx = targetPos.x - myPos.x;
            const dz = targetPos.z - myPos.z;

            // =============================================
            // TORSO ALWAYS FACES ENEMY
            // =============================================
            // Calculate angle to enemy (in XZ plane) - this is the WORLD angle
            const angleToEnemy = Math.atan2(dz, dx);

            // Get the pelvis's current world Y rotation
            // Since torso is parented to pelvis, we need to calculate LOCAL rotation
            const body = mech.pelvisAggregate.body;
            const pelvisQuat = body.transformNode.rotationQuaternion;
            let pelvisYaw = 0;
            if (pelvisQuat) {
                const euler = pelvisQuat.toEulerAngles();
                pelvisYaw = euler.y;
            }

            // Mech mesh faces +Z by default (chest at +Z, reactor at -Z)
            // Babylon.js uses LEFT-HANDED coordinates: +Y rotation is CLOCKWISE from above
            // rotation.y = 0 faces +Z, rotation.y = +Ï/2 faces +X, rotation.y = -Ï/2 faces -X
            // To convert world angle to mech rotation: baseAngle - angleToEnemy (not the reverse!)
            const baseAngle = Math.PI / 2;
            let worldTorsoAngle = baseAngle - angleToEnemy;

            // Convert to LOCAL torso rotation by subtracting pelvis world rotation
            // The torso is parented to the pelvis, so its rotation.y is relative to pelvis
            let torsoAngle = worldTorsoAngle - pelvisYaw;

            // Normalize to -PI to PI range
            while (torsoAngle > Math.PI) torsoAngle -= Math.PI * 2;
            while (torsoAngle < -Math.PI) torsoAngle += Math.PI * 2;

            // Clamp torso rotation to reasonable range (about 60 degrees each way from pelvis)
            mech.targetTorsoTwist = Math.max(-1.0, Math.min(1.0, torsoAngle));

            // Smooth interpolation for torso rotation
            mech.torsoTwist = BABYLON.Scalar.Lerp(mech.torsoTwist, mech.targetTorsoTwist, dt * 5);
            mech.torso.rotation.y = mech.torsoTwist;

            // Diagnostic: Log torso tracking calculations
            if (shouldLog) {
                dbg(`${name}: torso dx=${dx.toFixed(2)} dz=${dz.toFixed(2)} angleToEnemy=${(angleToEnemy * 180/Math.PI).toFixed(1)}Â°`, 'torso');
                dbg(`${name}: torso pelvisYaw=${(pelvisYaw * 180/Math.PI).toFixed(1)}Â° worldAngle=${(worldTorsoAngle * 180/Math.PI).toFixed(1)}Â° localAngle=${(torsoAngle * 180/Math.PI).toFixed(1)}Â° actual=${(mech.torsoTwist * 180/Math.PI).toFixed(1)}Â°`, 'torso');
            }

            // Head follows torso but can look even more toward enemy
            if (mech.head) {
                mech.head.rotation.y = mech.torsoTwist * 1.2;
            }

            // =============================================
            // LEGS/FEET - NO LEFT/RIGHT ROTATION
            // =============================================
            // Legs and feet should NOT rotate left/right independently
            // They are rigidly attached to the pelvis which handles all Y rotation
            // Feet can only pitch up/down (X rotation) to stay flat on ground

            // Initialize foot pitch tracker if not set
            if (mech.leftFootPitch === undefined) mech.leftFootPitch = 0;
            if (mech.rightFootPitch === undefined) mech.rightFootPitch = 0;

            // Ensure legGroups have no Y rotation (they follow pelvis)
            if (mech.leftLeg.legGroup) {
                mech.leftLeg.legGroup.rotation.y = 0;
                mech.rightLeg.legGroup.rotation.y = 0;
            }

            // Feet should stay HORIZONTAL to ground regardless of pelvis tilt
            // Counter-rotate feet to compensate for pelvis X rotation (forward/back tilt)
            if (mech.leftLeg.footGroup) {
                const body = mech.pelvisAggregate.body;
                const quat = body.transformNode.rotationQuaternion;
                if (quat) {
                    const euler = quat.toEulerAngles();
                    // Counter-rotate feet on X axis to cancel pelvis forward/back tilt
                    // The foot is parented through ankle->lowerLeg->knee->upperLeg->hip->legGroup->pelvis
                    // We need to cancel out the pelvis tilt to keep feet flat
                    const pelvisTiltX = euler.x;  // Forward/back tilt
                    const pelvisTiltZ = euler.z;  // Left/right tilt

                    // Counter-rotate both feet to stay horizontal
                    // Negative pelvisTiltX because we want to cancel it out
                    mech.leftLeg.footGroup.rotation.x = -pelvisTiltX;
                    mech.rightLeg.footGroup.rotation.x = -pelvisTiltX;

                    // Z tilt affects left/right feet differently
                    // Left foot needs more counter-rotation when tilting left
                    // This is simplified - in reality legs would bend to compensate
                    mech.leftLeg.footGroup.rotation.z = -pelvisTiltZ * 0.5;
                    mech.rightLeg.footGroup.rotation.z = -pelvisTiltZ * 0.5;
                }

                // Never any Y rotation on feet
                mech.leftLeg.footGroup.rotation.y = 0;
                mech.rightLeg.footGroup.rotation.y = 0;
            }
        }

        // ============================================
        // HYBRID ARCHITECTURE: No active stabilization needed!
        // In WALKING mode (ANIMATED), the body is kinematic - no tipping possible
        // In RAGDOLL mode (DYNAMIC), physics handles everything naturally
        // This function is kept for legacy compatibility but does minimal work
        // ============================================
        function stabilize(mech, dt) {
            // In hybrid mode, stabilization is handled by the state machine
            // This function is called but does nothing in walking mode
            // Ragdoll and recovery are handled by updateRagdoll() and updateRecovery()
        }

        // ============================================
        // GOAL-BASED MECH AI SYSTEM
        // Each mech has goals that combine into movement:
        // 1. Range Goal: Move to optimal weapon range
        // 2. Avoidance Goal: Stay away from other mechs (unless melee)
        // 3. Boundary Goal: Stay inside arena
        // 4. Strafe Goal: Lateral movement when other goals satisfied
        // ============================================
        function updateAI(mech, dt) {
            const name = mech.isPlayer ? 'P' : 'E';
            const shouldLog = gameTime - lastDebugTime > DEBUG_INTERVAL;

            if (!mech.ai.enabled) {
                if (shouldLog) dbg(`${name}: AI disabled`, 'warn');
                return;
            }
            if (mech.currentHP <= 0) {
                if (shouldLog) dbg(`${name}: HP=0, skip AI`, 'warn');
                return;
            }
            if (mech.staggerTime > 0) {
                if (shouldLog) dbg(`${name}: staggered (${mech.staggerTime.toFixed(2)}s)`, 'warn');
                return;
            }

            // Get or find target
            let target = mech.ai.target;
            if (!target || target.currentHP <= 0 || target.isDestroyed) {
                target = findNewTarget(mech);
                mech.ai.target = target;
            }
            if (!target) {
                if (shouldLog) dbg(`${name}: no valid target`, 'warn');
                mech.isWalking = false;
                return;
            }

            const body = mech.pelvisAggregate.body;
            const myPos = mech.pelvis.getAbsolutePosition();
            const targetPos = target.pelvis.getAbsolutePosition();
            const distance = BABYLON.Vector3.Distance(myPos, targetPos);

            // Log physics state periodically
            if (shouldLog) {
                const vel = body.getLinearVelocity();
                dbg(`${name}: pos=(${myPos.x.toFixed(1)},${myPos.y.toFixed(1)},${myPos.z.toFixed(1)}) dist=${distance.toFixed(1)}`, 'phys');
            }

            // ============================================
            // GOAL 1: RANGE - Move toward optimal weapon range
            // ============================================
            const optimalRange = mech.optimalRange || 10;
            const rangeTolerance = 2.0;  // Acceptable range variance
            let rangeGoal = new BABYLON.Vector3(0, 0, 0);
            let rangeUrgency = 0;

            const rangeError = distance - optimalRange;
            if (Math.abs(rangeError) > rangeTolerance) {
                // Direction toward/away from target based on range error
                const toTarget = targetPos.subtract(myPos);
                toTarget.y = 0;
                toTarget.normalize();

                // Positive rangeError = too far, need to move closer
                // Negative rangeError = too close, need to back up
                rangeUrgency = Math.min(1.0, Math.abs(rangeError) / 8.0);
                rangeGoal = toTarget.scale(Math.sign(rangeError) * rangeUrgency);
            }

            // ============================================
            // GOAL 2: AVOIDANCE - Stay away from other mechs
            // Importance scales with inverse square of distance
            // ============================================
            let avoidGoal = new BABYLON.Vector3(0, 0, 0);
            let avoidUrgency = 0;
            const avoidRadius = 6.0;  // Start avoiding at this distance
            const minSeparation = 3.0;  // Minimum desired distance

            // Check all mechs for avoidance
            allMechs.forEach(other => {
                if (other === mech || other.isDestroyed || other.currentHP <= 0) return;

                const otherPos = other.pelvis.getAbsolutePosition();
                const toOther = otherPos.subtract(myPos);
                toOther.y = 0;
                const mechDist = toOther.length();

                if (mechDist < avoidRadius && mechDist > 0.1) {
                    // Skip avoidance for melee mechs toward their target
                    if (mech.isMelee && other === target && mechDist > minSeparation * 0.5) {
                        return;  // Melee mech wants to be close to target
                    }

                    // Inverse square falloff - very strong when close, zero at avoidRadius
                    const normalizedDist = (mechDist - minSeparation) / (avoidRadius - minSeparation);
                    const clampedDist = Math.max(0.1, Math.min(1.0, normalizedDist));
                    const avoidStrength = 1.0 / (clampedDist * clampedDist) - 1.0;

                    // Push away from this mech
                    const awayDir = toOther.normalize().scale(-1);
                    avoidGoal.addInPlace(awayDir.scale(Math.min(avoidStrength, 3.0)));
                    avoidUrgency = Math.max(avoidUrgency, 1.0 - clampedDist);
                }
            });

            // Normalize avoidance if it got too strong
            if (avoidGoal.length() > 1.5) {
                avoidGoal.normalize().scaleInPlace(1.5);
            }

            // ============================================
            // GOAL 3: BOUNDARY - Stay inside arena
            // ============================================
            let boundaryGoal = new BABYLON.Vector3(0, 0, 0);
            let boundaryUrgency = 0;
            const softBoundaryX = 14;  // Start pushing back
            const softBoundaryZ = 6;

            // X boundaries
            if (myPos.x < -softBoundaryX) {
                const depth = (-softBoundaryX - myPos.x) / 4;
                boundaryGoal.x = Math.min(2.0, 0.5 + depth);
                boundaryUrgency = Math.max(boundaryUrgency, Math.min(1.0, depth));
            } else if (myPos.x > softBoundaryX) {
                const depth = (myPos.x - softBoundaryX) / 4;
                boundaryGoal.x = -Math.min(2.0, 0.5 + depth);
                boundaryUrgency = Math.max(boundaryUrgency, Math.min(1.0, depth));
            }

            // Z boundaries
            if (myPos.z < -softBoundaryZ) {
                const depth = (-softBoundaryZ - myPos.z) / 2;
                boundaryGoal.z = Math.min(2.0, 0.5 + depth);
                boundaryUrgency = Math.max(boundaryUrgency, Math.min(1.0, depth));
            } else if (myPos.z > softBoundaryZ) {
                const depth = (myPos.z - softBoundaryZ) / 2;
                boundaryGoal.z = -Math.min(2.0, 0.5 + depth);
                boundaryUrgency = Math.max(boundaryUrgency, Math.min(1.0, depth));
            }

            // ============================================
            // GOAL 4: STRAFE - Lateral movement when stable
            // More aggressive strafing when at ideal range
            // ============================================
            let strafeGoal = new BABYLON.Vector3(0, 0, 0);

            // Initialize strafe timer if needed
            if (!mech.ai.strafeTimer) mech.ai.strafeTimer = 0;
            if (!mech.ai.currentStrafeDir) mech.ai.currentStrafeDir = 0;

            // Can strafe when not urgently avoiding boundaries
            const canStrafe = avoidUrgency < 0.6 && boundaryUrgency < 0.4;

            // Strafe more aggressively when at ideal range (rangeUrgency is low)
            const atIdealRange = rangeUrgency < 0.2;

            if (canStrafe) {
                mech.ai.strafeTimer -= dt;
                if (mech.ai.strafeTimer <= 0) {
                    // Always strafe when at ideal range, high chance otherwise
                    const strafeChance = atIdealRange ? 0.95 : 0.7;
                    if (Math.random() < strafeChance) {
                        // Higher intensity when at ideal range
                        const intensity = atIdealRange ? (0.6 + Math.random() * 0.4) : (0.3 + Math.random() * 0.5);
                        mech.ai.currentStrafeDir = (Math.random() < 0.5 ? -1 : 1) * intensity;
                    } else {
                        mech.ai.currentStrafeDir = 0;  // Brief pause
                    }
                    // Shorter timer when at ideal range for more dynamic movement
                    mech.ai.strafeTimer = atIdealRange ? (0.5 + Math.random() * 1.0) : (1.0 + Math.random() * 2.0);
                }

                // Calculate strafe direction (perpendicular to target)
                if (Math.abs(mech.ai.currentStrafeDir) > 0.1) {
                    const toTarget = targetPos.subtract(myPos);
                    toTarget.y = 0;
                    toTarget.normalize();
                    // Cross product with up to get perpendicular
                    const strafeDir = new BABYLON.Vector3(-toTarget.z, 0, toTarget.x);
                    // Stronger strafe when at ideal range
                    const strafeMultiplier = atIdealRange ? 1.0 : 0.6;
                    strafeGoal = strafeDir.scale(mech.ai.currentStrafeDir * strafeMultiplier);
                }
            }

            // ============================================
            // COMBINE GOALS with priority weighting
            // ============================================
            // Weights: boundary > avoidance > range > strafe
            // Strafe weight increases when at ideal range
            const boundaryWeight = 2.0;
            const avoidWeight = 1.5;
            const rangeWeight = 1.0;
            const strafeWeight = atIdealRange ? 1.2 : 0.5;  // Much higher strafe weight at ideal range

            let desiredVelocity = new BABYLON.Vector3(0, 0, 0);
            desiredVelocity.addInPlace(boundaryGoal.scale(boundaryWeight));
            desiredVelocity.addInPlace(avoidGoal.scale(avoidWeight));
            desiredVelocity.addInPlace(rangeGoal.scale(rangeWeight));
            desiredVelocity.addInPlace(strafeGoal.scale(strafeWeight));

            // ============================================
            // CONVERT TO MECH-RELATIVE MOVEMENT
            // ============================================
            const pelvisQuat = body.transformNode.rotationQuaternion;
            let mechForward = new BABYLON.Vector3(1, 0, 0);
            let mechRight = new BABYLON.Vector3(0, 0, 1);
            if (pelvisQuat) {
                const rotMatrix = new BABYLON.Matrix();
                pelvisQuat.toRotationMatrix(rotMatrix);
                mechForward = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(1, 0, 0), rotMatrix);
                mechForward.y = 0;
                mechForward.normalize();
                mechRight = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(0, 0, 1), rotMatrix);
                mechRight.y = 0;
                mechRight.normalize();
            }

            // Project desired velocity onto mech's forward and right axes
            const forwardComponent = desiredVelocity.x * mechForward.x + desiredVelocity.z * mechForward.z;
            const rightComponent = desiredVelocity.x * mechRight.x + desiredVelocity.z * mechRight.z;

            // Set movement parameters
            const velocityMagnitude = desiredVelocity.length();
            mech.isWalking = velocityMagnitude > 0.15;
            mech.walkDirection = Math.max(-1, Math.min(1, forwardComponent));
            mech.ai.strafeAmount = Math.max(-1, Math.min(1, rightComponent));

            if (shouldLog) {
                dbg(`${name}: goals range=${rangeUrgency.toFixed(2)} avoid=${avoidUrgency.toFixed(2)} bound=${boundaryUrgency.toFixed(2)}`, 'ai');
                dbg(`${name}: walk=${mech.walkDirection.toFixed(2)} strafe=${mech.ai.strafeAmount.toFixed(2)}`, 'ai');
            }

            // ============================================
            // WEAPON FIRING (separate from movement)
            // ============================================
            if (gameTime - mech.ai.lastDecision > AI_CONFIG.decisionInterval) {
                mech.ai.lastDecision = gameTime;

                const now = Date.now();
                const mechKey = mech.name + '_' + (mech.isPlayer ? 'p' : 'e');
                if (!mechCooldowns[mechKey]) mechCooldowns[mechKey] = { erlaser: 0, lrm: 0, ac: 0, hatchet: 0 };
                const cooldowns = mechCooldowns[mechKey];

                if (mech.isMelee) {
                    const meleeRange = WEAPONS.hatchet.range;
                    if (distance <= meleeRange && now >= cooldowns.hatchet) {
                        fireWeapon(mech, 'hatchet');
                        cooldowns.hatchet = now + COOLDOWN_TIMES.hatchet;
                    } else if (distance <= 15 && now >= cooldowns.erlaser) {
                        fireWeapon(mech, 'erlaser');
                        cooldowns.erlaser = now + COOLDOWN_TIMES.erlaser;
                    }
                } else if (mech.loadoutWeapons && mech.loadoutWeapons.length > 0) {
                    // Fire weapons from loadout only
                    if (distance <= 18 && distance >= 3) {
                        for (const loadoutWpn of mech.loadoutWeapons) {
                            const wpnKey = loadoutWpn.itemId;
                            if (!cooldowns[wpnKey]) cooldowns[wpnKey] = 0;
                            if (now >= cooldowns[wpnKey]) {
                                fireLoadoutWeapon(mech, loadoutWpn);
                                const weaponCooldown = (loadoutWpn.battle && loadoutWpn.battle.cooldown) || 2000;
                                cooldowns[wpnKey] = now + weaponCooldown;
                                break;
                            }
                        }
                    }
                } else {
                    // Fallback to default weapons for AI enemies without loadout
                    if (distance <= 18 && distance >= 3) {
                        const weaponPriority = ['erlaser', 'ac', 'lrm'];
                        for (const wtype of weaponPriority) {
                            if (now >= cooldowns[wtype]) {
                                fireWeapon(mech, wtype);
                                cooldowns[wtype] = now + COOLDOWN_TIMES[wtype];
                                break;
                            }
                        }
                    }
                }
            }

            // === FULL BODY ROTATION TOWARD TARGET (KINEMATIC MODE) ===
            // The whole mech (pelvis/legs) should always try to face the target
            // In ANIMATED mode, we set angular velocity directly instead of applying impulses
            const quat = body.transformNode.rotationQuaternion;
            if (quat && mech.mechState === MechState.WALKING && !mech.isDestroyed) {
                const euler = quat.toEulerAngles();
                const currentYaw = euler.y;  // Current facing direction

                // Calculate desired facing angle (toward target)
                const dx = targetPos.x - myPos.x;
                const dz = targetPos.z - myPos.z;
                const angleToTarget = Math.atan2(dz, dx);  // Angle in XZ plane

                // Convert to body rotation (mesh faces +Z, so we need baseAngle offset)
                const baseAngle = Math.PI / 2;  // 90Â° offset because mesh faces +Z
                const desiredYaw = baseAngle - angleToTarget;

                // Calculate rotation error (shortest path)
                let yawError = desiredYaw - currentYaw;
                // Normalize to [-PI, PI]
                while (yawError > Math.PI) yawError -= 2 * Math.PI;
                while (yawError < -Math.PI) yawError += 2 * Math.PI;

                // Store the desired rotation for the kinematic walking function
                mech.ai.desiredYawError = yawError;

                if (shouldLog) {
                    dbg(`${name}: BODY ROTATE yaw=${(currentYaw * 57.3).toFixed(0)}Â° target=${(desiredYaw * 57.3).toFixed(0)}Â° err=${(yawError * 57.3).toFixed(0)}Â°`, 'torso');
                }
            }

            // Note: lastDebugTime is updated in the main render loop after all subsystems log
        }

        // ============================================
        // COMBAT
        // ============================================
        // Legacy weapon firing - only used for melee and default demo battles
        // For loadout-based mechs, use fireLoadoutWeapon instead
        function fireWeapon(mech, type) {
            try {
                const from = mech;
                const to = mech.ai.target;
                if (!from || !to || to.isDestroyed) return;

                log(`[FIRE] ${from.name} attempting ${type}...`);

                const weapon = WEAPONS[type];
                if (!weapon) {
                    log(`[ERROR] Unknown weapon type: ${type}`, 'error');
                    return;
                }

                from.recoilRecovery = weapon.recoil;
                from.lastFiredArm = from.lastFiredArm === 'left' ? 'right' : 'left';

                // Validate required properties
                if (!from.pelvis || !to.pelvis) {
                    log(`[ERROR] Missing pelvis: from=${!!from.pelvis} to=${!!to.pelvis}`, 'error');
                    return;
                }

                // Apply recoil in opposite direction of target
                const toTarget = to.pelvis.getAbsolutePosition().subtract(from.pelvis.getAbsolutePosition()).normalize();
                from.pelvisAggregate.body.applyImpulse(
                    toTarget.scale(-weapon.knockback * 0.25),
                    from.pelvis.getAbsolutePosition()
                );

                if (weapon.isMelee) {
                    if (fireMelee(from, to, weapon)) {
                        log(`${from.name} swings ${weapon.name}!`);
                        triggerCinematicAction(from, 'fire');
                    }
                } else if (weapon.isBeam) {
                    fireBeam(from, to, weapon);
                    log(`${from.name} fires ${weapon.name}!`);
                    triggerCinematicAction(from, 'fire');
                } else if (weapon.isCluster) {
                    fireCluster(from, to, weapon);
                    log(`${from.name} fires ${weapon.name}!`);
                    triggerCinematicAction(from, 'fire');
                } else {
                    fireProjectile(from, to, weapon);
                    log(`${from.name} fires ${weapon.name}!`);
                    triggerCinematicAction(from, 'fire');
                }
            } catch (e) {
                log(`[FIRE ERROR] ${e.message}`, 'error');
                console.error('fireWeapon error:', e);
            }
        }

        // Fire a weapon from loadout data (uses actual weapon stats)
        function fireLoadoutWeapon(mech, loadoutWeapon) {
            try {
                const from = mech;
                const to = mech.ai.target;
                if (!from || !to || to.isDestroyed) return;

                const wpnName = loadoutWeapon.name || loadoutWeapon.itemId;
                const battleProps = loadoutWeapon.battle || {};
                const damage = loadoutWeapon.damage || 10;

                log(`[LOADOUT FIRE] ${from.name} fires ${wpnName} (${damage} damage)`);

                // Build weapon object from loadout data - NO damage multipliers
                const weapon = {
                    name: wpnName,
                    damage: damage,
                    knockback: battleProps.knockback || 15,
                    recoil: battleProps.recoil || 0.15,
                    projectileSpeed: battleProps.projectileSpeed || 40,
                    projectileSize: battleProps.projectileSize || 0.12,
                    isBeam: battleProps.isBeam || false,
                    isCluster: battleProps.isCluster || false,
                    isProjectile: battleProps.isProjectile || (!battleProps.isBeam && !battleProps.isCluster),
                    beamDuration: battleProps.beamDuration || 180,
                    clusterCount: battleProps.clusterCount || 6,
                    color: battleProps.color ? new BABYLON.Color3(battleProps.color[0], battleProps.color[1], battleProps.color[2]) : new BABYLON.Color3(1, 0.8, 0.2)
                };

                from.recoilRecovery = weapon.recoil;
                from.lastFiredArm = from.lastFiredArm === 'left' ? 'right' : 'left';

                // Validate required properties
                if (!from.pelvis || !to.pelvis) {
                    log(`[ERROR] Missing pelvis: from=${!!from.pelvis} to=${!!to.pelvis}`, 'error');
                    return;
                }

                // Apply recoil in opposite direction of target
                const toTarget = to.pelvis.getAbsolutePosition().subtract(from.pelvis.getAbsolutePosition()).normalize();
                from.pelvisAggregate.body.applyImpulse(
                    toTarget.scale(-weapon.knockback * 0.25),
                    from.pelvis.getAbsolutePosition()
                );

                // Fire based on weapon type
                if (weapon.isBeam) {
                    fireBeam(from, to, weapon);
                    log(`${from.name} fires ${weapon.name}!`);
                    triggerCinematicAction(from, 'fire');
                } else if (weapon.isCluster) {
                    fireCluster(from, to, weapon);
                    log(`${from.name} fires ${weapon.name}!`);
                    triggerCinematicAction(from, 'fire');
                } else {
                    // Default to projectile
                    fireProjectile(from, to, weapon);
                    log(`${from.name} fires ${weapon.name}!`);
                    triggerCinematicAction(from, 'fire');
                }
            } catch (e) {
                log(`[LOADOUT FIRE ERROR] ${e.message}`, 'error');
                console.error('fireLoadoutWeapon error:', e);
            }
        }

        function fireProjectile(from, to, weapon) {
            try {
                log(`[PROJ] Starting fireProjectile...`);
                const arm = from.lastFiredArm === 'left' ? from.leftArm : from.rightArm;

                // Validate arm structure
                if (!arm) {
                    log(`[ERROR] No arm found: lastFiredArm=${from.lastFiredArm}`, 'error');
                    return;
                }
                if (!arm.weaponPod) {
                    log(`[ERROR] No weaponPod on arm. Arm keys: ${Object.keys(arm).join(',')}`, 'error');
                    return;
                }
                if (!to.torso) {
                    log(`[ERROR] No torso on target`, 'error');
                    return;
                }

                const start = arm.weaponPod.getAbsolutePosition();
                start.z += 0.5;
                const target = to.torso.getAbsolutePosition();
                target.x += (Math.random() - 0.5) * 0.4;
                target.y += (Math.random() - 0.5) * 0.4;

                // Validate positions
                if (isNaN(start.x) || isNaN(target.x)) {
                    log(`[ERROR] NaN position: start=${start} target=${target}`, 'error');
                    return;
                }

                const dir = target.subtract(start).normalize();
                const projSize = weapon.projectileSize || 0.1;  // Default if missing
                const proj = BABYLON.MeshBuilder.CreateSphere('proj' + Date.now(), { diameter: projSize * 2 }, scene);
                proj.position = start.clone();

                const mat = new BABYLON.StandardMaterial('projMat' + Date.now(), scene);
                mat.emissiveColor = weapon.color;
                proj.material = mat;

                const agg = new BABYLON.PhysicsAggregate(proj, BABYLON.PhysicsShapeType.SPHERE,
                    { mass: 0.8, friction: 0, restitution: 0.1 }, scene);

                // Disable projectile-to-projectile collisions
                agg.shape.filterMembershipMask = 4;  // Projectile group
                agg.shape.filterCollideMask = 1 | 2;  // Collide with ground (1) and mechs (2), not projectiles (4)

                agg.body.setLinearVelocity(dir.scale(weapon.projectileSpeed));

                projectiles.push({ mesh: proj, aggregate: agg, weapon, target: to, firedAt: Date.now() });
                createMuzzleFlash(start, weapon.color);
                log(`[PROJ] Projectile created successfully`);
            } catch (e) {
                log(`[PROJ ERROR] ${e.message}`, 'error');
                console.error('fireProjectile error:', e);
            }
        }

        function fireBeam(from, to, weapon) {
            try {
                log(`[BEAM] Starting fireBeam...`);
                const arm = from.lastFiredArm === 'left' ? from.leftArm : from.rightArm;

                // Validate arm structure
                if (!arm) {
                    log(`[ERROR] No arm found: lastFiredArm=${from.lastFiredArm}`, 'error');
                    return;
                }
                if (!arm.weaponPod) {
                    log(`[ERROR] No weaponPod on arm. Arm keys: ${Object.keys(arm).join(',')}`, 'error');
                    return;
                }
                if (!to.torso) {
                    log(`[ERROR] No torso on target`, 'error');
                    return;
                }

                const start = arm.weaponPod.getAbsolutePosition();
                start.z += 0.6;
                const end = to.torso.getAbsolutePosition();

                // Validate positions and check for degenerate path
                if (isNaN(start.x) || isNaN(end.x)) {
                    log(`[ERROR] NaN position: start=${start} end=${end}`, 'error');
                    return;
                }
                const dist = BABYLON.Vector3.Distance(start, end);
                if (dist < 0.1) {
                    log(`[ERROR] Beam path too short: ${dist}`, 'error');
                    return;
                }

                log(`[BEAM] Creating tube: dist=${dist.toFixed(2)}`);
                const beam = BABYLON.MeshBuilder.CreateTube('beam' + Date.now(), {
                    path: [start, end], radius: 0.1, updatable: false
                }, scene);
                const mat = new BABYLON.StandardMaterial('beamMat' + Date.now(), scene);
                mat.emissiveColor = weapon.color;
                mat.alpha = 0.85;
                beam.material = mat;

                beams.push({ mesh: beam, material: mat, createdAt: Date.now(), duration: weapon.beamDuration });
                applyDamage(to, weapon, from.isPlayer ? 1 : -1);
                createImpact(end.clone(), weapon.color);
                log(`[BEAM] Beam created successfully`);
            } catch (e) {
                log(`[BEAM ERROR] ${e.message}`, 'error');
                console.error('fireBeam error:', e);
            }
        }

        function fireCluster(from, to, weapon) {
            try {
                log(`[CLUSTER] Starting fireCluster...`);

                // Validate pods exist
                if (!from.leftPod || !from.rightPod) {
                    log(`[ERROR] Missing pods: left=${!!from.leftPod} right=${!!from.rightPod}`, 'error');
                    return;
                }
                if (!to.torso) {
                    log(`[ERROR] No torso on target`, 'error');
                    return;
                }

                // Use shoulder missile launchers (leftPod/rightPod) instead of arm weapons
                const usePod = from.lastFiredArm === 'left' ? from.leftPod : from.rightPod;
                from.lastFiredArm = from.lastFiredArm === 'left' ? 'right' : 'left';  // Alternate pods

                const podPos = usePod.getAbsolutePosition();
                const target = to.torso.getAbsolutePosition();

                // Validate positions
                if (isNaN(podPos.x) || isNaN(target.x)) {
                    log(`[ERROR] NaN position in cluster: pod=${podPos} target=${target}`, 'error');
                    return;
                }

            for (let i = 0; i < weapon.clusterCount; i++) {
                setTimeout(() => {
                    // Calculate tube position within the missile rack (5x4 grid)
                    const row = Math.floor(i / 5) % 4;
                    const col = i % 5;

                    // Offset from pod center to simulate missiles coming from individual tubes
                    const tubeOffset = new BABYLON.Vector3(
                        (col - 2) * 0.13,   // X spread across columns
                        (row - 1.5) * 0.16, // Y spread across rows
                        0.7                  // Forward from pod center
                    );

                    // Transform offset to world space based on pod orientation
                    const worldMatrix = usePod.getWorldMatrix();
                    const start = BABYLON.Vector3.TransformCoordinates(tubeOffset, worldMatrix);

                    const spread = target.clone();
                    spread.x += (Math.random() - 0.5) * 2;
                    spread.y += (Math.random() - 0.5) * 1.5;
                    spread.z += (Math.random() - 0.5) * 1;

                    const dir = spread.subtract(start).normalize();
                    dir.y += 0.18;  // Arc upward slightly
                    dir.normalize();

                    const missile = BABYLON.MeshBuilder.CreateBox('missile' + Date.now() + i, {
                        width: 0.06, height: 0.06, depth: 0.18
                    }, scene);
                    missile.position = start.clone();
                    missile.lookAt(spread);

                    const mat = new BABYLON.StandardMaterial('missileMat' + Date.now(), scene);
                    mat.emissiveColor = weapon.color.scale(0.6);
                    missile.material = mat;

                    const agg = new BABYLON.PhysicsAggregate(missile, BABYLON.PhysicsShapeType.BOX,
                        { mass: 0.25, friction: 0, restitution: 0 }, scene);

                    // Disable projectile-to-projectile collisions
                    agg.shape.filterMembershipMask = 4;  // Projectile group
                    agg.shape.filterCollideMask = 1 | 2;  // Collide with ground (1) and mechs (2), not projectiles (4)

                    agg.body.setLinearVelocity(dir.scale(weapon.projectileSpeed));

                    projectiles.push({
                        mesh: missile, aggregate: agg,
                        weapon: { ...weapon, damage: weapon.damage / weapon.clusterCount },
                        target: to, firedAt: Date.now(), isMissile: true
                    });

                    // Create small muzzle flash at each tube
                    createMuzzleFlash(start, weapon.color);
                }, i * 40);
            }
                log(`[CLUSTER] Cluster missiles launched`);
            } catch (e) {
                log(`[CLUSTER ERROR] ${e.message}`, 'error');
                console.error('fireCluster error:', e);
            }
        }

        function fireMelee(from, to, weapon) {
            try {
                log(`[MELEE] ${from.name} swinging hatchet!`);

                // Check melee range
                const fromPos = from.pelvis.getAbsolutePosition();
                const toPos = to.pelvis.getAbsolutePosition();
                const dist = BABYLON.Vector3.Distance(fromPos, toPos);

                if (dist > weapon.range) {
                    log(`[MELEE] Target too far: ${dist.toFixed(1)} > ${weapon.range}`, 'warn');
                    return false;
                }

                // Create melee swing visual effect
                const swingStart = from.leftArm.weaponPod ? from.leftArm.weaponPod.getAbsolutePosition() : fromPos.clone();
                const swingEnd = to.torso.getAbsolutePosition();

                // Orange arc flash for hatchet swing
                const arc = BABYLON.MeshBuilder.CreateTube('meleeArc' + Date.now(), {
                    path: [swingStart, swingEnd],
                    radius: 0.15,
                    updatable: false
                }, scene);
                const arcMat = new BABYLON.StandardMaterial('arcMat' + Date.now(), scene);
                arcMat.emissiveColor = weapon.color;
                arcMat.alpha = 0.9;
                arc.material = arcMat;

                // Fade and remove arc quickly
                let arcAlpha = 0.9;
                const arcFade = setInterval(() => {
                    arcAlpha -= 0.15;
                    if (arcAlpha <= 0) {
                        clearInterval(arcFade);
                        arc.dispose();
                    } else {
                        arcMat.alpha = arcAlpha;
                    }
                }, 30);

                // Apply damage with massive knockback
                applyDamage(to, weapon, from.isPlayer ? 1 : -1);

                // Extra knockback for melee
                const knockDir = toPos.subtract(fromPos).normalize();
                knockDir.y = 0.3;  // Slight upward
                to.pelvisAggregate.body.applyImpulse(knockDir.scale(weapon.knockback * 0.8), toPos);

                // Create impact sparks
                createImpact(swingEnd.clone(), weapon.color);
                createImpact(swingEnd.clone(), new BABYLON.Color3(1, 0.8, 0.2));

                log(`[MELEE] HATCHET HIT! ${to.name} takes ${weapon.damage} damage!`, 'warn');
                return true;
            } catch (e) {
                log(`[MELEE ERROR] ${e.message}`, 'error');
                console.error('fireMelee error:', e);
                return false;
            }
        }

        function applyDamage(mech, weapon, dirSign) {
            // Skip if mech is already destroyed or recovering
            if (mech.isDestroyed) return;
            if (mech.mechState === MechState.RECOVERING) return;  // Don't damage during recovery

            mech.currentHP -= weapon.damage;
            if (mech.currentHP < 0) mech.currentHP = 0;

            const knockback = weapon.knockback;
            const impactDir = new BABYLON.Vector3(dirSign, 0, 0);
            mech.impactDirection = impactDir;

            // Trigger cinematic camera to track damaged mech
            triggerCinematicAction(mech, 'damage');

            // Check for destruction first
            if (mech.currentHP <= 0 && !mech.isDestroyed) {
                log(`${mech.name} DESTROYED!`, 'error');
                triggerDestruction(mech);
                return;
            }

            // HYBRID DAMAGE SYSTEM: Determine flinch vs ragdoll based on knockback and stability

            // Reduce stability based on knockback
            mech.stability -= knockback * 0.8;
            if (mech.stability < 0) mech.stability = 0;

            dbg(`${mech.isPlayer ? 'P' : 'E'} ${mech.name}: Hit! KB=${knockback} Stability=${mech.stability.toFixed(0)}`, 'phys');

            // Case 1: Massive hit - immediate ragdoll regardless of stability
            if (knockback >= STABILITY_CONFIG.knockdownThreshold) {
                const hitForce = impactDir.scale(knockback * 1.5);
                hitForce.y = knockback * 0.3;  // Some upward lift
                triggerRagdoll(mech, hitForce);
                log(`${mech.name} KNOCKED DOWN!`, 'warn');
                return;
            }

            // Case 2: Stability depleted - ragdoll
            if (mech.stability <= 0 && mech.mechState === MechState.WALKING) {
                const hitForce = impactDir.scale(knockback * 1.2);
                hitForce.y = knockback * 0.2;
                triggerRagdoll(mech, hitForce);
                log(`${mech.name} STABILITY BROKEN!`, 'warn');
                return;
            }

            // Case 3: Medium hit - flinch and stagger
            if (knockback >= STABILITY_CONFIG.flinchThreshold) {
                mech.flinchIntensity = Math.min(1.0, knockback / 25);
                mech.staggerTime = 0.3;  // Brief pause
                log(`${mech.name} staggers!`, 'warn');

                // Small camera shake for medium hits
                triggerCameraShake(0.2, 0.15);
            } else {
                // Case 4: Small hit - minor flinch only
                mech.flinchIntensity = Math.min(0.5, knockback / 30);
            }

            // Visual flash effect for any hit
            createImpactSparks(mech.torso.getAbsolutePosition(), impactDir);
        }

        function updateProjectiles(dt) {
            const now = Date.now();
            projectiles = projectiles.filter(p => {
                try {
                    if (now - p.firedAt > 3500) { p.mesh.dispose(); return false; }

                    // Safety check for target and torso
                    if (!p.target || !p.target.torso) {
                        log(`[WARN] Projectile has invalid target, removing`, 'warn');
                        p.mesh.dispose();
                        return false;
                    }

                    const dist = BABYLON.Vector3.Distance(p.mesh.position, p.target.torso.getAbsolutePosition());
                    if (dist < 1.6) {
                        applyDamage(p.target, p.weapon, p.target.isPlayer ? -1 : 1);
                        log(`HIT! ${p.target.name} -${p.weapon.damage} (${p.target.currentHP}/${p.target.maxHP})`, 'warn');
                        createImpact(p.mesh.position.clone(), p.weapon.color);
                        p.mesh.dispose();
                        return false;
                    }

                    // Check for ground hit - create dust plume
                    if (p.mesh.position.y < 0.3) {
                        const groundPos = p.mesh.position.clone();
                        groundPos.y = 0.1;
                        createDustPlume(groundPos);
                        p.mesh.dispose();
                        return false;
                    }

                    // Out of bounds
                    if (Math.abs(p.mesh.position.x) > 22 || Math.abs(p.mesh.position.z) > 15) {
                        p.mesh.dispose();
                        return false;
                    }

                    if (p.isMissile && Math.random() < 0.25) createSmoke(p.mesh.position.clone());
                    return true;
                } catch (e) {
                    console.error('[PROJECTILE ERROR]', e);
                    try { p.mesh.dispose(); } catch (e2) {}
                    return false;
                }
            });
        }

        function updateBeams() {
            const now = Date.now();
            beams = beams.filter(b => {
                const age = now - b.createdAt;
                if (age > b.duration) { b.mesh.dispose(); return false; }
                b.material.alpha = 0.85 * (1 - age / b.duration);
                return true;
            });
        }

        // ============================================
        // EFFECTS
        // ============================================
        function createMuzzleFlash(pos, color) {
            const flash = BABYLON.MeshBuilder.CreateSphere('flash', { diameter: 0.35 }, scene);
            flash.position = pos;
            const mat = new BABYLON.StandardMaterial('flashMat', scene);
            mat.emissiveColor = color;
            mat.disableLighting = true;
            flash.material = mat;

            let a = 1;
            const int = setInterval(() => {
                a -= 0.18;
                if (a <= 0) { clearInterval(int); flash.dispose(); }
                else flash.scaling.setAll(a);
            }, 16);
        }

        function createImpact(pos, color) {
            const ps = new BABYLON.ParticleSystem('impact', 60, scene);
            ps.particleTexture = new BABYLON.Texture('https://assets.babylonjs.com/textures/flare.png', scene);
            ps.emitter = pos;
            ps.color1 = new BABYLON.Color4(color.r, color.g, color.b, 1);
            ps.color2 = new BABYLON.Color4(color.r * 0.5, color.g * 0.5, color.b * 0.5, 1);
            ps.colorDead = new BABYLON.Color4(0.15, 0.1, 0, 0);
            ps.minSize = 0.08; ps.maxSize = 0.35;
            ps.minLifeTime = 0.12; ps.maxLifeTime = 0.35;
            ps.emitRate = 250; ps.manualEmitCount = 40;
            ps.minEmitPower = 3; ps.maxEmitPower = 7;
            ps.direction1 = new BABYLON.Vector3(-1, 1, -1);
            ps.direction2 = new BABYLON.Vector3(1, 1.5, 1);
            ps.gravity = new BABYLON.Vector3(0, -10, 0);
            ps.start();
            ps.targetStopDuration = 0.18;
            ps.disposeOnStop = true;
        }

        function createSmoke(pos) {
            const s = BABYLON.MeshBuilder.CreateSphere('smoke', { diameter: 0.08 }, scene);
            s.position = pos;
            const mat = new BABYLON.StandardMaterial('smokeMat', scene);
            mat.diffuseColor = new BABYLON.Color3(0.35, 0.35, 0.35);
            mat.alpha = 0.45;
            s.material = mat;

            let life = 0.4;
            const int = setInterval(() => {
                life -= 0.04;
                if (life <= 0) { clearInterval(int); s.dispose(); }
                else { s.scaling.scaleInPlace(1.06); mat.alpha = life; }
            }, 45);
        }

        function createDustPlume(pos) {
            // Create a particle system for dust/dirt kicked up by projectile hitting ground
            const ps = new BABYLON.ParticleSystem('dustPlume', 40, scene);
            ps.particleTexture = new BABYLON.Texture('https://assets.babylonjs.com/textures/flare.png', scene);
            ps.emitter = pos;

            // Brown/tan dust colors
            ps.color1 = new BABYLON.Color4(0.6, 0.5, 0.35, 0.8);
            ps.color2 = new BABYLON.Color4(0.5, 0.4, 0.3, 0.6);
            ps.colorDead = new BABYLON.Color4(0.4, 0.35, 0.25, 0);

            ps.minSize = 0.15;
            ps.maxSize = 0.45;
            ps.minLifeTime = 0.3;
            ps.maxLifeTime = 0.8;

            ps.emitRate = 200;
            ps.manualEmitCount = 25;

            ps.minEmitPower = 1;
            ps.maxEmitPower = 3;

            // Spray upward and outward
            ps.direction1 = new BABYLON.Vector3(-1, 2, -1);
            ps.direction2 = new BABYLON.Vector3(1, 4, 1);

            ps.gravity = new BABYLON.Vector3(0, -6, 0);

            ps.start();
            ps.targetStopDuration = 0.15;
            ps.disposeOnStop = true;
        }

        function triggerDestruction(mech) {
            const pos = mech.pelvis.getAbsolutePosition();
            const mechName = mech.isPlayer ? 'TIMBER WOLF' : 'DIRE WOLF';

            // ========================================
            // SCREEN FLASH - bright orange/white (with guaranteed cleanup)
            // ========================================
            const flashPlane = BABYLON.MeshBuilder.CreatePlane('explosionFlash_' + Date.now(), { size: 100 }, scene);
            flashPlane.position = camera.position.add(camera.getForwardRay().direction.scale(5));
            flashPlane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
            const flashMat = new BABYLON.StandardMaterial('flashMat_' + Date.now(), scene);
            flashMat.emissiveColor = new BABYLON.Color3(1, 0.6, 0.2);
            flashMat.disableLighting = true;
            flashMat.alpha = 0.7;
            flashPlane.material = flashMat;

            // Use requestAnimationFrame for smoother fade and guaranteed cleanup
            const flashStartTime = performance.now();
            const flashDuration = 500; // ms
            function fadeFlash() {
                const elapsed = performance.now() - flashStartTime;
                const progress = elapsed / flashDuration;
                if (progress >= 1 || !flashPlane || flashPlane.isDisposed()) {
                    // Guaranteed cleanup
                    if (flashPlane && !flashPlane.isDisposed()) {
                        flashPlane.dispose();
                    }
                    if (flashMat && !flashMat.isDisposed) {
                        flashMat.dispose();
                    }
                    return;
                }
                flashMat.alpha = 0.7 * (1 - progress);
                requestAnimationFrame(fadeFlash);
            }
            requestAnimationFrame(fadeFlash);

            // Failsafe: force dispose after 1 second no matter what
            setTimeout(() => {
                if (flashPlane && !flashPlane.isDisposed()) {
                    flashPlane.dispose();
                }
            }, 1000);

            // ========================================
            // CAMERA SHAKE
            // ========================================
            const originalCamPos = camera.position.clone();
            let shakeTime = 0;
            const shakeInterval = setInterval(() => {
                shakeTime += 30;
                if (shakeTime > 1500) {
                    clearInterval(shakeInterval);
                    camera.position = originalCamPos;
                } else {
                    const intensity = 0.5 * (1 - shakeTime / 1500);
                    camera.position = originalCamPos.add(new BABYLON.Vector3(
                        (Math.random() - 0.5) * intensity,
                        (Math.random() - 0.5) * intensity * 0.5,
                        (Math.random() - 0.5) * intensity
                    ));
                }
            }, 30);

            // ========================================
            // MASSIVE CHAIN EXPLOSIONS
            // ========================================
            // Initial big explosion at center
            for (let i = 0; i < 3; i++) {
                createImpact(pos.clone(), new BABYLON.Color3(1, 0.4, 0));
            }

            // Ring of explosions spreading outward
            for (let i = 0; i < 16; i++) {
                setTimeout(() => {
                    const angle = (Math.PI * 2 * i) / 16;
                    const dist = 1.5 + Math.random() * 1.5;
                    createImpact(pos.add(new BABYLON.Vector3(
                        Math.cos(angle) * dist,
                        Math.random() * 2,
                        Math.sin(angle) * dist * 0.5
                    )), Math.random() > 0.5 ? COLORS.thruster : new BABYLON.Color3(1, 0.6, 0));
                }, i * 60);
            }

            // Delayed secondary explosions
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    createImpact(pos.add(new BABYLON.Vector3(
                        (Math.random() - 0.5) * 4,
                        Math.random() * 3,
                        (Math.random() - 0.5) * 2
                    )), new BABYLON.Color3(1, 0.3 + Math.random() * 0.4, 0));
                }, 500 + i * 100);
            }

            // ========================================
            // MAKE MECH COLLAPSE DRAMATICALLY
            // ========================================
            // Mark as destroyed so state machine and AI don't interfere
            mech.isDestroyed = true;
            mech.destroyedTimer = 0;  // Track time since destruction for friction ramping
            mech.mechState = MechState.RAGDOLL;
            mech.ai.enabled = false;
            mech.isWalking = false;

            const body = mech.pelvisAggregate.body;

            // HYBRID: Switch to DYNAMIC mode so physics can take over for dramatic fall
            body.setMotionType(BABYLON.PhysicsMotionType.DYNAMIC);

            // Set proper mass and very low damping for dramatic physics
            body.setMassProperties({ mass: mech.stats.mass || 75 });
            body.setLinearDamping(0.05);
            body.setAngularDamping(0.1);

            // Get the impact direction from the last damage
            const impactDir = mech.impactDirection || new BABYLON.Vector3(1, 0, 0);

            // Inherit velocity from kinematic movement
            const inheritedVel = mech.lastKinematicVelocity || new BABYLON.Vector3(0, 0, 0);
            body.setLinearVelocity(inheritedVel);

            // DRAMATIC EXPLOSION KNOCKBACK - 5x impulse for massive launch
            const explosionForce = impactDir.scale(-400);  // 5x: Away from impact direction
            explosionForce.y = 300 + Math.random() * 200;    // 5x: Strong upward lift
            explosionForce.x += (Math.random() - 0.5) * 150;
            explosionForce.z += (Math.random() - 0.5) * 100;

            body.applyImpulse(explosionForce, pos);

            // No spinning - just let physics handle natural tumbling
            const fallDirection = (Math.random() > 0.5) ? 1 : -1;

            // DRAMATIC LIMB FLINGING - 5x force for limbs
            const destructionHitForce = impactDir.scale(300);
            destructionHitForce.y = 150;
            flingLimbs(mech, destructionHitForce);

            // Additional limb chaos for destruction - more extreme than normal ragdoll
            destroyedLimbChaos(mech);

            // Continue applying downward force to ensure it falls
            let collapseTime = 0;
            const collapseInterval = setInterval(() => {
                collapseTime += 50;
                if (collapseTime > 1200 || !mech.pelvisAggregate.body) {
                    clearInterval(collapseInterval);
                    return;
                }
                // Just downward force, no spinning
                body.applyImpulse(
                    new BABYLON.Vector3(0, -15, 0),
                    mech.pelvis.getAbsolutePosition()
                );
            }, 50);

            log(`ððð ${mech.name} HAS BEEN DESTROYED! ððð`, 'error');
        }

        // ============================================
        // CONTROLS
        // ============================================
        function toggleWalking(isPlayer) {
            const mech = isPlayer ? playerMech : enemyMech;
            if (!mech) return;
            mech.isWalking = !mech.isWalking;
            log(`${mech.name} ${mech.isWalking ? 'walking' : 'stopped'}`);
        }

        function resetScene() {
            // Disable AI battle mode
            autoFireEnabled = false;
            battleEnded = false;
            const btn = document.getElementById('autoFireBtn');
            btn.textContent = 'AI Battle: OFF';
            btn.style.background = 'rgba(255, 200, 0, 0.3)';
            btn.style.borderColor = '#ffcc00';
            btn.style.color = '#ffcc00';

            // Starting positions for each team (4 mechs per side)
            const playerPositions = [
                { x: -7, y: 3.5, z: 0 },
                { x: -8, y: 3.0, z: 2 },
                { x: -10, y: 3.2, z: 4 },
                { x: -10, y: 3.0, z: -3 }
            ];
            const enemyPositions = [
                { x: 7, y: 3.8, z: 0 },
                { x: 8, y: 3.0, z: -2 },
                { x: 10, y: 3.2, z: 4 },
                { x: 10, y: 3.0, z: -3 }
            ];

            // Reset player mechs
            playerMechs.forEach((mech, i) => {
                if (!mech) return;
                const pos = playerPositions[i] || playerPositions[0];
                mech.pelvis.position = new BABYLON.Vector3(pos.x, pos.y, pos.z);
                // HYBRID: Reset to ANIMATED mode for kinematic walking
                mech.pelvisAggregate.body.setMotionType(BABYLON.PhysicsMotionType.ANIMATED);
                mech.pelvisAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                mech.pelvisAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());
                mech.pelvisAggregate.body.setAngularDamping(STABILITY_CONFIG.mechAngularDamping);
                mech.pelvisAggregate.body.setLinearDamping(STABILITY_CONFIG.mechLinearDamping);
                mech.currentHP = mech.maxHP;
                mech.isWalking = false;
                mech.isDestroyed = false;
                mech.destroyedTimer = 0;
                // HYBRID state reset
                mech.mechState = MechState.WALKING;
                mech.stability = STABILITY_CONFIG.maxStability;
                mech.ragdollSettleTimer = 0;
                mech.recoveryTimer = 0;
                mech.flinchIntensity = 0;
                mech.lastKinematicVelocity = new BABYLON.Vector3(0, 0, 0);
                mech.impactRecovery = 0;
                mech.recoilRecovery = 0;
                mech.torso.rotation.setAll(0);
                mech.ai.enabled = false;
                mech.ai.state = 'idle';
                mech.ai.target = null;
                mech.ai.lastDecision = 0;
                mech.ai.strafeDir = 0;
                mech.ai.strafeEndTime = 0;
                mech.ai.strafeAmount = 0;
                mech.ai.desiredYawError = 0;
            });

            // Reset enemy mechs
            enemyMechs.forEach((mech, i) => {
                if (!mech) return;
                const pos = enemyPositions[i] || enemyPositions[0];
                mech.pelvis.position = new BABYLON.Vector3(pos.x, pos.y, pos.z);
                // HYBRID: Reset to ANIMATED mode for kinematic walking
                mech.pelvisAggregate.body.setMotionType(BABYLON.PhysicsMotionType.ANIMATED);
                mech.pelvisAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                mech.pelvisAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());
                mech.pelvisAggregate.body.setAngularDamping(STABILITY_CONFIG.mechAngularDamping);
                mech.pelvisAggregate.body.setLinearDamping(STABILITY_CONFIG.mechLinearDamping);
                mech.currentHP = mech.maxHP;
                mech.isWalking = false;
                mech.isDestroyed = false;
                mech.destroyedTimer = 0;
                // HYBRID state reset
                mech.mechState = MechState.WALKING;
                mech.stability = STABILITY_CONFIG.maxStability;
                mech.ragdollSettleTimer = 0;
                mech.recoveryTimer = 0;
                mech.flinchIntensity = 0;
                mech.lastKinematicVelocity = new BABYLON.Vector3(0, 0, 0);
                mech.impactRecovery = 0;
                mech.recoilRecovery = 0;
                mech.torso.rotation.setAll(0);
                mech.ai.enabled = false;
                mech.ai.state = 'idle';
                mech.ai.target = null;
                mech.ai.lastDecision = 0;
                mech.ai.strafeDir = 0;
                mech.ai.strafeEndTime = 0;
                mech.ai.strafeAmount = 0;
                mech.ai.desiredYawError = 0;
            });

            projectiles.forEach(p => p.mesh.dispose());
            projectiles = [];
            beams.forEach(b => b.mesh.dispose());
            beams = [];

            // Reset cooldowns for all mechs
            Object.keys(mechCooldowns).forEach(key => {
                mechCooldowns[key] = { erlaser: 0, lrm: 0, ac: 0 };
            });

            log('Scene reset');
        }

        // ============================================
        // RETURN TO LOADOUT
        // ============================================
        function returnToLoadout() {
            // Clear the battle config
            localStorage.removeItem('battleConfig');

            // If running in an iframe, notify parent window
            if (window.parent !== window) {
                window.parent.postMessage({ type: 'battleEnd' }, '*');
            } else {
                // Navigate back to the loadout screen (standalone mode)
                window.location.href = 'test-babylon-havok.html';
            }
        }

        // ============================================
        // AI BATTLE SYSTEM
        // ============================================
        function toggleAutoFire() {
            autoFireEnabled = !autoFireEnabled;
            const btn = document.getElementById('autoFireBtn');

            if (autoFireEnabled) {
                btn.textContent = 'AI Battle: ON';
                btn.style.background = 'rgba(0, 255, 136, 0.4)';
                btn.style.borderColor = '#00ff88';
                btn.style.color = '#00ff88';
                battleEnded = false;  // Allow AI loop to run again
                log('AI ENABLED - mechs will fight autonomously!');

                // Clear debug logs for fresh start
                debugLogs.length = 0;
                lastDebugTime = 0;
                dbg('=== AI BATTLE STARTED ===', 'ai');

                // Enable AI on all mechs with proper initialization
                allMechs.forEach(mech => {
                    if (!mech || mech.isDestroyed) return;
                    mech.ai.enabled = true;
                    // Melee mechs start charging immediately!
                    mech.ai.state = mech.isMelee ? 'charging' : 'advancing';
                    mech.ai.target = findNewTarget(mech);  // Find initial target
                    mech.ai.lastDecision = gameTime;
                    mech.isWalking = true;
                    mech.walkDirection = mech.isPlayer ? 1 : -1;
                    dbg(`${mech.name} init: ai.enabled=${mech.ai.enabled} state=${mech.ai.state} target=${mech.ai.target?.name}`, 'ai');
                });

                log(`Battle started: ${playerMechs.length} vs ${enemyMechs.length} mechs!`);
            } else {
                btn.textContent = 'AI Battle: OFF';
                btn.style.background = 'rgba(255, 200, 0, 0.3)';
                btn.style.borderColor = '#ffcc00';
                btn.style.color = '#ffcc00';
                battleEnded = true;  // Stop the AI loop
                log('AI DISABLED');

                // Disable AI on all mechs
                allMechs.forEach(mech => {
                    if (!mech) return;
                    mech.ai.enabled = false;
                    mech.ai.state = 'idle';
                    mech.isWalking = false;
                });
            }
        }

        // ============================================
        // CINEMATIC CAMERA SYSTEM
        // ============================================
        function toggleCinematicCamera() {
            cinematicEnabled = !cinematicEnabled;
            const btn = document.getElementById('cinematicBtn');

            if (cinematicEnabled) {
                btn.textContent = 'Cinematic: ON';
                btn.style.background = 'rgba(136, 100, 255, 0.4)';
                btn.style.borderColor = '#8864ff';
                btn.style.color = '#8864ff';

                // Detach regular camera controls
                camera.detachControl();

                // Initialize cinematic state
                cinematicState.mode = 'sweep';
                cinematicState.transitionTime = 0;
                cinematicState.orbitAngle = camera.alpha;
                cinematicState.sweepPhase = 0;

                // Pick a random alive mech to start tracking
                const aliveMechs = allMechs.filter(m => m && !m.isDestroyed);
                if (aliveMechs.length > 0) {
                    cinematicState.target = aliveMechs[Math.floor(Math.random() * aliveMechs.length)];
                }

                log('Cinematic camera ENABLED');
            } else {
                btn.textContent = 'Cinematic: OFF';
                btn.style.background = 'rgba(0, 255, 136, 0.2)';
                btn.style.borderColor = '#00ff88';
                btn.style.color = '#00ff88';

                // Re-attach regular camera controls
                camera.attachControl(document.getElementById('renderCanvas'), true);
                log('Cinematic camera DISABLED');
            }
        }

        function triggerCinematicAction(mech, actionType) {
            // Called when interesting action happens (weapon fire, damage, destruction)
            if (!cinematicEnabled) return;

            cinematicState.actionTarget = mech;
            cinematicState.actionTime = gameTime;

            // Switch to action mode if the action is interesting enough
            if (actionType === 'fire' && Math.random() < 0.3) {
                cinematicState.mode = 'action';
                cinematicState.target = mech;
                cinematicState.transitionTime = 0;
                cinematicState.modeDuration = 2;  // Quick action shot
            } else if (actionType === 'damage' && Math.random() < 0.4) {
                cinematicState.mode = 'track';
                cinematicState.target = mech;
                cinematicState.transitionTime = 0;
                cinematicState.modeDuration = 3;
            }
        }

        function updateCinematicCamera(dt) {
            if (!cinematicEnabled) return;

            const state = cinematicState;
            state.transitionTime += dt;

            // Get alive mechs
            const aliveMechs = allMechs.filter(m => m && !m.isDestroyed);
            if (aliveMechs.length === 0) return;

            // Make sure target is still valid
            if (!state.target || state.target.isDestroyed) {
                state.target = aliveMechs[Math.floor(Math.random() * aliveMechs.length)];
            }

            // Mode transitions
            if (state.transitionTime > state.modeDuration) {
                state.transitionTime = 0;

                // Pick next mode with weighted random
                const roll = Math.random();
                if (roll < 0.35) {
                    state.mode = 'orbit';
                    state.modeDuration = 5 + Math.random() * 3;
                    state.orbitRadius = 10 + Math.random() * 8;
                    state.orbitHeight = 5 + Math.random() * 6;
                } else if (roll < 0.6) {
                    state.mode = 'track';
                    state.modeDuration = 4 + Math.random() * 2;
                    // Pick a new random target
                    state.target = aliveMechs[Math.floor(Math.random() * aliveMechs.length)];
                } else if (roll < 0.85) {
                    state.mode = 'sweep';
                    state.modeDuration = 6 + Math.random() * 4;
                    state.sweepPhase = 0;
                } else {
                    state.mode = 'action';
                    state.modeDuration = 3 + Math.random() * 2;
                    // Find mech with most enemies nearby for action shot
                    let bestMech = state.target;
                    let maxEnemies = 0;
                    aliveMechs.forEach(mech => {
                        const enemies = aliveMechs.filter(m => m.isPlayer !== mech.isPlayer);
                        let nearby = 0;
                        enemies.forEach(e => {
                            const d = BABYLON.Vector3.Distance(mech.pelvis.getAbsolutePosition(), e.pelvis.getAbsolutePosition());
                            if (d < 15) nearby++;
                        });
                        if (nearby > maxEnemies) {
                            maxEnemies = nearby;
                            bestMech = mech;
                        }
                    });
                    state.target = bestMech;
                }
            }

            // Calculate camera position based on mode
            let targetPos = state.target.pelvis.getAbsolutePosition();
            let cameraPos;
            let lookAt;

            switch (state.mode) {
                case 'orbit':
                    // Smooth orbit around target
                    state.orbitAngle += dt * 0.4;  // Slow rotation
                    cameraPos = new BABYLON.Vector3(
                        targetPos.x + Math.cos(state.orbitAngle) * state.orbitRadius,
                        targetPos.y + state.orbitHeight,
                        targetPos.z + Math.sin(state.orbitAngle) * state.orbitRadius
                    );
                    lookAt = targetPos.add(new BABYLON.Vector3(0, 2, 0));
                    break;

                case 'track':
                    // Over-the-shoulder tracking shot
                    const forward = state.target.pelvis.getDirection(BABYLON.Vector3.Forward());
                    const right = state.target.pelvis.getDirection(BABYLON.Vector3.Right());
                    cameraPos = targetPos
                        .add(forward.scale(-4))  // Behind
                        .add(right.scale(2))     // To the side
                        .add(new BABYLON.Vector3(0, 3.5, 0));  // Above
                    // Look at target's front
                    lookAt = targetPos.add(forward.scale(5)).add(new BABYLON.Vector3(0, 2.5, 0));
                    break;

                case 'sweep':
                    // Panoramic sweep across the battlefield
                    state.sweepPhase += dt * 0.15;
                    const sweepAngle = state.sweepPhase * Math.PI * 2;
                    const sweepRadius = 18 + Math.sin(state.sweepPhase * 2) * 5;
                    const sweepHeight = 8 + Math.sin(state.sweepPhase * 3) * 4;
                    cameraPos = new BABYLON.Vector3(
                        Math.cos(sweepAngle) * sweepRadius,
                        sweepHeight,
                        Math.sin(sweepAngle) * sweepRadius * 0.5
                    );
                    // Look at battle center or nearest mech
                    lookAt = new BABYLON.Vector3(0, 3, 0);
                    break;

                case 'action':
                    // Low dramatic angle looking up at target
                    const actionForward = state.target.pelvis.getDirection(BABYLON.Vector3.Forward());
                    const actionRight = state.target.pelvis.getDirection(BABYLON.Vector3.Right());
                    const actionSide = Math.sin(state.transitionTime * 2) > 0 ? 1 : -1;
                    cameraPos = targetPos
                        .add(actionForward.scale(3))
                        .add(actionRight.scale(3 * actionSide))
                        .add(new BABYLON.Vector3(0, 1.5, 0));  // Low angle
                    lookAt = targetPos.add(new BABYLON.Vector3(0, 3.5, 0));  // Look up at torso
                    break;
            }

            // Smooth camera movement
            const smoothFactor = 1 - Math.pow(0.1, dt);
            camera.position = BABYLON.Vector3.Lerp(camera.position, cameraPos, smoothFactor);

            // Update camera target using setTarget for smooth look
            const currentTarget = camera.target;
            camera.setTarget(BABYLON.Vector3.Lerp(currentTarget, lookAt, smoothFactor));
        }

        function checkBattleEnd() {
            if (battleEnded) return;  // Already ended
            if (!autoFireEnabled) return;

            // Check if either team is eliminated
            const alivePlayerMechs = getAliveMechs('player');
            const aliveEnemyMechs = getAliveMechs('enemy');

            if (alivePlayerMechs.length === 0 || aliveEnemyMechs.length === 0) {
                battleEnded = true;  // Mark as ended (AI already disabled in triggerDestruction)

                const playerWon = alivePlayerMechs.length > 0;
                const winner = playerWon ? 'PLAYER TEAM' : 'ENEMY TEAM';
                log(`Battle ended! ${winner} WINS!`, 'warn');

                // Delay UI update to allow destruction animation to play
                setTimeout(() => {
                    autoFireEnabled = false;
                    const btn = document.getElementById('autoFireBtn');
                    btn.textContent = 'AI Battle: OFF';
                    btn.style.background = 'rgba(255, 200, 0, 0.3)';
                    btn.style.borderColor = '#ffcc00';
                    btn.style.color = '#ffcc00';

                    // Show victory/defeat overlay
                    showBattleResult(playerWon);
                }, 3000);  // 3 second delay to watch destruction
            }
        }

        function showBattleResult(playerWon) {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.id = 'battleResultOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0, 0, 0, 0.85);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 1000;
            `;

            const resultText = playerWon ? 'VICTORY!' : 'DEFEAT';
            const resultColor = playerWon ? '#00ff88' : '#ff4444';

            overlay.innerHTML = `
                <div style="font-size: 72px; font-weight: bold; color: ${resultColor}; text-shadow: 0 0 30px ${resultColor}; margin-bottom: 30px;">
                    ${resultText}
                </div>
                <div style="font-size: 24px; color: #aaa; margin-bottom: 50px;">
                    ${playerWon ? 'All enemy mechs destroyed!' : 'Your mech was destroyed!'}
                </div>
                <button id="continueToSalvageBtn" style="
                    padding: 15px 40px;
                    font-size: 20px;
                    background: rgba(0, 255, 136, 0.2);
                    border: 2px solid #00ff88;
                    color: #00ff88;
                    cursor: pointer;
                    border-radius: 8px;
                    font-family: monospace;
                ">Continue to Salvage â</button>
            `;

            document.body.appendChild(overlay);

            // Handle continue button
            document.getElementById('continueToSalvageBtn').addEventListener('click', () => {
                // Generate salvage rewards
                const rewards = generateSalvageRewards(playerWon);

                // Send to parent with rewards
                if (window.parent !== window) {
                    window.parent.postMessage({
                        type: 'battleEnd',
                        result: playerWon ? 'victory' : 'defeat',
                        rewards: rewards
                    }, '*');
                } else {
                    // Standalone mode
                    localStorage.setItem('battleRewards', JSON.stringify(rewards));
                    window.location.href = 'test-babylon-havok.html';
                }
            });
        }

        function generateSalvageRewards(playerWon) {
            const rewards = {
                xp: 0,
                scrap: 0,
                components: []
            };

            if (playerWon) {
                // Victory rewards
                rewards.xp = 50 + Math.floor(Math.random() * 50);  // 50-100 XP
                rewards.scrap = 100 + Math.floor(Math.random() * 150);  // 100-250 scrap

                // 30% chance for a component
                if (Math.random() < 0.3) {
                    const componentIds = ['railgun_mk1', 'laser_array', 'armor_plate', 'reactor_core', 'targeting_computer', 'heat_sink'];
                    const randomComponent = componentIds[Math.floor(Math.random() * componentIds.length)];
                    rewards.components.push(randomComponent);
                }
            } else {
                // Defeat rewards (consolation)
                rewards.xp = 10 + Math.floor(Math.random() * 20);  // 10-30 XP
                rewards.scrap = 25 + Math.floor(Math.random() * 50);  // 25-75 scrap
            }

            return rewards;
        }

        function updateUI() {
            // Triangle count
            const triCount = document.getElementById('triCount');
            if (triCount && scene) {
                triCount.textContent = scene.getActiveIndices() / 3 | 0;
            }

            // Calculate team HP totals
            let playerTotalHP = 0, playerMaxHP = 0, playerAlive = 0;
            let enemyTotalHP = 0, enemyMaxHP = 0, enemyAlive = 0;

            playerMechs.forEach(mech => {
                if (!mech) return;
                playerMaxHP += mech.maxHP;
                playerTotalHP += Math.max(0, mech.currentHP);
                if (mech.currentHP > 0 && !mech.isDestroyed) playerAlive++;
            });

            enemyMechs.forEach(mech => {
                if (!mech) return;
                enemyMaxHP += mech.maxHP;
                enemyTotalHP += Math.max(0, mech.currentHP);
                if (mech.currentHP > 0 && !mech.isDestroyed) enemyAlive++;
            });

            // Player team status
            if (playerMaxHP > 0) {
                document.getElementById('playerHP').style.width = (playerTotalHP / playerMaxHP * 100) + '%';
                document.getElementById('playerHPText').textContent = `Team HP: ${playerTotalHP}/${playerMaxHP} (${playerAlive} alive)`;

                let stateText = playerAlive === 0 ? 'ELIMINATED' : `${playerAlive} mechs fighting`;
                document.getElementById('playerState').textContent = stateText;
            }

            // Enemy team status
            if (enemyMaxHP > 0) {
                document.getElementById('enemyHP').style.width = (enemyTotalHP / enemyMaxHP * 100) + '%';
                document.getElementById('enemyHPText').textContent = `Team HP: ${enemyTotalHP}/${enemyMaxHP} (${enemyAlive} alive)`;

                let stateText = enemyAlive === 0 ? 'ELIMINATED' : `${enemyAlive} mechs fighting`;
                document.getElementById('enemyState').textContent = stateText;
            }
        }

        initEngine();
    </script>
</body>
</html>
