<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon.js + Havok Physics Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            font-family: monospace;
            color: #00ff88;
            overflow: auto;
            min-height: 100vh;
        }
        #renderCanvas {
            width: 100%;
            max-width: 900px;
            height: 50vh;
            max-height: 350px;
            display: block;
            margin: 0 auto;
            border: 3px solid #00ff88;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }
        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }
        #status {
            max-width: 900px;
            margin: 20px auto;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #00ff88;
            border-radius: 8px;
        }
        .log {
            font-size: 12px;
            margin: 2px 0;
            padding: 2px 5px;
        }
        .log.info { color: #00ff88; }
        .log.warn { color: #ffaa00; }
        .log.error { color: #ff4444; }
    </style>
</head>
<body>
    <h1>Babylon.js + Havok Physics Test</h1>
    <div style="text-align: center; margin: 10px;">
        <button id="toggleAutoFire" style="padding: 10px 20px; font-size: 16px; background: #00ff88; border: none; border-radius: 5px; cursor: pointer;">
            Start Auto-Fire
        </button>
    </div>
    <canvas id="renderCanvas"></canvas>
    <div id="status">
        <div id="logs"></div>
    </div>

    <!-- Babylon.js Core -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <!-- Havok Physics -->
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>

    <script>
        // Logging system
        const logs = [];
        function log(msg, type = 'info') {
            console.log(msg);
            logs.push({ msg, type });
            const logsDiv = document.getElementById('logs');
            logsDiv.innerHTML = logs.slice(-15).map(l =>
                `<div class="log ${l.type}">${l.msg}</div>`
            ).join('');
        }

        log('Initializing Babylon.js + Havok Physics...', 'info');

        // Global references
        let engine, scene, camera, havokInstance, havokPlugin;
        let playerMech, enemyMech;
        let projectiles = [];
        let laserBeams = [];
        let autoFireEnabled = false;
        let autoFireInterval = null;

        // Colors
        const COLORS = {
            player: new BABYLON.Color3(0, 1, 0.53),     // #00ff88
            enemy: new BABYLON.Color3(1, 0.27, 0.27),   // #ff4444
            ground: new BABYLON.Color3(0.29, 0.29, 0.42), // #4a4a6a
            projectile: new BABYLON.Color3(1, 0.67, 0),  // #ffaa00
            laser: new BABYLON.Color3(1, 0, 0),          // Red
            explosion: new BABYLON.Color3(1, 0.4, 0)     // #ff6600
        };

        // Initialize Babylon.js and Havok
        async function initEngine() {
            const canvas = document.getElementById('renderCanvas');

            // Create Babylon engine (it will handle WebGL internally)
            try {
                engine = new BABYLON.Engine(canvas, true, {
                    preserveDrawingBuffer: true,
                    stencil: true
                });
                log('Babylon Engine created', 'info');
            } catch (error) {
                log('ERROR: Failed to create Babylon engine (WebGL may not be supported): ' + error.message, 'error');
                return;
            }

            log(`Canvas element CSS size: ${canvas.clientWidth}x${canvas.clientHeight}`, 'info');
            log(`Canvas buffer size: ${canvas.width}x${canvas.height}`, 'info');
            log(`Engine rendering size: ${engine.getRenderWidth()}x${engine.getRenderHeight()}`, 'info');

            // Initialize Havok Physics
            try {
                havokInstance = await HavokPhysics();
                log('Havok Physics initialized!', 'info');
            } catch (error) {
                log('Failed to load Havok: ' + error.message, 'error');
                return;
            }

            // Create scene
            scene = createScene();

            // Start render loop
            // CRITICAL FIX DOCUMENTATION:
            // The update functions (especially stabilizeMechs) MUST be wrapped in try-catch.
            // Without this, errors during mech initialization (accessing undefined physics properties)
            // would silently kill the entire render loop, causing a gray screen with no rendering.
            // The try-catch allows the render loop to continue even if update functions throw errors.
            let frameCount = 0;
            let diagnosticsLogged = false;
            let firstFrameLogged = false;

            log('Starting render loop...', 'error');

            engine.runRenderLoop(() => {
                if (!firstFrameLogged) {
                    log('RENDER LOOP FRAME 1 EXECUTING', 'error');
                    firstFrameLogged = true;
                }

                if (scene) {
                    try {
                        scene.render();
                    } catch (e) {
                        log(`ERROR in scene.render(): ${e.message}`, 'error');
                        console.error(e);
                    }

                    frameCount++;

                    // Log diagnostics immediately at frame 10 (about 0.16 seconds)
                    if (frameCount === 10 && !diagnosticsLogged) {
                        diagnosticsLogged = true;
                        log(`=== RENDER DIAGNOSTICS (Frame ${frameCount}) ===`, 'error');
                        log(`Active meshes: ${scene.getActiveMeshes().length} / Total: ${scene.meshes.length}`, 'error');
                        log(`Draw calls: ${scene.getEngine().drawCalls}`, 'error');
                    }

                    try {
                        // Update walking animations
                        const deltaTime = engine.getDeltaTime() / 1000;
                        if (playerMech) updateMechWalking(playerMech, deltaTime);
                        if (enemyMech) updateMechWalking(enemyMech, deltaTime);

                        updateProjectiles();
                        updateLaserBeams();
                        debugMechPositions();
                    } catch (e) {
                        if (!diagnosticsLogged) {
                            log(`ERROR in update functions: ${e.message}`, 'error');
                            console.error(e);
                            diagnosticsLogged = true;
                        }
                    }
                } else {
                    if (!diagnosticsLogged) {
                        log('ERROR: scene is null/undefined in render loop!', 'error');
                        diagnosticsLogged = true;
                    }
                }
            });

            // Handle resize
            window.addEventListener('resize', () => engine.resize());

            log('Scene created and render loop started!', 'info');
        }

        function createScene() {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.05, 0.05, 0.12); // Dark background

            // Create Havok physics plugin
            havokPlugin = new BABYLON.HavokPlugin(true, havokInstance);
            scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), havokPlugin);
            log('Physics enabled with Havok', 'info');

            // Create camera - fixed isometric-style view
            camera = new BABYLON.ArcRotateCamera(
                'camera',
                -Math.PI / 2,  // Alpha (horizontal rotation)
                Math.PI / 4,   // Beta (vertical angle - 45 degree isometric)
                25,            // Radius - increased from 18 to see more
                new BABYLON.Vector3(0, 3, 0), // Target
                scene
            );
            camera.attachControl(document.getElementById('renderCanvas'), true);
            camera.lowerRadiusLimit = 5;
            camera.upperRadiusLimit = 50;

            // Ensure proper clipping planes
            camera.minZ = 0.1;
            camera.maxZ = 1000;

            // Lighting - make it much brighter
            const hemisphericLight = new BABYLON.HemisphericLight(
                'hemiLight',
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            hemisphericLight.intensity = 2.0; // Very bright

            // Create ground
            createGround(scene);

            // Create boundary walls
            createWalls(scene);

            // Create mechs (spawned at x position, they will drop to ground)
            try {
                playerMech = createMech(scene, -5, true);
                enemyMech = createMech(scene, 5, false);
                log('Scene fully initialized with mechs!', 'info');

                // DEBUG: Log scene info
                log(`Scene has ${scene.meshes.length} meshes`, 'warn');
                log(`Scene has ${scene.lights.length} lights`, 'warn');
                log(`Camera alpha: ${camera.alpha.toFixed(2)}, beta: ${camera.beta.toFixed(2)}, radius: ${camera.radius.toFixed(2)}`, 'warn');
                log(`Camera position: ${camera.position.toString()}`, 'warn');
                log(`Camera target: ${camera.target.toString()}`, 'warn');

                // List all meshes
                scene.meshes.forEach(mesh => {
                    log(`Mesh: ${mesh.name} at ${mesh.position.toString()}, visible: ${mesh.isVisible}`, 'info');
                });
            } catch (error) {
                log('CRITICAL ERROR creating mechs: ' + error.message, 'error');
                console.error('Full error:', error);
            }
            return scene;
        }

        function createGround(scene) {
            const ground = BABYLON.MeshBuilder.CreateGround('ground', {
                width: 30,
                height: 15
            }, scene);

            const groundMat = new BABYLON.StandardMaterial('groundMat', scene);
            groundMat.diffuseColor = COLORS.ground;
            groundMat.emissiveColor = COLORS.ground.scale(0.3); // Add emission for visibility
            groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            ground.material = groundMat;

            // Add physics to ground (static body)
            const groundAggregate = new BABYLON.PhysicsAggregate(
                ground,
                BABYLON.PhysicsShapeType.BOX,
                { mass: 0, friction: 0.8, restitution: 0.1 },
                scene
            );

            // Set collision group (group 4 = ground)
            groundAggregate.shape.filterMembershipMask = 4;
            groundAggregate.shape.filterCollideMask = 1 | 2; // Collide with mechs and projectiles

            log('Ground created with physics', 'info');
            return ground;
        }

        function createWalls(scene) {
            // Create invisible boundary walls
            const wallHeight = 8;
            const wallThickness = 1;
            const arenaWidth = 30;
            const arenaDepth = 15;

            const wallMat = new BABYLON.StandardMaterial('wallMat', scene);
            wallMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.4);
            wallMat.alpha = 0.3;

            // Left wall
            const leftWall = BABYLON.MeshBuilder.CreateBox('leftWall', {
                width: wallThickness, height: wallHeight, depth: arenaDepth
            }, scene);
            leftWall.position = new BABYLON.Vector3(-arenaWidth/2, wallHeight/2, 0);
            leftWall.material = wallMat;
            new BABYLON.PhysicsAggregate(leftWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

            // Right wall
            const rightWall = BABYLON.MeshBuilder.CreateBox('rightWall', {
                width: wallThickness, height: wallHeight, depth: arenaDepth
            }, scene);
            rightWall.position = new BABYLON.Vector3(arenaWidth/2, wallHeight/2, 0);
            rightWall.material = wallMat;
            new BABYLON.PhysicsAggregate(rightWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

            // Front wall
            const frontWall = BABYLON.MeshBuilder.CreateBox('frontWall', {
                width: arenaWidth, height: wallHeight, depth: wallThickness
            }, scene);
            frontWall.position = new BABYLON.Vector3(0, wallHeight/2, arenaDepth/2);
            frontWall.material = wallMat;
            new BABYLON.PhysicsAggregate(frontWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

            // Back wall
            const backWall = BABYLON.MeshBuilder.CreateBox('backWall', {
                width: arenaWidth, height: wallHeight, depth: wallThickness
            }, scene);
            backWall.position = new BABYLON.Vector3(0, wallHeight/2, -arenaDepth/2);
            backWall.material = wallMat;
            new BABYLON.PhysicsAggregate(backWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

            log('Boundary walls created', 'info');
        }

        function createMech(scene, xPos, isPlayer) {
            try {
                const color = isPlayer ? COLORS.player : COLORS.enemy;
                const mechName = isPlayer ? 'player' : 'enemy';

                log(`Creating ${mechName} mech with SKELETON...`, 'warn');

                // Create parent transform node
                const mechRoot = new BABYLON.TransformNode(`${mechName}_root`, scene);
                mechRoot.position = new BABYLON.Vector3(xPos, 0, 0);

                // Create materials
                const bodyMat = new BABYLON.StandardMaterial(`${mechName}_bodyMat`, scene);
                bodyMat.diffuseColor = color;
                bodyMat.emissiveColor = color.scale(0.5);

                const darkMat = new BABYLON.StandardMaterial(`${mechName}_darkMat`, scene);
                darkMat.diffuseColor = color.scale(0.5);
                darkMat.emissiveColor = color.scale(0.3);

                const veryDarkMat = new BABYLON.StandardMaterial(`${mechName}_veryDarkMat`, scene);
                veryDarkMat.diffuseColor = color.scale(0.3);
                veryDarkMat.emissiveColor = color.scale(0.15);

                const jointMat = new BABYLON.StandardMaterial(`${mechName}_jointMat`, scene);
                jointMat.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8);
                jointMat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);

                const spawnY = 2.5;

                // === CREATE SKELETON ===
                const skeleton = new BABYLON.Skeleton(`${mechName}Skeleton`, `${mechName}`, scene);

                // Root bone (at mech base)
                const rootBone = new BABYLON.Bone("root", skeleton);
                const rootMatrix = BABYLON.Matrix.Translation(0, 0, 0);
                rootBone.setBindPose(rootMatrix);
                rootBone.setAbsolutePosition(new BABYLON.Vector3(xPos, 0, 0), scene);

                // Torso bone (main body)
                const torsoBone = new BABYLON.Bone("torso", skeleton, rootBone);
                const torsoMatrix = BABYLON.Matrix.Translation(0, spawnY, 0);
                torsoBone.setBindPose(torsoMatrix);

                log(`Skeleton created: ${skeleton.bones.length} bones`, 'info');

                // Right arm bones
                const rightShoulderBone = new BABYLON.Bone("rightShoulder", skeleton, torsoBone);
                const rightShoulderMatrix = BABYLON.Matrix.Translation(0.9, 0.65, 0); // Relative to torso
                rightShoulderBone.setBindPose(rightShoulderMatrix);

                const rightArmBone = new BABYLON.Bone("rightArm", skeleton, rightShoulderBone);
                const rightArmMatrix = BABYLON.Matrix.Translation(0, -0.3, 0); // Relative to shoulder, down
                rightArmBone.setBindPose(rightArmMatrix);

                const rightForearmBone = new BABYLON.Bone("rightForearm", skeleton, rightArmBone);
                const rightForearmMatrix = BABYLON.Matrix.Translation(0, -0.4, 0); // Relative to arm
                rightForearmBone.setBindPose(rightForearmMatrix);

                // Left arm bones (mirror of right)
                const leftShoulderBone = new BABYLON.Bone("leftShoulder", skeleton, torsoBone);
                const leftShoulderMatrix = BABYLON.Matrix.Translation(-0.9, 0.65, 0);
                leftShoulderBone.setBindPose(leftShoulderMatrix);

                const leftArmBone = new BABYLON.Bone("leftArm", skeleton, leftShoulderBone);
                const leftArmMatrix = BABYLON.Matrix.Translation(0, -0.3, 0);
                leftArmBone.setBindPose(leftArmMatrix);

                const leftForearmBone = new BABYLON.Bone("leftForearm", skeleton, leftArmBone);
                const leftForearmMatrix = BABYLON.Matrix.Translation(0, -0.4, 0);
                leftForearmBone.setBindPose(leftForearmMatrix);

                // Right leg bones
                const rightHipBone = new BABYLON.Bone("rightHip", skeleton, torsoBone);
                const rightHipMatrix = BABYLON.Matrix.Translation(0.3, -0.75, 0);
                rightHipBone.setBindPose(rightHipMatrix);

                const rightUpperLegBone = new BABYLON.Bone("rightUpperLeg", skeleton, rightHipBone);
                const rightUpperLegMatrix = BABYLON.Matrix.Translation(0, -0.35, 0);
                rightUpperLegBone.setBindPose(rightUpperLegMatrix);

                const rightLowerLegBone = new BABYLON.Bone("rightLowerLeg", skeleton, rightUpperLegBone);
                const rightLowerLegMatrix = BABYLON.Matrix.Translation(0, -0.35, 0);
                rightLowerLegBone.setBindPose(rightLowerLegMatrix);

                // Left leg bones (mirror of right)
                const leftHipBone = new BABYLON.Bone("leftHip", skeleton, torsoBone);
                const leftHipMatrix = BABYLON.Matrix.Translation(-0.3, -0.75, 0);
                leftHipBone.setBindPose(leftHipMatrix);

                const leftUpperLegBone = new BABYLON.Bone("leftUpperLeg", skeleton, leftHipBone);
                const leftUpperLegMatrix = BABYLON.Matrix.Translation(0, -0.35, 0);
                leftUpperLegBone.setBindPose(leftUpperLegMatrix);

                const leftLowerLegBone = new BABYLON.Bone("leftLowerLeg", skeleton, leftUpperLegBone);
                const leftLowerLegMatrix = BABYLON.Matrix.Translation(0, -0.35, 0);
                leftLowerLegBone.setBindPose(leftLowerLegMatrix);

                log(`Skeleton bones: ${skeleton.bones.map(b => b.name).join(', ')}`, 'info');

                // === CREATE VISUAL MESHES ===

                // Torso mesh
                const torso = BABYLON.MeshBuilder.CreateBox(`${mechName}_torso`, {
                    width: 1.2, height: 1.5, depth: 0.8
                }, scene);
                torso.material = bodyMat;

                // Right arm meshes (upper arm and forearm with different colors)
                const rightArm = BABYLON.MeshBuilder.CreateBox(`${mechName}_rightArm`, {
                    width: 0.25, height: 0.6, depth: 0.25
                }, scene);
                rightArm.material = darkMat;

                const rightForearm = BABYLON.MeshBuilder.CreateBox(`${mechName}_rightForearm`, {
                    width: 0.2, height: 0.5, depth: 0.2
                }, scene);
                rightForearm.material = veryDarkMat; // Darker for contrast

                // Left arm meshes (upper arm and forearm with different colors)
                const leftArm = BABYLON.MeshBuilder.CreateBox(`${mechName}_leftArm`, {
                    width: 0.25, height: 0.6, depth: 0.25
                }, scene);
                leftArm.material = darkMat;

                const leftForearm = BABYLON.MeshBuilder.CreateBox(`${mechName}_leftForearm`, {
                    width: 0.2, height: 0.5, depth: 0.2
                }, scene);
                leftForearm.material = veryDarkMat; // Darker for contrast

                // Right leg meshes with different colors
                const rightUpperLeg = BABYLON.MeshBuilder.CreateBox(`${mechName}_rightUpperLeg`, {
                    width: 0.3, height: 0.7, depth: 0.3
                }, scene);
                rightUpperLeg.material = darkMat;

                const rightLowerLeg = BABYLON.MeshBuilder.CreateBox(`${mechName}_rightLowerLeg`, {
                    width: 0.25, height: 0.7, depth: 0.25
                }, scene);
                rightLowerLeg.material = veryDarkMat; // Darker for contrast

                // Left leg meshes with different colors
                const leftUpperLeg = BABYLON.MeshBuilder.CreateBox(`${mechName}_leftUpperLeg`, {
                    width: 0.3, height: 0.7, depth: 0.3
                }, scene);
                leftUpperLeg.material = darkMat;

                const leftLowerLeg = BABYLON.MeshBuilder.CreateBox(`${mechName}_leftLowerLeg`, {
                    width: 0.25, height: 0.7, depth: 0.25
                }, scene);
                leftLowerLeg.material = veryDarkMat; // Darker for contrast

                // Add visible joint spheres at elbows and knees
                const rightElbow = BABYLON.MeshBuilder.CreateSphere(`${mechName}_rightElbow`, {
                    diameter: 0.15
                }, scene);
                rightElbow.material = jointMat;
                rightElbow.position = new BABYLON.Vector3(0, 0, 0); // At joint
                rightElbow.attachToBone(rightForearmBone, mechRoot);

                const leftElbow = BABYLON.MeshBuilder.CreateSphere(`${mechName}_leftElbow`, {
                    diameter: 0.15
                }, scene);
                leftElbow.material = jointMat;
                leftElbow.position = new BABYLON.Vector3(0, 0, 0);
                leftElbow.attachToBone(leftForearmBone, mechRoot);

                const rightKnee = BABYLON.MeshBuilder.CreateSphere(`${mechName}_rightKnee`, {
                    diameter: 0.2
                }, scene);
                rightKnee.material = jointMat;
                rightKnee.position = new BABYLON.Vector3(0, 0, 0);
                rightKnee.attachToBone(rightLowerLegBone, mechRoot);

                const leftKnee = BABYLON.MeshBuilder.CreateSphere(`${mechName}_leftKnee`, {
                    diameter: 0.2
                }, scene);
                leftKnee.material = jointMat;
                leftKnee.position = new BABYLON.Vector3(0, 0, 0);
                leftKnee.attachToBone(leftLowerLegBone, mechRoot);

                // Head (parented to torso for now)
                const head = BABYLON.MeshBuilder.CreateBox(`${mechName}_head`, {
                    width: 0.6, height: 0.5, depth: 0.5
                }, scene);
                head.position = new BABYLON.Vector3(0, 1.2, 0);
                head.parent = torso;
                head.material = bodyMat;

                // === ATTACH MESHES TO BONES ===
                log(`Attaching meshes to bones...`, 'info');

                // Attach torso to torso bone
                torso.attachToBone(torsoBone, mechRoot);

                // Position and attach arms - upper segments extend down from shoulder/hip
                // Upper arms: extend down from shoulder
                rightArm.position = new BABYLON.Vector3(0, -0.3, 0); // Half mesh height down
                rightArm.attachToBone(rightArmBone, mechRoot);
                leftArm.position = new BABYLON.Vector3(0, -0.3, 0);
                leftArm.attachToBone(leftArmBone, mechRoot);

                // Forearms: extend further down to avoid overlap with upper arm
                rightForearm.position = new BABYLON.Vector3(0, -0.6, 0); // Offset further to avoid overlap
                rightForearm.attachToBone(rightForearmBone, mechRoot);
                leftForearm.position = new BABYLON.Vector3(0, -0.6, 0);
                leftForearm.attachToBone(leftForearmBone, mechRoot);

                // Position and attach legs
                // Upper legs: extend down from hip
                rightUpperLeg.position = new BABYLON.Vector3(0, -0.35, 0); // Half mesh height down
                rightUpperLeg.attachToBone(rightUpperLegBone, mechRoot);
                leftUpperLeg.position = new BABYLON.Vector3(0, -0.35, 0);
                leftUpperLeg.attachToBone(leftUpperLegBone, mechRoot);

                // Lower legs: offset further down to avoid overlap with upper leg
                rightLowerLeg.position = new BABYLON.Vector3(0, -0.7, 0); // Offset further to avoid overlap
                rightLowerLeg.attachToBone(rightLowerLegBone, mechRoot);
                leftLowerLeg.position = new BABYLON.Vector3(0, -0.7, 0);
                leftLowerLeg.attachToBone(leftLowerLegBone, mechRoot);

                log(`Meshes attached to bones`, 'info');

                // Prepare skeleton (compute bone matrices)
                skeleton.prepare();
                log(`Skeleton prepared`, 'info');

                // === POSE BONES FOR FIRING STANCE ===
                // Rotate bones to create articulated, ready-to-fire pose
                // CRITICAL: Use setRotation() API, not direct .rotation assignment

                // Raise right arm forward and out (ready to fire)
                rightArmBone.setRotation(new BABYLON.Vector3(Math.PI / 3, 0, -Math.PI / 6), BABYLON.Space.LOCAL);
                // Bend right elbow
                rightForearmBone.setRotation(new BABYLON.Vector3(-Math.PI / 4, 0, 0), BABYLON.Space.LOCAL);

                // Raise left arm forward and out (ready to fire)
                leftArmBone.setRotation(new BABYLON.Vector3(Math.PI / 3, 0, Math.PI / 6), BABYLON.Space.LOCAL);
                // Bend left elbow
                leftForearmBone.setRotation(new BABYLON.Vector3(-Math.PI / 4, 0, 0), BABYLON.Space.LOCAL);

                // Legs start with slight bends (will be overridden by walking animation)
                rightUpperLegBone.setRotation(new BABYLON.Vector3(Math.PI / 12, 0, 0), BABYLON.Space.LOCAL);
                rightLowerLegBone.setRotation(new BABYLON.Vector3(-Math.PI / 12, 0, 0), BABYLON.Space.LOCAL);
                leftUpperLegBone.setRotation(new BABYLON.Vector3(Math.PI / 12, 0, 0), BABYLON.Space.LOCAL);
                leftLowerLegBone.setRotation(new BABYLON.Vector3(-Math.PI / 12, 0, 0), BABYLON.Space.LOCAL);

                skeleton.prepare(); // Recompute after rotations
                log(`Bones posed for firing stance using setRotation()`, 'info');

                // === RAGDOLL CONFIGURATION ===
                const ragdollConfig = [
                    // Torso - main physics body
                    {
                        bones: ["torso"],
                        size: 0.75,  // Half-height
                        mass: 80,
                        boxOffset: 0.01
                    },
                    // Arms - upper arms (no limits = free rotation at shoulder)
                    {
                        bones: ["rightArm", "leftArm"],
                        depth: 0.25,
                        size: 0.3,
                        width: 0.25,
                        mass: 4,
                        rotationAxis: BABYLON.Axis.Y,
                        // No min/max = free rotation like walking example
                        boxOffset: 0.15,
                        boneOffsetAxis: BABYLON.Axis.Y
                    },
                    // Forearms (elbows have limits)
                    {
                        bones: ["rightForearm", "leftForearm"],
                        depth: 0.2,
                        size: 0.2,
                        width: 0.2,
                        mass: 2,
                        rotationAxis: BABYLON.Axis.Y,
                        min: -1,  // Elbow bends one way
                        max: 1,
                        boxOffset: 0.1,
                        boneOffsetAxis: BABYLON.Axis.Y
                    },
                    // Upper legs (hips)
                    {
                        bones: ["rightUpperLeg", "leftUpperLeg"],
                        depth: 0.3,
                        size: 0.35,
                        width: 0.3,
                        mass: 6,
                        rotationAxis: BABYLON.Axis.Y,
                        min: -1,
                        max: 1,
                        boxOffset: 0.175,
                        boneOffsetAxis: BABYLON.Axis.Y
                    },
                    // Lower legs (knees)
                    {
                        bones: ["rightLowerLeg", "leftLowerLeg"],
                        depth: 0.25,
                        size: 0.35,
                        width: 0.25,
                        mass: 4,
                        rotationAxis: BABYLON.Axis.Y,
                        min: -1,
                        max: 1,
                        boxOffset: 0.175,
                        boneOffsetAxis: BABYLON.Axis.Y
                    }
                ];

                log(`Creating Ragdoll with ${ragdollConfig.length} parts...`, 'info');

                // === CREATE RAGDOLL ===
                // DISABLED: Ragdoll physics locks bones and prevents animation
                // Using kinematic bone animation instead
                const ragdoll = null; // new BABYLON.Ragdoll(skeleton, mechRoot, ragdollConfig);

                log(`Ragdoll DISABLED - using kinematic animation`, 'info');

                // Store mech data
                const mechData = {
                    root: mechRoot,
                    torso: torso,
                    torsoBone: torsoBone, // Store torso bone for rotation
                    skeleton: skeleton,
                    ragdoll: ragdoll,
                    rightArm: { mesh: rightArm, bone: rightArmBone },
                    rightForearm: { mesh: rightForearm, bone: rightForearmBone },
                    leftArm: { mesh: leftArm, bone: leftArmBone },
                    leftForearm: { mesh: leftForearm, bone: leftForearmBone },
                    rightUpperLeg: { mesh: rightUpperLeg, bone: rightUpperLegBone },
                    rightLowerLeg: { mesh: rightLowerLeg, bone: rightLowerLegBone },
                    leftUpperLeg: { mesh: leftUpperLeg, bone: leftUpperLegBone },
                    leftLowerLeg: { mesh: leftLowerLeg, bone: leftLowerLegBone },
                    head: head,
                    isPlayer: isPlayer,
                    currentHP: 100,
                    maxHP: 100,
                    color: color,
                    walkTime: 0, // For walking animation
                    walkSpeed: 1.5, // Units per second
                    walkDirection: isPlayer ? 1 : -1 // Player walks right, enemy walks left
                };

                // No ragdoll physics - using kinematic animation
                // Create placeholder for backward compatibility
                mechData.torsoAggregate = {
                    body: {
                        setLinearVelocity: () => {},
                        setAngularVelocity: () => {},
                        applyImpulse: () => {}
                    }
                };

                log(`${isPlayer ? 'Player' : 'Enemy'} SKELETAL mech created at (${xPos}, ${spawnY}, 0)`, 'info');
                return mechData;

            } catch (error) {
                log(`ERROR creating ${isPlayer ? 'player' : 'enemy'} mech: ${error.message}`, 'error');
                console.error('Mech creation error:', error);
                throw error;
            }
        }

        // === WALKING ANIMATION ===
        function updateMechWalking(mech, deltaTime) {
            if (!mech || !mech.skeleton) return;

            // Update walk cycle time
            mech.walkTime += deltaTime * 3; // Speed up animation cycle

            // Calculate walking animation (sine wave for smooth motion)
            const walkCycle = Math.sin(mech.walkTime);
            const walkCycleAlt = Math.sin(mech.walkTime + Math.PI); // Opposite phase

            // Move mech side-to-side
            const moveAmountX = mech.walkSpeed * deltaTime * mech.walkDirection;
            mech.root.position.x += moveAmountX;

            // Move slightly forward and back (Z axis) for more dynamic movement
            mech.root.position.z = Math.sin(mech.walkTime * 0.5) * 1.5;

            // Reverse direction at boundaries
            if (Math.abs(mech.root.position.x) > 6) {
                mech.walkDirection *= -1;
            }

            // LEGS face the walk direction (root rotation)
            // If walking right (+X), face right (0). If walking left (-X), face left (PI)
            const targetRootRotation = mech.walkDirection > 0 ? 0 : Math.PI;
            mech.root.rotation.y = targetRootRotation;

            // TORSO rotates independently to face enemy
            const otherMech = mech.isPlayer ? enemyMech : playerMech;
            if (otherMech) {
                const mechPos = mech.root.getAbsolutePosition();
                const targetPos = otherMech.root.getAbsolutePosition();
                const dx = targetPos.x - mechPos.x;
                const dz = targetPos.z - mechPos.z;

                // Calculate world angle to target
                const angleToTarget = Math.atan2(dz, dx);

                // Torso rotation is relative to root rotation (in root's local space)
                let relativeAngle = angleToTarget - mech.root.rotation.y;

                // Normalize angle to -PI to PI range for smooth rotation
                while (relativeAngle > Math.PI) relativeAngle -= 2 * Math.PI;
                while (relativeAngle < -Math.PI) relativeAngle += 2 * Math.PI;

                // Torso smoothly rotates to face enemy (no clamp - full range)
                mech.torsoBone.setRotation(new BABYLON.Vector3(0, relativeAngle, 0), BABYLON.Space.LOCAL);
            }

            // Animate legs - alternating walking motion
            const legSwing = walkCycle * 0.6; // Maximum swing angle
            const kneeSwing = Math.max(0, -walkCycle * 0.4); // Knee bends only forward

            // CRITICAL: Use proper Babylon.js Bone API
            // Bones need setRotation(), not direct .rotation assignment

            // Right leg (forward when walkCycle positive)
            const rightUpperLegAngle = Math.PI / 12 + legSwing;
            const rightLowerLegAngle = -Math.PI / 12 - kneeSwing * 2;

            mech.rightUpperLeg.bone.setRotation(new BABYLON.Vector3(rightUpperLegAngle, 0, 0), BABYLON.Space.LOCAL);
            mech.rightLowerLeg.bone.setRotation(new BABYLON.Vector3(rightLowerLegAngle, 0, 0), BABYLON.Space.LOCAL);

            // Left leg (forward when walkCycle negative)
            const legSwingAlt = walkCycleAlt * 0.6;
            const kneeSwingAlt = Math.max(0, -walkCycleAlt * 0.4);

            const leftUpperLegAngle = Math.PI / 12 + legSwingAlt;
            const leftLowerLegAngle = -Math.PI / 12 - kneeSwingAlt * 2;

            mech.leftUpperLeg.bone.setRotation(new BABYLON.Vector3(leftUpperLegAngle, 0, 0), BABYLON.Space.LOCAL);
            mech.leftLowerLeg.bone.setRotation(new BABYLON.Vector3(leftLowerLegAngle, 0, 0), BABYLON.Space.LOCAL);

            // Slight torso bob for natural walking
            const bob = Math.abs(walkCycle) * 0.08;
            mech.root.position.y = bob;

            // Update skeleton - CRITICAL for bones to update
            mech.skeleton.prepare();
        }

        // === PROJECTILE SYSTEM ===

        // === PROJECTILE SYSTEM ===
        function firePlayerProjectile() {
            if (!playerMech || !enemyMech) return;
            createProjectile(playerMech, enemyMech, 15);
        }

        function fireEnemyProjectile() {
            if (!playerMech || !enemyMech) return;
            createProjectile(enemyMech, playerMech, 12);
        }

        // Arm raising animation for firing - no longer needed with motor-controlled arms
        function raiseArmsToFire(mech) {
            // Arms are now controlled by motors and already in firing position
            // No manual animation needed
        }

        function createProjectile(fromMech, toMech, damage) {
            // Fire from right forearm (weapon position)
            const weaponPos = fromMech.rightForearm.mesh.getAbsolutePosition().clone();
            const targetPos = toMech.torso.getAbsolutePosition().clone();

            log(`Firing from arm at (${weaponPos.x.toFixed(1)}, ${weaponPos.y.toFixed(1)}, ${weaponPos.z.toFixed(1)})`, 'info');
            log(`Targeting torso at (${targetPos.x.toFixed(1)}, ${targetPos.y.toFixed(1)}, ${targetPos.z.toFixed(1)})`, 'info');

            const startPos = weaponPos;

            log(`PROJECTILE: from (${startPos.x.toFixed(1)}, ${startPos.y.toFixed(1)}, ${startPos.z.toFixed(1)}) to (${targetPos.x.toFixed(1)}, ${targetPos.y.toFixed(1)}, ${targetPos.z.toFixed(1)})`, 'info');

            // Calculate direction
            const direction = targetPos.subtract(startPos).normalize();
            log(`PROJECTILE direction: (${direction.x.toFixed(2)}, ${direction.y.toFixed(2)}, ${direction.z.toFixed(2)})`, 'info');
            const angle = Math.atan2(direction.x, direction.z);

            // Create large, visible projectile (energy bolt shape)
            const projectile = BABYLON.MeshBuilder.CreateSphere('projectile_' + Date.now(), {
                diameter: 0.4,
                segments: 8
            }, scene);
            projectile.position = startPos.clone();

            // Projectile material with VERY intense glow
            const projMat = new BABYLON.StandardMaterial('projMat_' + Date.now(), scene);
            projMat.diffuseColor = COLORS.projectile;
            projMat.emissiveColor = COLORS.projectile.scale(3); // VERY bright glow
            projMat.specularColor = new BABYLON.Color3(1, 1, 1);
            projectile.material = projMat;

            // NO PHYSICS - use kinematic movement for fast, reliable projectiles
            // Physics at high speeds causes tunneling and instability

            const speed = 30; // Units per second - visible but still fast
            const velocity = direction.scale(speed);

            log(`PROJECTILE velocity: (${velocity.x.toFixed(1)}, ${velocity.y.toFixed(1)}, ${velocity.z.toFixed(1)})`, 'info');

            // Store projectile data (no aggregate - kinematic movement)
            projectiles.push({
                mesh: projectile,
                velocity: velocity, // Store velocity for manual movement
                damage: damage,
                target: toMech,
                firedAt: Date.now(),
                fromPlayer: fromMech.isPlayer
            });

            log(`${fromMech.isPlayer ? 'Player' : 'Enemy'} fired projectile!`, 'info');
        }

        function updateProjectiles() {
            const now = Date.now();
            const deltaTime = engine.getDeltaTime() / 1000; // Convert to seconds

            projectiles = projectiles.filter(proj => {
                // Move projectile manually (kinematic)
                const movement = proj.velocity.scale(deltaTime);
                proj.mesh.position.addInPlace(movement);

                // Remove old projectiles (after 5 seconds)
                if (now - proj.firedAt > 5000) {
                    proj.mesh.dispose();
                    return false;
                }

                // Check for collision with target - check all body parts
                const projPos = proj.mesh.position;

                // Check which body part was hit
                let hitPart = null;
                let hitPartName = 'torso';
                let minDist = Infinity;

                // Check torso
                const torsoPos = proj.target.torso.getAbsolutePosition();
                let dist = BABYLON.Vector3.Distance(projPos, torsoPos);
                if (dist < 1.2) {
                    hitPart = proj.target.torso;
                    hitPartName = 'torso';
                    minDist = dist;
                }

                // Check head
                const headPos = proj.target.head.getAbsolutePosition();
                dist = BABYLON.Vector3.Distance(projPos, headPos);
                if (dist < 0.6 && dist < minDist) {
                    hitPart = proj.target.head;
                    hitPartName = 'head';
                    minDist = dist;
                }

                // Check arms (skeletal system uses .mesh)
                if (proj.target.leftArm && proj.target.leftArm.mesh) {
                    const leftArmPos = proj.target.leftArm.mesh.getAbsolutePosition();
                    dist = BABYLON.Vector3.Distance(projPos, leftArmPos);
                    if (dist < 0.8 && dist < minDist) {
                        hitPart = proj.target.leftArm.mesh;
                        hitPartName = 'left arm';
                        minDist = dist;
                    }
                }

                if (proj.target.rightArm && proj.target.rightArm.mesh) {
                    const rightArmPos = proj.target.rightArm.mesh.getAbsolutePosition();
                    dist = BABYLON.Vector3.Distance(projPos, rightArmPos);
                    if (dist < 0.8 && dist < minDist) {
                        hitPart = proj.target.rightArm.mesh;
                        hitPartName = 'right arm';
                        minDist = dist;
                    }
                }

                // Check legs (skeletal system uses .mesh)
                if (proj.target.leftUpperLeg && proj.target.leftUpperLeg.mesh) {
                    const leftLegPos = proj.target.leftUpperLeg.mesh.getAbsolutePosition();
                    dist = BABYLON.Vector3.Distance(projPos, leftLegPos);
                    if (dist < 0.8 && dist < minDist) {
                        hitPart = proj.target.leftUpperLeg.mesh;
                        hitPartName = 'left leg';
                        minDist = dist;
                    }
                }

                if (proj.target.rightUpperLeg && proj.target.rightUpperLeg.mesh) {
                    const rightLegPos = proj.target.rightUpperLeg.mesh.getAbsolutePosition();
                    dist = BABYLON.Vector3.Distance(projPos, rightLegPos);
                    if (dist < 0.8 && dist < minDist) {
                        hitPart = proj.target.rightUpperLeg.mesh;
                        hitPartName = 'right leg';
                        minDist = dist;
                    }
                }

                if (hitPart) {
                    // Hit a body part!
                    proj.target.currentHP -= proj.damage;
                    log(`HIT ${hitPartName}! ${proj.fromPlayer ? 'Enemy' : 'Player'} takes ${proj.damage} damage! (${proj.target.currentHP}/${proj.target.maxHP} HP)`, 'warn');

                    // Create impact effect at hit location
                    createImpactEffect(projPos.clone());

                    // Flash the specific part that was hit
                    flashMeshOnHit(hitPart);

                    // Apply impact force to torso (if physics body exists)
                    try {
                        if (proj.target.torsoAggregate && proj.target.torsoAggregate.body && proj.target.torsoAggregate.body.applyImpulse) {
                            const impactDir = projPos.subtract(proj.target.torso.getAbsolutePosition()).normalize();
                            proj.target.torsoAggregate.body.applyImpulse(
                                impactDir.scale(12),
                                projPos
                            );
                        }
                    } catch (e) {
                        // Ragdoll physics might not support direct impulse - that's OK
                    }

                    proj.mesh.dispose();
                    return false;
                }

                // Check if projectile is out of bounds
                if (projPos.y < -5 || Math.abs(projPos.x) > 20 || Math.abs(projPos.z) > 10) {
                    proj.mesh.dispose();
                    return false;
                }

                return true;
            });
        }

        // === LASER BEAM SYSTEM ===
        function fireLaser(isPlayer) {
            const fromMech = isPlayer ? playerMech : enemyMech;
            const toMech = isPlayer ? enemyMech : playerMech;

            // Fire from left forearm (other weapon)
            const startPos = fromMech.leftForearm.mesh.getAbsolutePosition().clone();
            const endPos = toMech.torso.getAbsolutePosition().clone();

            log(`LASER: from left arm at (${startPos.x.toFixed(1)}, ${startPos.y.toFixed(1)}, ${startPos.z.toFixed(1)}) to (${endPos.x.toFixed(1)}, ${endPos.y.toFixed(1)}, ${endPos.z.toFixed(1)})`, 'info');

            // Create main laser beam (thin, bright core)
            const points = [startPos, endPos];
            const laserBeam = BABYLON.MeshBuilder.CreateTube('laser_' + Date.now(), {
                path: points,
                radius: 0.05, // Much thinner core
                updatable: false
            }, scene);

            // Laser material with intense glow
            const laserMat = new BABYLON.StandardMaterial('laserMat_' + Date.now(), scene);
            laserMat.diffuseColor = COLORS.laser;
            laserMat.emissiveColor = COLORS.laser.scale(2); // Very bright
            laserMat.alpha = 0.9;
            laserBeam.material = laserMat;

            // Create outer glow layer (subtle)
            const glowBeam = BABYLON.MeshBuilder.CreateTube('laserGlow_' + Date.now(), {
                path: points,
                radius: 0.12, // Thinner glow
                updatable: false
            }, scene);
            const glowMat = new BABYLON.StandardMaterial('glowMat_' + Date.now(), scene);
            glowMat.diffuseColor = COLORS.laser;
            glowMat.emissiveColor = COLORS.laser.scale(0.8);
            glowMat.alpha = 0.3; // More transparent
            glowBeam.material = glowMat;

            // Detect which body part was hit by checking end position
            let hitPart = toMech.torso;
            let hitPartName = 'torso';
            let minDist = BABYLON.Vector3.Distance(endPos, toMech.torso.getAbsolutePosition());

            // Check head
            let dist = BABYLON.Vector3.Distance(endPos, toMech.head.getAbsolutePosition());
            if (dist < minDist) {
                hitPart = toMech.head;
                hitPartName = 'head';
                minDist = dist;
            }

            // Check arms (skeletal system uses .mesh)
            if (toMech.leftArm && toMech.leftArm.mesh) {
                dist = BABYLON.Vector3.Distance(endPos, toMech.leftArm.mesh.getAbsolutePosition());
                if (dist < minDist) {
                    hitPart = toMech.leftArm.mesh;
                    hitPartName = 'left arm';
                    minDist = dist;
                }
            }

            if (toMech.rightArm && toMech.rightArm.mesh) {
                dist = BABYLON.Vector3.Distance(endPos, toMech.rightArm.mesh.getAbsolutePosition());
                if (dist < minDist) {
                    hitPart = toMech.rightArm.mesh;
                    hitPartName = 'right arm';
                    minDist = dist;
                }
            }

            // Check legs (skeletal system uses .mesh)
            if (toMech.leftUpperLeg && toMech.leftUpperLeg.mesh) {
                dist = BABYLON.Vector3.Distance(endPos, toMech.leftUpperLeg.mesh.getAbsolutePosition());
                if (dist < minDist) {
                    hitPart = toMech.leftUpperLeg.mesh;
                    hitPartName = 'left leg';
                    minDist = dist;
                }
            }

            if (toMech.rightUpperLeg && toMech.rightUpperLeg.mesh) {
                dist = BABYLON.Vector3.Distance(endPos, toMech.rightUpperLeg.mesh.getAbsolutePosition());
                if (dist < minDist) {
                    hitPart = toMech.rightUpperLeg.mesh;
                    hitPartName = 'right leg';
                    minDist = dist;
                }
            }

            // Apply damage immediately (laser is instant)
            const damage = 10;
            toMech.currentHP -= damage;
            log(`LASER HIT ${hitPartName}! ${isPlayer ? 'Enemy' : 'Player'} takes ${damage} damage! (${toMech.currentHP}/${toMech.maxHP} HP)`, 'warn');

            // Store both beams for fadeout
            laserBeams.push({
                mesh: laserBeam,
                glowMesh: glowBeam,
                material: laserMat,
                glowMaterial: glowMat,
                createdAt: Date.now(),
                duration: 200 // ms
            });

            // Create impact at target
            createImpactEffect(endPos.clone());

            // Flash the specific part that was hit
            flashMeshOnHit(hitPart);

            // Apply impact force to torso (if physics body exists)
            try {
                if (toMech.torsoAggregate && toMech.torsoAggregate.body && toMech.torsoAggregate.body.applyImpulse) {
                    const laserDir = endPos.subtract(startPos).normalize();
                    toMech.torsoAggregate.body.applyImpulse(
                        laserDir.scale(8),
                        endPos
                    );
                }
            } catch (e) {
                // Ragdoll physics might not support direct impulse - that's OK
            }
        }

        function updateLaserBeams() {
            const now = Date.now();

            laserBeams = laserBeams.filter(beam => {
                const age = now - beam.createdAt;

                if (age > beam.duration) {
                    beam.mesh.dispose();
                    beam.glowMesh.dispose();
                    return false;
                }

                // Fade out both beams
                const fadeProgress = age / beam.duration;
                beam.material.alpha = 0.9 * (1 - fadeProgress);
                beam.glowMaterial.alpha = 0.4 * (1 - fadeProgress);
                return true;
            });
        }

        // Debug: Log mech positions periodically
        let lastDebugTime = 0;
        function debugMechPositions() {
            const now = Date.now();
            if (now - lastDebugTime < 3000) return; // Log every 3 seconds
            lastDebugTime = now;

            if (playerMech) {
                const pos = playerMech.torso.getAbsolutePosition();
                log(`Player at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`, 'info');
            }
            if (enemyMech) {
                const pos = enemyMech.torso.getAbsolutePosition();
                log(`Enemy at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`, 'info');
            }
        }

        // No active stabilization needed - using single physics body per mech

        // === EFFECTS ===

        function flashMeshOnHit(mesh) {
            // Store original material properties
            const material = mesh.material;
            if (!material) return;

            const originalEmissive = material.emissiveColor ? material.emissiveColor.clone() : new BABYLON.Color3(0, 0, 0);
            const originalDiffuse = material.diffuseColor ? material.diffuseColor.clone() : new BABYLON.Color3(1, 1, 1);

            // Flash bright red/white
            material.emissiveColor = new BABYLON.Color3(1, 0.3, 0.3);
            material.diffuseColor = new BABYLON.Color3(1.8, 0.8, 0.8);

            // Quick fade back through orange to original
            setTimeout(() => {
                if (material) {
                    material.emissiveColor = new BABYLON.Color3(1, 0.5, 0);
                    material.diffuseColor = new BABYLON.Color3(1.5, 1, 0.8);
                }
            }, 50);

            // Restore original colors after a short delay
            setTimeout(() => {
                if (material) {
                    material.emissiveColor = originalEmissive;
                    material.diffuseColor = originalDiffuse;
                }
            }, 150);
        }


        function createImpactEffect(position) {
            // Create particle system for impact
            const particleSystem = new BABYLON.ParticleSystem('impact_' + Date.now(), 100, scene);

            // Texture (procedural)
            particleSystem.particleTexture = new BABYLON.Texture('https://assets.babylonjs.com/textures/flare.png', scene);

            // Emitter
            particleSystem.emitter = position;
            particleSystem.minEmitBox = new BABYLON.Vector3(-0.2, -0.2, -0.2);
            particleSystem.maxEmitBox = new BABYLON.Vector3(0.2, 0.2, 0.2);

            // Colors - bright orange/yellow explosion
            particleSystem.color1 = new BABYLON.Color4(1, 0.8, 0, 1);
            particleSystem.color2 = new BABYLON.Color4(1, 0.3, 0, 1);
            particleSystem.colorDead = new BABYLON.Color4(0.3, 0.1, 0, 0);

            // Size - larger particles
            particleSystem.minSize = 0.15;
            particleSystem.maxSize = 0.5;

            // Lifetime
            particleSystem.minLifeTime = 0.15;
            particleSystem.maxLifeTime = 0.4;

            // Emission - burst of particles
            particleSystem.emitRate = 300;
            particleSystem.manualEmitCount = 60;

            // Speed - faster explosion
            particleSystem.minEmitPower = 3;
            particleSystem.maxEmitPower = 8;
            particleSystem.updateSpeed = 0.015;

            // Direction - spherical burst
            particleSystem.direction1 = new BABYLON.Vector3(-1, -0.5, -1);
            particleSystem.direction2 = new BABYLON.Vector3(1, 1, 1);

            // Gravity
            particleSystem.gravity = new BABYLON.Vector3(0, -8, 0);

            // Add glow/blend mode for more dramatic effect
            particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;

            // Start and auto-dispose
            particleSystem.start();
            particleSystem.targetStopDuration = 0.4;
            particleSystem.disposeOnStop = true;
        }

        function resetScene() {
            const resetHeight = 3.5;

            // Reset player mech
            if (playerMech) {
                playerMech.torso.position = new BABYLON.Vector3(-5, resetHeight, 0);
                playerMech.torsoAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                playerMech.torsoAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());
                playerMech.currentHP = playerMech.maxHP;
            }

            // Reset enemy mech
            if (enemyMech) {
                enemyMech.torso.position = new BABYLON.Vector3(5, resetHeight, 0);
                enemyMech.torsoAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                enemyMech.torsoAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());
                enemyMech.currentHP = enemyMech.maxHP;
            }

            // Clear projectiles
            projectiles.forEach(p => p.mesh.dispose());
            projectiles = [];

            // Clear laser beams
            laserBeams.forEach(b => {
                b.mesh.dispose();
                if (b.glowMesh) b.glowMesh.dispose();
            });
            laserBeams = [];

            log('Scene reset!', 'info');
        }

        // Auto-fire weapons periodically
        function startAutoFire() {
            if (autoFireInterval) {
                clearInterval(autoFireInterval);
            }
            autoFireInterval = setInterval(() => {
                if (autoFireEnabled && playerMech && enemyMech && playerMech.currentHP > 0 && enemyMech.currentHP > 0) {
                    // Randomly fire weapons
                    if (Math.random() > 0.7) {
                        createProjectile(playerMech, enemyMech, 15);
                    }
                    if (Math.random() > 0.7) {
                        createProjectile(enemyMech, playerMech, 12);
                    }
                    if (Math.random() > 0.8) {
                        fireLaser(true);
                    }
                    if (Math.random() > 0.8) {
                        fireLaser(false);
                    }
                }
            }, 1000); // Fire every second
        }

        function toggleAutoFire() {
            autoFireEnabled = !autoFireEnabled;
            const button = document.getElementById('toggleAutoFire');
            if (autoFireEnabled) {
                button.textContent = 'Stop Auto-Fire';
                button.style.background = '#ff4444';
                log('Auto-fire ENABLED', 'warn');
            } else {
                button.textContent = 'Start Auto-Fire';
                button.style.background = '#00ff88';
                log('Auto-fire DISABLED', 'warn');
            }
        }

        // === DIAGNOSTIC TEST SUITE ===
        let debugSpheres = [];

        function runDiagnostics() {
            log('=== RUNNING DIAGNOSTICS ===', 'warn');

            // Clear old debug objects
            debugSpheres.forEach(sphere => sphere.dispose());
            debugSpheres = [];

            testJointAlignment();
            testProjectileAngles();
            testConstraintIntegrity();
            testMotorConfiguration();

            log('=== DIAGNOSTICS COMPLETE ===', 'warn');
        }

        function createDebugSphere(position, color, label) {
            const sphere = BABYLON.MeshBuilder.CreateSphere(label + '_debug', { diameter: 0.2 }, scene);
            sphere.position = position.clone();
            const mat = new BABYLON.StandardMaterial(label + '_mat', scene);
            mat.diffuseColor = color;
            mat.emissiveColor = color.scale(0.5);
            sphere.material = mat;
            debugSpheres.push(sphere);
            return sphere;
        }

        function testJointAlignment() {
            log('--- JOINT ALIGNMENT TEST ---', 'info');

            if (!playerMech || !enemyMech) {
                log('ERROR: Mechs not created yet', 'error');
                return;
            }

            // Test player mech arms
            const torsoPos = playerMech.torso.getAbsolutePosition();
            log(`Player torso at: (${torsoPos.x.toFixed(2)}, ${torsoPos.y.toFixed(2)}, ${torsoPos.z.toFixed(2)})`, 'info');

            // Left arm
            const leftArmPos = playerMech.leftArm.upperArm.getAbsolutePosition();
            const leftShoulderWorld = torsoPos.add(new BABYLON.Vector3(-0.9, 0.65, 0));
            const leftArmTopWorld = leftArmPos.add(new BABYLON.Vector3(0, 0.3, 0)); // armHeight/2

            createDebugSphere(leftShoulderWorld, new BABYLON.Color3(1, 0, 0), 'leftShoulder');
            createDebugSphere(leftArmTopWorld, new BABYLON.Color3(0, 1, 0), 'leftArmTop');

            const leftDist = BABYLON.Vector3.Distance(leftShoulderWorld, leftArmTopWorld);
            log(`Left arm pivot distance: ${leftDist.toFixed(4)} (should be near 0)`, leftDist < 0.1 ? 'info' : 'error');

            // Right arm
            const rightArmPos = playerMech.rightArm.upperArm.getAbsolutePosition();
            const rightShoulderWorld = torsoPos.add(new BABYLON.Vector3(0.9, 0.65, 0));
            const rightArmTopWorld = rightArmPos.add(new BABYLON.Vector3(0, 0.3, 0));

            createDebugSphere(rightShoulderWorld, new BABYLON.Color3(1, 0, 0), 'rightShoulder');
            createDebugSphere(rightArmTopWorld, new BABYLON.Color3(0, 1, 0), 'rightArmTop');

            const rightDist = BABYLON.Vector3.Distance(rightShoulderWorld, rightArmTopWorld);
            log(`Right arm pivot distance: ${rightDist.toFixed(4)} (should be near 0)`, rightDist < 0.1 ? 'info' : 'error');

            // Test legs
            const leftLegPos = playerMech.leftLeg.upperLeg.getAbsolutePosition();
            const leftHipWorld = torsoPos.add(new BABYLON.Vector3(-0.4, -0.85, 0));
            const leftLegTopWorld = leftLegPos.add(new BABYLON.Vector3(0, 0.35, 0)); // legHeight/2

            createDebugSphere(leftHipWorld, new BABYLON.Color3(1, 1, 0), 'leftHip');
            createDebugSphere(leftLegTopWorld, new BABYLON.Color3(0, 1, 1), 'leftLegTop');

            const leftLegDist = BABYLON.Vector3.Distance(leftHipWorld, leftLegTopWorld);
            log(`Left leg pivot distance: ${leftLegDist.toFixed(4)} (should be near 0)`, leftLegDist < 0.1 ? 'info' : 'error');
        }

        function testProjectileAngles() {
            log('--- PROJECTILE ANGLE TEST ---', 'info');

            if (!playerMech || !enemyMech) return;

            const playerTorsoPos = playerMech.torso.getAbsolutePosition();
            const enemyTorsoPos = enemyMech.torso.getAbsolutePosition();

            // Test firing calculation (same as actual firing code)
            const startPos = playerTorsoPos.clone();
            startPos.y += 0.3;
            const targetPos = enemyTorsoPos.clone();

            const direction = targetPos.subtract(startPos).normalize();
            const angle = Math.atan2(direction.x, direction.z);

            log(`Player torso: (${playerTorsoPos.x.toFixed(2)}, ${playerTorsoPos.y.toFixed(2)}, ${playerTorsoPos.z.toFixed(2)})`, 'info');
            log(`Enemy torso: (${enemyTorsoPos.x.toFixed(2)}, ${enemyTorsoPos.y.toFixed(2)}, ${enemyTorsoPos.z.toFixed(2)})`, 'info');
            log(`Fire direction: (${direction.x.toFixed(3)}, ${direction.y.toFixed(3)}, ${direction.z.toFixed(3)})`, 'info');
            log(`Expected Y component (vertical): ${direction.y.toFixed(3)} (should be near 0 for level shot)`, Math.abs(direction.y) < 0.2 ? 'info' : 'error');

            // Draw line showing expected trajectory
            const trajectoryLine = BABYLON.MeshBuilder.CreateLines('trajectory', {
                points: [startPos, targetPos]
            }, scene);
            trajectoryLine.color = new BABYLON.Color3(1, 0, 1);
            debugSpheres.push(trajectoryLine);
        }

        function testConstraintIntegrity() {
            log('--- MECH STRUCTURE TEST ---', 'info');

            if (!playerMech) return;

            // Check if limbs exist
            const hasLeftArm = playerMech.leftArm && playerMech.leftArm.upperArm;
            const hasRightArm = playerMech.rightArm && playerMech.rightArm.upperArm;
            const hasLeftLeg = playerMech.leftLeg && playerMech.leftLeg.upperLeg;
            const hasRightLeg = playerMech.rightLeg && playerMech.rightLeg.upperLeg;

            log(`Left arm: ${hasLeftArm ? 'EXISTS' : 'MISSING'}`, hasLeftArm ? 'info' : 'error');
            log(`Right arm: ${hasRightArm ? 'EXISTS' : 'MISSING'}`, hasRightArm ? 'info' : 'error');
            log(`Left leg: ${hasLeftLeg ? 'EXISTS' : 'MISSING'}`, hasLeftLeg ? 'info' : 'error');
            log(`Right leg: ${hasRightLeg ? 'EXISTS' : 'MISSING'}`, hasRightLeg ? 'info' : 'error');

            log('Note: All limbs are currently VISUAL ONLY (parented to torso)', 'info');
            log('No constraints or motors (simplified to diagnose issues)', 'info');
        }

        function testMotorConfiguration() {
            log('--- MOTOR CONFIGURATION TEST ---', 'info');
            log('Motor targets set to:', 'info');
            log('  Arms: X=-/4 (-45), Y=0, Z=/8 (22.5)', 'info');
            log('  Legs: X=0, Y=0, Z=0', 'info');
            log('Note: Motor rotation may take time to settle', 'info');
        }

        // Run diagnostics button
        function createDiagnosticsButton() {
            const button = document.createElement('button');
            button.textContent = 'Run Diagnostics';
            button.style.cssText = 'position: absolute; top: 120px; right: 20px; padding: 10px 20px; font-size: 14px; background: #ffaa00; color: black; border: none; cursor: pointer; border-radius: 4px; font-weight: bold;';
            button.addEventListener('click', runDiagnostics);
            document.body.appendChild(button);
        }

        // Initialize when page loads
        initEngine().then(() => {
            // Set up auto-fire interval (but it won't fire unless enabled)
            startAutoFire();
            createDiagnosticsButton();

            // Run diagnostics after a short delay to let physics settle
            setTimeout(() => {
                runDiagnostics();
            }, 2000);

            log('Scene ready! Click "Start Auto-Fire" button to begin combat.', 'info');
        });

        // Add button event listener
        document.getElementById('toggleAutoFire').addEventListener('click', toggleAutoFire);
    </script>
</body>
</html>
