<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BattleTech Arena - AI Combat</title>
    <style>
        body {
            margin: 0;
            padding: 15px;
            background: #1a1a2e;
            font-family: monospace;
            color: #00ff88;
            overflow-x: hidden;
        }
        #canvasContainer {
            position: relative;
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
        }

        #renderCanvas {
            width: 100%;
            height: 55vh;
            max-height: 450px;
            display: block;
            border: 3px solid #00ff88;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            touch-action: none;
        }
        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin: 8px 0;
            font-size: 1.3em;
        }
        #status {
            max-width: 1000px;
            margin: 10px auto;
            padding: 8px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #00ff88;
            border-radius: 8px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        #logs {
            flex: 1;
            min-width: 200px;
            max-height: 100px;
            overflow-y: auto;
            font-size: 10px;
        }
        #mechStatus {
            flex: 1;
            min-width: 280px;
            display: flex;
            gap: 10px;
        }
        .mech-info {
            flex: 1;
            padding: 5px;
            border: 1px solid #00ff88;
            border-radius: 4px;
            font-size: 11px;
        }
        .mech-info.enemy { border-color: #ff4444; }
        .log { margin: 1px 0; padding: 1px 3px; }
        .log.info { color: #00ff88; }
        .log.warn { color: #ffaa00; }
        .log.error { color: #ff4444; }
        #controls {
            text-align: center;
            margin: 8px 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 4px;
        }
        button {
            padding: 6px 12px;
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            border-radius: 5px;
            font-family: monospace;
            font-size: 11px;
        }
        button:hover, button:active {
            background: rgba(0, 255, 136, 0.4);
        }
        button.red {
            border-color: #ff4444;
            color: #ff4444;
            background: rgba(255, 68, 68, 0.2);
        }
        .hp-bar {
            height: 10px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin: 2px 0;
        }
        .hp-fill {
            height: 100%;
            transition: width 0.3s;
        }
        .hp-fill.player { background: linear-gradient(90deg, #00aa55, #00ff88); }
        .hp-fill.enemy { background: linear-gradient(90deg, #aa2222, #ff4444); }
        #polyCount {
            text-align: center;
            font-size: 10px;
            color: #888;
            margin-top: 5px;
        }
        #debugPanel {
            max-width: 1000px;
            margin: 10px auto;
            padding: 8px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #ff8800;
            border-radius: 8px;
            font-size: 10px;
        }
        #debugPanel .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        #debugPanel .title { color: #ff8800; font-weight: bold; }
        #debugLogs {
            max-height: 150px;
            overflow-y: auto;
            font-family: monospace;
            white-space: pre;
            color: #aaa;
            line-height: 1.3;
        }
        #debugLogs .dbg-ai { color: #88ff88; }
        #debugLogs .dbg-phys { color: #88ffff; }
        #debugLogs .dbg-torso { color: #ff88ff; }
        #debugLogs .dbg-err { color: #ff4444; }
        #debugLogs .dbg-warn { color: #ffaa00; }
        .copy-btn {
            padding: 3px 8px;
            font-size: 10px;
            background: rgba(255, 136, 0, 0.3);
            border: 1px solid #ff8800;
            color: #ff8800;
            cursor: pointer;
            border-radius: 3px;
        }
        .copy-btn:hover { background: rgba(255, 136, 0, 0.5); }

        /* Countdown overlay styles */
        #countdownOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            pointer-events: none;
        }
        #countdownOverlay.hidden {
            display: none;
        }
        #countdownText {
            font-size: 150px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 40px #00ff88, 0 0 80px #00ff88, 0 0 120px rgba(0, 255, 136, 0.5);
            animation: countdownPulse 0.5s ease-out;
            font-family: monospace;
        }
        #countdownText.fight {
            color: #ff4444;
            text-shadow: 0 0 40px #ff4444, 0 0 80px #ff4444, 0 0 120px rgba(255, 68, 68, 0.5);
            font-size: 120px;
            letter-spacing: 20px;
        }
        @keyframes countdownPulse {
            0% {
                transform: scale(2);
                opacity: 0;
            }
            50% {
                transform: scale(1.1);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        @keyframes fightShake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); }
            20%, 40%, 60%, 80% { transform: translateX(10px); }
        }
        #countdownText.fight {
            animation: countdownPulse 0.3s ease-out, fightShake 0.5s ease-out 0.3s;
        }

        /* ============================================
           WEAPON MINIGAME OVERLAY STYLES
           ============================================ */
        #weaponMinigameOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            flex-direction: column;
            gap: 20px;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        #weaponMinigameOverlay.active {
            display: flex;
        }
        #minigameWeaponName {
            font-size: 28px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 20px #00ff88;
            letter-spacing: 3px;
            text-transform: uppercase;
        }
        #minigameInstruction {
            font-size: 16px;
            color: #aaa;
            margin-bottom: 10px;
        }
        #minigameChargeContainer {
            width: 400px;
            max-width: 90vw;
            height: 60px;
            background: #111;
            border: 3px solid #444;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }
        /* Zone backgrounds */
        .minigame-zone {
            position: absolute;
            top: 0;
            height: 100%;
        }
        .zone-low {
            left: 0;
            width: 30%;
            background: linear-gradient(90deg, #553333, #664444);
        }
        .zone-green {
            left: 30%;
            width: 48%;
            background: linear-gradient(90deg, #335533, #447744);
        }
        .zone-yellow {
            left: 78%;
            width: 10%;
            background: linear-gradient(90deg, #665533, #887744);
        }
        .zone-red {
            left: 88%;
            width: 12%;
            background: linear-gradient(90deg, #663333, #884444);
        }
        /* Zone labels */
        .zone-label {
            position: absolute;
            bottom: 4px;
            font-size: 10px;
            color: rgba(255,255,255,0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 100%;
            text-align: center;
        }
        .zone-low .zone-label { color: #ff8888; }
        .zone-green .zone-label { color: #88ff88; }
        .zone-yellow .zone-label { color: #ffff88; }
        .zone-red .zone-label { color: #ff6666; }

        /* Charge fill bar */
        #minigameChargeFill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(180deg, rgba(255,255,255,0.3), rgba(255,255,255,0.1));
            border-right: 3px solid #fff;
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
            transition: none;
        }
        #minigameChargeFill.charging {
            animation: chargeGlow 0.2s infinite alternate;
        }
        @keyframes chargeGlow {
            from { box-shadow: 0 0 20px rgba(255,255,255,0.5); }
            to { box-shadow: 0 0 40px rgba(255,255,255,0.9); }
        }

        /* Weapon image container */
        #minigameWeaponVisual {
            width: 150px;
            height: 150px;
            border: 3px solid #00ff88;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 60px;
            background: radial-gradient(circle, #002211 0%, #001108 100%);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
            position: relative;
            overflow: hidden;
        }
        #minigameWeaponVisual.charging {
            animation: weaponPulse 0.3s infinite alternate;
        }
        @keyframes weaponPulse {
            from {
                box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
                transform: scale(1);
            }
            to {
                box-shadow: 0 0 60px rgba(0, 255, 136, 0.7);
                transform: scale(1.05);
            }
        }
        #minigameEnergyFill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: linear-gradient(180deg, rgba(0,255,136,0.8), rgba(0,200,100,0.4));
            transition: none;
        }
        #minigameWeaponIcon {
            position: relative;
            z-index: 2;
        }

        /* Result display */
        #minigameResult {
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 20px currentColor;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #minigameResult.show {
            opacity: 1;
        }
        #minigameResult.perfect { color: #ffff00; }
        #minigameResult.good { color: #00ff88; }
        #minigameResult.weak { color: #ff8844; }
        #minigameResult.jam { color: #ff4444; }

        /* Cockpit/Piloting Mode HUD */
        #pilotingHUD {
            display: none;
        }

        /* Weapon indicators in cockpit panel */
        .weapon-indicator {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 6px 10px;
            background: rgba(0, 30, 20, 0.8);
            border: 2px solid rgba(0, 255, 136, 0.4);
            border-radius: 6px;
            min-width: 70px;
            transition: all 0.2s ease;
        }

        .weapon-indicator.ready {
            border-color: #00ff88;
            box-shadow: 0 0 12px rgba(0, 255, 136, 0.5);
            background: rgba(0, 40, 25, 0.9);
        }

        .weapon-indicator.charging {
            border-color: #ffaa00;
        }

        .weapon-indicator-name {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 3px;
            text-align: center;
            max-width: 65px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            letter-spacing: 0.5px;
        }

        .weapon-indicator.ready .weapon-indicator-name {
            color: #00ff88;
        }

        .weapon-cooldown-bar {
            width: 55px;
            height: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 3px;
        }

        .weapon-cooldown-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffaa00, #00ff88);
            transition: width 0.1s linear;
        }

        .weapon-indicator.ready .weapon-cooldown-fill {
            background: #00ff88;
        }

        .weapon-damage {
            font-size: 13px;
            font-weight: bold;
            color: #ffaa00;
            margin-top: 2px;
        }

        .weapon-indicator.ready .weapon-damage {
            color: #00ff88;
        }

        /* Crosshair */
        #cockpitCrosshair {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 99;
        }

        #cockpitCrosshair.active {
            display: block;
        }

        .crosshair-element {
            position: absolute;
            background: rgba(0, 255, 136, 0.8);
        }

        .crosshair-h {
            width: 20px;
            height: 2px;
        }

        .crosshair-v {
            width: 2px;
            height: 20px;
        }

        .crosshair-top { top: -25px; left: -1px; }
        .crosshair-bottom { top: 5px; left: -1px; }
        .crosshair-left { left: -25px; top: -1px; }
        .crosshair-right { left: 5px; top: -1px; }

        .crosshair-center {
            width: 6px;
            height: 6px;
            border: 2px solid rgba(0, 255, 136, 0.8);
            border-radius: 50%;
            position: absolute;
            top: -3px;
            left: -3px;
            background: transparent;
        }

        /* ============================================
           DETAILED MECH COCKPIT OVERLAY
           ============================================ */
        #cockpitFrame {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 98;
            border-radius: 8px;
            overflow: hidden;
        }

        #cockpitFrame.active {
            display: block;
        }

        /* SVG noise filter for metallic texture - embedded */
        .noise-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0.15;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* Brushed metal base texture */
        .brushed-metal {
            background:
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 1px,
                    rgba(255,255,255,0.03) 1px,
                    rgba(255,255,255,0.03) 2px
                ),
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 3px,
                    rgba(0,0,0,0.05) 3px,
                    rgba(0,0,0,0.05) 4px
                ),
                linear-gradient(180deg, #3a3530 0%, #252220 50%, #1a1510 100%);
        }

        /* Distressed scratched metal */
        .distressed-metal {
            background:
                /* Horizontal scratches */
                repeating-linear-gradient(
                    2deg,
                    transparent 0px,
                    transparent 8px,
                    rgba(60,55,50,0.4) 8px,
                    rgba(60,55,50,0.4) 9px,
                    transparent 9px,
                    transparent 23px
                ),
                repeating-linear-gradient(
                    -1deg,
                    transparent 0px,
                    transparent 15px,
                    rgba(80,75,70,0.3) 15px,
                    rgba(80,75,70,0.3) 16px,
                    transparent 16px,
                    transparent 41px
                ),
                /* Vertical grain */
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 1px,
                    rgba(255,255,255,0.02) 1px,
                    rgba(255,255,255,0.02) 2px
                ),
                /* Base gradient */
                linear-gradient(180deg,
                    #4a4540 0%,
                    #353025 25%,
                    #252015 50%,
                    #302a20 75%,
                    #1a1510 100%);
        }

        /* Worn edge effect */
        .worn-edge {
            border: 2px solid #5a5550;
            box-shadow:
                inset 2px 2px 3px rgba(255,255,255,0.08),
                inset -1px -1px 2px rgba(0,0,0,0.4),
                inset 0 0 15px rgba(0,0,0,0.3),
                2px 2px 6px rgba(0,0,0,0.6);
        }

        /* Main curved frame struts - now with distressed metal */
        .frame-strut {
            position: absolute;
            background:
                /* Scratches */
                repeating-linear-gradient(
                    5deg,
                    transparent 0px,
                    transparent 12px,
                    rgba(70,65,60,0.5) 12px,
                    rgba(70,65,60,0.5) 13px,
                    transparent 13px,
                    transparent 31px
                ),
                repeating-linear-gradient(
                    -3deg,
                    transparent 0px,
                    transparent 20px,
                    rgba(90,85,80,0.3) 20px,
                    rgba(90,85,80,0.3) 21px,
                    transparent 21px,
                    transparent 55px
                ),
                /* Brushed vertical lines */
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 1px,
                    rgba(255,255,255,0.04) 1px,
                    rgba(255,255,255,0.04) 2px
                ),
                linear-gradient(180deg, #5a5550 0%, #3a3530 30%, #252015 60%, #1a1510 100%);
            border: 2px solid #6a6560;
            box-shadow:
                inset 3px 3px 6px rgba(255,255,255,0.1),
                inset -2px -2px 4px rgba(0,0,0,0.4),
                4px 4px 10px rgba(0,0,0,0.6);
        }

        .frame-strut-left {
            left: 0;
            top: 0;
            width: 20px;
            height: 100%;
            border-radius: 0 12px 12px 0;
            clip-path: polygon(0 0, 100% 3%, 100% 97%, 0 100%);
        }

        .frame-strut-right {
            right: 0;
            top: 0;
            width: 20px;
            height: 100%;
            border-radius: 12px 0 0 12px;
            clip-path: polygon(0 3%, 100% 0, 100% 100%, 0 97%);
        }

        .frame-strut-top-left {
            left: 16px;
            top: 0;
            width: 30%;
            height: 16px;
            transform: skewX(30deg);
            transform-origin: left top;
            border-radius: 0 0 8px 0;
        }

        .frame-strut-top-right {
            right: 16px;
            top: 0;
            width: 30%;
            height: 16px;
            transform: skewX(-30deg);
            transform-origin: right top;
            border-radius: 0 0 0 8px;
        }

        /* Bottom console panel - reduced height */
        .console-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 25%;
            background:
                repeating-linear-gradient(
                    1deg,
                    transparent 0px,
                    transparent 10px,
                    rgba(50,45,40,0.3) 10px,
                    rgba(50,45,40,0.3) 11px
                ),
                linear-gradient(0deg, #1a1510 0%, #252015 40%, #302a20 70%, transparent 100%);
            border-top: 3px solid #4a4540;
            box-shadow: inset 0 5px 15px rgba(0,0,0,0.4);
        }

        /* TOP LEFT WEAPON PANEL - New position */
        .weapon-panel-topleft {
            position: absolute;
            top: 22px;
            left: 26px;
            padding: 6px 10px;
            background:
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 2px,
                    rgba(0,0,0,0.1) 2px,
                    rgba(0,0,0,0.1) 3px
                ),
                linear-gradient(135deg, rgba(20,25,20,0.95) 0%, rgba(10,15,10,0.95) 100%);
            border: 2px solid #3a4a3a;
            border-radius: 6px;
            box-shadow:
                inset 1px 1px 3px rgba(0,255,100,0.1),
                2px 2px 8px rgba(0,0,0,0.5);
            z-index: 5;
        }

        .weapon-panel-topleft .digital-text {
            font-size: 7px;
            margin-bottom: 4px;
            letter-spacing: 1px;
        }

        /* Left instrument panel - reduced */
        .instrument-panel-left {
            position: absolute;
            left: 22px;
            bottom: 8px;
            width: 110px;
            height: 22%;
            background:
                repeating-linear-gradient(
                    -2deg,
                    transparent 0px,
                    transparent 8px,
                    rgba(40,35,30,0.4) 8px,
                    rgba(40,35,30,0.4) 9px
                ),
                linear-gradient(135deg, #2a2520 0%, #1a1510 100%);
            border: 2px solid #3a3530;
            border-radius: 6px;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.5), 2px 2px 6px rgba(0,0,0,0.5);
            padding: 6px;
        }

        /* Right instrument panel - reduced */
        .instrument-panel-right {
            position: absolute;
            right: 22px;
            bottom: 8px;
            width: 110px;
            height: 22%;
            background:
                repeating-linear-gradient(
                    2deg,
                    transparent 0px,
                    transparent 8px,
                    rgba(40,35,30,0.4) 8px,
                    rgba(40,35,30,0.4) 9px
                ),
                linear-gradient(225deg, #2a2520 0%, #1a1510 100%);
            border: 2px solid #3a3530;
            border-radius: 6px;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.5), 2px 2px 6px rgba(0,0,0,0.5);
            padding: 6px;
        }

        /* Center console - much smaller, just status */
        .center-console {
            position: absolute;
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: 30%;
            max-width: 200px;
            height: 18%;
            background:
                repeating-linear-gradient(
                    0deg,
                    transparent 0px,
                    transparent 6px,
                    rgba(40,35,30,0.3) 6px,
                    rgba(40,35,30,0.3) 7px
                ),
                linear-gradient(180deg, #2a2520 0%, #1a1510 100%);
            border: 2px solid #3a3530;
            border-radius: 8px 8px 4px 4px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5), 0 -3px 10px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 5px;
        }

        /* CRT Screen displays */
        .crt-screen {
            background: radial-gradient(ellipse at center, #001a0a 0%, #000a05 70%, #000502 100%);
            border: 3px solid #2a2a25;
            border-radius: 5px;
            box-shadow:
                inset 0 0 30px rgba(0, 255, 100, 0.1),
                inset 0 0 10px rgba(0, 255, 100, 0.05),
                2px 2px 4px rgba(0,0,0,0.5);
            position: relative;
            overflow: hidden;
        }

        .crt-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 1px,
                rgba(0, 50, 0, 0.03) 1px,
                rgba(0, 50, 0, 0.03) 2px
            );
            pointer-events: none;
        }

        /* Radar display */
        .radar-display {
            width: 90%;
            height: 55%;
            margin: 5px auto;
            position: relative;
        }

        .radar-grid {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
            border: 1px solid rgba(0, 255, 100, 0.3);
            border-radius: 50%;
        }

        .radar-grid::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background: rgba(0, 255, 100, 0.2);
        }

        .radar-grid::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 1px;
            background: rgba(0, 255, 100, 0.2);
        }

        .radar-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            border: 1px solid #00ff66;
            border-radius: 50%;
        }

        /* Button clusters */
        .button-cluster {
            display: grid;
            gap: 3px;
            padding: 4px;
            background: #1a1815;
            border-radius: 4px;
            border: 1px solid #2a2520;
        }

        .button-row {
            display: flex;
            gap: 3px;
            justify-content: center;
        }

        .cockpit-btn {
            width: 14px;
            height: 10px;
            border-radius: 2px;
            border: 1px solid rgba(0,0,0,0.5);
            box-shadow: inset 1px 1px 2px rgba(255,255,255,0.2);
        }

        .btn-red { background: linear-gradient(180deg, #cc3333 0%, #881111 100%); }
        .btn-red.lit { background: linear-gradient(180deg, #ff4444 0%, #cc2222 100%); box-shadow: 0 0 5px #ff4444; }
        .btn-green { background: linear-gradient(180deg, #33cc33 0%, #118811 100%); }
        .btn-green.lit { background: linear-gradient(180deg, #44ff44 0%, #22cc22 100%); box-shadow: 0 0 5px #44ff44; }
        .btn-amber { background: linear-gradient(180deg, #cc9933 0%, #886611 100%); }
        .btn-amber.lit { background: linear-gradient(180deg, #ffaa44 0%, #cc8822 100%); box-shadow: 0 0 5px #ffaa44; }
        .btn-dark { background: linear-gradient(180deg, #444 0%, #222 100%); }

        /* Toggle switches */
        .toggle-switch {
            width: 10px;
            height: 18px;
            background: linear-gradient(90deg, #2a2520 0%, #3a3530 50%, #2a2520 100%);
            border-radius: 3px;
            border: 1px solid #1a1510;
            position: relative;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            height: 6px;
            background: linear-gradient(180deg, #666 0%, #444 100%);
            border-radius: 2px;
        }

        /* Screen labels */
        .screen-label {
            position: absolute;
            font-size: 6px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: #1a1815;
            padding: 1px 3px;
            border-radius: 2px;
        }

        /* HP Bar integrated */
        .cockpit-hp-bar {
            width: 100%;
            height: 8px;
            background: #111;
            border: 1px solid #333;
            border-radius: 2px;
            margin: 3px 0;
            overflow: hidden;
        }

        .cockpit-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444 0%, #ffaa00 50%, #00ff66 100%);
            transition: width 0.3s;
            box-shadow: 0 0 5px currentColor;
        }

        /* Integrated weapon panel - now in top left */
        .cockpit-weapon-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            padding: 0;
            background: transparent;
        }

        /* Warning indicator lights */
        .indicator-light {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 1px solid #222;
            box-shadow: inset 1px 1px 2px rgba(0,0,0,0.5);
        }

        .indicator-off { background: #333; }
        .indicator-red { background: radial-gradient(circle at 30% 30%, #ff6666, #aa2222); box-shadow: 0 0 4px #ff4444; }
        .indicator-green { background: radial-gradient(circle at 30% 30%, #66ff66, #22aa22); box-shadow: 0 0 4px #44ff44; }
        .indicator-amber { background: radial-gradient(circle at 30% 30%, #ffaa66, #aa6622); box-shadow: 0 0 4px #ffaa44; }

        /* Wiring/cable details */
        .cable {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, #222 0%, #333 50%, #222 100%);
            border-radius: 2px;
        }

        /* Text displays */
        .digital-text {
            font-family: monospace;
            color: #00ff66;
            text-shadow: 0 0 5px #00ff66;
            font-size: 9px;
        }

        .amber-text {
            color: #ffaa44;
            text-shadow: 0 0 5px #ffaa44;
        }

        /* Cockpit scanline effect */
        .cockpit-scanlines {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.02) 2px,
                rgba(0, 0, 0, 0.02) 4px
            );
            pointer-events: none;
            z-index: 1;
        }

        /* Warning blink animation */
        @keyframes warningBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .warning-blink {
            animation: warningBlink 0.5s ease-in-out infinite;
        }

        /* Piloting mode instruction */
        #pilotingInstruction {
            display: none;
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #ffaa00;
            border-radius: 8px;
            padding: 8px 16px;
            color: #ffaa00;
            font-size: 11px;
            z-index: 101;
            text-align: center;
        }

        #pilotingInstruction.active {
            display: block;
        }

        /* Click effect */
        .fire-effect {
            position: fixed;
            width: 40px;
            height: 40px;
            border: 3px solid #ff4400;
            border-radius: 50%;
            pointer-events: none;
            animation: fireRipple 0.4s ease-out forwards;
            z-index: 102;
        }

        @keyframes fireRipple {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <h1>BattleTech Arena <span id="version" style="font-size: 0.6em; color: #888;">v10.17-ground</span></h1>
    <div id="controls">
        <button id="autoFireBtn" onclick="toggleAutoFire()" style="background: rgba(255, 200, 0, 0.3); border-color: #ffcc00; color: #ffcc00;">AI Battle: OFF</button>
        <button id="cinematicBtn" onclick="toggleCinematicCamera()">Cinematic: OFF</button>
        <button onclick="resetScene()">Reset</button>
        <button id="returnToLoadoutBtn" onclick="returnToLoadout()" style="background: rgba(0, 255, 136, 0.3); border-color: #00ff88; color: #00ff88;">Return to Loadout</button>
    </div>

    <!-- Canvas container for relative positioning of cockpit overlay -->
    <div id="canvasContainer">
        <canvas id="renderCanvas"></canvas>

        <!-- Cockpit crosshair -->
        <div id="cockpitCrosshair">
            <div class="crosshair-element crosshair-v crosshair-top"></div>
            <div class="crosshair-element crosshair-v crosshair-bottom"></div>
            <div class="crosshair-element crosshair-h crosshair-left"></div>
            <div class="crosshair-element crosshair-h crosshair-right"></div>
            <div class="crosshair-center"></div>
        </div>

        <!-- Detailed Mech Cockpit Frame -->
        <div id="cockpitFrame">
            <!-- Frame struts with distressed metal -->
            <div class="frame-strut frame-strut-left"></div>
            <div class="frame-strut frame-strut-right"></div>
            <div class="frame-strut frame-strut-top-left"></div>
            <div class="frame-strut frame-strut-top-right"></div>

            <!-- Bottom console panel background -->
            <div class="console-panel"></div>

            <!-- TOP LEFT WEAPON PANEL -->
            <div class="weapon-panel-topleft">
                <div class="digital-text">WEAPONS</div>
                <div class="cockpit-weapon-panel" id="weaponIndicators">
                    <!-- Populated by JS -->
                </div>
            </div>

            <!-- LEFT INSTRUMENT PANEL - compact -->
            <div class="instrument-panel-left">
                <div class="crt-screen" style="height: 60%; margin-bottom: 4px;">
                    <div style="padding: 3px;">
                        <div class="digital-text" style="font-size: 6px; margin-bottom: 2px;">STATUS</div>
                        <div class="cockpit-hp-bar">
                            <div class="cockpit-hp-fill" id="cockpitHpFill" style="width: 100%;"></div>
                        </div>
                        <div class="digital-text" style="font-size: 5px; margin-top: 2px;">HEAT: <span id="cockpitHeat" class="amber-text">0%</span></div>
                    </div>
                </div>
                <div class="button-cluster">
                    <div class="button-row">
                        <div class="cockpit-btn btn-red" id="warnBtn1"></div>
                        <div class="cockpit-btn btn-amber"></div>
                        <div class="cockpit-btn btn-green lit"></div>
                    </div>
                </div>
            </div>

            <!-- RIGHT INSTRUMENT PANEL - compact radar -->
            <div class="instrument-panel-right">
                <div class="crt-screen" style="height: 60%; margin-bottom: 4px;">
                    <div style="padding: 3px;">
                        <div class="digital-text" style="font-size: 6px; margin-bottom: 2px;">RADAR</div>
                        <div style="display: flex; justify-content: center; align-items: center; height: 75%;">
                            <div style="width: 40px; height: 40px; border: 1px solid rgba(0,255,100,0.3); border-radius: 50%; position: relative;">
                                <div style="position: absolute; top: 50%; left: 0; right: 0; height: 1px; background: rgba(0,255,100,0.2);"></div>
                                <div style="position: absolute; left: 50%; top: 0; bottom: 0; width: 1px; background: rgba(0,255,100,0.2);"></div>
                                <div id="radarEnemy" style="position: absolute; width: 4px; height: 4px; background: #ff4444; border-radius: 50%; top: 30%; left: 60%; box-shadow: 0 0 4px #ff4444;"></div>
                                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 3px; height: 3px; background: #00ff66; border-radius: 50%;"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div style="display: flex; gap: 3px; justify-content: center;">
                    <div class="indicator-light indicator-green"></div>
                    <div class="indicator-light indicator-amber" id="heatIndicator"></div>
                    <div class="indicator-light indicator-off" id="damageIndicator"></div>
                </div>
            </div>

            <!-- CENTER CONSOLE - minimal, just zoom -->
            <div class="center-console">
                <div class="digital-text" style="font-size: 8px;">ZOOM: <span id="cockpitZoom">1.0x</span></div>
                <div id="radarEnemyMain" style="display: none;"></div>
            </div>

            <!-- Noise texture overlay for metallic effect -->
            <div class="noise-overlay"></div>

            <!-- Scanline overlay -->
            <div class="cockpit-scanlines"></div>
        </div>

        <!-- Piloting instructions -->
        <div id="pilotingInstruction">
            CLICK/TAP to fire â€¢ DRAG to look around â€¢ SCROLL/PINCH to zoom
        </div>
    </div>

    <!-- Countdown overlay -->
    <div id="countdownOverlay" class="hidden">
        <div id="countdownText">3</div>
    </div>

    <!-- Weapon Minigame overlay -->
    <div id="weaponMinigameOverlay">
        <div id="minigameWeaponName">LASER</div>
        <div id="minigameWeaponVisual">
            <div id="minigameEnergyFill"></div>
            <span id="minigameWeaponIcon">âš¡</span>
        </div>
        <div id="minigameInstruction">HOLD TO CHARGE - RELEASE TO FIRE!</div>
        <div id="minigameChargeContainer">
            <div class="minigame-zone zone-low"><span class="zone-label">WEAK</span></div>
            <div class="minigame-zone zone-green"><span class="zone-label">GOOD</span></div>
            <div class="minigame-zone zone-yellow"><span class="zone-label">PERFECT!</span></div>
            <div class="minigame-zone zone-red"><span class="zone-label">JAM!</span></div>
            <div id="minigameChargeFill"></div>
        </div>
        <div id="minigameResult"></div>
    </div>

    <div id="polyCount">Triangles: <span id="triCount">0</span></div>
    <div id="status">
        <div id="logs"></div>
        <div id="mechStatus">
            <div class="mech-info player">
                <strong style="color: #00ff88;">TIMBER WOLF (Mad Cat)</strong>
                <div class="hp-bar"><div class="hp-fill player" id="playerHP" style="width: 100%"></div></div>
                <div id="playerHPText">HP: 150/150</div>
                <div id="playerState">Idle</div>
            </div>
            <div class="mech-info enemy">
                <strong style="color: #ff4444;">DIRE WOLF (Daishi)</strong>
                <div class="hp-bar"><div class="hp-fill enemy" id="enemyHP" style="width: 100%"></div></div>
                <div id="enemyHPText">HP: 200/200</div>
                <div id="enemyState">Idle</div>
            </div>
        </div>
    </div>

    <div id="debugPanel">
        <div class="header">
            <span class="title">DIAGNOSTIC LOGS</span>
            <button class="copy-btn" onclick="copyDebugLogs()">Copy Logs</button>
        </div>
        <div id="debugLogs"></div>
    </div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>

    <script>
        // Logging
        const logs = [];
        function log(msg, type = 'info') {
            console.log(msg);
            logs.push({ msg, type });
            const logsDiv = document.getElementById('logs');
            if (logsDiv) {
                logsDiv.innerHTML = logs.slice(-10).map(l =>
                    `<div class="log ${l.type}">${l.msg}</div>`
                ).join('');
            }
        }

        // Debug logging system
        const debugLogs = [];
        let lastDebugTime = 0;
        const DEBUG_INTERVAL = 0.5; // Log every 0.5 seconds to avoid spam

        function dbg(msg, category = '') {
            const ts = gameTime.toFixed(2);
            const entry = `[${ts}] ${msg}`;
            debugLogs.push({ msg: entry, cat: category });
            if (debugLogs.length > 100) debugLogs.shift(); // Keep last 100 entries
            updateDebugPanel();
        }

        function updateDebugPanel() {
            const el = document.getElementById('debugLogs');
            if (el) {
                el.innerHTML = debugLogs.slice(-30).map(l => {
                    const cls = l.cat ? `dbg-${l.cat}` : '';
                    return `<span class="${cls}">${l.msg}</span>`;
                }).join('\n');
                el.scrollTop = el.scrollHeight;
            }
        }

        function copyDebugLogs() {
            const text = debugLogs.map(l => l.msg).join('\n');
            navigator.clipboard.writeText(text).then(() => {
                log('Logs copied to clipboard!', 'info');
            }).catch(err => {
                // Fallback for browsers without clipboard API
                const ta = document.createElement('textarea');
                ta.value = text;
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                document.body.removeChild(ta);
                log('Logs copied!', 'info');
            });
        }

        log('Initializing Mad Cat Physics Test...');

        // Globals
        let engine, scene, camera, havokInstance, havokPlugin;
        let playerMechs = [];  // Array of player team mechs
        let enemyMechs = [];   // Array of enemy team mechs
        let allMechs = [];     // Combined array for iteration
        let projectiles = [];
        let beams = [];
        let gameTime = 0;
        let autoFireEnabled = false;
        let autoFireInterval = null;
        let battleEnded = false;  // Flag to stop AI loops when battle is over

        // Cinematic camera system
        let cinematicEnabled = false;
        let cinematicState = {
            mode: 'orbit',           // 'orbit', 'track', 'action', 'sweep'
            target: null,            // Current mech being focused
            orbitAngle: 0,           // Current orbit angle
            orbitHeight: 8,          // Camera height
            orbitRadius: 12,         // Distance from target
            transitionTime: 0,       // Time in current mode
            modeDuration: 4,         // Seconds before mode change
            actionTarget: null,      // Mech that just fired/took damage
            actionTime: 0,           // When action occurred
            sweepPhase: 0            // Phase of panoramic sweep
        };

        // Piloting mode state
        let pilotingModeActive = false;
        let pilotingState = {
            weaponCooldowns: {},     // Track cooldowns for player weapons
            lastClickTime: 0,        // Prevent rapid clicking
            clickCooldown: 100,      // Minimum ms between clicks
            zoomLevel: 1.0,          // Camera zoom (1.0 = normal, higher = zoomed in)
            minZoom: 0.5,
            maxZoom: 2.5,
            // Mouse-aim torso control
            mouseX: 0,               // Current mouse X on canvas
            mouseY: 0,               // Current mouse Y on canvas
            targetYaw: 0,            // Target torso yaw angle (radians)
            targetPitch: 0,          // Target torso pitch angle (radians)
            currentYaw: 0,           // Current torso yaw (with lag)
            currentPitch: 0,         // Current torso pitch (with lag)
            aimSpeed: 3.0,           // How fast torso follows mouse (lower = more lag)
            maxYaw: 1.2,             // Max horizontal rotation (radians, ~69 degrees)
            maxPitch: 0.4            // Max vertical rotation (radians, ~23 degrees)
        };

        // Weapon cooldowns per mech (keyed by mech name)
        const mechCooldowns = {};
        const COOLDOWN_TIMES = { erlaser: 2000, lrm: 3500, ac: 1500, hatchet: 1800 };

        // ============================================
        // WEAPON MINIGAME SYSTEM
        // ============================================
        const MINIGAME_CONFIG = {
            triggerChance: 0.40,         // 40% chance to trigger minigame
            chargeSpeed: 110,            // Percent per second (faster = harder)
            autoFireDelay: 200,          // ms before auto-fire if not holding
            cooldownMs: 7000,            // 7 seconds between minigames (5-10 range)
            // Zone boundaries (as percentages) - narrower perfect zone for difficulty
            zones: {
                low: { min: 0, max: 35, multiplier: 0.5, name: 'WEAK', class: 'weak' },
                green: { min: 35, max: 75, multiplier: 1.0, name: 'GOOD', class: 'good' },
                yellow: { min: 75, max: 85, multiplier: 1.25, name: 'PERFECT!', class: 'perfect' },
                red: { min: 85, max: 100, multiplier: 0, name: 'JAMMED!', class: 'jam' }
            },
            // Weapon-specific icons and colors
            weaponVisuals: {
                laser: { icon: 'âš¡', name: 'LASER', color: '#00ff88' },
                beam: { icon: 'âš¡', name: 'ENERGY BEAM', color: '#00ffff' },
                projectile: { icon: 'ðŸ’¥', name: 'CANNON', color: '#ffaa00' },
                cluster: { icon: 'ðŸš€', name: 'MISSILES', color: '#ff6600' },
                melee: { icon: 'âš”ï¸', name: 'MELEE', color: '#ff4444' }
            }
        };

        // Minigame state
        let minigameState = {
            active: false,
            isCharging: false,
            chargePercent: 0,
            weaponData: null,
            mech: null,
            target: null,
            startTime: 0,
            animationFrame: null,
            pendingWeaponFire: null,
            lastMinigameEndTime: 0    // Track when last minigame ended for cooldown
        };

        // Get weapon type for visuals
        function getWeaponType(weaponData) {
            const battle = weaponData.battle || {};
            if (battle.isBeam) return 'beam';
            if (battle.isCluster) return 'cluster';
            if (battle.isMelee) return 'melee';
            // Check weapon name for hints
            const name = (weaponData.name || weaponData.itemId || '').toLowerCase();
            if (name.includes('laser') || name.includes('beam') || name.includes('ppc')) return 'laser';
            if (name.includes('missile') || name.includes('lrm') || name.includes('srm')) return 'cluster';
            if (name.includes('hatchet') || name.includes('sword') || name.includes('melee')) return 'melee';
            return 'projectile';
        }

        // Start the minigame
        function startWeaponMinigame(mech, weaponData, target) {
            if (minigameState.active) return false;

            const weaponType = getWeaponType(weaponData);
            const visuals = MINIGAME_CONFIG.weaponVisuals[weaponType] || MINIGAME_CONFIG.weaponVisuals.projectile;

            // Save all mech positions and velocities before pausing
            const savedMechStates = [];
            if (typeof allMechs !== 'undefined') {
                allMechs.forEach(m => {
                    if (m && m.pelvis && m.pelvisAggregate) {
                        const pos = m.pelvis.getAbsolutePosition().clone();
                        const body = m.pelvisAggregate.body;
                        const linVel = body.getLinearVelocity();
                        const angVel = body.getAngularVelocity();
                        savedMechStates.push({
                            mech: m,
                            position: pos,
                            linearVelocity: linVel ? linVel.clone() : new BABYLON.Vector3(0, 0, 0),
                            angularVelocity: angVel ? angVel.clone() : new BABYLON.Vector3(0, 0, 0)
                        });
                        // Freeze the physics body
                        body.setLinearVelocity(new BABYLON.Vector3(0, 0, 0));
                        body.setAngularVelocity(new BABYLON.Vector3(0, 0, 0));
                    }
                });
            }

            minigameState = {
                active: true,
                isCharging: false,
                chargePercent: 0,
                weaponData: weaponData,
                mech: mech,
                target: target,
                startTime: performance.now(),
                animationFrame: null,
                pendingWeaponFire: null,
                savedMechStates: savedMechStates
            };

            // Disable physics entirely during minigame
            if (typeof scene !== 'undefined' && scene.physicsEnabled) {
                minigameState.wasPhysicsEnabled = true;
                scene.physicsEnabled = false;
            }

            // Update UI
            const overlay = document.getElementById('weaponMinigameOverlay');
            const weaponName = document.getElementById('minigameWeaponName');
            const weaponIcon = document.getElementById('minigameWeaponIcon');
            const chargeFill = document.getElementById('minigameChargeFill');
            const energyFill = document.getElementById('minigameEnergyFill');
            const result = document.getElementById('minigameResult');
            const weaponVisual = document.getElementById('minigameWeaponVisual');

            weaponName.textContent = weaponData.name || visuals.name;
            weaponName.style.color = visuals.color;
            weaponName.style.textShadow = `0 0 20px ${visuals.color}`;
            weaponIcon.textContent = visuals.icon;
            weaponVisual.style.borderColor = visuals.color;
            chargeFill.style.width = '0%';
            chargeFill.classList.remove('charging');
            energyFill.style.height = '0%';
            result.textContent = '';
            result.className = '';
            weaponVisual.classList.remove('charging');

            overlay.classList.add('active');

            // Pause the game during minigame
            if (typeof gameTime !== 'undefined') {
                minigameState.pausedGameTime = gameTime;
            }

            log(`[MINIGAME] Started for ${weaponData.name || 'weapon'}`);

            return true;
        }

        // Update minigame charge (called on animation frame)
        function updateMinigameCharge() {
            if (!minigameState.active || !minigameState.isCharging) return;

            const now = performance.now();
            const elapsed = now - minigameState.chargeStartTime;
            const chargeAmount = (elapsed / 1000) * MINIGAME_CONFIG.chargeSpeed;

            minigameState.chargePercent = Math.min(100, chargeAmount);

            // Update UI
            const chargeFill = document.getElementById('minigameChargeFill');
            const energyFill = document.getElementById('minigameEnergyFill');

            chargeFill.style.width = minigameState.chargePercent + '%';
            energyFill.style.height = minigameState.chargePercent + '%';

            // Change fill color based on zone
            if (minigameState.chargePercent >= 88) {
                chargeFill.style.background = 'linear-gradient(180deg, rgba(255,100,100,0.5), rgba(255,50,50,0.3))';
            } else if (minigameState.chargePercent >= 78) {
                chargeFill.style.background = 'linear-gradient(180deg, rgba(255,255,100,0.5), rgba(200,200,50,0.3))';
            } else if (minigameState.chargePercent >= 30) {
                chargeFill.style.background = 'linear-gradient(180deg, rgba(100,255,100,0.5), rgba(50,200,50,0.3))';
            } else {
                chargeFill.style.background = 'linear-gradient(180deg, rgba(255,150,100,0.4), rgba(200,100,50,0.2))';
            }

            // Continue animation if still charging
            if (minigameState.chargePercent < 100) {
                minigameState.animationFrame = requestAnimationFrame(updateMinigameCharge);
            } else {
                // Auto-fire at 100%
                endMinigame();
            }
        }

        // Start charging (on mouse/touch down)
        function startCharging() {
            if (!minigameState.active || minigameState.isCharging) return;

            minigameState.isCharging = true;
            minigameState.chargeStartTime = performance.now();

            const chargeFill = document.getElementById('minigameChargeFill');
            const weaponVisual = document.getElementById('minigameWeaponVisual');

            chargeFill.classList.add('charging');
            weaponVisual.classList.add('charging');

            minigameState.animationFrame = requestAnimationFrame(updateMinigameCharge);
        }

        // Stop charging (on mouse/touch up)
        function stopCharging() {
            if (!minigameState.active || !minigameState.isCharging) return;

            minigameState.isCharging = false;

            if (minigameState.animationFrame) {
                cancelAnimationFrame(minigameState.animationFrame);
                minigameState.animationFrame = null;
            }

            const chargeFill = document.getElementById('minigameChargeFill');
            const weaponVisual = document.getElementById('minigameWeaponVisual');

            chargeFill.classList.remove('charging');
            weaponVisual.classList.remove('charging');

            endMinigame();
        }

        // Determine zone and multiplier from charge percent
        function getZoneResult(percent) {
            const zones = MINIGAME_CONFIG.zones;
            if (percent >= zones.red.min) return zones.red;
            if (percent >= zones.yellow.min) return zones.yellow;
            if (percent >= zones.green.min) return zones.green;
            return zones.low;
        }

        // End the minigame and fire weapon
        function endMinigame() {
            if (!minigameState.active) return;

            const zone = getZoneResult(minigameState.chargePercent);

            // Show result
            const result = document.getElementById('minigameResult');
            result.textContent = zone.name;
            result.className = 'show ' + zone.class;

            log(`[MINIGAME] Result: ${zone.name} (${minigameState.chargePercent.toFixed(0)}%) - ${zone.multiplier}x damage`);

            // Store the fire data and saved states for after animation
            const fireData = {
                mech: minigameState.mech,
                weaponData: minigameState.weaponData,
                target: minigameState.target,
                damageMultiplier: zone.multiplier
            };
            const savedStates = minigameState.savedMechStates;
            const wasPhysicsEnabled = minigameState.wasPhysicsEnabled;

            // Hide overlay after short delay
            setTimeout(() => {
                const overlay = document.getElementById('weaponMinigameOverlay');
                overlay.classList.remove('active');

                // Re-enable physics
                if (typeof scene !== 'undefined' && wasPhysicsEnabled) {
                    scene.physicsEnabled = true;
                }

                // Restore mech positions and velocities
                if (savedStates && savedStates.length > 0) {
                    savedStates.forEach(state => {
                        if (state.mech && state.mech.pelvis && state.mech.pelvisAggregate) {
                            const body = state.mech.pelvisAggregate.body;
                            // Restore position
                            body.transformNode.position.copyFrom(state.position);
                            // Restore velocities
                            body.setLinearVelocity(state.linearVelocity);
                            body.setAngularVelocity(state.angularVelocity);
                        }
                    });
                }

                // Reset state and record end time for cooldown
                minigameState.active = false;
                minigameState.isCharging = false;
                minigameState.chargePercent = 0;
                minigameState.savedMechStates = null;
                minigameState.wasPhysicsEnabled = false;
                minigameState.lastMinigameEndTime = performance.now();

                // Actually fire the weapon with the multiplier
                if (fireData.damageMultiplier > 0) {
                    fireLoadoutWeaponWithMultiplier(
                        fireData.mech,
                        fireData.weaponData,
                        fireData.target,
                        fireData.damageMultiplier
                    );
                } else {
                    // Weapon jammed - play jam effect
                    log(`[MINIGAME] Weapon JAMMED! No damage dealt.`);
                    // Could add jam visual/sound effect here
                }
            }, 600);
        }

        // Set up minigame event listeners
        function setupMinigameListeners() {
            const overlay = document.getElementById('weaponMinigameOverlay');
            const chargeContainer = document.getElementById('minigameChargeContainer');
            const weaponVisual = document.getElementById('minigameWeaponVisual');

            // Mouse events
            overlay.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startCharging();
            });
            overlay.addEventListener('mouseup', (e) => {
                e.preventDefault();
                stopCharging();
            });
            overlay.addEventListener('mouseleave', (e) => {
                if (minigameState.isCharging) {
                    stopCharging();
                }
            });

            // Touch events
            overlay.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startCharging();
            });
            overlay.addEventListener('touchend', (e) => {
                e.preventDefault();
                stopCharging();
            });
            overlay.addEventListener('touchcancel', (e) => {
                if (minigameState.isCharging) {
                    stopCharging();
                }
            });

            // Keyboard support (spacebar)
            document.addEventListener('keydown', (e) => {
                if (minigameState.active && e.code === 'Space' && !e.repeat) {
                    e.preventDefault();
                    startCharging();
                }
            });
            document.addEventListener('keyup', (e) => {
                if (minigameState.active && e.code === 'Space') {
                    e.preventDefault();
                    stopCharging();
                }
            });
        }

        // Initialize minigame listeners when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupMinigameListeners);
        } else {
            setupMinigameListeners();
        }

        // Helper to get alive mechs
        function getAliveMechs(team) {
            const mechs = team === 'player' ? playerMechs : enemyMechs;
            return mechs.filter(m => m && m.currentHP > 0 && !m.isDestroyed);
        }

        // Helper to find a new target for a mech
        function findNewTarget(mech) {
            const enemies = mech.isPlayer ? enemyMechs : playerMechs;
            const aliveEnemies = enemies.filter(e => e && e.currentHP > 0 && !e.isDestroyed);
            if (aliveEnemies.length === 0) return null;
            // Find closest enemy
            const myPos = mech.pelvis.getAbsolutePosition();
            let closest = null;
            let closestDist = Infinity;
            for (const enemy of aliveEnemies) {
                const dist = BABYLON.Vector3.Distance(myPos, enemy.pelvis.getAbsolutePosition());
                if (dist < closestDist) {
                    closestDist = dist;
                    closest = enemy;
                }
            }
            return closest;
        }

        // AI Configuration
        const AI_CONFIG = {
            idealRange: 10,         // Optimal combat distance
            minRange: 6,            // Too close - back up
            maxRange: 13,           // Too far - close in (slightly less than starting distance)
            edgeBoundary: 14,       // X position to start avoiding edges (ground is Â±20)
            edgeForce: 80,          // Force to push away from edges
            moveForce: 150,         // Normal movement force (increased significantly)
            strafeForce: 60,        // Lateral movement force (increased significantly)
            decisionInterval: 0.2,  // How often AI makes decisions (faster for responsiveness)
            strafeChance: 0.6,      // Higher chance to strafe at optimal range for more dynamic combat
            strafeDuration: 1.5     // How long to strafe before reconsidering
        };

        // Weapons
        const WEAPONS = {
            erlaser: {
                name: 'ER Large Laser',
                damage: 14,
                knockback: 8,
                recoil: 0.2,
                isBeam: true,
                beamDuration: 180,
                color: new BABYLON.Color3(0.2, 1, 0.3)
            },
            lrm: {
                name: 'LRM-20',
                damage: 18,
                knockback: 12,
                recoil: 0.15,
                projectileSpeed: 38,  // Faster missiles
                isCluster: true,
                clusterCount: 8,
                color: new BABYLON.Color3(1, 0.5, 0.1)
            },
            ac: {
                name: 'UAC/5',
                damage: 12,
                knockback: 22,  // Still good impact
                recoil: 0.12,
                projectileSpeed: 45,  // Faster rounds
                projectileSize: 0.1,
                color: new BABYLON.Color3(1, 0.9, 0.3)
            },
            hatchet: {
                name: 'Hatchet',
                damage: 25,
                knockback: 40,  // Huge knockback
                recoil: 0.3,
                isMelee: true,
                range: 3.5,  // Must be very close
                color: new BABYLON.Color3(1, 0.3, 0.1)
            }
        };

        // ============================================
        // HYBRID STATE MACHINE - Mech States
        // Phase 1: WALKING (Kinematic/ANIMATED) - Perfect control
        // Phase 2: FLINCH (Kinematic + additive animation)
        // Phase 3: RAGDOLL (Dynamic) - Physics takes over
        // Phase 4: RECOVERING (Blend back to kinematic)
        // ============================================
        const MechState = {
            WALKING: 'walking',     // Kinematic mode - controlled movement
            RAGDOLL: 'ragdoll',     // Dynamic mode - physics simulation
            RECOVERING: 'recovering' // Transitioning from ragdoll back to walking
        };

        // Stability and impact thresholds
        const STABILITY_CONFIG = {
            maxStability: 100,           // Full stability value
            flinchThreshold: 15,         // Knockback below this = flinch only
            knockdownThreshold: 35,      // Knockback above this = ragdoll
            stabilityRecoveryRate: 25,   // Stability recovered per second
            ragdollSettleVelocity: 0.3,  // Velocity threshold for ragdoll settle
            ragdollSettleTime: 0.5,      // Time at low velocity before recovery starts
            recoveryBlendTime: 0.4,      // Time to blend from ragdoll to standing
            mechAngularDamping: 0.85,    // Mechs are stiff, not floppy
            mechLinearDamping: 0.3       // Some resistance to sliding
        };

        // Arena bounds - HARD limits for kinematic movement
        const ARENA_BOUNDS = {
            minX: -18,
            maxX: 18,
            minZ: -8,
            maxZ: 8
        };

        // ============================================
        // SHADOW & QUALITY CONFIGURATION
        // Mobile-optimized shadow system with adaptive quality
        // ============================================
        const SHADOW_CONFIG = {
            enabled: true,                    // Master shadow toggle
            mapSize: 1024,                    // Shadow map resolution (512/1024/2048)
            blurKernel: 32,                   // Blur kernel size for soft shadows
            darkness: 0.35,                   // Shadow darkness (0=black, 1=invisible)
        };

        // Detect mobile and adjust quality
        function detectMobileAndSetQuality() {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isLowPower = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4;
            const canvas = document.getElementById('renderCanvas');
            const isSmallScreen = canvas && (canvas.width < 800 || canvas.height < 600);

            if (isMobile || isLowPower || isSmallScreen) {
                // Mobile/low-end settings
                SHADOW_CONFIG.mapSize = 512;
                SHADOW_CONFIG.blurKernel = 16;
                log('[SHADOWS] Mobile mode (512px)');
            } else {
                // Desktop settings
                SHADOW_CONFIG.mapSize = 1024;
                SHADOW_CONFIG.blurKernel = 32;
                log('[SHADOWS] Desktop mode (1024px)');
            }
        }

        // Global shadow generator reference
        let shadowGenerator = null;

        // Helper to add mesh as shadow caster (call after creating important meshes)
        function addShadowCaster(mesh, includeChildren = false) {
            if (shadowGenerator && mesh) {
                shadowGenerator.addShadowCaster(mesh, includeChildren);
            }
        }

        // Configure shadow casters for all mechs
        // For performance, we only add key body parts instead of all 30-40 meshes per mech
        function configureMechShadows(mechs, shadowGen) {
            if (!shadowGen || !mechs) return;

            let casterCount = 0;

            mechs.forEach(mech => {
                if (!mech || !mech.pelvis) return;

                // Use getDescendants() which gets ALL descendants recursively
                // This is more reliable than manual recursion
                const allNodes = mech.pelvis.getDescendants(false);
                allNodes.unshift(mech.pelvis); // Include pelvis itself

                allNodes.forEach(node => {
                    // Only add actual meshes (have getBoundingInfo)
                    if (node && typeof node.getBoundingInfo === 'function') {
                        shadowGen.addShadowCaster(node);
                        casterCount++;
                    }
                });
            });

            log(`[SHADOWS] ${casterCount} casters from ${mechs.length} mechs`);
        }

        // Colors
        const COLORS = {
            playerPrimary: new BABYLON.Color3(0.15, 0.35, 0.2),
            playerSecondary: new BABYLON.Color3(0.25, 0.45, 0.3),
            playerAccent: new BABYLON.Color3(0.7, 0.6, 0.1),
            enemyPrimary: new BABYLON.Color3(0.4, 0.12, 0.12),
            enemySecondary: new BABYLON.Color3(0.5, 0.18, 0.18),
            enemyAccent: new BABYLON.Color3(0.25, 0.25, 0.3),
            metal: new BABYLON.Color3(0.35, 0.35, 0.4),
            darkMetal: new BABYLON.Color3(0.12, 0.12, 0.15),
            chrome: new BABYLON.Color3(0.6, 0.6, 0.65),
            cockpit: new BABYLON.Color3(0.1, 0.9, 0.95),
            thruster: new BABYLON.Color3(1, 0.4, 0.1),
            ground: new BABYLON.Color3(0.22, 0.2, 0.18)
        };

        // Texture URLs from Babylon.js assets
        const TEXTURE_URLS = {
            // Ground textures
            grass: 'https://i.imgur.com/c3l8U9o.png',  // Better tiling grass texture
            grassNormal: 'https://playground.babylonjs.com/textures/grassn.png',
            rock: 'https://playground.babylonjs.com/textures/rock.png',
            rockNormal: 'https://playground.babylonjs.com/textures/rockn.png',
            // Metal textures
            metal: 'https://playground.babylonjs.com/textures/floor.png',
            metalNormal: 'https://playground.babylonjs.com/textures/floorNormal.png',
            rustMetal: 'https://assets.babylonjs.com/textures/rustediron2_basecolor.png',
            rustMetalNormal: 'https://assets.babylonjs.com/textures/rustediron2_normal.png',
            // Detail textures
            crate: 'https://playground.babylonjs.com/textures/crate.png',
            wood: 'https://playground.babylonjs.com/textures/wood.jpg',
            // Misc
            distortion: 'https://playground.babylonjs.com/textures/distortion.png',
            // Sky
            skybox: 'https://playground.babylonjs.com/textures/skybox'
        };

        // Global texture cache
        let TEXTURES = {};

        // Read background type from URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const backgroundType = urlParams.get('bg') || 'grasslands';
        console.log('Background type:', backgroundType);

        // Read piloting mode from URL parameter
        const userPilotingMode = urlParams.get('piloting') === '1';
        console.log('User piloting mode:', userPilotingMode);

        // Background configurations
        const BACKGROUND_CONFIGS = {
            grasslands: {
                skyColor: new BABYLON.Color3(0.5, 0.6, 0.75),
                fogDensity: 0.003,
                fogColor: new BABYLON.Color3(0.7, 0.78, 0.85),
                groundTexture: 'grass',
                groundColor: new BABYLON.Color3(0.85, 0.9, 0.75),
                horizonColor: new BABYLON.Color3(0.7, 0.75, 0.6),
                showMountains: true,
                showDebris: true,
                showSkybox: true,
                groundElevation: 0,
                arenaStyle: 'natural'
            },
            metal_arena: {
                skyColor: new BABYLON.Color3(0.15, 0.18, 0.25),
                fogDensity: 0.002,
                fogColor: new BABYLON.Color3(0.2, 0.22, 0.28),
                groundTexture: 'metal',
                groundColor: new BABYLON.Color3(0.5, 0.52, 0.55),
                horizonColor: new BABYLON.Color3(0.1, 0.12, 0.15),
                showMountains: false,
                showDebris: false,
                showSkybox: true,
                groundElevation: 0,
                arenaStyle: 'platform'
            },
            foggy: {
                skyColor: new BABYLON.Color3(0.42, 0.44, 0.48),
                fogDensity: 0.035,
                fogColor: new BABYLON.Color3(0.52, 0.54, 0.58),
                groundTexture: 'rock',
                groundColor: new BABYLON.Color3(0.38, 0.38, 0.38),
                horizonColor: new BABYLON.Color3(0.42, 0.42, 0.42),
                showMountains: false,
                showDebris: true,
                showSkybox: false,
                groundElevation: 0,
                arenaStyle: 'wasteland'
            },
            desert: {
                skyColor: new BABYLON.Color3(0.85, 0.75, 0.55),
                fogDensity: 0.004,
                fogColor: new BABYLON.Color3(0.9, 0.82, 0.65),
                groundTexture: 'rock',
                groundColor: new BABYLON.Color3(0.85, 0.7, 0.45),
                horizonColor: new BABYLON.Color3(0.9, 0.78, 0.55),
                showMountains: true,
                showDebris: false,
                showSkybox: true,
                groundElevation: 0,
                arenaStyle: 'dunes'
            }
        };

        // Get current background config (default to grasslands)
        const bgConfig = BACKGROUND_CONFIGS[backgroundType] || BACKGROUND_CONFIGS.grasslands;

        async function initEngine() {
            const canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

            // Detect device capabilities and adjust shadow quality
            detectMobileAndSetQuality();

            try {
                havokInstance = await HavokPhysics();
                log('Havok initialized');
            } catch (e) {
                log('Havok failed: ' + e.message, 'error');
                return;
            }

            scene = createScene();

            let lastTime = performance.now();
            let frameCount = 0;
            engine.runRenderLoop(() => {
                if (scene) {
                    try {
                        const now = performance.now();
                        const dt = (now - lastTime) / 1000;
                        lastTime = now;
                        gameTime += dt;
                        frameCount++;

                        // Log frame start occasionally
                        if (frameCount % 60 === 0) {
                            console.log(`[FRAME ${frameCount}] t=${gameTime.toFixed(2)}`);
                        }

                        // Skip all game updates during minigame (full pause)
                        if (minigameState.active) {
                            // Only render the frozen scene, no physics or game logic
                            scene.render();
                            return;
                        }

                        // Update projectiles and beams
                        updateProjectiles(dt);
                        updateBeams();

                        // Only run AI/mech logic if battle hasn't ended
                        if (!battleEnded) {
                            updateMechs(dt);
                            checkBattleEnd();
                        } else {
                            // Still update destroyed mech physics during death animation
                            allMechs.forEach(mech => {
                                if (mech && mech.isDestroyed) {
                                    // Keep feet horizontal even when falling
                                    const body = mech.pelvisAggregate.body;
                                    const quat = body.transformNode.rotationQuaternion;
                                    if (quat && mech.leftLeg.footGroup) {
                                        const euler = quat.toEulerAngles();
                                        mech.leftLeg.footGroup.rotation.x = -euler.x;
                                        mech.rightLeg.footGroup.rotation.x = -euler.x;
                                        mech.leftLeg.footGroup.rotation.z = -euler.z * 0.5;
                                        mech.rightLeg.footGroup.rotation.z = -euler.z * 0.5;
                                    }
                                }
                            });
                        }
                        updateUI();
                        updateCinematicCamera(dt);
                        updateCockpitCamera(dt);

                        // Update debug timer AFTER all subsystems have had a chance to log
                        if (gameTime - lastDebugTime > DEBUG_INTERVAL) {
                            lastDebugTime = gameTime;
                        }
                        scene.render();
                    } catch (e) {
                        console.error('[RENDER LOOP ERROR]', e);
                        log(`[RENDER ERROR] ${e.message}`, 'error');
                    }
                }
            });

            window.addEventListener('resize', () => engine.resize());
            log('Scene ready!');

            // Log initial mech state for debugging and start countdown
            setTimeout(() => {
                const motionTypes = ['STATIC', 'ANIMATED', 'DYNAMIC'];
                dbg(`Created ${playerMechs.length} player mechs and ${enemyMechs.length} enemy mechs`, 'ai');
                allMechs.forEach(mech => {
                    if (!mech) return;
                    const pos = mech.pelvis.getAbsolutePosition();
                    const body = mech.pelvisAggregate.body;
                    const side = mech.isPlayer ? 'P' : 'E';
                    dbg(`${side} ${mech.name}: pos=(${pos.x.toFixed(1)},${pos.y.toFixed(1)},${pos.z.toFixed(1)}) HP=${mech.maxHP}`, 'ai');
                });
                // Start countdown and then begin battle
                startCountdown();
            }, 500);
        }

        // Countdown animation before battle starts
        function startCountdown() {
            const overlay = document.getElementById('countdownOverlay');
            const text = document.getElementById('countdownText');

            overlay.classList.remove('hidden');

            const sequence = ['3', '2', '1', 'FIGHT!'];
            let index = 0;

            function showNext() {
                if (index < sequence.length) {
                    text.textContent = sequence[index];
                    text.className = '';  // Reset classes

                    if (sequence[index] === 'FIGHT!') {
                        text.classList.add('fight');
                    }

                    // Force reflow to restart animation
                    void text.offsetWidth;
                    text.style.animation = 'none';
                    void text.offsetWidth;
                    text.style.animation = '';

                    index++;

                    if (index < sequence.length) {
                        setTimeout(showNext, 800);
                    } else {
                        // After "FIGHT!", wait a moment then start battle and hide overlay
                        setTimeout(() => {
                            overlay.classList.add('hidden');
                            // Auto-start the AI battle
                            if (!autoFireEnabled) {
                                toggleAutoFire();
                            }
                            // Initialize piloting mode if enabled
                            if (userPilotingMode) {
                                initPilotingMode();
                            }
                        }, 600);
                    }
                }
            }

            showNext();
        }

        function createScene() {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = bgConfig.skyColor;  // Use background config

            havokPlugin = new BABYLON.HavokPlugin(true, havokInstance);
            scene.enablePhysics(new BABYLON.Vector3(0, -18, 0), havokPlugin);

            // Load textures
            TEXTURES.grass = new BABYLON.Texture(TEXTURE_URLS.grass, scene);
            TEXTURES.grass.uScale = 8;
            TEXTURES.grass.vScale = 4;
            TEXTURES.grassNormal = new BABYLON.Texture(TEXTURE_URLS.grassNormal, scene);
            TEXTURES.grassNormal.uScale = 8;
            TEXTURES.grassNormal.vScale = 4;

            TEXTURES.rock = new BABYLON.Texture(TEXTURE_URLS.rock, scene);
            TEXTURES.rock.uScale = 2;
            TEXTURES.rock.vScale = 2;
            TEXTURES.rockNormal = new BABYLON.Texture(TEXTURE_URLS.rockNormal, scene);
            TEXTURES.rockNormal.uScale = 2;
            TEXTURES.rockNormal.vScale = 2;

            TEXTURES.metal = new BABYLON.Texture(TEXTURE_URLS.metal, scene);
            TEXTURES.metal.uScale = 4;
            TEXTURES.metal.vScale = 4;

            TEXTURES.rustMetal = new BABYLON.Texture(TEXTURE_URLS.rustMetal, scene);
            TEXTURES.rustMetal.uScale = 2;
            TEXTURES.rustMetal.vScale = 2;
            TEXTURES.rustMetalNormal = new BABYLON.Texture(TEXTURE_URLS.rustMetalNormal, scene);
            TEXTURES.rustMetalNormal.uScale = 2;
            TEXTURES.rustMetalNormal.vScale = 2;

            // Camera - zoomed out to show all mechs
            // Adjust camera target height based on ground elevation
            const cameraTargetY = 2 + (bgConfig.groundElevation || 0);
            camera = new BABYLON.ArcRotateCamera('cam', -Math.PI/2, Math.PI/3.5, 32,
                new BABYLON.Vector3(0, cameraTargetY, 0), scene);
            camera.attachControl(document.getElementById('renderCanvas'), true);
            camera.lowerRadiusLimit = 15;
            camera.upperRadiusLimit = 120;
            camera.wheelPrecision = 30;

            // ============================================
            // LIGHTING + SHADOWS (v10.7 - Texture test)
            // ============================================

            // ============================================
            // v10.14: FULL SCENE WITH MECH SHADOWS
            // ============================================

            // Ambient light - bright for miniature photography look
            const hemi = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0, 1, 0), scene);
            hemi.intensity = 0.9;
            hemi.groundColor = new BABYLON.Color3(0.4, 0.4, 0.45);

            // DirectionalLight for shadows - bright like studio lighting
            const sunLight = new BABYLON.DirectionalLight('sunLight', new BABYLON.Vector3(-1, -2, -1), scene);
            sunLight.position = new BABYLON.Vector3(0, 30, 0);  // Centered above arena
            sunLight.intensity = 2.2;

            // Expand shadow frustum to cover all mechs
            sunLight.shadowMinZ = 1;
            sunLight.shadowMaxZ = 60;
            sunLight.shadowFrustumSize = 50;  // Fixed frustum size to cover arena

            // Shadow generator with PCF filtering
            if (SHADOW_CONFIG.enabled) {
                shadowGenerator = new BABYLON.ShadowGenerator(SHADOW_CONFIG.mapSize, sunLight);
                shadowGenerator.bias = 0.0005;
                shadowGenerator.normalBias = 0.005;
                shadowGenerator.usePercentageCloserFiltering = true;
                shadowGenerator.filteringQuality = BABYLON.ShadowGenerator.QUALITY_MEDIUM;
                log(`[v10.16] Shadows: PCF, frustum=50, ${SHADOW_CONFIG.mapSize}px`);
            }

            // Fog - uses background config
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
            scene.fogDensity = bgConfig.fogDensity;
            scene.fogColor = bgConfig.fogColor;

            // Create ground and walls
            createGround(scene, shadowGenerator);
            createWalls(scene);

            // Check for battle config from MechBuilder
            const battleConfigStr = localStorage.getItem('battleConfig');
            let battleConfig = null;
            let itemDatabase = null; // ITEM_DATABASE from loadout screen for special properties
            if (battleConfigStr) {
                try {
                    battleConfig = JSON.parse(battleConfigStr);
                    itemDatabase = battleConfig.itemDatabase || null;
                    console.log('Loaded battle config:', battleConfig);
                    console.log('Item database available:', !!itemDatabase);
                } catch(e) {
                    console.error('Failed to parse battle config:', e);
                }
            }

            // Create mechs based on config or default
            if (battleConfig) {
                // Create player mech based on loadout
                const playerMech = createMadCatMech(scene, -7, 0, true);
                // Apply player stats from loadout
                if (battleConfig.player && battleConfig.player.stats) {
                    playerMech.maxHP = battleConfig.player.stats.maxHealth || playerMech.maxHP;
                    playerMech.currentHP = playerMech.maxHP;
                    // Store loadout damage for weapon calculations
                    // Loadout damage is total damage from all equipped weapons
                    playerMech.loadoutDamage = battleConfig.player.stats.damage || 0;
                    playerMech.loadoutWeapons = battleConfig.player.stats.weapons || [];
                    // New armor stats
                    playerMech.damageReduction = battleConfig.player.stats.damageReduction || 0;
                    playerMech.energyShieldMaxHP = battleConfig.player.stats.energyShieldHP || 0;
                    playerMech.energyShieldHP = playerMech.energyShieldMaxHP;
                    console.log('Player loadout damage:', playerMech.loadoutDamage, 'weapons:', playerMech.loadoutWeapons);
                    console.log('Player armor stats - DR:', playerMech.damageReduction, 'Shield:', playerMech.energyShieldHP);
                    // Create energy shield visual if equipped
                    if (playerMech.energyShieldMaxHP > 0) {
                        setTimeout(() => createEnergyShield(playerMech), 100);
                    }
                }
                playerMechs = [playerMech];

                // Create enemy mechs - support multiple enemies!
                const enemyRisk = battleConfig.mission?.risk || 1;
                const enemiesConfig = battleConfig.enemies || [battleConfig.enemy];
                enemyMechs = [];

                // Spawn positions for multiple enemies (spread out on right side)
                const enemyPositions = [
                    { x: 7, z: 0 },
                    { x: 10, z: 4 },
                    { x: 10, z: -4 },
                    { x: 13, z: 2 },
                    { x: 13, z: -2 }
                ];

                enemiesConfig.forEach((enemyData, index) => {
                    const pos = enemyPositions[index] || { x: 7 + index * 3, z: (index % 2 === 0 ? 1 : -1) * (index + 1) };

                    // Choose mech type based on risk level
                    let enemyMech;
                    if (enemyRisk >= 3) {
                        enemyMech = createDireWolfMech(scene, pos.x, pos.z, false);
                    } else if (enemyRisk >= 2) {
                        enemyMech = createMadCatMech(scene, pos.x, pos.z, false);
                    } else {
                        enemyMech = createCommandoMech(scene, pos.x, pos.z, false);
                    }

                    // Apply enemy stats from config
                    if (enemyData) {
                        if (enemyData.maxHealth) {
                            enemyMech.maxHP = enemyData.maxHealth;
                            enemyMech.currentHP = enemyMech.maxHP;
                        }
                        // Use weapons from ITEM_DATABASE
                        enemyMech.loadoutWeapons = enemyData.weapons || [];
                        // Store enemy name for UI
                        enemyMech.displayName = enemyData.name || `Enemy ${index + 1}`;
                        console.log(`Enemy ${index + 1} (${enemyMech.displayName}) weapons:`, enemyMech.loadoutWeapons);
                    }

                    enemyMechs.push(enemyMech);
                });

                console.log(`Spawned ${enemyMechs.length} enemies for this mission`);

                // Update UI with mission info
                setTimeout(() => {
                    const missionName = battleConfig.mission?.name || 'Battle';
                    document.querySelector('.mech-info.player strong').textContent = battleConfig.player?.name || 'PLAYER';
                    // Show enemy count if multiple
                    const enemyLabel = enemyMechs.length > 1
                        ? `${enemiesConfig[0]?.name || 'ENEMIES'} (Ã—${enemyMechs.length})`
                        : (enemiesConfig[0]?.name || 'ENEMY');
                    document.querySelector('.mech-info.enemy strong').textContent = enemyLabel;
                }, 100);
            } else {
                // Default: full battle with multiple mechs
                playerMechs = [
                    createMadCatMech(scene, -7, 0, true),
                    createHatchetmanMech(scene, -14, 2, true),
                    createCatapultMech(scene, -10, 4, true),
                    createCommandoMech(scene, -10, -3, true)
                ];
                enemyMechs = [
                    createDireWolfMech(scene, 7, 0, false),
                    createHatchetmanMech(scene, 14, -2, false),
                    createCatapultMech(scene, 10, 4, false),
                    createCommandoMech(scene, 10, -3, false)
                ];
            }
            allMechs = [...playerMechs, ...enemyMechs];

            // Adjust mech positions for ground elevation (e.g., metal arena platform)
            const groundElevation = bgConfig.groundElevation || 0;
            if (groundElevation > 0) {
                allMechs.forEach(mech => {
                    if (mech.pelvis && mech.pelvisAggregate) {
                        // Update mesh position
                        mech.pelvis.position.y += groundElevation;
                        // Update physics body transform to match
                        mech.pelvisAggregate.body.setTargetTransform(
                            mech.pelvis.position,
                            mech.pelvis.rotationQuaternion || BABYLON.Quaternion.Identity()
                        );
                    }
                });
            }

            allMechs.forEach(mech => {
                mechCooldowns[mech.name + '_' + (mech.isPlayer ? 'p' : 'e')] = { erlaser: 0, lrm: 0, ac: 0, hatchet: 0 };
            });

            // Add mech shadows
            if (shadowGenerator) {
                configureMechShadows(allMechs, shadowGenerator);
            }

            // ============================================
            // MINIATURE/TILT-SHIFT EFFECT
            // Creates the illusion that mechs are tiny tabletop miniatures
            // ============================================

            // Default Rendering Pipeline for post-processing effects
            const pipeline = new BABYLON.DefaultRenderingPipeline(
                "miniaturePipeline",
                true, // HDR enabled
                scene,
                [camera]
            );

            // Store reference for dynamic focus adjustment
            scene.miniaturePipeline = pipeline;

            // ----- FXAA (Fast anti-aliasing) -----
            pipeline.fxaaEnabled = true;

            // ----- DEPTH OF FIELD (Core tilt-shift effect) -----
            // Very strong blur at edges, sharp focus in center - extreme miniature look
            pipeline.depthOfFieldEnabled = true;
            pipeline.depthOfFieldBlurLevel = BABYLON.DepthOfFieldEffectBlurLevel.High;
            pipeline.depthOfField.focalLength = 300; // Extreme telephoto (macro lens effect)
            pipeline.depthOfField.fStop = 0.5; // Very wide aperture for maximum blur
            pipeline.depthOfField.focusDistance = 32000; // Focus at camera target distance

            // ----- BLOOM (Glow on bright areas) -----
            // Strong bloom for that hyperreal studio-lit miniature look
            pipeline.bloomEnabled = true;
            pipeline.bloomThreshold = 0.5;
            pipeline.bloomWeight = 0.5;
            pipeline.bloomKernel = 100;
            pipeline.bloomScale = 0.7;

            // ----- CHROMATIC ABERRATION (Lens imperfection) -----
            // Color fringing at edges, like a real camera lens
            pipeline.chromaticAberrationEnabled = true;
            pipeline.chromaticAberration.aberrationAmount = 50;
            pipeline.chromaticAberration.radialIntensity = 2.0;

            // ----- VIGNETTE (Subtle darkened corners) -----
            // Lighter vignette to keep scene bright
            pipeline.imageProcessing.vignetteEnabled = true;
            pipeline.imageProcessing.vignetteWeight = 1.2;
            pipeline.imageProcessing.vignetteStretch = 0.4;
            pipeline.imageProcessing.vignetteColor = new BABYLON.Color4(0, 0, 0, 0);
            pipeline.imageProcessing.vignetteCameraFov = 0.6;

            // ----- COLOR GRADING (Hyperreal vibrant miniature colors) -----
            // High exposure and contrast for bright, punchy toy-like look
            pipeline.imageProcessing.contrast = 1.5;
            pipeline.imageProcessing.exposure = 1.6;
            pipeline.imageProcessingEnabled = true;

            // ----- SHARPEN (Crisp details like macro photography) -----
            pipeline.sharpenEnabled = true;
            pipeline.sharpen.edgeAmount = 0.4;
            pipeline.sharpen.colorAmount = 1.0;

            // ----- GRAIN (Subtle film grain for photographic feel) -----
            pipeline.grainEnabled = true;
            pipeline.grain.intensity = 5;
            pipeline.grain.animated = true;

            // Update DOF focus distance based on camera radius
            scene.registerBeforeRender(() => {
                // Convert camera radius (meters) to mm for focusDistance
                pipeline.depthOfField.focusDistance = camera.radius * 1000;
            });

            return scene;
        }

        function createGround(scene, shadowGen) {
            // === SKYBOX (conditional based on background config) ===
            if (bgConfig.showSkybox) {
                const skybox = BABYLON.MeshBuilder.CreateBox('skyBox', { size: 1000 }, scene);
                const skyboxMaterial = new BABYLON.StandardMaterial('skyBoxMat', scene);
                skyboxMaterial.backFaceCulling = false;
                skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(TEXTURE_URLS.skybox, scene);
                skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
                skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
                skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
                skybox.material = skyboxMaterial;
                skybox.receiveShadows = false;
            }

            // ================================================================
            // === ARENA GROUND - Style based on background config ===
            // ================================================================

            const groundElevation = bgConfig.groundElevation || 0;

            // Create main arena ground
            const ground = BABYLON.MeshBuilder.CreateGround('ground', {
                width: 40, height: 20, subdivisions: 32
            }, scene);
            ground.position.y = groundElevation;

            // Ground material based on background config
            const mat = new BABYLON.StandardMaterial('groundMat', scene);
            const textureUrl = TEXTURE_URLS[bgConfig.groundTexture] || TEXTURE_URLS.grass;
            const groundTex = new BABYLON.Texture(textureUrl, scene);
            groundTex.uScale = bgConfig.arenaStyle === 'platform' ? 8 : 10;
            groundTex.vScale = bgConfig.arenaStyle === 'platform' ? 4 : 5;
            mat.diffuseTexture = groundTex;
            mat.diffuseColor = bgConfig.groundColor;
            mat.specularColor = bgConfig.arenaStyle === 'platform'
                ? new BABYLON.Color3(0.2, 0.2, 0.2)
                : new BABYLON.Color3(0.05, 0.05, 0.04);
            mat.specularPower = bgConfig.arenaStyle === 'platform' ? 32 : 16;

            ground.material = mat;

            // Vertex colors for natural environments
            if (bgConfig.arenaStyle !== 'platform') {
                applyGroundVertexColors(ground);
            }

            new BABYLON.PhysicsAggregate(ground, BABYLON.PhysicsShapeType.BOX,
                { mass: 0, friction: 1.0, restitution: 0.05 }, scene);

            if (shadowGen) {
                ground.receiveShadows = true;
            }

            // ================================================================
            // === ARENA STYLE SPECIFIC ELEMENTS ===
            // ================================================================

            if (bgConfig.arenaStyle === 'platform') {
                // Metal arena platform - create elevated stage with supports
                createMetalArenaPlatform(scene, groundElevation);
            } else if (bgConfig.arenaStyle === 'dunes') {
                // Sand dunes environment
                createSandDunes(scene, shadowGen);
            }

            // === DEBRIS SCATTER (conditional) ===
            if (bgConfig.showDebris) {
                createDebrisScatter(scene, shadowGen);
            }

            // ================================================================
            // === EXTENDED HORIZON GROUND ===
            // ================================================================
            const horizonGround = BABYLON.MeshBuilder.CreateGround('horizonGround', {
                width: 800, height: 800, subdivisions: 8
            }, scene);
            horizonGround.position.y = bgConfig.arenaStyle === 'platform' ? -0.1 : groundElevation - 0.1;

            const horizonMat = new BABYLON.StandardMaterial('horizonMat', scene);
            const horizonTexUrl = TEXTURE_URLS[bgConfig.groundTexture] || TEXTURE_URLS.grass;
            const horizonTex = new BABYLON.Texture(horizonTexUrl, scene);
            horizonTex.uScale = 100;
            horizonTex.vScale = 100;
            horizonMat.diffuseTexture = horizonTex;
            horizonMat.diffuseColor = bgConfig.horizonColor;
            horizonMat.specularColor = new BABYLON.Color3(0, 0, 0);
            horizonMat.fogEnabled = true;

            horizonGround.material = horizonMat;
            horizonGround.receiveShadows = false;

            // Vertex colors for natural horizons
            if (bgConfig.arenaStyle !== 'platform') {
                applyGroundVertexColors(horizonGround, true);
            }

            // === DISTANT MOUNTAINS (conditional) ===
            if (bgConfig.showMountains) {
                if (bgConfig.arenaStyle === 'dunes') {
                    createDesertMountains(scene);
                } else {
                    createMountains(scene);
                }
            }

            // === ARENA ROCKS (for natural environments) ===
            if (bgConfig.arenaStyle === 'natural' || bgConfig.arenaStyle === 'wasteland') {
                const rockMat = new BABYLON.StandardMaterial('rockMat', scene);
                rockMat.diffuseTexture = TEXTURES.rock;
                rockMat.bumpTexture = TEXTURES.rockNormal;
                rockMat.bumpTexture.level = 1.0;
                rockMat.diffuseColor = new BABYLON.Color3(0.6, 0.55, 0.5);
                rockMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

                for (let i = 0; i < 6; i++) {
                    const rock = BABYLON.MeshBuilder.CreateBox('rock' + i, {
                        width: 0.6 + Math.random() * 0.8,
                        height: 0.2 + Math.random() * 0.4,
                        depth: 0.6 + Math.random() * 0.8
                    }, scene);
                    rock.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 25,
                        groundElevation + 0.15,
                        (Math.random() - 0.5) * 10
                    );
                    rock.rotation.y = Math.random() * Math.PI;
                    rock.material = rockMat;
                    new BABYLON.PhysicsAggregate(rock, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);
                }
            }

            log('[GROUND] Background: ' + backgroundType);
        }

        // ================================================================
        // === METAL ARENA PLATFORM ===
        // ================================================================
        // Creates an elevated metal combat platform with industrial supports
        function createMetalArenaPlatform(scene, elevation) {
            const platformMat = new BABYLON.StandardMaterial('platformMat', scene);
            platformMat.diffuseColor = new BABYLON.Color3(0.3, 0.32, 0.35);
            platformMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
            platformMat.specularPower = 64;

            // Platform edge rim
            const rimHeight = 0.3;
            const rimWidth = 0.5;

            // Create platform edges
            const edges = [
                { pos: [0, elevation - rimHeight/2, -10], size: [40, rimHeight, rimWidth] },
                { pos: [0, elevation - rimHeight/2, 10], size: [40, rimHeight, rimWidth] },
                { pos: [-20, elevation - rimHeight/2, 0], size: [rimWidth, rimHeight, 20] },
                { pos: [20, elevation - rimHeight/2, 0], size: [rimWidth, rimHeight, 20] }
            ];

            edges.forEach((edge, i) => {
                const edgeMesh = BABYLON.MeshBuilder.CreateBox('platformEdge' + i, {
                    width: edge.size[0], height: edge.size[1], depth: edge.size[2]
                }, scene);
                edgeMesh.position = new BABYLON.Vector3(...edge.pos);
                edgeMesh.material = platformMat;
            });

            // Support pillars
            const pillarMat = new BABYLON.StandardMaterial('pillarMat', scene);
            pillarMat.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.28);
            pillarMat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);

            const pillarPositions = [
                [-18, -8], [-18, 8], [18, -8], [18, 8],
                [-10, -8], [-10, 8], [10, -8], [10, 8],
                [0, -8], [0, 8]
            ];

            pillarPositions.forEach((pos, i) => {
                const pillar = BABYLON.MeshBuilder.CreateCylinder('pillar' + i, {
                    diameter: 1.2,
                    height: elevation,
                    tessellation: 8
                }, scene);
                pillar.position = new BABYLON.Vector3(pos[0], elevation / 2, pos[1]);
                pillar.material = pillarMat;
            });

            log('[PLATFORM] Metal arena created at elevation ' + elevation);
        }

        // ================================================================
        // === SAND DUNES ===
        // ================================================================
        // Creates rolling sand dunes around the arena
        function createSandDunes(scene, shadowGen) {
            const sandMat = new BABYLON.StandardMaterial('sandMat', scene);
            sandMat.diffuseColor = new BABYLON.Color3(0.9, 0.75, 0.5);
            sandMat.specularColor = new BABYLON.Color3(0.1, 0.08, 0.05);
            sandMat.specularPower = 8;

            // Create dunes around the arena
            const duneConfigs = [
                { x: -25, z: -5, scaleX: 12, scaleY: 3, scaleZ: 8, rotY: 0.2 },
                { x: -28, z: 6, scaleX: 10, scaleY: 2.5, scaleZ: 7, rotY: -0.3 },
                { x: 25, z: -3, scaleX: 11, scaleY: 2.8, scaleZ: 9, rotY: 0.4 },
                { x: 28, z: 7, scaleX: 9, scaleY: 2.2, scaleZ: 6, rotY: -0.1 },
                { x: 0, z: -15, scaleX: 20, scaleY: 2, scaleZ: 6, rotY: 0.1 },
                { x: -10, z: 14, scaleX: 14, scaleY: 2.5, scaleZ: 7, rotY: -0.2 },
                { x: 12, z: 15, scaleX: 12, scaleY: 2, scaleZ: 5, rotY: 0.3 }
            ];

            duneConfigs.forEach((config, i) => {
                // Use hemisphere for smooth dune shape
                const dune = BABYLON.MeshBuilder.CreateSphere('dune' + i, {
                    diameter: 1,
                    segments: 16
                }, scene);
                dune.scaling = new BABYLON.Vector3(config.scaleX, config.scaleY, config.scaleZ);
                dune.position = new BABYLON.Vector3(config.x, config.scaleY * 0.3, config.z);
                dune.rotation.y = config.rotY;
                dune.material = sandMat;

                if (shadowGen) {
                    dune.receiveShadows = true;
                }
            });

            // === SAND PATCHES ON ARENA FLOOR ===
            // Flat sand patches scattered across the arena for visual variety
            const sandPatchMat = new BABYLON.StandardMaterial('sandPatchMat', scene);
            sandPatchMat.diffuseColor = new BABYLON.Color3(0.5, 0.38, 0.2);
            sandPatchMat.specularColor = new BABYLON.Color3(0, 0, 0);
            sandPatchMat.emissiveColor = new BABYLON.Color3(0, 0, 0);
            sandPatchMat.backFaceCulling = false;

            for (let i = 0; i < 15; i++) {
                const patchSize = 2 + Math.random() * 3;
                const patch = BABYLON.MeshBuilder.CreateGround('sandPatch' + i, {
                    width: patchSize,
                    height: patchSize * (0.6 + Math.random() * 0.4)
                }, scene);
                patch.position = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 32,
                    0.02,  // Just above ground
                    (Math.random() - 0.5) * 16
                );
                patch.rotation.y = Math.random() * Math.PI * 2;
                patch.material = sandPatchMat;
                if (shadowGen) {
                    patch.receiveShadows = true;
                }
            }

            // Add some small rocks/debris in sand
            const rockMat = new BABYLON.StandardMaterial('desertRockMat', scene);
            rockMat.diffuseColor = new BABYLON.Color3(0.5, 0.45, 0.35);
            rockMat.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);

            for (let i = 0; i < 12; i++) {
                const rock = BABYLON.MeshBuilder.CreateBox('desertRock' + i, {
                    width: 0.3 + Math.random() * 0.4,
                    height: 0.1 + Math.random() * 0.15,
                    depth: 0.3 + Math.random() * 0.4
                }, scene);
                rock.position = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 35,
                    0.08,
                    (Math.random() - 0.5) * 18
                );
                rock.rotation.y = Math.random() * Math.PI;
                rock.material = rockMat;
            }

            log('[DUNES] Sand dunes and patches created');
        }

        // ================================================================
        // === DESERT MOUNTAINS ===
        // ================================================================
        // Creates mesa-style desert rock formations - closer to the arena
        function createDesertMountains(scene) {
            const mesaMat = new BABYLON.StandardMaterial('mesaMat', scene);
            mesaMat.diffuseColor = new BABYLON.Color3(0.55, 0.4, 0.25);
            mesaMat.specularColor = new BABYLON.Color3(0, 0, 0);
            mesaMat.emissiveColor = new BABYLON.Color3(0, 0, 0);
            mesaMat.fogEnabled = true;

            // Create mesa/butte style formations - MUCH CLOSER to arena
            const mesaConfigs = [
                { angle: 0, distance: 45, width: 15, height: 12 },
                { angle: Math.PI * 0.25, distance: 55, width: 18, height: 15 },
                { angle: Math.PI * 0.5, distance: 40, width: 12, height: 10 },
                { angle: Math.PI * 0.75, distance: 50, width: 16, height: 14 },
                { angle: Math.PI, distance: 45, width: 14, height: 11 },
                { angle: -Math.PI * 0.25, distance: 52, width: 17, height: 13 },
                { angle: -Math.PI * 0.5, distance: 42, width: 13, height: 9 },
                { angle: -Math.PI * 0.75, distance: 48, width: 15, height: 12 }
            ];

            mesaConfigs.forEach((config, i) => {
                const x = Math.sin(config.angle) * config.distance;
                const z = Math.cos(config.angle) * config.distance;

                // Main mesa body (flat-topped)
                const mesa = BABYLON.MeshBuilder.CreateCylinder('mesa' + i, {
                    diameterTop: config.width * 0.6,
                    diameterBottom: config.width,
                    height: config.height,
                    tessellation: 6
                }, scene);
                mesa.position = new BABYLON.Vector3(x, config.height / 2 - 2, z);
                mesa.material = mesaMat;

                // Add some variation with secondary spires
                if (Math.random() > 0.5) {
                    const spire = BABYLON.MeshBuilder.CreateCylinder('spire' + i, {
                        diameterTop: 0,
                        diameterBottom: config.width * 0.35,
                        height: config.height * 0.7,
                        tessellation: 5
                    }, scene);
                    spire.position = new BABYLON.Vector3(
                        x + (Math.random() - 0.5) * config.width * 0.6,
                        config.height * 0.35,
                        z + (Math.random() - 0.5) * config.width * 0.6
                    );
                    spire.material = mesaMat;
                }
            });

            log('[MOUNTAINS] Desert mesas created');
        }

        // ================================================================
        // === ORGANIC GROUND TEXTURE (Full Color, No Tiling) ===
        // ================================================================
        // Creates a natural-looking ground texture with grass colors
        // Spans entire ground - NO TILING means no repeating patterns
        // Uses multiple layers of organic blobs for natural variation

        function createOrganicGroundTexture(scene, size) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Base: mid-tone earthy green
            ctx.fillStyle = '#4a6b3a';
            ctx.fillRect(0, 0, size, size);

            // Layer 1: Large color variation blobs (the "fields")
            // These create broad areas of different grass shades
            for (let i = 0; i < 35; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const radius = size * 0.08 + Math.random() * size * 0.2;

                // Random grass/earth colors
                const colorType = Math.random();
                let r, g, b;
                if (colorType < 0.4) {
                    // Darker green (shadow/lush)
                    r = 50 + Math.random() * 30;
                    g = 80 + Math.random() * 40;
                    b = 40 + Math.random() * 25;
                } else if (colorType < 0.7) {
                    // Lighter green (sun/dry)
                    r = 90 + Math.random() * 40;
                    g = 120 + Math.random() * 40;
                    b = 60 + Math.random() * 30;
                } else if (colorType < 0.85) {
                    // Yellow-green (dead grass)
                    r = 110 + Math.random() * 40;
                    g = 115 + Math.random() * 35;
                    b = 50 + Math.random() * 30;
                } else {
                    // Brown/dirt patches
                    r = 100 + Math.random() * 40;
                    g = 80 + Math.random() * 30;
                    b = 50 + Math.random() * 25;
                }

                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.9)`);
                gradient.addColorStop(0.4, `rgba(${r}, ${g}, ${b}, 0.5)`);
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Layer 2: Medium patches for more detail
            for (let i = 0; i < 80; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const radius = size * 0.02 + Math.random() * size * 0.08;

                const r = 60 + Math.random() * 70;
                const g = 85 + Math.random() * 60;
                const b = 40 + Math.random() * 40;

                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.7)`);
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Layer 3: Fine pixel noise for texture
            const imageData = ctx.getImageData(0, 0, size, size);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 25;
                data[i] = Math.max(0, Math.min(255, data[i] + noise));
                data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise * 1.1));
                data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise * 0.7));
            }
            ctx.putImageData(imageData, 0, 0);

            // Layer 4: Scattered dirt/bare patches
            ctx.globalAlpha = 0.6;
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const radius = size * 0.01 + Math.random() * size * 0.04;

                ctx.fillStyle = `rgb(${90 + Math.random() * 50}, ${70 + Math.random() * 40}, ${45 + Math.random() * 30})`;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;

            // Layer 5: Subtle highlight streaks (sun/wind patterns)
            ctx.globalAlpha = 0.2;
            for (let i = 0; i < 12; i++) {
                const startX = Math.random() * size;
                const startY = Math.random() * size;
                const length = size * 0.1 + Math.random() * size * 0.25;
                const angle = Math.random() * Math.PI * 2;

                ctx.strokeStyle = `rgb(${130 + Math.random() * 50}, ${145 + Math.random() * 40}, ${80 + Math.random() * 40})`;
                ctx.lineWidth = 10 + Math.random() * 30;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.quadraticCurveTo(
                    startX + Math.cos(angle) * length * 0.5 + (Math.random() - 0.5) * 30,
                    startY + Math.sin(angle) * length * 0.5 + (Math.random() - 0.5) * 30,
                    startX + Math.cos(angle) * length,
                    startY + Math.sin(angle) * length
                );
                ctx.stroke();
            }
            ctx.globalAlpha = 1.0;

            // Create Babylon texture
            const texture = new BABYLON.DynamicTexture('organicGround', canvas, scene, false);
            texture.update();

            return texture;
        }

        // ================================================================
        // === VERTEX COLORS (Darken Battle Zone) ===
        // ================================================================
        // Paints ground mesh vertices based on distance from center
        // Center = darker (scorched battle zone), edges = lighter
        // This is FREE on GPU and breaks repetition pattern

        function applyGroundVertexColors(ground, isHorizon = false) {
            const positions = ground.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            if (!positions) return;

            const vertexCount = positions.length / 3;
            const colors = new Float32Array(vertexCount * 4);  // RGBA

            // Ground dimensions (from mesh)
            const boundingInfo = ground.getBoundingInfo();
            const halfWidth = (boundingInfo.maximum.x - boundingInfo.minimum.x) / 2;
            const halfDepth = (boundingInfo.maximum.z - boundingInfo.minimum.z) / 2;

            for (let i = 0; i < vertexCount; i++) {
                const x = positions[i * 3];
                const z = positions[i * 3 + 2];

                // Normalized distance from center (0 = center, 1 = edge)
                const distX = Math.abs(x) / halfWidth;
                const distZ = Math.abs(z) / halfDepth;
                const dist = Math.sqrt(distX * distX + distZ * distZ) / Math.sqrt(2);

                // Add random variation to break uniformity
                const noise = (Math.random() - 0.5) * 0.15;

                if (isHorizon) {
                    // Horizon: slight variation, generally uniform
                    const brightness = 0.85 + noise * 0.5;
                    colors[i * 4] = brightness;
                    colors[i * 4 + 1] = brightness + 0.02;
                    colors[i * 4 + 2] = brightness - 0.02;
                    colors[i * 4 + 3] = 1.0;
                } else {
                    // Arena: darken center (battle zone), lighter edges
                    // Center brightness ~0.7, edge brightness ~1.0
                    const centerDarkness = 0.7;
                    const brightness = centerDarkness + (1.0 - centerDarkness) * dist + noise;

                    // Slight color variation (more brown in center, more green at edges)
                    colors[i * 4] = Math.max(0.5, Math.min(1.0, brightness + 0.03));      // R
                    colors[i * 4 + 1] = Math.max(0.5, Math.min(1.0, brightness + 0.01));  // G
                    colors[i * 4 + 2] = Math.max(0.4, Math.min(0.95, brightness - 0.05)); // B
                    colors[i * 4 + 3] = 1.0;  // A
                }
            }

            ground.setVerticesData(BABYLON.VertexBuffer.ColorKind, colors);

            // Enable vertex colors in material
            if (ground.material) {
                ground.material.useVertexColors = true;
            }
        }

        // ================================================================
        // === THIN INSTANCE DEBRIS SCATTER ===
        // ================================================================
        // Creates hundreds of small debris items with the cost of ~1 draw call
        // This is the "Cover-Up" technique that hides ground tiling

        function createDebrisScatter(scene, shadowGen) {
            // === SMALL ROCKS/PEBBLES ===
            // Larger base size so they're visible
            const pebble = BABYLON.MeshBuilder.CreateBox('pebble', {
                width: 0.25, height: 0.12, depth: 0.2
            }, scene);
            pebble.isVisible = false;  // Template is invisible

            // Use textured material for visible rocks
            const debrisMat = new BABYLON.StandardMaterial('debrisMat', scene);
            debrisMat.diffuseTexture = new BABYLON.Texture(TEXTURE_URLS.rock, scene);
            debrisMat.diffuseColor = new BABYLON.Color3(0.55, 0.5, 0.45);
            debrisMat.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);
            pebble.material = debrisMat;

            // Create transformation matrices for each debris piece
            const debrisCount = 150;  // Moderate count
            const matrices = [];

            for (let i = 0; i < debrisCount; i++) {
                // Random position across arena (40x20)
                const x = (Math.random() - 0.5) * 36;
                const z = (Math.random() - 0.5) * 16;
                const y = 0.04;  // Sit on ground

                // Larger scale variation (0.8x to 2.5x) so some are very visible
                const scale = 0.8 + Math.random() * 1.7;

                // Random Y rotation
                const rotY = Math.random() * Math.PI * 2;
                // Slight tilt for natural look
                const rotX = (Math.random() - 0.5) * 0.3;
                const rotZ = (Math.random() - 0.5) * 0.3;

                // Build transformation matrix
                const matrix = BABYLON.Matrix.Compose(
                    new BABYLON.Vector3(scale, scale * (0.4 + Math.random() * 0.4), scale),
                    BABYLON.Quaternion.RotationYawPitchRoll(rotY, rotX, rotZ),
                    new BABYLON.Vector3(x, y, z)
                );
                matrices.push(matrix);
            }

            // Add all instances at once (single draw call)
            pebble.thinInstanceAdd(matrices);
            pebble.thinInstanceEnablePicking = false;

            log(`[DEBRIS] ${debrisCount} rock instances`);

            // === GRASS TUFTS / DEAD VEGETATION ===
            // Small vertical boxes to simulate grass clumps
            const grassTuft = BABYLON.MeshBuilder.CreateBox('grassTuft', {
                width: 0.08, height: 0.2, depth: 0.08
            }, scene);
            grassTuft.isVisible = false;

            const grassMat = new BABYLON.StandardMaterial('grassMat', scene);
            grassMat.diffuseColor = new BABYLON.Color3(0.45, 0.55, 0.3);  // Yellow-green dead grass
            grassMat.specularColor = new BABYLON.Color3(0, 0, 0);
            grassTuft.material = grassMat;

            const grassMatrices = [];
            for (let i = 0; i < 120; i++) {
                const x = (Math.random() - 0.5) * 38;
                const z = (Math.random() - 0.5) * 18;
                const scale = 0.6 + Math.random() * 1.0;
                const rotY = Math.random() * Math.PI * 2;

                const matrix = BABYLON.Matrix.Compose(
                    new BABYLON.Vector3(scale, scale * (0.8 + Math.random() * 0.8), scale),
                    BABYLON.Quaternion.RotationYawPitchRoll(rotY, 0, 0),
                    new BABYLON.Vector3(x, 0.08, z)
                );
                grassMatrices.push(matrix);
            }

            grassTuft.thinInstanceAdd(grassMatrices);
            grassTuft.thinInstanceEnablePicking = false;

            // === Dirt/mud patches using decal-style flat planes ===
            createDirtPatches(scene);
        }

        // ================================================================
        // === DIRT PATCHES - Texture Splatting Lite ===
        // ================================================================
        // Overlays dirt texture patches on the ground to simulate paths/wear
        // This is a lightweight alternative to full terrain splatting

        function createDirtPatches(scene) {
            // Create a flat plane for dirt patches - LARGE for high camera visibility
            const dirtPatch = BABYLON.MeshBuilder.CreateGround('dirtPatch', {
                width: 1, height: 1
            }, scene);
            dirtPatch.isVisible = false;

            // Dirt material - more visible brown/tan color
            const dirtMat = new BABYLON.StandardMaterial('dirtMat', scene);
            const dirtTex = new BABYLON.Texture(TEXTURE_URLS.rock, scene);
            dirtTex.uScale = 0.5;  // Low tiling so texture is visible
            dirtTex.vScale = 0.5;
            dirtMat.diffuseTexture = dirtTex;
            dirtMat.diffuseColor = new BABYLON.Color3(0.6, 0.5, 0.38);  // Tan/brown dirt
            dirtMat.specularColor = new BABYLON.Color3(0, 0, 0);
            dirtMat.alpha = 0.55;  // Semi-transparent for blending
            dirtPatch.material = dirtMat;

            const patchMatrices = [];

            // LARGE battle lane patches - visible from high camera
            // Center horizontal strip where mechs fight
            for (let i = 0; i < 8; i++) {
                const x = -15 + i * 4 + (Math.random() - 0.5) * 3;
                const z = (Math.random() - 0.5) * 5;
                // MUCH larger scale: 5-10 units instead of 2-3
                const scale = 5 + Math.random() * 5;
                const rotY = Math.random() * Math.PI;

                const matrix = BABYLON.Matrix.Compose(
                    new BABYLON.Vector3(scale, 1, scale * (0.5 + Math.random() * 0.5)),
                    BABYLON.Quaternion.RotationYawPitchRoll(rotY, 0, 0),
                    new BABYLON.Vector3(x, 0.03, z)  // Above noise overlay
                );
                patchMatrices.push(matrix);
            }

            // Large scattered patches covering more ground
            for (let i = 0; i < 12; i++) {
                const x = (Math.random() - 0.5) * 35;
                const z = (Math.random() - 0.5) * 16;
                // Large patches: 4-9 units
                const scale = 4 + Math.random() * 5;
                const rotY = Math.random() * Math.PI;

                const matrix = BABYLON.Matrix.Compose(
                    new BABYLON.Vector3(scale, 1, scale * (0.7 + Math.random() * 0.3)),
                    BABYLON.Quaternion.RotationYawPitchRoll(rotY, 0, 0),
                    new BABYLON.Vector3(x, 0.03, z)
                );
                patchMatrices.push(matrix);
            }

            dirtPatch.thinInstanceAdd(patchMatrices);
            dirtPatch.thinInstanceEnablePicking = false;

            log('[DIRT] 20 large patches for ground variation');
        }

        function createMountains(scene) {
            // Mountain material - dark silhouette that blends with fog
            const mountainMat = new BABYLON.StandardMaterial('mountainMat', scene);
            mountainMat.diffuseColor = new BABYLON.Color3(0.15, 0.18, 0.22);
            mountainMat.specularColor = new BABYLON.Color3(0, 0, 0);
            mountainMat.emissiveColor = new BABYLON.Color3(0.03, 0.04, 0.05);
            mountainMat.fogEnabled = true;

            // Create mountain ranges around the arena
            const mountainRanges = [
                { angle: 0, distance: 150, count: 8 },        // Front
                { angle: Math.PI, distance: 150, count: 8 },  // Back
                { angle: Math.PI/2, distance: 120, count: 6 },  // Right
                { angle: -Math.PI/2, distance: 120, count: 6 }, // Left
                // Corner fills
                { angle: Math.PI/4, distance: 140, count: 4 },
                { angle: 3*Math.PI/4, distance: 140, count: 4 },
                { angle: -Math.PI/4, distance: 140, count: 4 },
                { angle: -3*Math.PI/4, distance: 140, count: 4 }
            ];

            mountainRanges.forEach((range, rangeIdx) => {
                for (let i = 0; i < range.count; i++) {
                    // Randomize position along the range
                    const spreadAngle = (i / range.count - 0.5) * 0.8;
                    const finalAngle = range.angle + spreadAngle;
                    const dist = range.distance + (Math.random() - 0.5) * 40;

                    const x = Math.sin(finalAngle) * dist;
                    const z = Math.cos(finalAngle) * dist;

                    // Create jagged mountain peak using merged cones
                    const baseHeight = 25 + Math.random() * 35;
                    const baseWidth = 20 + Math.random() * 25;

                    // Main peak
                    const peak = BABYLON.MeshBuilder.CreateCylinder('mountain_' + rangeIdx + '_' + i, {
                        diameterTop: 0,
                        diameterBottom: baseWidth,
                        height: baseHeight,
                        tessellation: 6  // Hexagonal for more angular look
                    }, scene);
                    peak.position = new BABYLON.Vector3(x, baseHeight / 2 - 5, z);
                    peak.rotation.y = Math.random() * Math.PI;
                    peak.material = mountainMat;

                    // Secondary peaks for more interesting silhouette
                    if (Math.random() > 0.3) {
                        const secondaryHeight = baseHeight * (0.5 + Math.random() * 0.3);
                        const secondary = BABYLON.MeshBuilder.CreateCylinder('mountain_sec_' + rangeIdx + '_' + i, {
                            diameterTop: 0,
                            diameterBottom: baseWidth * 0.6,
                            height: secondaryHeight,
                            tessellation: 5
                        }, scene);
                        secondary.position = new BABYLON.Vector3(
                            x + (Math.random() - 0.5) * baseWidth * 0.4,
                            secondaryHeight / 2 - 5,
                            z + (Math.random() - 0.5) * baseWidth * 0.4
                        );
                        secondary.rotation.y = Math.random() * Math.PI;
                        secondary.material = mountainMat;
                    }
                }
            });

            // Add some very distant large mountains for depth
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const dist = 280 + Math.random() * 50;
                const x = Math.sin(angle) * dist;
                const z = Math.cos(angle) * dist;
                const height = 60 + Math.random() * 40;
                const width = 50 + Math.random() * 30;

                const farMountain = BABYLON.MeshBuilder.CreateCylinder('farMountain_' + i, {
                    diameterTop: 0,
                    diameterBottom: width,
                    height: height,
                    tessellation: 6
                }, scene);
                farMountain.position = new BABYLON.Vector3(x, height / 2 - 10, z);
                farMountain.material = mountainMat;
            }
        }

        function createWalls(scene) {
            // Invisible walls - physics only, no rendering
            // Adjust wall height based on ground elevation
            const groundElevation = bgConfig.groundElevation || 0;
            const wallCenterY = 5 + groundElevation;

            const walls = [
                { p: [-20, wallCenterY, 0], s: [1, 10, 20] },
                { p: [20, wallCenterY, 0], s: [1, 10, 20] },
                { p: [0, wallCenterY, 10], s: [40, 10, 1] },
                { p: [0, wallCenterY, -10], s: [40, 10, 1] }
            ];
            walls.forEach((w, i) => {
                const wall = BABYLON.MeshBuilder.CreateBox('wall' + i, { width: w.s[0], height: w.s[1], depth: w.s[2] }, scene);
                wall.position = new BABYLON.Vector3(...w.p);
                wall.isVisible = false;  // Invisible but still has physics
                new BABYLON.PhysicsAggregate(wall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);
            });
        }

        // ============================================
        // SHARED DIGITIGRADE LEG SYSTEM
        // Creates proper "lightning bolt" legs for all mechs
        // Short thin thigh (back-angled) â†’ knee â†’ long thick shin (forward-angled)
        // ============================================
        function createDigitigradeLeg(config) {
            const { scene, name, side, parent, scale, bulk, hipOffset, materials } = config;
            const { primaryMat, secondaryMat, darkMat, metalMat } = materials;
            const xOff = side === 'left' ? -1 : 1;
            const b = bulk || 1.0;  // Bulk multiplier for thickness

            // === HIP JOINT ===
            const hip = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Hip', {
                diameter: 0.32 * scale * b
            }, scene);
            hip.position = new BABYLON.Vector3(
                xOff * (hipOffset?.x || 0.7) * scale,
                (hipOffset?.y || -0.25) * scale,
                (hipOffset?.z || 0) * scale
            );
            hip.parent = parent;
            hip.material = metalMat;

            // Leg group for animation
            const legGroup = new BABYLON.TransformNode(name + '_' + side + 'LegGroup', scene);
            legGroup.position = hip.position.clone();
            legGroup.parent = parent;

            // === UPPER LEG (THIGH) - SHORT and THIN, angled BACKWARD ===
            const thighHeight = 0.5 * scale;  // SHORT thigh
            const upperLeg = new BABYLON.TransformNode(name + '_' + side + 'UpperLeg', scene);
            upperLeg.parent = legGroup;
            upperLeg.rotation.x = 0.5;  // Less forward = more back-angled appearance

            // Thin thigh mesh
            const upperLegMesh = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'UpperLegMesh', {
                width: 0.22 * scale * b,   // THIN
                height: thighHeight,
                depth: 0.24 * scale * b    // THIN
            }, scene);
            upperLegMesh.position = new BABYLON.Vector3(0, -thighHeight / 2, 0);
            upperLegMesh.parent = upperLeg;
            upperLegMesh.material = primaryMat;

            // Small thigh armor plate
            const thighArmor = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ThighArmor', {
                width: 0.26 * scale * b,
                height: 0.35 * scale,
                depth: 0.08 * scale
            }, scene);
            thighArmor.position = new BABYLON.Vector3(0, -thighHeight / 2, 0.14 * scale * b);
            thighArmor.parent = upperLeg;
            thighArmor.material = secondaryMat;

            // === KNEE JOINT - at bottom of thigh ===
            const knee = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Knee', {
                diameter: 0.3 * scale * b
            }, scene);
            knee.position = new BABYLON.Vector3(0, -thighHeight, 0);
            knee.parent = upperLeg;
            knee.material = metalMat;

            // Knee cap (pointing forward)
            const kneeCap = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'KneeCap', {
                width: 0.22 * scale * b,
                height: 0.2 * scale,
                depth: 0.14 * scale
            }, scene);
            kneeCap.position = new BABYLON.Vector3(0, 0, 0.18 * scale * b);
            kneeCap.parent = knee;
            kneeCap.material = secondaryMat;

            // === LOWER LEG (SHIN/CALF) - LONG and THICK, angled FORWARD ===
            const shinHeight = 1.2 * scale;  // LONG shin
            const lowerLeg = new BABYLON.TransformNode(name + '_' + side + 'LowerLeg', scene);
            lowerLeg.parent = knee;
            lowerLeg.rotation.x = -0.4;  // Less backward = more forward angle

            // Thick shin mesh
            const lowerLegMesh = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'LowerLegMesh', {
                width: 0.42 * scale * b,   // THICK
                height: shinHeight,
                depth: 0.48 * scale * b    // THICK
            }, scene);
            lowerLegMesh.position = new BABYLON.Vector3(0, -shinHeight / 2, 0);
            lowerLegMesh.parent = lowerLeg;
            lowerLegMesh.material = primaryMat;

            // Large calf bulge (rear actuator housing)
            const calfBulge = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'CalfBulge', {
                width: 0.38 * scale * b,
                height: 0.6 * scale,
                depth: 0.2 * scale
            }, scene);
            calfBulge.position = new BABYLON.Vector3(0, -shinHeight * 0.3, -0.32 * scale * b);
            calfBulge.parent = lowerLeg;
            calfBulge.material = secondaryMat;

            // Shin armor (front)
            const shinArmor = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ShinArmor', {
                width: 0.38 * scale * b,
                height: 0.8 * scale,
                depth: 0.1 * scale
            }, scene);
            shinArmor.position = new BABYLON.Vector3(0, -shinHeight * 0.35, 0.28 * scale * b);
            shinArmor.parent = lowerLeg;
            shinArmor.material = secondaryMat;

            // === ANKLE JOINT ===
            const ankle = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Ankle', {
                diameter: 0.26 * scale * b
            }, scene);
            ankle.position = new BABYLON.Vector3(0, -shinHeight, 0);
            ankle.parent = lowerLeg;
            ankle.material = metalMat;

            // Foot group for independent rotation
            const footGroup = new BABYLON.TransformNode(name + '_' + side + 'FootGroup', scene);
            footGroup.position = new BABYLON.Vector3(0, -0.1 * scale, 0);
            footGroup.parent = ankle;

            // === FOOT - THICK, tapered towards ends ===
            // Main foot body - chunky
            const foot = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Foot', {
                width: 0.5 * scale * b,
                height: 0.18 * scale,   // THICK
                depth: 0.4 * scale
            }, scene);
            foot.position = new BABYLON.Vector3(0, 0, 0.08 * scale);
            foot.parent = footGroup;
            foot.material = darkMat;

            // Foot armor top - chunky
            const footArmor = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'FootArmor', {
                width: 0.45 * scale * b,
                height: 0.1 * scale,
                depth: 0.35 * scale
            }, scene);
            footArmor.position = new BABYLON.Vector3(0, 0.1 * scale, 0);
            footArmor.parent = foot;
            footArmor.material = primaryMat;

            // Front toes - TAPERED (wide at base, narrow at tip)
            const toeL = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ToeL', {
                width: 0.14 * scale * b,
                height: 0.12 * scale,  // Thick
                depth: 0.35 * scale
            }, scene);
            toeL.position = new BABYLON.Vector3(-0.14 * scale * b, -0.02 * scale, 0.32 * scale);
            toeL.rotation.y = 0.25;
            toeL.parent = foot;
            toeL.material = primaryMat;

            // Toe tip L (tapered - smaller)
            const toeTipL = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ToeTipL', {
                width: 0.08 * scale * b,
                height: 0.08 * scale,
                depth: 0.15 * scale
            }, scene);
            toeTipL.position = new BABYLON.Vector3(0, -0.02 * scale, 0.22 * scale);
            toeTipL.parent = toeL;
            toeTipL.material = darkMat;

            const toeR = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ToeR', {
                width: 0.14 * scale * b,
                height: 0.12 * scale,  // Thick
                depth: 0.35 * scale
            }, scene);
            toeR.position = new BABYLON.Vector3(0.14 * scale * b, -0.02 * scale, 0.32 * scale);
            toeR.rotation.y = -0.25;
            toeR.parent = foot;
            toeR.material = primaryMat;

            // Toe tip R (tapered - smaller)
            const toeTipR = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ToeTipR', {
                width: 0.08 * scale * b,
                height: 0.08 * scale,
                depth: 0.15 * scale
            }, scene);
            toeTipR.position = new BABYLON.Vector3(0, -0.02 * scale, 0.22 * scale);
            toeTipR.parent = toeR;
            toeTipR.material = darkMat;

            // Rear heel spur - chunky
            const heel = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Heel', {
                width: 0.2 * scale * b,
                height: 0.1 * scale,
                depth: 0.25 * scale
            }, scene);
            heel.position = new BABYLON.Vector3(0, -0.02 * scale, -0.28 * scale);
            heel.rotation.x = 0.2;
            heel.parent = foot;
            heel.material = darkMat;

            return {
                hip, legGroup, upperLeg, knee, lowerLeg, ankle, foot, footGroup,
                thighArmor, kneeCap, calfBulge, shinArmor
            };
        }

        // ============================================
        // MAD CAT (Timber Wolf) - Highly Detailed
        // ============================================
        function createMadCatMech(scene, xPos, zPos, isPlayer) {
            const name = isPlayer ? 'player' : 'enemy';
            const primary = isPlayer ? COLORS.playerPrimary : COLORS.enemyPrimary;
            const secondary = isPlayer ? COLORS.playerSecondary : COLORS.enemySecondary;
            const accent = isPlayer ? COLORS.playerAccent : COLORS.enemyAccent;

            // Materials with textures
            const primaryMat = new BABYLON.StandardMaterial(name + '_primary', scene);
            primaryMat.diffuseTexture = TEXTURES.rustMetal.clone();
            primaryMat.diffuseTexture.uScale = 3;
            primaryMat.diffuseTexture.vScale = 3;
            primaryMat.diffuseColor = primary.scale(1.5);  // Tint the texture
            primaryMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            primaryMat.bumpTexture.uScale = 3;
            primaryMat.bumpTexture.vScale = 3;
            primaryMat.bumpTexture.level = 0.6;
            primaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            primaryMat.specularPower = 32;

            const secondaryMat = new BABYLON.StandardMaterial(name + '_secondary', scene);
            secondaryMat.diffuseTexture = TEXTURES.metal.clone();
            secondaryMat.diffuseTexture.uScale = 2;
            secondaryMat.diffuseTexture.vScale = 2;
            secondaryMat.diffuseColor = secondary.scale(1.3);
            secondaryMat.specularColor = new BABYLON.Color3(0.15, 0.15, 0.15);

            const accentMat = new BABYLON.StandardMaterial(name + '_accent', scene);
            accentMat.diffuseColor = accent;
            accentMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.3);
            accentMat.specularPower = 48;

            const metalMat = new BABYLON.StandardMaterial(name + '_metal', scene);
            metalMat.diffuseTexture = TEXTURES.rustMetal.clone();
            metalMat.diffuseTexture.uScale = 4;
            metalMat.diffuseTexture.vScale = 4;
            metalMat.diffuseColor = COLORS.metal.scale(1.2);
            metalMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            metalMat.bumpTexture.uScale = 4;
            metalMat.bumpTexture.vScale = 4;
            metalMat.bumpTexture.level = 0.5;
            metalMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            metalMat.specularPower = 64;

            const darkMat = new BABYLON.StandardMaterial(name + '_dark', scene);
            darkMat.diffuseColor = COLORS.darkMetal;
            darkMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            const cockpitMat = new BABYLON.StandardMaterial(name + '_cockpit', scene);
            cockpitMat.diffuseColor = COLORS.cockpit;
            cockpitMat.emissiveColor = COLORS.cockpit.scale(0.6);
            cockpitMat.alpha = 0.8;

            const chromeMat = new BABYLON.StandardMaterial(name + '_chrome', scene);
            chromeMat.diffuseColor = COLORS.chrome;
            chromeMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.9);
            chromeMat.specularPower = 128;

            // === PELVIS / CENTER (Physics body) - Wide stance for stability ===
            const pelvis = BABYLON.MeshBuilder.CreateBox(name + '_pelvis', {
                width: 1.8, height: 0.5, depth: 0.9  // Wider pelvis
            }, scene);
            pelvis.position = new BABYLON.Vector3(xPos, 3.5, zPos);  // Spawn height
            pelvis.material = darkMat;

            // Create a taller collision shape to represent the full mech standing height
            // The visual legs extend ~3 units below pelvis, so we use a tall box offset downward
            const pelvisShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -1.5, 0),  // Center offset (shift down to cover legs)
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(1.8, 3.5, 0.9),  // Full standing height
                scene
            );
            // HYBRID ARCHITECTURE: Start in ANIMATED (kinematic) mode for perfect walking control
            // Switch to DYNAMIC only when ragdolling from heavy impacts
            const pelvisBody = new BABYLON.PhysicsBody(pelvis, BABYLON.PhysicsMotionType.ANIMATED, false, scene);
            pelvisBody.shape = pelvisShape;
            pelvisBody.setMassProperties({ mass: 75 });
            // High angular damping for stiff mech feel (robots aren't floppy)
            pelvisBody.setAngularDamping(STABILITY_CONFIG.mechAngularDamping);
            pelvisBody.setLinearDamping(STABILITY_CONFIG.mechLinearDamping);

            // Set friction and restitution on the shape
            pelvisShape.material = { friction: 0.3, restitution: 0.05 };

            const pelvisAgg = { body: pelvisBody, shape: pelvisShape };  // Compatibility wrapper

            // === TORSO - Mad Cat Style with Conical Front ===
            const torsoCore = BABYLON.MeshBuilder.CreateBox(name + '_torsoCore', {
                width: 1.6, height: 1.2, depth: 1.1
            }, scene);
            torsoCore.position.y = 0.75;
            torsoCore.parent = pelvis;
            torsoCore.material = primaryMat;

            // Torso upper section (wider for missile racks)
            const torsoUpper = BABYLON.MeshBuilder.CreateBox(name + '_torsoUpper', {
                width: 1.8, height: 0.55, depth: 0.95
            }, scene);
            torsoUpper.position.y = 0.8;
            torsoUpper.parent = torsoCore;
            torsoUpper.material = secondaryMat;

            // === DISTINCTIVE CONICAL FRONT (Mad Cat "Bird Beak") ===
            // Main nose cone pointing forward
            const noseCone = BABYLON.MeshBuilder.CreateCylinder(name + '_noseCone', {
                height: 0.9, diameterTop: 0.15, diameterBottom: 0.7, tessellation: 8
            }, scene);
            noseCone.rotation.x = Math.PI / 2;
            noseCone.position = new BABYLON.Vector3(0, 0.15, 0.75);
            noseCone.parent = torsoCore;
            noseCone.material = primaryMat;

            // Nose cone tip (darker)
            const noseTip = BABYLON.MeshBuilder.CreateCylinder(name + '_noseTip', {
                height: 0.25, diameterTop: 0.08, diameterBottom: 0.18, tessellation: 8
            }, scene);
            noseTip.rotation.x = Math.PI / 2;
            noseTip.position = new BABYLON.Vector3(0, 0.15, 1.15);
            noseTip.parent = torsoCore;
            noseTip.material = darkMat;

            // Laser ports on nose (glowing)
            for (let i = 0; i < 2; i++) {
                const laserPort = BABYLON.MeshBuilder.CreateCylinder(name + '_laserPort' + i, {
                    height: 0.15, diameter: 0.12, tessellation: 12
                }, scene);
                laserPort.rotation.x = Math.PI / 2;
                laserPort.position = new BABYLON.Vector3((i - 0.5) * 0.25, 0.15, 1.22);
                laserPort.parent = torsoCore;
                const laserMat = new BABYLON.StandardMaterial(name + '_laserMat' + i, scene);
                laserMat.emissiveColor = isPlayer ? new BABYLON.Color3(0, 0.8, 1) : new BABYLON.Color3(1, 0.3, 0.1);
                laserPort.material = laserMat;
            }

            // Side chest plates (angled to form the cone shape)
            const chestLeft = BABYLON.MeshBuilder.CreateBox(name + '_chestL', {
                width: 0.5, height: 0.85, depth: 0.55
            }, scene);
            chestLeft.position = new BABYLON.Vector3(-0.5, 0.1, 0.4);
            chestLeft.rotation.x = -0.15;
            chestLeft.rotation.y = 0.35;
            chestLeft.parent = torsoCore;
            chestLeft.material = primaryMat;

            const chestRight = chestLeft.clone(name + '_chestR');
            chestRight.position.x = 0.5;
            chestRight.rotation.y = -0.35;
            chestRight.parent = torsoCore;

            // Side intake vents (decorative)
            for (let side = -1; side <= 1; side += 2) {
                const intake = BABYLON.MeshBuilder.CreateBox(name + '_intake' + side, {
                    width: 0.08, height: 0.4, depth: 0.35
                }, scene);
                intake.position = new BABYLON.Vector3(side * 0.65, 0.2, 0.25);
                intake.parent = torsoCore;
                intake.material = darkMat;

                // Vent slats
                for (let j = 0; j < 4; j++) {
                    const slat = BABYLON.MeshBuilder.CreateBox(name + '_slat' + side + j, {
                        width: 0.1, height: 0.03, depth: 0.3
                    }, scene);
                    slat.position = new BABYLON.Vector3(side * 0.02, (j - 1.5) * 0.09, 0);
                    slat.parent = intake;
                    slat.material = metalMat;
                }
            }

            // Center chest armor ridge
            const chestRidge = BABYLON.MeshBuilder.CreateBox(name + '_chestRidge', {
                width: 0.15, height: 0.7, depth: 0.5
            }, scene);
            chestRidge.position = new BABYLON.Vector3(0, 0.15, 0.35);
            chestRidge.parent = torsoCore;
            chestRidge.material = accentMat;

            // Lower chest detail
            const chestLower = BABYLON.MeshBuilder.CreateBox(name + '_chestLower', {
                width: 0.8, height: 0.25, depth: 0.4
            }, scene);
            chestLower.position = new BABYLON.Vector3(0, -0.35, 0.45);
            chestLower.parent = torsoCore;
            chestLower.material = secondaryMat;

            // Reactor housing (back) - larger
            const reactor = BABYLON.MeshBuilder.CreateBox(name + '_reactor', {
                width: 1.1, height: 0.9, depth: 0.6
            }, scene);
            reactor.position = new BABYLON.Vector3(0, 0.25, -0.7);
            reactor.parent = torsoCore;
            reactor.material = darkMat;

            // Heat sink fins (more prominent)
            for (let i = 0; i < 5; i++) {
                const fin = BABYLON.MeshBuilder.CreateBox(name + '_fin' + i, {
                    width: 0.06, height: 0.6, depth: 0.45
                }, scene);
                fin.position = new BABYLON.Vector3((i - 2) * 0.2, 0.05, 0.15);
                fin.parent = reactor;
                fin.material = metalMat;
            }

            // Exhaust vents (glowing)
            for (let i = 0; i < 3; i++) {
                const vent = BABYLON.MeshBuilder.CreateCylinder(name + '_vent' + i, {
                    height: 0.18, diameter: 0.2, tessellation: 12
                }, scene);
                vent.position = new BABYLON.Vector3((i - 1) * 0.32, -0.32, 0.32);
                vent.rotation.x = Math.PI / 2;
                vent.parent = reactor;
                const ventMat = new BABYLON.StandardMaterial(name + '_ventMat' + i, scene);
                ventMat.emissiveColor = COLORS.thruster.scale(0.5);
                vent.material = ventMat;
            }

            // === COCKPIT / HEAD - Detailed ===
            const headBase = BABYLON.MeshBuilder.CreateBox(name + '_headBase', {
                width: 0.6, height: 0.35, depth: 0.5
            }, scene);
            headBase.position = new BABYLON.Vector3(0, 0.55, 0.25);
            headBase.parent = torsoUpper;
            headBase.material = primaryMat;

            // Cockpit canopy (angled)
            const canopy = BABYLON.MeshBuilder.CreateBox(name + '_canopy', {
                width: 0.45, height: 0.25, depth: 0.35
            }, scene);
            canopy.position = new BABYLON.Vector3(0, 0.15, 0.15);
            canopy.rotation.x = -0.4;
            canopy.parent = headBase;
            canopy.material = cockpitMat;

            // Cockpit frame
            const frame1 = BABYLON.MeshBuilder.CreateBox(name + '_frame1', {
                width: 0.5, height: 0.04, depth: 0.3
            }, scene);
            frame1.position = new BABYLON.Vector3(0, 0.28, 0.1);
            frame1.rotation.x = -0.4;
            frame1.parent = headBase;
            frame1.material = darkMat;

            // Sensor pod on top
            const sensor = BABYLON.MeshBuilder.CreateCylinder(name + '_sensor', {
                height: 0.15, diameter: 0.12
            }, scene);
            sensor.position = new BABYLON.Vector3(0, 0.3, -0.1);
            sensor.parent = headBase;
            sensor.material = chromeMat;

            // Antenna
            const antenna = BABYLON.MeshBuilder.CreateCylinder(name + '_antenna', {
                height: 0.35, diameter: 0.04
            }, scene);
            antenna.position = new BABYLON.Vector3(0.2, 0.35, -0.1);
            antenna.parent = headBase;
            antenna.material = metalMat;

            // Chin sensor
            const chin = BABYLON.MeshBuilder.CreateBox(name + '_chin', {
                width: 0.2, height: 0.12, depth: 0.15
            }, scene);
            chin.position = new BABYLON.Vector3(0, -0.15, 0.25);
            chin.parent = headBase;
            chin.material = darkMat;

            // === GIANT SHOULDER MISSILE RACKS (LRM-20 Style) ===
            function createMissilePod(side) {
                const xOff = side === 'left' ? -1 : 1;
                const pod = new BABYLON.TransformNode(name + '_' + side + 'Pod', scene);
                pod.parent = torsoUpper;
                pod.position = new BABYLON.Vector3(xOff * 1.1, 0.5, -0.15);
                // Angle pods slightly outward for intimidating look
                pod.rotation.z = xOff * -0.15;

                // Main pod housing (much larger)
                const podBase = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodBase', {
                    width: 0.75, height: 0.85, depth: 1.0
                }, scene);
                podBase.parent = pod;
                podBase.material = primaryMat;

                // Angled front face plate
                const podFront = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodFront', {
                    width: 0.7, height: 0.8, depth: 0.15
                }, scene);
                podFront.position = new BABYLON.Vector3(0, 0, 0.5);
                podFront.rotation.x = -0.1;
                podFront.parent = podBase;
                podFront.material = secondaryMat;

                // Missile tubes (5x4 grid = 20 missiles per rack)
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 5; col++) {
                        const tube = BABYLON.MeshBuilder.CreateCylinder(name + '_tube_' + side + row + col, {
                            height: 0.2, diameter: 0.11, tessellation: 8
                        }, scene);
                        tube.rotation.x = Math.PI / 2;
                        tube.position = new BABYLON.Vector3(
                            (col - 2) * 0.13,
                            (row - 1.5) * 0.16,
                            0.55
                        );
                        tube.parent = podBase;
                        tube.material = darkMat;

                        // Missile tip visible in each tube
                        const missileTip = BABYLON.MeshBuilder.CreateCylinder(name + '_missile_' + side + row + col, {
                            height: 0.08, diameterTop: 0.02, diameterBottom: 0.07, tessellation: 6
                        }, scene);
                        missileTip.rotation.x = Math.PI / 2;
                        missileTip.position = new BABYLON.Vector3(
                            (col - 2) * 0.13,
                            (row - 1.5) * 0.16,
                            0.62
                        );
                        missileTip.parent = podBase;
                        missileTip.material = metalMat;
                    }
                }

                // Armored top with angular shape
                const podTop = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodTop', {
                    width: 0.72, height: 0.15, depth: 0.95
                }, scene);
                podTop.position.y = 0.48;
                podTop.parent = podBase;
                podTop.material = secondaryMat;

                // Top ridge
                const topRidge = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'TopRidge', {
                    width: 0.2, height: 0.12, depth: 0.85
                }, scene);
                topRidge.position = new BABYLON.Vector3(0, 0.58, 0);
                topRidge.parent = podBase;
                topRidge.material = accentMat;

                // Outer side armor panel
                const podSideOuter = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodSideO', {
                    width: 0.12, height: 0.75, depth: 0.9
                }, scene);
                podSideOuter.position.x = xOff * 0.4;
                podSideOuter.parent = podBase;
                podSideOuter.material = primaryMat;

                // Inner side armor panel
                const podSideInner = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodSideI', {
                    width: 0.1, height: 0.6, depth: 0.8
                }, scene);
                podSideInner.position.x = xOff * -0.38;
                podSideInner.parent = podBase;
                podSideInner.material = secondaryMat;

                // Bottom armor
                const podBottom = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodBottom', {
                    width: 0.65, height: 0.1, depth: 0.85
                }, scene);
                podBottom.position.y = -0.45;
                podBottom.parent = podBase;
                podBottom.material = darkMat;

                // Mounting strut connecting to torso
                const strut = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Strut', {
                    width: 0.2, height: 0.35, depth: 0.3
                }, scene);
                strut.position = new BABYLON.Vector3(xOff * -0.35, -0.25, 0);
                strut.parent = podBase;
                strut.material = metalMat;

                // Hydraulic actuator
                const actuator = BABYLON.MeshBuilder.CreateCylinder(name + '_' + side + 'Actuator', {
                    height: 0.4, diameter: 0.1, tessellation: 8
                }, scene);
                actuator.position = new BABYLON.Vector3(xOff * -0.28, -0.15, -0.25);
                actuator.rotation.x = 0.3;
                actuator.parent = podBase;
                actuator.material = chromeMat;

                // Warning stripes on side
                for (let i = 0; i < 3; i++) {
                    const stripe = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Stripe' + i, {
                        width: 0.13, height: 0.08, depth: 0.25
                    }, scene);
                    stripe.position = new BABYLON.Vector3(xOff * 0.405, 0.2 - i * 0.25, 0.2);
                    stripe.parent = podBase;
                    const stripeMat = new BABYLON.StandardMaterial(name + '_stripeMat' + side + i, scene);
                    stripeMat.diffuseColor = i % 2 === 0 ?
                        new BABYLON.Color3(0.9, 0.7, 0) : new BABYLON.Color3(0.1, 0.1, 0.1);
                    stripe.material = stripeMat;
                }

                return pod;
            }

            const leftPod = createMissilePod('left');
            const rightPod = createMissilePod('right');

            // === ARMS (Large Laser Pods) ===
            function createArm(side) {
                const xOff = side === 'left' ? -1 : 1;
                const armGroup = new BABYLON.TransformNode(name + '_' + side + 'Arm', scene);
                armGroup.parent = torsoCore;
                armGroup.position = new BABYLON.Vector3(xOff * 0.95, 0.1, 0);

                // Shoulder joint
                const shoulderJoint = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'ShoulderJ', {
                    diameter: 0.32
                }, scene);
                shoulderJoint.parent = armGroup;
                shoulderJoint.material = chromeMat;

                // Upper arm
                const upperArm = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'UpperArm', {
                    width: 0.28, height: 0.55, depth: 0.28
                }, scene);
                upperArm.position = new BABYLON.Vector3(xOff * 0.15, -0.35, 0);
                upperArm.parent = armGroup;
                upperArm.material = primaryMat;

                // Upper arm detail
                const upperDetail = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'UpperDetail', {
                    width: 0.32, height: 0.2, depth: 0.15
                }, scene);
                upperDetail.position = new BABYLON.Vector3(xOff * 0.05, 0, 0.15);
                upperDetail.parent = upperArm;
                upperDetail.material = secondaryMat;

                // Elbow
                const elbow = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Elbow', {
                    diameter: 0.22
                }, scene);
                elbow.position = new BABYLON.Vector3(0, -0.35, 0);
                elbow.parent = upperArm;
                elbow.material = metalMat;

                // Lower arm / weapon pod
                const weaponPod = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'WeaponPod', {
                    width: 0.45, height: 0.75, depth: 0.4
                }, scene);
                weaponPod.position = new BABYLON.Vector3(0, -0.75, 0);
                weaponPod.parent = upperArm;
                weaponPod.material = primaryMat;

                // Weapon pod front plate
                const podFront = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodFront', {
                    width: 0.4, height: 0.5, depth: 0.1
                }, scene);
                podFront.position.z = 0.22;
                podFront.parent = weaponPod;
                podFront.material = secondaryMat;

                // ER Large Laser barrels (2 per arm)
                for (let i = 0; i < 2; i++) {
                    const laserBarrel = BABYLON.MeshBuilder.CreateCylinder(name + '_laser_' + side + i, {
                        height: 0.7, diameter: 0.12
                    }, scene);
                    laserBarrel.rotation.x = Math.PI / 2;
                    laserBarrel.position = new BABYLON.Vector3((i - 0.5) * 0.15, -0.1, 0.5);
                    laserBarrel.parent = weaponPod;
                    laserBarrel.material = chromeMat;

                    // Barrel tip
                    const tip = BABYLON.MeshBuilder.CreateCylinder(name + '_laserTip_' + side + i, {
                        height: 0.08, diameter: 0.15
                    }, scene);
                    tip.rotation.x = Math.PI / 2;
                    tip.position.z = 0.38;
                    tip.parent = laserBarrel;
                    tip.material = darkMat;
                }

                // Weapon pod side detail
                const podSideL = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodSideL', {
                    width: 0.08, height: 0.5, depth: 0.3
                }, scene);
                podSideL.position = new BABYLON.Vector3(-0.22, 0, 0);
                podSideL.parent = weaponPod;
                podSideL.material = accentMat;

                const podSideR = podSideL.clone(name + '_' + side + 'PodSideR');
                podSideR.position.x = 0.22;
                podSideR.parent = weaponPod;

                return { armGroup, upperArm, weaponPod };
            }

            const leftArm = createArm('left');
            const rightArm = createArm('right');

            // === LEGS - Using shared digitigrade system ===
            const legMaterials = { primaryMat, secondaryMat, darkMat, metalMat };
            const leftLeg = createDigitigradeLeg({
                scene, name, side: 'left', parent: pelvis, scale: 1.0,
                bulk: 1.1,  // Slightly heavier for assault mech
                hipOffset: { x: 0.8, y: -0.3, z: -0.1 },
                materials: legMaterials
            });
            const rightLeg = createDigitigradeLeg({
                scene, name, side: 'right', parent: pelvis, scale: 1.0,
                bulk: 1.1,
                hipOffset: { x: 0.8, y: -0.3, z: -0.1 },
                materials: legMaterials
            });
            // Build mech data
            return {
                name: 'TIMBER WOLF',
                pelvis, pelvisAggregate: pelvisAgg,
                torso: torsoCore, head: headBase, cockpit: canopy,
                leftArm, rightArm, leftLeg, rightLeg,
                leftPod, rightPod,
                isPlayer, scale: 1.0,
                standingHeight: 2.5,  // Pelvis Y for feet to touch ground
                optimalRange: 10,      // Ideal combat distance for this mech
                stats: { maxHP: 150, mass: 75 },
                currentHP: 150, maxHP: 150,
                isWalking: false, walkCycle: 0, walkSpeed: 2.8,
                walkDirection: isPlayer ? 1 : -1,
                impactRecovery: 0, impactDirection: new BABYLON.Vector3(0,0,0),
                staggerTime: 0, recoilRecovery: 0, lastFiredArm: 'right',
                torsoTwist: 0, targetTorsoTwist: 0,
                // HYBRID STATE MACHINE properties
                mechState: MechState.WALKING,
                stability: STABILITY_CONFIG.maxStability,
                ragdollSettleTimer: 0,
                recoveryTimer: 0,
                destroyedTimer: 0,
                lastKinematicVelocity: new BABYLON.Vector3(0, 0, 0),
                flinchIntensity: 0,
                // AI state
                ai: {
                    enabled: false,
                    state: 'idle',        // idle, advancing, retreating, optimal, strafing
                    target: null,         // Current target mech
                    lastDecision: 0,
                    strafeDir: 0,         // -1 left, 0 none, 1 right
                    strafeEndTime: 0
                }
            };
        }

        // ============================================
        // DIRE WOLF (Daishi) - Even More Detailed, Heavier
        // ============================================
        function createDireWolfMech(scene, xPos, zPos, isPlayer) {
            const name = isPlayer ? 'player' : 'enemy';
            const primary = isPlayer ? COLORS.playerPrimary : COLORS.enemyPrimary;
            const secondary = isPlayer ? COLORS.playerSecondary : COLORS.enemySecondary;
            const accent = isPlayer ? COLORS.playerAccent : COLORS.enemyAccent;

            // Materials with textures
            const primaryMat = new BABYLON.StandardMaterial(name + '_primary', scene);
            primaryMat.diffuseTexture = TEXTURES.rustMetal.clone();
            primaryMat.diffuseTexture.uScale = 3;
            primaryMat.diffuseTexture.vScale = 3;
            primaryMat.diffuseColor = primary.scale(1.5);
            primaryMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            primaryMat.bumpTexture.uScale = 3;
            primaryMat.bumpTexture.vScale = 3;
            primaryMat.bumpTexture.level = 0.6;
            primaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            primaryMat.specularPower = 32;

            const secondaryMat = new BABYLON.StandardMaterial(name + '_secondary', scene);
            secondaryMat.diffuseTexture = TEXTURES.metal.clone();
            secondaryMat.diffuseTexture.uScale = 2;
            secondaryMat.diffuseTexture.vScale = 2;
            secondaryMat.diffuseColor = secondary.scale(1.3);
            secondaryMat.specularColor = new BABYLON.Color3(0.15, 0.15, 0.15);

            const accentMat = new BABYLON.StandardMaterial(name + '_accent', scene);
            accentMat.diffuseColor = accent;
            accentMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.3);
            accentMat.specularPower = 48;

            const metalMat = new BABYLON.StandardMaterial(name + '_metal', scene);
            metalMat.diffuseTexture = TEXTURES.rustMetal.clone();
            metalMat.diffuseTexture.uScale = 4;
            metalMat.diffuseTexture.vScale = 4;
            metalMat.diffuseColor = COLORS.metal.scale(1.2);
            metalMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            metalMat.bumpTexture.uScale = 4;
            metalMat.bumpTexture.vScale = 4;
            metalMat.bumpTexture.level = 0.5;
            metalMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            metalMat.specularPower = 64;

            const darkMat = new BABYLON.StandardMaterial(name + '_dark', scene);
            darkMat.diffuseColor = COLORS.darkMetal;
            darkMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            const cockpitMat = new BABYLON.StandardMaterial(name + '_cockpit', scene);
            cockpitMat.diffuseColor = COLORS.cockpit;
            cockpitMat.emissiveColor = COLORS.cockpit.scale(0.5);
            cockpitMat.alpha = 0.8;

            const chromeMat = new BABYLON.StandardMaterial(name + '_chrome', scene);
            chromeMat.diffuseColor = COLORS.chrome;
            chromeMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.9);
            chromeMat.specularPower = 128;

            const scale = 1.15; // Bigger mech

            // === PELVIS - Wide stance for stability ===
            const pelvis = BABYLON.MeshBuilder.CreateBox(name + '_pelvis', {
                width: 2.0 * scale, height: 0.55 * scale, depth: 1.0 * scale  // Wider pelvis
            }, scene);
            pelvis.position = new BABYLON.Vector3(xPos, 3.8, zPos);  // Spawn height
            pelvis.material = darkMat;

            // Create a taller collision shape to represent the full mech standing height
            // Dire Wolf is bigger (scale 1.15), legs extend ~3.5 units below pelvis
            const pelvisShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -1.7 * scale, 0),  // Center offset (shift down to cover legs)
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(2.0 * scale, 4.0 * scale, 1.0 * scale),  // Full standing height
                scene
            );
            // HYBRID ARCHITECTURE: Start in ANIMATED (kinematic) mode for perfect walking control
            const pelvisBody = new BABYLON.PhysicsBody(pelvis, BABYLON.PhysicsMotionType.ANIMATED, false, scene);
            pelvisBody.shape = pelvisShape;
            pelvisBody.setMassProperties({ mass: 100 });
            pelvisBody.setAngularDamping(STABILITY_CONFIG.mechAngularDamping);
            pelvisBody.setLinearDamping(STABILITY_CONFIG.mechLinearDamping);

            // Set friction and restitution on the shape
            pelvisShape.material = { friction: 0.3, restitution: 0.05 };

            const pelvisAgg = { body: pelvisBody, shape: pelvisShape };  // Compatibility wrapper

            // === MASSIVE TORSO - Dire Wolf Style with Angular Front ===
            const torsoCore = BABYLON.MeshBuilder.CreateBox(name + '_torsoCore', {
                width: 1.9 * scale, height: 1.4 * scale, depth: 1.3 * scale
            }, scene);
            torsoCore.position.y = 0.85 * scale;
            torsoCore.parent = pelvis;
            torsoCore.material = primaryMat;

            // Upper torso (wider for weapon pods)
            const torsoUpper = BABYLON.MeshBuilder.CreateBox(name + '_torsoUpper', {
                width: 2.0 * scale, height: 0.65 * scale, depth: 1.1 * scale
            }, scene);
            torsoUpper.position.y = 0.9 * scale;
            torsoUpper.parent = torsoCore;
            torsoUpper.material = secondaryMat;

            // === DISTINCTIVE ANGULAR FRONT (Dire Wolf "Fortress" style) ===
            // Main angular nose section
            const noseCone = BABYLON.MeshBuilder.CreateCylinder(name + '_noseCone', {
                height: 1.1 * scale, diameterTop: 0.2 * scale, diameterBottom: 0.85 * scale, tessellation: 6
            }, scene);
            noseCone.rotation.x = Math.PI / 2;
            noseCone.position = new BABYLON.Vector3(0, 0.1 * scale, 0.85 * scale);
            noseCone.parent = torsoCore;
            noseCone.material = primaryMat;

            // Nose armor tip
            const noseTip = BABYLON.MeshBuilder.CreateCylinder(name + '_noseTip', {
                height: 0.3 * scale, diameterTop: 0.1 * scale, diameterBottom: 0.25 * scale, tessellation: 6
            }, scene);
            noseTip.rotation.x = Math.PI / 2;
            noseTip.position = new BABYLON.Vector3(0, 0.1 * scale, 1.35 * scale);
            noseTip.parent = torsoCore;
            noseTip.material = darkMat;

            // Heavy laser array on nose (4 barrels)
            for (let i = 0; i < 4; i++) {
                const laserBarrel = BABYLON.MeshBuilder.CreateCylinder(name + '_laserBarrel' + i, {
                    height: 0.25 * scale, diameter: 0.1 * scale, tessellation: 12
                }, scene);
                laserBarrel.rotation.x = Math.PI / 2;
                const angle = (i / 4) * Math.PI * 2;
                laserBarrel.position = new BABYLON.Vector3(
                    Math.cos(angle) * 0.18 * scale,
                    0.1 * scale + Math.sin(angle) * 0.18 * scale,
                    1.45 * scale
                );
                laserBarrel.parent = torsoCore;
                const barrelMat = new BABYLON.StandardMaterial(name + '_barrelMat' + i, scene);
                barrelMat.emissiveColor = isPlayer ? new BABYLON.Color3(0, 0.8, 1) : new BABYLON.Color3(1, 0.2, 0.1);
                laserBarrel.material = barrelMat;
            }

            // Side chest plates (angled for angular look)
            for (let side = -1; side <= 1; side += 2) {
                const chestPlate = BABYLON.MeshBuilder.CreateBox(name + '_chestPlate' + side, {
                    width: 0.6 * scale, height: 0.95 * scale, depth: 0.6 * scale
                }, scene);
                chestPlate.position = new BABYLON.Vector3(side * 0.6 * scale, 0.05 * scale, 0.45 * scale);
                chestPlate.rotation.y = side * 0.4;
                chestPlate.parent = torsoCore;
                chestPlate.material = primaryMat;

                // Armor detail on chest plates
                const plateDetail = BABYLON.MeshBuilder.CreateBox(name + '_plateDetail' + side, {
                    width: 0.5 * scale, height: 0.6 * scale, depth: 0.12 * scale
                }, scene);
                plateDetail.position = new BABYLON.Vector3(0, 0, 0.32 * scale);
                plateDetail.parent = chestPlate;
                plateDetail.material = secondaryMat;
            }

            // Side torso panels (larger)
            for (let side = -1; side <= 1; side += 2) {
                const sidePanel = BABYLON.MeshBuilder.CreateBox(name + '_sidePanel' + side, {
                    width: 0.18 * scale, height: 1.0 * scale, depth: 0.9 * scale
                }, scene);
                sidePanel.position = new BABYLON.Vector3(side * 0.95 * scale, 0.15 * scale, 0);
                sidePanel.parent = torsoCore;
                sidePanel.material = secondaryMat;

                // Vent grilles
                for (let j = 0; j < 3; j++) {
                    const grille = BABYLON.MeshBuilder.CreateBox(name + '_grille' + side + j, {
                        width: 0.2 * scale, height: 0.05 * scale, depth: 0.4 * scale
                    }, scene);
                    grille.position = new BABYLON.Vector3(side * 0.02, (j - 1) * 0.2 * scale, 0.1 * scale);
                    grille.parent = sidePanel;
                    grille.material = darkMat;
                }
            }

            // Center chest ridge
            const chestRidge = BABYLON.MeshBuilder.CreateBox(name + '_chestRidge', {
                width: 0.2 * scale, height: 0.8 * scale, depth: 0.55 * scale
            }, scene);
            chestRidge.position = new BABYLON.Vector3(0, 0.1 * scale, 0.4 * scale);
            chestRidge.parent = torsoCore;
            chestRidge.material = accentMat;

            // Large reactor (back)
            const reactor = BABYLON.MeshBuilder.CreateBox(name + '_reactor', {
                width: 1.3 * scale, height: 1.1 * scale, depth: 0.7 * scale
            }, scene);
            reactor.position = new BABYLON.Vector3(0, 0.3 * scale, -0.85 * scale);
            reactor.parent = torsoCore;
            reactor.material = darkMat;

            // Reactor pipes
            for (let i = 0; i < 4; i++) {
                const pipe = BABYLON.MeshBuilder.CreateCylinder(name + '_pipe' + i, {
                    height: 0.9 * scale, diameter: 0.14 * scale
                }, scene);
                pipe.position = new BABYLON.Vector3((i - 1.5) * 0.28 * scale, 0.15 * scale, 0);
                pipe.rotation.x = 0.15;
                pipe.parent = reactor;
                pipe.material = chromeMat;
            }

            // Exhaust array (larger)
            for (let i = 0; i < 4; i++) {
                const exhaust = BABYLON.MeshBuilder.CreateCylinder(name + '_exhaust' + i, {
                    height: 0.22 * scale, diameter: 0.18 * scale, tessellation: 12
                }, scene);
                exhaust.rotation.x = Math.PI / 2;
                exhaust.position = new BABYLON.Vector3((i - 1.5) * 0.28 * scale, -0.4 * scale, 0.38 * scale);
                exhaust.parent = reactor;
                const exMat = new BABYLON.StandardMaterial(name + '_exMat' + i, scene);
                exMat.emissiveColor = COLORS.thruster.scale(0.4);
                exhaust.material = exMat;
            }

            // === HEAD (Smaller, bunker-style) ===
            const headBase = BABYLON.MeshBuilder.CreateBox(name + '_headBase', {
                width: 0.55 * scale, height: 0.35 * scale, depth: 0.45 * scale
            }, scene);
            headBase.position = new BABYLON.Vector3(0, 0.55 * scale, 0.2 * scale);
            headBase.parent = torsoUpper;
            headBase.material = primaryMat;

            const canopy = BABYLON.MeshBuilder.CreateBox(name + '_canopy', {
                width: 0.4 * scale, height: 0.18 * scale, depth: 0.25 * scale
            }, scene);
            canopy.position = new BABYLON.Vector3(0, 0.1 * scale, 0.15 * scale);
            canopy.rotation.x = -0.35;
            canopy.parent = headBase;
            canopy.material = cockpitMat;

            // Sensor array
            for (let i = 0; i < 2; i++) {
                const sens = BABYLON.MeshBuilder.CreateCylinder(name + '_sens' + i, {
                    height: 0.12 * scale, diameter: 0.08 * scale
                }, scene);
                sens.position = new BABYLON.Vector3((i - 0.5) * 0.2 * scale, 0.22 * scale, 0);
                sens.parent = headBase;
                sens.material = chromeMat;
            }

            // === MASSIVE SHOULDER WEAPON PODS ===
            function createWeaponPod(side) {
                const xOff = side === 'left' ? -1 : 1;
                const pod = new BABYLON.TransformNode(name + '_' + side + 'WeaponPod', scene);
                pod.parent = torsoUpper;
                pod.position = new BABYLON.Vector3(xOff * 1.1 * scale, 0.2 * scale, 0);

                // Main pod body
                const podBody = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodBody', {
                    width: 0.7 * scale, height: 0.65 * scale, depth: 0.9 * scale
                }, scene);
                podBody.parent = pod;
                podBody.material = primaryMat;

                // Pod top armor
                const podTop = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodTop', {
                    width: 0.65 * scale, height: 0.15 * scale, depth: 0.85 * scale
                }, scene);
                podTop.position.y = 0.38 * scale;
                podTop.parent = podBody;
                podTop.material = secondaryMat;

                // Missile tubes (5x4)
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 5; c++) {
                        const tube = BABYLON.MeshBuilder.CreateCylinder(name + '_mtube' + side + r + c, {
                            height: 0.1 * scale, diameter: 0.07 * scale
                        }, scene);
                        tube.rotation.x = Math.PI / 2;
                        tube.position = new BABYLON.Vector3(
                            (c - 2) * 0.11 * scale,
                            (r - 1.5) * 0.11 * scale,
                            0.48 * scale
                        );
                        tube.parent = podBody;
                        tube.material = darkMat;
                    }
                }

                // Side weapon (autocannon or laser)
                const sideGun = BABYLON.MeshBuilder.CreateCylinder(name + '_' + side + 'SideGun', {
                    height: 0.8 * scale, diameter: 0.15 * scale
                }, scene);
                sideGun.rotation.x = Math.PI / 2;
                sideGun.position = new BABYLON.Vector3(xOff * 0.32 * scale, -0.15 * scale, 0.55 * scale);
                sideGun.parent = podBody;
                sideGun.material = chromeMat;

                return pod;
            }

            const leftPod = createWeaponPod('left');
            const rightPod = createWeaponPod('right');

            // === ARMS (Heavy weapon mounts) ===
            function createArm(side) {
                const xOff = side === 'left' ? -1 : 1;
                const armGroup = new BABYLON.TransformNode(name + '_' + side + 'Arm', scene);
                armGroup.parent = torsoCore;
                armGroup.position = new BABYLON.Vector3(xOff * 1.1 * scale, 0, 0);

                const shoulder = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Shoulder', {
                    diameter: 0.35 * scale
                }, scene);
                shoulder.parent = armGroup;
                shoulder.material = chromeMat;

                const upperArm = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'UpperArm', {
                    width: 0.32 * scale, height: 0.6 * scale, depth: 0.32 * scale
                }, scene);
                upperArm.position = new BABYLON.Vector3(xOff * 0.12 * scale, -0.38 * scale, 0);
                upperArm.parent = armGroup;
                upperArm.material = primaryMat;

                const elbow = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Elbow', {
                    diameter: 0.25 * scale
                }, scene);
                elbow.position.y = -0.38 * scale;
                elbow.parent = upperArm;
                elbow.material = metalMat;

                // Massive weapon pod
                const weaponPod = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ArmWeapon', {
                    width: 0.5 * scale, height: 0.85 * scale, depth: 0.45 * scale
                }, scene);
                weaponPod.position = new BABYLON.Vector3(0, -0.8 * scale, 0);
                weaponPod.parent = upperArm;
                weaponPod.material = primaryMat;

                // Quad laser barrels
                for (let r = 0; r < 2; r++) {
                    for (let c = 0; c < 2; c++) {
                        const barrel = BABYLON.MeshBuilder.CreateCylinder(name + '_barrel' + side + r + c, {
                            height: 0.75 * scale, diameter: 0.1 * scale
                        }, scene);
                        barrel.rotation.x = Math.PI / 2;
                        barrel.position = new BABYLON.Vector3(
                            (c - 0.5) * 0.15 * scale,
                            -0.15 * scale + r * 0.2 * scale,
                            0.55 * scale
                        );
                        barrel.parent = weaponPod;
                        barrel.material = chromeMat;
                    }
                }

                return { armGroup, upperArm, weaponPod };
            }

            const leftArm = createArm('left');
            const rightArm = createArm('right');

            // === LEGS - Using shared digitigrade system ===
            const legMaterials = { primaryMat, secondaryMat, darkMat, metalMat };
            const leftLeg = createDigitigradeLeg({
                scene, name, side: 'left', parent: pelvis, scale,
                bulk: 1.2,  // Extra heavy for assault mech
                hipOffset: { x: 0.9, y: -0.32, z: -0.1 },
                materials: legMaterials
            });
            const rightLeg = createDigitigradeLeg({
                scene, name, side: 'right', parent: pelvis, scale,
                bulk: 1.2,
                hipOffset: { x: 0.9, y: -0.32, z: -0.1 },
                materials: legMaterials
            });

            return {
                name: 'DIRE WOLF',
                pelvis, pelvisAggregate: pelvisAgg,
                torso: torsoCore, head: headBase, cockpit: canopy,
                leftArm, rightArm, leftLeg, rightLeg,
                leftPod, rightPod,
                isPlayer, scale,
                standingHeight: 3.2,   // Pelvis Y for feet to touch ground
                optimalRange: 12,       // Heavier mech prefers longer range
                stats: { maxHP: 200, mass: 100 },
                currentHP: 200, maxHP: 200,
                isWalking: false, walkCycle: 0, walkSpeed: 2.2,
                walkDirection: isPlayer ? 1 : -1,
                impactRecovery: 0, impactDirection: new BABYLON.Vector3(0,0,0),
                staggerTime: 0, recoilRecovery: 0, lastFiredArm: 'right',
                torsoTwist: 0, targetTorsoTwist: 0,
                // HYBRID STATE MACHINE properties
                mechState: MechState.WALKING,
                stability: STABILITY_CONFIG.maxStability,
                ragdollSettleTimer: 0,
                recoveryTimer: 0,
                destroyedTimer: 0,
                lastKinematicVelocity: new BABYLON.Vector3(0, 0, 0),
                flinchIntensity: 0,
                // AI state
                ai: {
                    enabled: false,
                    state: 'idle',        // idle, advancing, retreating, optimal, strafing
                    target: null,         // Current target mech
                    lastDecision: 0,
                    strafeDir: 0,         // -1 left, 0 none, 1 right
                    strafeEndTime: 0
                }
            };
        }

        // ============================================
        // COMMANDO - Light Scout Mech
        // ============================================
        function createCommandoMech(scene, xPos, zPos, isPlayer) {
            const name = (isPlayer ? 'player' : 'enemy') + '_commando_' + Math.random().toString(36).substr(2, 4);
            const primary = isPlayer ? COLORS.playerPrimary : COLORS.enemyPrimary;
            const secondary = isPlayer ? COLORS.playerSecondary : COLORS.enemySecondary;
            const scale = 0.7;  // Smaller mech

            // Materials with textures
            const primaryMat = new BABYLON.StandardMaterial(name + '_primary', scene);
            primaryMat.diffuseTexture = TEXTURES.rustMetal.clone();
            primaryMat.diffuseTexture.uScale = 2;
            primaryMat.diffuseTexture.vScale = 2;
            primaryMat.diffuseColor = primary.scale(1.4);
            primaryMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            primaryMat.bumpTexture.uScale = 2;
            primaryMat.bumpTexture.vScale = 2;
            primaryMat.bumpTexture.level = 0.5;
            primaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            primaryMat.specularPower = 32;

            const secondaryMat = new BABYLON.StandardMaterial(name + '_secondary', scene);
            secondaryMat.diffuseTexture = TEXTURES.metal.clone();
            secondaryMat.diffuseTexture.uScale = 2;
            secondaryMat.diffuseTexture.vScale = 2;
            secondaryMat.diffuseColor = secondary.scale(1.2);
            secondaryMat.specularColor = new BABYLON.Color3(0.15, 0.15, 0.15);

            const darkMat = new BABYLON.StandardMaterial(name + '_dark', scene);
            darkMat.diffuseColor = COLORS.darkMetal;
            darkMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            const metalMat = new BABYLON.StandardMaterial(name + '_metal', scene);
            metalMat.diffuseTexture = TEXTURES.rustMetal.clone();
            metalMat.diffuseTexture.uScale = 3;
            metalMat.diffuseTexture.vScale = 3;
            metalMat.diffuseColor = COLORS.metal.scale(1.2);
            metalMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            metalMat.bumpTexture.uScale = 3;
            metalMat.bumpTexture.vScale = 3;
            metalMat.bumpTexture.level = 0.4;
            metalMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
            metalMat.specularPower = 48;

            // Pelvis - smaller
            const pelvis = BABYLON.MeshBuilder.CreateBox(name + '_pelvis', {
                width: 1.2 * scale, height: 0.4 * scale, depth: 0.7 * scale
            }, scene);
            pelvis.position = new BABYLON.Vector3(xPos, 3.0, zPos);
            pelvis.material = darkMat;

            const pelvisShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -1.2, 0),
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(1.2 * scale, 2.8, 0.7 * scale),
                scene
            );
            // HYBRID ARCHITECTURE: Start in ANIMATED (kinematic) mode for perfect walking control
            const pelvisBody = new BABYLON.PhysicsBody(pelvis, BABYLON.PhysicsMotionType.ANIMATED, false, scene);
            pelvisBody.shape = pelvisShape;
            pelvisBody.setMassProperties({ mass: 40 });
            pelvisBody.setAngularDamping(STABILITY_CONFIG.mechAngularDamping);
            pelvisBody.setLinearDamping(STABILITY_CONFIG.mechLinearDamping);
            pelvisShape.material = { friction: 0.3, restitution: 0.05 };
            const pelvisAgg = { body: pelvisBody, shape: pelvisShape };

            // Torso - compact, angular
            const torsoCore = BABYLON.MeshBuilder.CreateBox(name + '_torso', {
                width: 1.0 * scale, height: 1.2 * scale, depth: 0.8 * scale
            }, scene);
            torsoCore.position.y = 0.8 * scale;
            torsoCore.parent = pelvis;
            torsoCore.material = primaryMat;

            // Head - small sensor dome
            const headBase = BABYLON.MeshBuilder.CreateCylinder(name + '_head', {
                diameter: 0.5 * scale, height: 0.4 * scale
            }, scene);
            headBase.position.y = 0.9 * scale;
            headBase.parent = torsoCore;
            headBase.material = secondaryMat;

            const canopy = BABYLON.MeshBuilder.CreateSphere(name + '_canopy', {
                diameter: 0.35 * scale
            }, scene);
            canopy.position.y = 0.15 * scale;
            canopy.parent = headBase;
            canopy.material = new BABYLON.StandardMaterial(name + '_cockpit', scene);
            canopy.material.diffuseColor = COLORS.cockpit;
            canopy.material.emissiveColor = COLORS.cockpit.scale(0.5);
            canopy.material.alpha = 0.8;

            // Arms - simple laser mounts
            function createArm(side) {
                const sign = side === 'left' ? -1 : 1;
                const shoulder = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Shoulder', {
                    width: 0.25 * scale, height: 0.3 * scale, depth: 0.25 * scale
                }, scene);
                shoulder.position = new BABYLON.Vector3(sign * 0.55 * scale, 0.5 * scale, 0);
                shoulder.parent = torsoCore;
                shoulder.material = secondaryMat;

                const arm = BABYLON.MeshBuilder.CreateCylinder(name + '_' + side + 'Arm', {
                    diameter: 0.18 * scale, height: 0.8 * scale
                }, scene);
                arm.rotation.z = sign * 0.2;
                arm.position = new BABYLON.Vector3(sign * 0.15 * scale, -0.4 * scale, 0);
                arm.parent = shoulder;
                arm.material = metalMat;

                // Weapon pod at end of arm (required for firing)
                const weaponPod = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'WeaponPod', {
                    width: 0.12 * scale, height: 0.2 * scale, depth: 0.15 * scale
                }, scene);
                weaponPod.position = new BABYLON.Vector3(0, -0.45 * scale, 0);
                weaponPod.parent = arm;
                weaponPod.material = darkMat;

                return { shoulder, arm, weaponPod };
            }

            const leftArm = createArm('left');
            const rightArm = createArm('right');

            // Simple missile pod on shoulder
            const leftPod = BABYLON.MeshBuilder.CreateBox(name + '_leftPod', {
                width: 0.2 * scale, height: 0.15 * scale, depth: 0.3 * scale
            }, scene);
            leftPod.position = new BABYLON.Vector3(-0.5 * scale, 0.85 * scale, 0.1 * scale);
            leftPod.parent = torsoCore;
            leftPod.material = darkMat;

            const rightPod = BABYLON.MeshBuilder.CreateBox(name + '_rightPod', {
                width: 0.2 * scale, height: 0.15 * scale, depth: 0.3 * scale
            }, scene);
            rightPod.position = new BABYLON.Vector3(0.5 * scale, 0.85 * scale, 0.1 * scale);
            rightPod.parent = torsoCore;
            rightPod.material = darkMat;

            // Legs - using shared digitigrade system
            const legMaterials = { primaryMat, secondaryMat, darkMat, metalMat };
            const leftLeg = createDigitigradeLeg({
                scene, name, side: 'left', parent: pelvis, scale,
                bulk: 0.9,  // Slightly slimmer for light mech
                hipOffset: { x: 0.55, y: -0.18, z: 0 },
                materials: legMaterials
            });
            const rightLeg = createDigitigradeLeg({
                scene, name, side: 'right', parent: pelvis, scale,
                bulk: 0.9,
                hipOffset: { x: 0.55, y: -0.18, z: 0 },
                materials: legMaterials
            });

            return {
                name: 'COMMANDO',
                pelvis, pelvisAggregate: pelvisAgg,
                torso: torsoCore, head: headBase, cockpit: canopy,
                leftArm, rightArm, leftLeg, rightLeg,
                leftPod, rightPod,
                isPlayer, scale,
                standingHeight: 1.9,    // Pelvis Y for feet to touch ground
                optimalRange: 8,        // Light mech prefers closer range, fast hit and run
                stats: { maxHP: 80, mass: 40 },
                currentHP: 80, maxHP: 80,
                isWalking: false, walkCycle: 0, walkSpeed: 3.5,
                walkDirection: isPlayer ? 1 : -1,
                impactRecovery: 0, impactDirection: new BABYLON.Vector3(0,0,0),
                staggerTime: 0, recoilRecovery: 0, lastFiredArm: 'right',
                torsoTwist: 0, targetTorsoTwist: 0,
                // HYBRID STATE MACHINE properties
                mechState: MechState.WALKING,
                stability: STABILITY_CONFIG.maxStability,
                ragdollSettleTimer: 0,
                recoveryTimer: 0,
                destroyedTimer: 0,
                lastKinematicVelocity: new BABYLON.Vector3(0, 0, 0),
                flinchIntensity: 0,
                ai: {
                    enabled: false,
                    state: 'idle',
                    target: null,
                    lastDecision: 0,
                    strafeDir: 0,
                    strafeEndTime: 0
                }
            };
        }

        // ============================================
        // CATAPULT - Medium Support Mech
        // ============================================
        function createCatapultMech(scene, xPos, zPos, isPlayer) {
            const name = (isPlayer ? 'player' : 'enemy') + '_catapult_' + Math.random().toString(36).substr(2, 4);
            const primary = isPlayer ? COLORS.playerPrimary : COLORS.enemyPrimary;
            const secondary = isPlayer ? COLORS.playerSecondary : COLORS.enemySecondary;
            const scale = 0.85;

            // Materials with textures
            const primaryMat = new BABYLON.StandardMaterial(name + '_primary', scene);
            primaryMat.diffuseTexture = TEXTURES.rustMetal.clone();
            primaryMat.diffuseTexture.uScale = 2.5;
            primaryMat.diffuseTexture.vScale = 2.5;
            primaryMat.diffuseColor = primary.scale(1.3);
            primaryMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            primaryMat.bumpTexture.uScale = 2.5;
            primaryMat.bumpTexture.vScale = 2.5;
            primaryMat.bumpTexture.level = 0.55;
            primaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            primaryMat.specularPower = 32;

            const secondaryMat = new BABYLON.StandardMaterial(name + '_secondary', scene);
            secondaryMat.diffuseTexture = TEXTURES.metal.clone();
            secondaryMat.diffuseTexture.uScale = 2;
            secondaryMat.diffuseTexture.vScale = 2;
            secondaryMat.diffuseColor = secondary.scale(1.2);
            secondaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);

            const darkMat = new BABYLON.StandardMaterial(name + '_dark', scene);
            darkMat.diffuseColor = COLORS.darkMetal;
            darkMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            const metalMat = new BABYLON.StandardMaterial(name + '_metal', scene);
            metalMat.diffuseTexture = TEXTURES.rustMetal.clone();
            metalMat.diffuseTexture.uScale = 3;
            metalMat.diffuseTexture.vScale = 3;
            metalMat.diffuseColor = COLORS.metal.scale(1.2);
            metalMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            metalMat.bumpTexture.uScale = 3;
            metalMat.bumpTexture.vScale = 3;
            metalMat.bumpTexture.level = 0.45;
            metalMat.specularColor = new BABYLON.Color3(0.45, 0.45, 0.45);
            metalMat.specularPower = 56;

            // Pelvis
            const pelvis = BABYLON.MeshBuilder.CreateBox(name + '_pelvis', {
                width: 1.5 * scale, height: 0.45 * scale, depth: 0.8 * scale
            }, scene);
            pelvis.position = new BABYLON.Vector3(xPos, 3.2, zPos);
            pelvis.material = darkMat;

            const pelvisShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -1.3, 0),
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(1.5 * scale, 3.0, 0.8 * scale),
                scene
            );
            // HYBRID ARCHITECTURE: Start in ANIMATED (kinematic) mode for perfect walking control
            const pelvisBody = new BABYLON.PhysicsBody(pelvis, BABYLON.PhysicsMotionType.ANIMATED, false, scene);
            pelvisBody.shape = pelvisShape;
            pelvisBody.setMassProperties({ mass: 60 });
            pelvisBody.setAngularDamping(STABILITY_CONFIG.mechAngularDamping);
            pelvisBody.setLinearDamping(STABILITY_CONFIG.mechLinearDamping);
            pelvisShape.material = { friction: 0.3, restitution: 0.05 };
            const pelvisAgg = { body: pelvisBody, shape: pelvisShape };

            // Torso - boxy with rounded top
            const torsoCore = BABYLON.MeshBuilder.CreateBox(name + '_torso', {
                width: 1.3 * scale, height: 1.0 * scale, depth: 0.9 * scale
            }, scene);
            torsoCore.position.y = 0.7 * scale;
            torsoCore.parent = pelvis;
            torsoCore.material = primaryMat;

            // Head - sensor array
            const headBase = BABYLON.MeshBuilder.CreateBox(name + '_head', {
                width: 0.5 * scale, height: 0.35 * scale, depth: 0.4 * scale
            }, scene);
            headBase.position.y = 0.7 * scale;
            headBase.parent = torsoCore;
            headBase.material = secondaryMat;

            const canopy = BABYLON.MeshBuilder.CreateBox(name + '_canopy', {
                width: 0.35 * scale, height: 0.2 * scale, depth: 0.25 * scale
            }, scene);
            canopy.position = new BABYLON.Vector3(0, 0.1 * scale, 0.1 * scale);
            canopy.parent = headBase;
            canopy.material = new BABYLON.StandardMaterial(name + '_cockpit', scene);
            canopy.material.diffuseColor = COLORS.cockpit;
            canopy.material.emissiveColor = COLORS.cockpit.scale(0.5);
            canopy.material.alpha = 0.8;

            // Large missile pods on shoulders (Catapult's signature)
            const leftPod = BABYLON.MeshBuilder.CreateCylinder(name + '_leftPod', {
                diameter: 0.5 * scale, height: 0.9 * scale
            }, scene);
            leftPod.rotation.x = Math.PI / 2;
            leftPod.position = new BABYLON.Vector3(-0.85 * scale, 0.6 * scale, 0.2 * scale);
            leftPod.parent = torsoCore;
            leftPod.material = secondaryMat;

            const rightPod = BABYLON.MeshBuilder.CreateCylinder(name + '_rightPod', {
                diameter: 0.5 * scale, height: 0.9 * scale
            }, scene);
            rightPod.rotation.x = Math.PI / 2;
            rightPod.position = new BABYLON.Vector3(0.85 * scale, 0.6 * scale, 0.2 * scale);
            rightPod.parent = torsoCore;
            rightPod.material = secondaryMat;

            // Arms - smaller, laser focused
            function createArm(side) {
                const sign = side === 'left' ? -1 : 1;
                const shoulder = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Shoulder', {
                    diameter: 0.3 * scale
                }, scene);
                shoulder.position = new BABYLON.Vector3(sign * 0.6 * scale, 0.2 * scale, 0);
                shoulder.parent = torsoCore;
                shoulder.material = metalMat;

                const arm = BABYLON.MeshBuilder.CreateCylinder(name + '_' + side + 'Arm', {
                    diameter: 0.15 * scale, height: 0.7 * scale
                }, scene);
                arm.rotation.z = sign * 0.3;
                arm.position = new BABYLON.Vector3(sign * 0.2 * scale, -0.35 * scale, 0);
                arm.parent = shoulder;
                arm.material = primaryMat;

                // Weapon pod at end of arm (required for firing)
                const weaponPod = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'WeaponPod', {
                    width: 0.12 * scale, height: 0.18 * scale, depth: 0.14 * scale
                }, scene);
                weaponPod.position = new BABYLON.Vector3(0, -0.4 * scale, 0);
                weaponPod.parent = arm;
                weaponPod.material = darkMat;

                return { shoulder, arm, weaponPod };
            }

            const leftArm = createArm('left');
            const rightArm = createArm('right');

            // Legs - using shared digitigrade system
            const legMaterials = { primaryMat, secondaryMat, darkMat, metalMat };
            const leftLeg = createDigitigradeLeg({
                scene, name, side: 'left', parent: pelvis, scale,
                bulk: 1.0,  // Standard bulk for medium mech
                hipOffset: { x: 0.65, y: -0.22, z: 0 },
                materials: legMaterials
            });
            const rightLeg = createDigitigradeLeg({
                scene, name, side: 'right', parent: pelvis, scale,
                bulk: 1.0,
                hipOffset: { x: 0.65, y: -0.22, z: 0 },
                materials: legMaterials
            });

            return {
                name: 'CATAPULT',
                pelvis, pelvisAggregate: pelvisAgg,
                torso: torsoCore, head: headBase, cockpit: canopy,
                leftArm, rightArm, leftLeg, rightLeg,
                leftPod, rightPod,
                isPlayer, scale,
                standingHeight: 2.1,    // Pelvis Y for feet to touch ground
                optimalRange: 14,       // Missile boat prefers long range
                stats: { maxHP: 120, mass: 60 },
                currentHP: 120, maxHP: 120,
                isWalking: false, walkCycle: 0, walkSpeed: 2.5,
                walkDirection: isPlayer ? 1 : -1,
                impactRecovery: 0, impactDirection: new BABYLON.Vector3(0,0,0),
                staggerTime: 0, recoilRecovery: 0, lastFiredArm: 'right',
                torsoTwist: 0, targetTorsoTwist: 0,
                // HYBRID STATE MACHINE properties
                mechState: MechState.WALKING,
                stability: STABILITY_CONFIG.maxStability,
                ragdollSettleTimer: 0,
                recoveryTimer: 0,
                destroyedTimer: 0,
                lastKinematicVelocity: new BABYLON.Vector3(0, 0, 0),
                flinchIntensity: 0,
                ai: {
                    enabled: false,
                    state: 'idle',
                    target: null,
                    lastDecision: 0,
                    strafeDir: 0,
                    strafeEndTime: 0
                }
            };
        }

        // ============================================
        // HATCHETMAN - Melee specialist mech
        // ============================================
        function createHatchetmanMech(scene, xPos, zPos, isPlayer) {
            const name = (isPlayer ? 'player' : 'enemy') + '_hatchetman_' + Math.random().toString(36).substr(2, 4);
            const primary = isPlayer ? COLORS.playerPrimary : COLORS.enemyPrimary;
            const secondary = isPlayer ? COLORS.playerSecondary : COLORS.enemySecondary;
            const scale = 0.8;  // Medium mech

            // Materials with textures
            const primaryMat = new BABYLON.StandardMaterial(name + '_primary', scene);
            primaryMat.diffuseTexture = TEXTURES.rustMetal.clone();
            primaryMat.diffuseTexture.uScale = 2.5;
            primaryMat.diffuseTexture.vScale = 2.5;
            primaryMat.diffuseColor = primary.scale(1.3);
            primaryMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            primaryMat.bumpTexture.uScale = 2.5;
            primaryMat.bumpTexture.vScale = 2.5;
            primaryMat.bumpTexture.level = 0.6;
            primaryMat.specularColor = new BABYLON.Color3(0.25, 0.25, 0.25);
            primaryMat.specularPower = 32;

            const secondaryMat = new BABYLON.StandardMaterial(name + '_secondary', scene);
            secondaryMat.diffuseTexture = TEXTURES.metal.clone();
            secondaryMat.diffuseTexture.uScale = 2;
            secondaryMat.diffuseTexture.vScale = 2;
            secondaryMat.diffuseColor = secondary.scale(1.2);
            secondaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);

            const darkMat = new BABYLON.StandardMaterial(name + '_dark', scene);
            darkMat.diffuseColor = COLORS.darkMetal;
            darkMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            const metalMat = new BABYLON.StandardMaterial(name + '_metal', scene);
            metalMat.diffuseTexture = TEXTURES.rustMetal.clone();
            metalMat.diffuseTexture.uScale = 3;
            metalMat.diffuseTexture.vScale = 3;
            metalMat.diffuseColor = COLORS.metal.scale(1.2);
            metalMat.bumpTexture = TEXTURES.rustMetalNormal.clone();
            metalMat.bumpTexture.uScale = 3;
            metalMat.bumpTexture.vScale = 3;
            metalMat.bumpTexture.level = 0.5;
            metalMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
            metalMat.specularPower = 48;

            // Hatchet blade material - bright and shiny
            const bladeMat = new BABYLON.StandardMaterial(name + '_blade', scene);
            bladeMat.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.75);
            bladeMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.9);
            bladeMat.specularPower = 128;
            bladeMat.emissiveColor = new BABYLON.Color3(0.1, 0.05, 0.0);

            // Pelvis - sturdy build
            const pelvis = BABYLON.MeshBuilder.CreateBox(name + '_pelvis', {
                width: 1.4 * scale, height: 0.5 * scale, depth: 0.85 * scale
            }, scene);
            pelvis.position = new BABYLON.Vector3(xPos, 3.0, zPos);
            pelvis.material = darkMat;

            const pelvisShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -1.2, 0),
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(1.4 * scale, 2.9, 0.85 * scale),
                scene
            );
            // HYBRID ARCHITECTURE: Start in ANIMATED (kinematic) mode for perfect walking control
            const pelvisBody = new BABYLON.PhysicsBody(pelvis, BABYLON.PhysicsMotionType.ANIMATED, false, scene);
            pelvisBody.shape = pelvisShape;
            pelvisBody.setMassProperties({ mass: 50 });
            pelvisBody.setAngularDamping(STABILITY_CONFIG.mechAngularDamping);
            pelvisBody.setLinearDamping(STABILITY_CONFIG.mechLinearDamping);
            pelvisShape.material = { friction: 0.3, restitution: 0.05 };
            const pelvisAgg = { body: pelvisBody, shape: pelvisShape };

            // Torso - hunched forward, aggressive stance
            const torsoCore = BABYLON.MeshBuilder.CreateBox(name + '_torso', {
                width: 1.2 * scale, height: 1.1 * scale, depth: 0.9 * scale
            }, scene);
            torsoCore.position.y = 0.75 * scale;
            torsoCore.rotation.x = 0.15;  // Slight forward lean
            torsoCore.parent = pelvis;
            torsoCore.material = primaryMat;

            // Head - angular, aggressive
            const headBase = BABYLON.MeshBuilder.CreateBox(name + '_head', {
                width: 0.45 * scale, height: 0.4 * scale, depth: 0.5 * scale
            }, scene);
            headBase.position = new BABYLON.Vector3(0, 0.75 * scale, 0.1 * scale);
            headBase.parent = torsoCore;
            headBase.material = secondaryMat;

            const canopy = BABYLON.MeshBuilder.CreateBox(name + '_canopy', {
                width: 0.3 * scale, height: 0.2 * scale, depth: 0.25 * scale
            }, scene);
            canopy.position = new BABYLON.Vector3(0, 0.1 * scale, 0.15 * scale);
            canopy.parent = headBase;
            canopy.material = new BABYLON.StandardMaterial(name + '_cockpit', scene);
            canopy.material.diffuseColor = COLORS.cockpit;
            canopy.material.emissiveColor = COLORS.cockpit.scale(0.5);
            canopy.material.alpha = 0.8;

            // Right arm - normal weapon arm with laser
            function createWeaponArm() {
                const shoulder = BABYLON.MeshBuilder.CreateSphere(name + '_rightShoulder', {
                    diameter: 0.35 * scale
                }, scene);
                shoulder.position = new BABYLON.Vector3(0.65 * scale, 0.35 * scale, 0);
                shoulder.parent = torsoCore;
                shoulder.material = metalMat;

                const arm = BABYLON.MeshBuilder.CreateCylinder(name + '_rightArm', {
                    diameter: 0.2 * scale, height: 0.75 * scale
                }, scene);
                arm.rotation.z = 0.25;
                arm.position = new BABYLON.Vector3(0.15 * scale, -0.4 * scale, 0);
                arm.parent = shoulder;
                arm.material = primaryMat;

                const weaponPod = BABYLON.MeshBuilder.CreateBox(name + '_rightWeaponPod', {
                    width: 0.15 * scale, height: 0.2 * scale, depth: 0.18 * scale
                }, scene);
                weaponPod.position = new BABYLON.Vector3(0, -0.45 * scale, 0);
                weaponPod.parent = arm;
                weaponPod.material = darkMat;

                return { shoulder, arm, weaponPod };
            }

            // Left arm - THE HATCHET ARM
            function createHatchetArm() {
                const shoulder = BABYLON.MeshBuilder.CreateSphere(name + '_leftShoulder', {
                    diameter: 0.4 * scale
                }, scene);
                shoulder.position = new BABYLON.Vector3(-0.65 * scale, 0.35 * scale, 0);
                shoulder.parent = torsoCore;
                shoulder.material = metalMat;

                // Beefier arm for the hatchet
                const arm = BABYLON.MeshBuilder.CreateCylinder(name + '_leftArm', {
                    diameterTop: 0.25 * scale, diameterBottom: 0.2 * scale, height: 0.8 * scale
                }, scene);
                arm.rotation.z = -0.3;
                arm.position = new BABYLON.Vector3(-0.18 * scale, -0.42 * scale, 0);
                arm.parent = shoulder;
                arm.material = primaryMat;

                // Hatchet handle
                const handle = BABYLON.MeshBuilder.CreateCylinder(name + '_hatchetHandle', {
                    diameter: 0.08 * scale, height: 0.6 * scale
                }, scene);
                handle.position = new BABYLON.Vector3(0, -0.55 * scale, 0);
                handle.parent = arm;
                handle.material = darkMat;

                // Hatchet head - large axe blade
                const bladeMain = BABYLON.MeshBuilder.CreateBox(name + '_hatchetBlade', {
                    width: 0.08 * scale, height: 0.5 * scale, depth: 0.35 * scale
                }, scene);
                bladeMain.position = new BABYLON.Vector3(0, -0.25 * scale, 0.2 * scale);
                bladeMain.parent = handle;
                bladeMain.material = bladeMat;

                // Blade edge (tapered)
                const bladeEdge = BABYLON.MeshBuilder.CreateBox(name + '_bladeEdge', {
                    width: 0.04 * scale, height: 0.45 * scale, depth: 0.1 * scale
                }, scene);
                bladeEdge.position = new BABYLON.Vector3(0, 0, 0.2 * scale);
                bladeEdge.parent = bladeMain;
                bladeEdge.material = bladeMat;

                // WeaponPod at hatchet for melee hit detection
                const weaponPod = BABYLON.MeshBuilder.CreateBox(name + '_leftWeaponPod', {
                    width: 0.1 * scale, height: 0.1 * scale, depth: 0.1 * scale
                }, scene);
                weaponPod.position = new BABYLON.Vector3(0, -0.35 * scale, 0.25 * scale);
                weaponPod.parent = handle;
                weaponPod.material = darkMat;
                weaponPod.visibility = 0;  // Invisible, just for hit detection

                return { shoulder, arm, handle, bladeMain, weaponPod };
            }

            const rightArm = createWeaponArm();
            const leftArm = createHatchetArm();

            // Small shoulder pods for backup weapons
            const leftPod = BABYLON.MeshBuilder.CreateBox(name + '_leftPod', {
                width: 0.2 * scale, height: 0.15 * scale, depth: 0.25 * scale
            }, scene);
            leftPod.position = new BABYLON.Vector3(-0.55 * scale, 0.8 * scale, 0.1 * scale);
            leftPod.parent = torsoCore;
            leftPod.material = darkMat;

            const rightPod = BABYLON.MeshBuilder.CreateBox(name + '_rightPod', {
                width: 0.2 * scale, height: 0.15 * scale, depth: 0.25 * scale
            }, scene);
            rightPod.position = new BABYLON.Vector3(0.55 * scale, 0.8 * scale, 0.1 * scale);
            rightPod.parent = torsoCore;
            rightPod.material = darkMat;

            // Legs - using shared digitigrade system (fast melee mech)
            const legMaterials = { primaryMat, secondaryMat, darkMat, metalMat };
            const leftLeg = createDigitigradeLeg({
                scene, name, side: 'left', parent: pelvis, scale,
                bulk: 0.95,  // Slightly lean for speed
                hipOffset: { x: 0.6, y: -0.2, z: 0 },
                materials: legMaterials
            });
            const rightLeg = createDigitigradeLeg({
                scene, name, side: 'right', parent: pelvis, scale,
                bulk: 0.95,
                hipOffset: { x: 0.6, y: -0.2, z: 0 },
                materials: legMaterials
            });

            return {
                name: 'HATCHETMAN',
                pelvis, pelvisAggregate: pelvisAgg,
                torso: torsoCore, head: headBase, cockpit: canopy,
                leftArm, rightArm, leftLeg, rightLeg,
                leftPod, rightPod,
                isPlayer, scale,
                standingHeight: 1.95,   // Pelvis Y for feet to touch ground
                optimalRange: 3,        // Melee mech wants to be in your face
                stats: { maxHP: 90, mass: 50 },
                currentHP: 90, maxHP: 90,
                isWalking: false, walkCycle: 0, walkSpeed: 3.2,  // Faster than average
                walkDirection: isPlayer ? 1 : -1,
                impactRecovery: 0, impactDirection: new BABYLON.Vector3(0,0,0),
                staggerTime: 0, recoilRecovery: 0, lastFiredArm: 'right',
                torsoTwist: 0, targetTorsoTwist: 0,
                isMelee: true,  // Flag for melee AI behavior
                // HYBRID STATE MACHINE properties
                mechState: MechState.WALKING,
                stability: STABILITY_CONFIG.maxStability,
                ragdollSettleTimer: 0,
                recoveryTimer: 0,
                destroyedTimer: 0,
                lastKinematicVelocity: new BABYLON.Vector3(0, 0, 0),
                flinchIntensity: 0,
                ai: {
                    enabled: false,
                    state: 'idle',
                    target: null,
                    lastDecision: 0,
                    strafeDir: 0,
                    strafeEndTime: 0
                }
            };
        }

        // ============================================
        // ANIMATION & PHYSICS
        // ============================================
        // Handle mech-to-mech collisions - push apart based on mass
        // HYBRID ARCHITECTURE: For kinematic mechs, directly adjust positions
        function updateMechCollisions() {
            const minDist = 2.5;  // Minimum distance between mech centers
            for (let i = 0; i < allMechs.length; i++) {
                const mechA = allMechs[i];
                if (!mechA || mechA.isDestroyed) continue;

                for (let j = i + 1; j < allMechs.length; j++) {
                    const mechB = allMechs[j];
                    if (!mechB || mechB.isDestroyed) continue;

                    const posA = mechA.pelvis.getAbsolutePosition();
                    const posB = mechB.pelvis.getAbsolutePosition();

                    const diff = posB.subtract(posA);
                    diff.y = 0;  // Only consider horizontal distance
                    const dist = diff.length();

                    if (dist < minDist && dist > 0.01) {
                        // Mechs are overlapping - push them apart
                        const pushDir = diff.normalize();
                        const overlap = minDist - dist;

                        // Calculate push ratio based on mass (lighter mech moves more)
                        const massA = mechA.stats.mass || 75;
                        const massB = mechB.stats.mass || 75;
                        const totalMass = massA + massB;
                        const ratioA = massB / totalMass;
                        const ratioB = massA / totalMass;

                        // HYBRID: Handle differently based on mech states
                        // Kinematic mechs get position adjustments, dynamic get impulses
                        if (mechA.mechState === MechState.WALKING) {
                            // Directly adjust position for kinematic mech
                            const pushA = pushDir.scale(-overlap * ratioA * 0.5);
                            mechA.pelvis.position.addInPlace(pushA);
                        } else if (mechA.mechState === MechState.RAGDOLL) {
                            // Apply impulse for dynamic mech
                            const impulseA = pushDir.scale(-overlap * 15 * ratioA);
                            mechA.pelvisAggregate.body.applyImpulse(impulseA, posA);
                        }

                        if (mechB.mechState === MechState.WALKING) {
                            const pushB = pushDir.scale(overlap * ratioB * 0.5);
                            mechB.pelvis.position.addInPlace(pushB);
                        } else if (mechB.mechState === MechState.RAGDOLL) {
                            const impulseB = pushDir.scale(overlap * 15 * ratioB);
                            mechB.pelvisAggregate.body.applyImpulse(impulseB, posB);
                        }
                    }
                }
            }
        }

        function updateMechs(dt) {
            updateMechCollisions();  // Handle mech-to-mech collisions first
            allMechs.forEach(mech => {
                if (!mech || mech.isDestroyed) return;

                // HYBRID STATE MACHINE - Route to appropriate update based on state
                switch (mech.mechState) {
                    case MechState.WALKING:
                        // Perfect kinematic control - no physics fighting us
                        updateAI(mech, dt);
                        updateWalkingKinematic(mech, dt);
                        updateFlinch(mech, dt);
                        updateRecoil(mech, dt);
                        updateTorsoTrack(mech, dt);
                        recoverStability(mech, dt);
                        break;

                    case MechState.RAGDOLL:
                        // Physics takes over - just check if we've settled
                        updateRagdoll(mech, dt);
                        break;

                    case MechState.RECOVERING:
                        // Blending from ragdoll back to standing
                        updateRecovery(mech, dt);
                        break;
                }
            });
        }

        // ============================================
        // PHASE 1: KINEMATIC WALKING (ANIMATED Mode)
        // Perfect control - mech is an unstoppable force
        // ============================================
        function updateWalkingKinematic(mech, dt) {
            const body = mech.pelvisAggregate.body;
            const myPos = mech.pelvis.getAbsolutePosition();

            // Handle body rotation toward target (from AI)
            const yawError = mech.ai.desiredYawError || 0;
            const maxRotationSpeed = 2.0;  // rad/s - mechs turn deliberately
            const rotationThreshold = 0.05;  // ~3 degrees
            let yawVelocity = 0;

            if (Math.abs(yawError) > rotationThreshold) {
                // Rate-limited rotation
                yawVelocity = Math.sign(yawError) * Math.min(Math.abs(yawError) * 3, maxRotationSpeed);
            }

            // === SMOOTH STRAFE RAMPING ===
            // Gradually transition strafe amount instead of snapping
            if (!mech.currentStrafeAmount) mech.currentStrafeAmount = 0;
            const targetStrafe = mech.ai.strafeAmount || 0;
            const strafeRampSpeed = 2.0;  // How fast strafe ramps up/down
            if (Math.abs(targetStrafe - mech.currentStrafeAmount) > 0.01) {
                mech.currentStrafeAmount += Math.sign(targetStrafe - mech.currentStrafeAmount) * strafeRampSpeed * dt;
                // Clamp to target
                if ((targetStrafe > 0 && mech.currentStrafeAmount > targetStrafe) ||
                    (targetStrafe < 0 && mech.currentStrafeAmount < targetStrafe) ||
                    (targetStrafe === 0 && Math.abs(mech.currentStrafeAmount) < 0.05)) {
                    mech.currentStrafeAmount = targetStrafe;
                }
            }

            if (!mech.isWalking) {
                // When not walking, stay in place but still rotate toward target
                // Still need ground-seeking even when stationary
                const targetY = mech.standingHeight || 3.0;
                const heightError = targetY - myPos.y;
                const groundSeekSpeed = 8.0;
                body.setLinearVelocity(new BABYLON.Vector3(0, heightError * groundSeekSpeed, 0));
                body.setAngularVelocity(new BABYLON.Vector3(0, yawVelocity, 0));
                dampLegs(mech, dt);
                mech.lastKinematicVelocity.setAll(0);
                return;
            }

            // Walk cycle speed tied to movement - heavier mechs have slower cycles
            mech.walkCycle += dt * mech.walkSpeed * 1.6;
            const cycle = mech.walkCycle;

            const leftPhase = Math.sin(cycle);
            const rightPhase = Math.sin(cycle + Math.PI);

            animateLeg(mech.leftLeg, leftPhase, mech.scale);
            animateLeg(mech.rightLeg, rightPhase, mech.scale);

            // Body bob - pronounced dip on each footfall for grounded feel
            const bobPhase = Math.abs(Math.sin(cycle));
            const bob = (1 - bobPhase) * 0.06 * mech.scale;  // Increased bob

            // Hip sway for weight transfer - side to side with each step
            const hipSway = Math.sin(cycle) * 0.02;

            // Get pelvis facing direction
            const quat = body.transformNode.rotationQuaternion;
            let forwardDir = new BABYLON.Vector3(1, 0, 0);
            let rightDir = new BABYLON.Vector3(0, 0, 1);
            if (quat) {
                const rotMatrix = new BABYLON.Matrix();
                quat.toRotationMatrix(rotMatrix);
                forwardDir = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(1, 0, 0), rotMatrix);
                forwardDir.y = 0;
                forwardDir.normalize();
                rightDir = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(0, 0, 1), rotMatrix);
                rightDir.y = 0;
                rightDir.normalize();
            }

            // KINEMATIC MODE: Set velocity directly instead of applying forces
            // Slightly reduced speed for heavier, more grounded feel
            const walkSpeed = 3.0 * mech.scale;  // Units per second
            const strafeSpeed = 1.8 * mech.scale;  // Strafe is slower than walking

            // Calculate velocity from walk direction and strafe (using smoothed strafe)
            let velocity = forwardDir.scale(mech.walkDirection * walkSpeed);
            velocity.addInPlace(rightDir.scale(mech.currentStrafeAmount * strafeSpeed));

            // === GROUND-SEEKING FOR KINEMATIC MODE ===
            // In ANIMATED mode, gravity doesn't apply, so we need to manually seek ground level
            const targetY = mech.standingHeight || 3.0;  // Fallback if not defined
            const heightError = targetY - myPos.y;
            const groundSeekSpeed = 8.0;  // How fast we correct height
            // Apply ground-seeking with bob effect on top
            velocity.y = heightError * groundSeekSpeed - bob * 2;

            // === HARD BOUNDARY CLAMPING ===
            // If we're at or past the boundary, zero velocity in that direction
            const boundaryMargin = 0.5;
            if (myPos.x <= ARENA_BOUNDS.minX + boundaryMargin) {
                // At left edge - only allow movement toward center (positive X)
                if (velocity.x < 0) velocity.x = 0;
            } else if (myPos.x >= ARENA_BOUNDS.maxX - boundaryMargin) {
                // At right edge - only allow movement toward center (negative X)
                if (velocity.x > 0) velocity.x = 0;
            }
            if (myPos.z <= ARENA_BOUNDS.minZ + boundaryMargin) {
                // At back edge - only allow movement toward center (positive Z)
                if (velocity.z < 0) velocity.z = 0;
            } else if (myPos.z >= ARENA_BOUNDS.maxZ - boundaryMargin) {
                // At front edge - only allow movement toward center (negative Z)
                if (velocity.z > 0) velocity.z = 0;
            }

            // Store velocity for ragdoll inheritance
            mech.lastKinematicVelocity = velocity.clone();

            // Set the kinematic body velocity
            body.setLinearVelocity(velocity);

            // Apply body rotation - combines target tracking with visual motion
            // Rock = forward/back tilt, sway = side-to-side tilt, hipSway = rolling motion
            const sway = Math.sin(cycle) * 0.02;  // Side-to-side lean with each step
            const rock = Math.sin(cycle * 2) * 0.01;  // Subtle double-frequency rock

            // In ANIMATED mode, set angular velocity for rotation + visual feel
            // Add hipSway for rolling weight transfer motion
            body.setAngularVelocity(new BABYLON.Vector3(rock + hipSway, yawVelocity, sway));
        }

        function animateLeg(leg, phase, scale) {
            // Lightning bolt digitigrade animation - matched to new geometry
            // Base rotations: upperLeg = 0.5, lowerLeg = -0.4

            // Upper leg swings forward/back from hip - more pronounced for grounded feel
            const swing = phase * 0.35;  // Increased swing for visible stepping
            leg.upperLeg.rotation.x = 0.5 + swing;

            // Lower leg bends more during lift phase (phase > 0 = leg lifting)
            const liftPhase = Math.max(0, phase);
            const plantPhase = Math.max(0, -phase);

            // Knee bends more during lift, straightens during plant - exaggerated
            const kneeBend = liftPhase * 0.5;  // More pronounced bend when lifting
            leg.lowerLeg.rotation.x = -0.4 - kneeBend + plantPhase * 0.15;

            // Foot tilts up during lift, plants flat during ground contact
            const footLift = liftPhase * 0.4;  // Toe points up more when lifting
            const footPlant = plantPhase * 0.2;  // More tilt when planting
            leg.foot.rotation.x = 0.1 - footLift + footPlant;
        }

        function dampLegs(mech, dt) {
            const d = 3 * dt;
            [mech.leftLeg, mech.rightLeg].forEach(leg => {
                // Return to lightning bolt digitigrade stance (matches new geometry)
                leg.upperLeg.rotation.x = BABYLON.Scalar.Lerp(leg.upperLeg.rotation.x, 0.5, d);
                leg.lowerLeg.rotation.x = BABYLON.Scalar.Lerp(leg.lowerLeg.rotation.x, -0.4, d);
                leg.foot.rotation.x = BABYLON.Scalar.Lerp(leg.foot.rotation.x, 0.1, d);
            });
        }

        // ============================================
        // PHASE 2: FLINCH SYSTEM (Additive Animation)
        // Small hits - mech keeps walking but jerks visually
        // ============================================
        function updateFlinch(mech, dt) {
            // Decay flinch intensity
            if (mech.flinchIntensity > 0) {
                mech.flinchIntensity -= dt * 3.0;  // Quick recovery
                if (mech.flinchIntensity < 0) mech.flinchIntensity = 0;

                // Apply additive animation to torso
                const tilt = mech.flinchIntensity * 0.35;
                mech.torso.rotation.x = mech.impactDirection.z * tilt;
                mech.torso.rotation.z = -mech.impactDirection.x * tilt;
            } else {
                // Return torso to neutral
                mech.torso.rotation.x = BABYLON.Scalar.Lerp(mech.torso.rotation.x, 0, dt * 5);
                mech.torso.rotation.z = BABYLON.Scalar.Lerp(mech.torso.rotation.z, 0, dt * 5);
            }

            // Handle stagger (brief pause in walking)
            if (mech.staggerTime > 0) {
                mech.staggerTime -= dt;
                mech.isWalking = false;
            }
        }

        // Stability recovery - regenerate stability over time
        function recoverStability(mech, dt) {
            if (mech.stability < STABILITY_CONFIG.maxStability) {
                mech.stability += STABILITY_CONFIG.stabilityRecoveryRate * dt;
                if (mech.stability > STABILITY_CONFIG.maxStability) {
                    mech.stability = STABILITY_CONFIG.maxStability;
                }
            }
        }

        // ============================================
        // PHASE 3: RAGDOLL MODE (Dynamic Physics)
        // Heavy hits - physics takes over completely
        // ============================================
        function triggerRagdoll(mech, hitForce) {
            if (mech.mechState === MechState.RAGDOLL) return;  // Already ragdolling

            dbg(`${mech.isPlayer ? 'P' : 'E'} ${mech.name}: RAGDOLL triggered!`, 'warn');

            mech.mechState = MechState.RAGDOLL;
            mech.ragdollSettleTimer = 0;
            mech.isWalking = false;

            const body = mech.pelvisAggregate.body;
            const pos = mech.pelvis.getAbsolutePosition();

            // 1. Switch from ANIMATED to DYNAMIC - physics now controls us
            body.setMotionType(BABYLON.PhysicsMotionType.DYNAMIC);

            // 2. Set proper mass and reduce damping for ragdoll physics
            body.setMassProperties({ mass: mech.stats.mass || 75 });
            body.setLinearDamping(0.1);
            body.setAngularDamping(0.2);

            // 3. CRITICAL: Inherit velocity from animation to avoid dead-fish effect
            const inheritedVel = mech.lastKinematicVelocity || new BABYLON.Vector3(0, 0, 0);
            body.setLinearVelocity(inheritedVel);

            // 4. Apply knockback force - throw mech backwards from strike
            // Scale force by mass for consistent knockback across mech sizes
            const massScale = 75 / (mech.stats.mass || 75);
            const scaledHitForce = hitForce.scale(massScale * 2.5);

            // Add significant upward component to lift mech off ground
            scaledHitForce.y = Math.max(scaledHitForce.y, hitForce.length() * 0.5);

            body.applyImpulse(scaledHitForce, pos);

            // 5. Strong angular impulse for dramatic spin/tumble
            const hitDir = hitForce.normalizeToNew();
            body.applyAngularImpulse(new BABYLON.Vector3(
                hitDir.z * hitForce.length() * 0.3,  // Pitch based on Z hit direction
                (Math.random() - 0.5) * hitForce.length() * 0.1,  // Random yaw spin
                -hitDir.x * hitForce.length() * 0.3  // Roll based on X hit direction
            ));

            // 6. DRAMATIC LIMB FLINGING - arms and legs fly outward on impact
            flingLimbs(mech, hitForce);

            // 7. Shake camera - mechs are HEAVY
            const shakeIntensity = Math.min(1.0, hitForce.length() / 50);
            triggerCameraShake(shakeIntensity, 0.5 + shakeIntensity * 0.3);

            // 8. Spawn impact sparks
            createImpactSparks(pos, hitDir);
        }

        // Dramatic limb animation when ragdolling
        function flingLimbs(mech, hitForce) {
            const hitDir = hitForce.normalizeToNew();
            const intensity = Math.min(1.5, hitForce.length() / 30);

            // Arms fling outward and back
            if (mech.leftArm && mech.leftArm.rotation) {
                const leftArmFling = () => {
                    let t = 0;
                    const startRot = mech.leftArm.rotation.clone();
                    const flingInterval = setInterval(() => {
                        t += 0.05;
                        if (t >= 1 || mech.mechState !== MechState.RAGDOLL) {
                            clearInterval(flingInterval);
                            return;
                        }
                        // Fling arm outward and back with easing
                        const ease = Math.sin(t * Math.PI);
                        mech.leftArm.rotation.z = startRot.z - intensity * 1.2 * ease;  // Out to side
                        mech.leftArm.rotation.x = startRot.x + intensity * 0.8 * ease;  // Back
                        mech.leftArm.rotation.y = startRot.y + (hitDir.x * 0.5 + 0.3) * ease;  // Twist from impact
                    }, 16);
                };
                leftArmFling();
            }

            if (mech.rightArm && mech.rightArm.rotation) {
                const rightArmFling = () => {
                    let t = 0;
                    const startRot = mech.rightArm.rotation.clone();
                    const flingInterval = setInterval(() => {
                        t += 0.05;
                        if (t >= 1 || mech.mechState !== MechState.RAGDOLL) {
                            clearInterval(flingInterval);
                            return;
                        }
                        const ease = Math.sin(t * Math.PI);
                        mech.rightArm.rotation.z = startRot.z + intensity * 1.2 * ease;  // Out to side (opposite)
                        mech.rightArm.rotation.x = startRot.x + intensity * 0.8 * ease;  // Back
                        mech.rightArm.rotation.y = startRot.y - (hitDir.x * 0.5 + 0.3) * ease;  // Twist from impact
                    }, 16);
                };
                rightArmFling();
            }

            // Legs kick outward on big hits
            if (intensity > 0.8) {
                if (mech.leftLeg && mech.leftLeg.upperLeg) {
                    const leftLegKick = () => {
                        let t = 0;
                        const startRot = mech.leftLeg.upperLeg.rotation.x;
                        const flingInterval = setInterval(() => {
                            t += 0.04;
                            if (t >= 1 || mech.mechState !== MechState.RAGDOLL) {
                                clearInterval(flingInterval);
                                return;
                            }
                            const ease = Math.sin(t * Math.PI);
                            mech.leftLeg.upperLeg.rotation.x = startRot - intensity * 0.6 * ease;
                        }, 16);
                    };
                    leftLegKick();
                }

                if (mech.rightLeg && mech.rightLeg.upperLeg) {
                    const rightLegKick = () => {
                        let t = 0;
                        const startRot = mech.rightLeg.upperLeg.rotation.x;
                        const flingInterval = setInterval(() => {
                            t += 0.04;
                            if (t >= 1 || mech.mechState !== MechState.RAGDOLL) {
                                clearInterval(flingInterval);
                                return;
                            }
                            const ease = Math.sin(t * Math.PI);
                            mech.rightLeg.upperLeg.rotation.x = startRot - intensity * 0.6 * ease;
                        }, 16);
                    };
                    rightLegKick();
                }
            }
        }

        // Extra chaotic limb movement for destruction - more extreme than regular ragdoll
        function destroyedLimbChaos(mech) {
            // Arms flail wildly
            if (mech.leftArm && mech.leftArm.rotation) {
                let t = 0;
                const chaosInterval = setInterval(() => {
                    t += 0.03;
                    if (t >= 2.0 || !mech.leftArm || !mech.leftArm.rotation) {
                        clearInterval(chaosInterval);
                        return;
                    }
                    // Wild oscillating movement
                    const chaos = Math.sin(t * 8) * Math.exp(-t * 0.8);
                    mech.leftArm.rotation.z = -1.5 + chaos * 1.0;
                    mech.leftArm.rotation.x = 0.5 + chaos * 0.8;
                }, 16);
            }

            if (mech.rightArm && mech.rightArm.rotation) {
                let t = 0;
                const chaosInterval = setInterval(() => {
                    t += 0.03;
                    if (t >= 2.0 || !mech.rightArm || !mech.rightArm.rotation) {
                        clearInterval(chaosInterval);
                        return;
                    }
                    const chaos = Math.sin(t * 8 + 1) * Math.exp(-t * 0.8);
                    mech.rightArm.rotation.z = 1.5 - chaos * 1.0;
                    mech.rightArm.rotation.x = 0.5 + chaos * 0.8;
                }, 16);
            }

            // Legs kick wildly
            if (mech.leftLeg && mech.leftLeg.upperLeg && mech.leftLeg.upperLeg.rotation) {
                let t = 0;
                const chaosInterval = setInterval(() => {
                    t += 0.03;
                    if (t >= 2.0 || !mech.leftLeg || !mech.leftLeg.upperLeg || !mech.leftLeg.upperLeg.rotation) {
                        clearInterval(chaosInterval);
                        return;
                    }
                    const chaos = Math.sin(t * 6) * Math.exp(-t * 1.0);
                    mech.leftLeg.upperLeg.rotation.x = 0.5 - chaos * 0.8;
                    if (mech.leftLeg.lowerLeg && mech.leftLeg.lowerLeg.rotation) {
                        mech.leftLeg.lowerLeg.rotation.x = -0.4 - Math.abs(chaos) * 0.5;
                    }
                }, 16);
            }

            if (mech.rightLeg && mech.rightLeg.upperLeg && mech.rightLeg.upperLeg.rotation) {
                let t = 0;
                const chaosInterval = setInterval(() => {
                    t += 0.03;
                    if (t >= 2.0 || !mech.rightLeg || !mech.rightLeg.upperLeg || !mech.rightLeg.upperLeg.rotation) {
                        clearInterval(chaosInterval);
                        return;
                    }
                    const chaos = Math.sin(t * 6 + 2) * Math.exp(-t * 1.0);
                    mech.rightLeg.upperLeg.rotation.x = 0.5 - chaos * 0.8;
                    if (mech.rightLeg.lowerLeg && mech.rightLeg.lowerLeg.rotation) {
                        mech.rightLeg.lowerLeg.rotation.x = -0.4 - Math.abs(chaos) * 0.5;
                    }
                }, 16);
            }

            // Torso twist
            if (mech.torso && mech.torso.rotation) {
                let t = 0;
                const torsoInterval = setInterval(() => {
                    t += 0.03;
                    if (t >= 1.5 || !mech.torso || !mech.torso.rotation) {
                        clearInterval(torsoInterval);
                        return;
                    }
                    const chaos = Math.sin(t * 10) * Math.exp(-t * 1.5);
                    mech.torso.rotation.y = chaos * 0.4;
                    mech.torso.rotation.x = -Math.abs(chaos) * 0.3;  // Slump forward
                }, 16);
            }
        }

        function updateRagdoll(mech, dt) {
            const body = mech.pelvisAggregate.body;
            const velocity = body.getLinearVelocity();
            const speed = velocity.length();

            // Handle destroyed mechs differently - they don't recover, but need friction
            if (mech.isDestroyed) {
                mech.destroyedTimer += dt;

                // After dramatic phase (1.5s), gradually ramp up friction to stop sliding
                const dramaticPhase = 1.5;
                const frictionRampTime = 2.0;  // Time to ramp from low to high friction

                if (mech.destroyedTimer > dramaticPhase) {
                    const frictionT = Math.min(1.0, (mech.destroyedTimer - dramaticPhase) / frictionRampTime);
                    // Ramp linear damping from 0.05 to 0.8 for strong friction
                    const targetLinearDamping = 0.05 + frictionT * 0.75;
                    // Ramp angular damping from 0.1 to 0.9
                    const targetAngularDamping = 0.1 + frictionT * 0.8;

                    body.setLinearDamping(targetLinearDamping);
                    body.setAngularDamping(targetAngularDamping);
                }

                // Keep feet somewhat level during ragdoll for visual consistency
                const quat = body.transformNode.rotationQuaternion;
                if (quat && mech.leftLeg.footGroup) {
                    const euler = quat.toEulerAngles();
                    mech.leftLeg.footGroup.rotation.x = -euler.x * 0.5;
                    mech.rightLeg.footGroup.rotation.x = -euler.x * 0.5;
                }
                return;  // Destroyed mechs don't recover
            }

            // Check if mech has settled (low velocity)
            if (speed < STABILITY_CONFIG.ragdollSettleVelocity) {
                mech.ragdollSettleTimer += dt;

                // If settled for long enough, start recovery
                if (mech.ragdollSettleTimer > STABILITY_CONFIG.ragdollSettleTime) {
                    startRecovery(mech);
                }
            } else {
                // Still moving - reset settle timer
                mech.ragdollSettleTimer = 0;
            }

            // Keep feet somewhat level during ragdoll for visual consistency
            const quat = body.transformNode.rotationQuaternion;
            if (quat && mech.leftLeg.footGroup) {
                const euler = quat.toEulerAngles();
                mech.leftLeg.footGroup.rotation.x = -euler.x * 0.5;
                mech.rightLeg.footGroup.rotation.x = -euler.x * 0.5;
            }
        }

        // ============================================
        // PHASE 4: RECOVERY (Ragdoll â†’ Standing)
        // ============================================
        function startRecovery(mech) {
            dbg(`${mech.isPlayer ? 'P' : 'E'} ${mech.name}: Starting RECOVERY`, 'ai');

            mech.mechState = MechState.RECOVERING;
            mech.recoveryTimer = 0;

            const body = mech.pelvisAggregate.body;

            // Detect orientation - are we face up or face down?
            const quat = body.transformNode.rotationQuaternion;
            const euler = quat ? quat.toEulerAngles() : new BABYLON.Vector3(0, 0, 0);

            // Check if face down (torso pointing to ground)
            const forward = new BABYLON.Vector3(0, 0, 1);
            if (quat) {
                const rotMatrix = new BABYLON.Matrix();
                quat.toRotationMatrix(rotMatrix);
                forward.copyFrom(BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(0, 1, 0), rotMatrix));
            }
            mech.isFaceDown = forward.y < 0;

            // Stop all motion before recovery
            body.setLinearVelocity(new BABYLON.Vector3(0, 0, 0));
            body.setAngularVelocity(new BABYLON.Vector3(0, 0, 0));
        }

        function updateRecovery(mech, dt) {
            mech.recoveryTimer += dt;
            const body = mech.pelvisAggregate.body;
            const pos = mech.pelvis.getAbsolutePosition();
            const quat = body.transformNode.rotationQuaternion;
            const euler = quat ? quat.toEulerAngles() : new BABYLON.Vector3(0, 0, 0);

            const blendTime = STABILITY_CONFIG.recoveryBlendTime;

            if (mech.recoveryTimer < blendTime) {
                // Phase 1: Blend rotation to upright
                const t = mech.recoveryTimer / blendTime;
                const easeT = t * t * (3 - 2 * t);  // Smoothstep for nice easing

                // Blend to upright (keep Y rotation for facing)
                const targetQuat = BABYLON.Quaternion.FromEulerAngles(0, euler.y, 0);
                const blendedQuat = BABYLON.Quaternion.Slerp(quat, targetQuat, easeT);
                body.transformNode.rotationQuaternion = blendedQuat;

                // Also lift to standing height
                const standingY = 3.5 * mech.scale;
                const targetY = Math.max(pos.y, standingY);
                mech.pelvis.position.y = BABYLON.Scalar.Lerp(pos.y, targetY, easeT);

                // Reset leg positions during blend
                dampLegs(mech, dt * 3);

            } else if (mech.recoveryTimer < blendTime + 0.3) {
                // Phase 2: Switch back to kinematic and stabilize
                if (body.getMotionType() !== BABYLON.PhysicsMotionType.ANIMATED) {
                    body.setMotionType(BABYLON.PhysicsMotionType.ANIMATED);
                    body.setLinearVelocity(new BABYLON.Vector3(0, 0, 0));
                    body.setAngularVelocity(new BABYLON.Vector3(0, 0, 0));

                    // Make sure we're upright
                    body.transformNode.rotationQuaternion = BABYLON.Quaternion.FromEulerAngles(0, euler.y, 0);

                    dbg(`${mech.isPlayer ? 'P' : 'E'} ${mech.name}: Switched back to ANIMATED`, 'ai');
                }

            } else {
                // Phase 3: Recovery complete - back to walking state
                mech.mechState = MechState.WALKING;
                mech.stability = STABILITY_CONFIG.maxStability * 0.5;  // Partial stability after recovery

                dbg(`${mech.isPlayer ? 'P' : 'E'} ${mech.name}: RECOVERED! Back to WALKING`, 'ai');
            }
        }

        // ============================================
        // CAMERA SHAKE & EFFECTS
        // ============================================
        function triggerCameraShake(intensity, duration) {
            if (!camera) return;

            const originalPos = camera.position.clone();
            let shakeTime = 0;
            const shakeInterval = setInterval(() => {
                shakeTime += 30;
                if (shakeTime > duration * 1000) {
                    clearInterval(shakeInterval);
                    camera.position = originalPos;
                } else {
                    const remaining = 1 - (shakeTime / (duration * 1000));
                    const shake = intensity * remaining;
                    camera.position = originalPos.add(new BABYLON.Vector3(
                        (Math.random() - 0.5) * shake,
                        (Math.random() - 0.5) * shake * 0.5,
                        (Math.random() - 0.5) * shake
                    ));
                }
            }, 30);
        }

        function createImpactSparks(position, direction) {
            // Create spark particles at impact point
            for (let i = 0; i < 8; i++) {
                const spark = BABYLON.MeshBuilder.CreateSphere('spark', { diameter: 0.08 }, scene);
                spark.position = position.clone();

                const sparkMat = new BABYLON.StandardMaterial('sparkMat', scene);
                sparkMat.emissiveColor = new BABYLON.Color3(1, 0.7, 0.2);
                sparkMat.disableLighting = true;
                spark.material = sparkMat;

                // Random velocity with bias in impact direction
                const vel = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 5 + direction.x * 3,
                    Math.random() * 4 + 1,
                    (Math.random() - 0.5) * 5 + direction.z * 3
                );

                let age = 0;
                const sparkUpdate = setInterval(() => {
                    age += 30;
                    if (age > 500) {
                        clearInterval(sparkUpdate);
                        spark.dispose();
                        return;
                    }

                    spark.position.addInPlace(vel.scale(0.03));
                    vel.y -= 0.3;  // Gravity
                    sparkMat.alpha = 1 - (age / 500);
                }, 30);
            }
        }

        // Create shimmering energy shield visual around mech
        function createEnergyShield(mech) {
            if (!mech.energyShieldMaxHP || mech.energyShieldMaxHP <= 0) return;

            // Create shield sphere around the mech
            const shield = BABYLON.MeshBuilder.CreateSphere('energyShield', {
                diameter: 4.5,
                segments: 16
            }, scene);
            shield.position = mech.torso.getAbsolutePosition().clone();
            shield.parent = mech.torso;
            shield.position = new BABYLON.Vector3(0, 0.5, 0);  // Offset to center on torso

            // Shield material - translucent blue with shimmer
            const shieldMat = new BABYLON.StandardMaterial('shieldMat', scene);
            shieldMat.diffuseColor = new BABYLON.Color3(0.2, 0.6, 1);
            shieldMat.emissiveColor = new BABYLON.Color3(0.1, 0.4, 0.9);
            shieldMat.alpha = 0.15;
            shieldMat.backFaceCulling = false;
            shieldMat.specularColor = new BABYLON.Color3(0.5, 0.8, 1);
            shield.material = shieldMat;

            // Store reference on mech
            mech.shieldMesh = shield;
            mech.shieldMaterial = shieldMat;

            // Add shimmer animation
            let shimmerPhase = 0;
            mech.shieldShimmer = setInterval(() => {
                if (!mech.shieldMesh || mech.energyShieldHP <= 0) {
                    clearInterval(mech.shieldShimmer);
                    if (mech.shieldMesh) {
                        mech.shieldMesh.dispose();
                        mech.shieldMesh = null;
                    }
                    return;
                }
                shimmerPhase += 0.1;
                const shimmer = 0.1 + 0.05 * Math.sin(shimmerPhase * 3);
                const healthRatio = mech.energyShieldHP / mech.energyShieldMaxHP;
                shieldMat.alpha = shimmer * healthRatio;
                shieldMat.emissiveColor = new BABYLON.Color3(0.1, 0.4 * healthRatio, 0.9 * healthRatio);
            }, 50);
        }

        // Flash effect when energy shield absorbs damage
        function createShieldFlash(mech) {
            if (!mech.shieldMesh || !mech.shieldMaterial) return;

            // Bright flash
            const originalAlpha = mech.shieldMaterial.alpha;
            mech.shieldMaterial.alpha = 0.6;
            mech.shieldMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.8, 1);

            // Create ripple particles
            const pos = mech.torso.getAbsolutePosition();
            for (let i = 0; i < 12; i++) {
                const particle = BABYLON.MeshBuilder.CreateSphere('shieldParticle', { diameter: 0.15 }, scene);
                const angle = (i / 12) * Math.PI * 2;
                particle.position = pos.add(new BABYLON.Vector3(Math.cos(angle) * 2, 0.5, Math.sin(angle) * 2));

                const pMat = new BABYLON.StandardMaterial('shieldParticleMat', scene);
                pMat.emissiveColor = new BABYLON.Color3(0.3, 0.7, 1);
                pMat.disableLighting = true;
                pMat.alpha = 0.8;
                particle.material = pMat;

                // Expand outward and fade
                let age = 0;
                const update = setInterval(() => {
                    age += 30;
                    if (age > 400) {
                        clearInterval(update);
                        particle.dispose();
                        return;
                    }
                    const t = age / 400;
                    particle.position.addInPlace(new BABYLON.Vector3(Math.cos(angle) * 0.1, 0, Math.sin(angle) * 0.1));
                    pMat.alpha = 0.8 * (1 - t);
                    particle.scaling = new BABYLON.Vector3(1 + t, 1 + t, 1 + t);
                }, 30);
            }

            // Fade back
            setTimeout(() => {
                if (mech.shieldMaterial) {
                    mech.shieldMaterial.alpha = originalAlpha;
                    const healthRatio = mech.energyShieldHP / mech.energyShieldMaxHP;
                    mech.shieldMaterial.emissiveColor = new BABYLON.Color3(0.1, 0.4 * healthRatio, 0.9 * healthRatio);
                }
            }, 200);
        }

        function updateRecoil(mech, dt) {
            if (mech.recoilRecovery <= 0) return;
            mech.recoilRecovery -= dt * 4.5;
            if (mech.recoilRecovery < 0) mech.recoilRecovery = 0;

            const arm = mech.lastFiredArm === 'left' ? mech.leftArm : mech.rightArm;
            // Handle different arm structures: armGroup (Mad Cat, Dire Wolf) or shoulder (others)
            const armNode = arm.armGroup || arm.shoulder;
            if (armNode) {
                armNode.rotation.x = -mech.recoilRecovery * 0.45;
            }
            mech.torso.rotation.x = Math.max(mech.torso.rotation.x, -mech.recoilRecovery * 0.08);
        }

        function updateTorsoTrack(mech, dt) {
            const name = mech.isPlayer ? 'P' : 'E';
            const shouldLog = gameTime - lastDebugTime > DEBUG_INTERVAL;

            // Diagnostic: Check if mech object is valid
            if (!mech) {
                if (shouldLog) dbg(`${name}: updateTorsoTrack - mech is null/undefined!`, 'warn');
                return;
            }
            if (!mech.torso) {
                if (shouldLog) dbg(`${name}: updateTorsoTrack - mech.torso is null/undefined!`, 'warn');
                return;
            }
            if (!mech.pelvis) {
                if (shouldLog) dbg(`${name}: updateTorsoTrack - mech.pelvis is null/undefined!`, 'warn');
                return;
            }

            // Get or find target
            let target = mech.ai.target;
            if (!target || target.currentHP <= 0 || target.isDestroyed) {
                target = findNewTarget(mech);
                mech.ai.target = target;
            }

            // Diagnostic: Check target validity
            if (!target) {
                if (shouldLog) dbg(`${name}: updateTorsoTrack - no valid target found`, 'warn');
                return;
            }
            if (!target.pelvis) {
                if (shouldLog) dbg(`${name}: updateTorsoTrack - target.pelvis is null/undefined!`, 'warn');
                return;
            }

            const myPos = mech.pelvis.getAbsolutePosition();
            const targetPos = target.pelvis.getAbsolutePosition();
            const dx = targetPos.x - myPos.x;
            const dz = targetPos.z - myPos.z;

            // =============================================
            // TORSO ALWAYS FACES ENEMY (AI-controlled mechs only)
            // =============================================
            // Skip torso AI for player mech when in piloting mode - player controls it
            if (pilotingModeActive && mech.isPlayer) {
                // Player torso is controlled by updateCockpitCamera via mouse input
                // Just skip this section
            } else {
                // Calculate angle to enemy (in XZ plane) - this is the WORLD angle
                const angleToEnemy = Math.atan2(dz, dx);

                // Get the pelvis's current world Y rotation
                // Since torso is parented to pelvis, we need to calculate LOCAL rotation
                const body = mech.pelvisAggregate.body;
                const pelvisQuat = body.transformNode.rotationQuaternion;
                let pelvisYaw = 0;
                if (pelvisQuat) {
                    const euler = pelvisQuat.toEulerAngles();
                    pelvisYaw = euler.y;
                }

                // Mech mesh faces +Z by default (chest at +Z, reactor at -Z)
                // Babylon.js uses LEFT-HANDED coordinates: +Y rotation is CLOCKWISE from above
                // rotation.y = 0 faces +Z, rotation.y = +Ï€/2 faces +X, rotation.y = -Ï€/2 faces -X
                // To convert world angle to mech rotation: baseAngle - angleToEnemy (not the reverse!)
                const baseAngle = Math.PI / 2;
                let worldTorsoAngle = baseAngle - angleToEnemy;

                // Convert to LOCAL torso rotation by subtracting pelvis world rotation
                // The torso is parented to the pelvis, so its rotation.y is relative to pelvis
                let torsoAngle = worldTorsoAngle - pelvisYaw;

                // Normalize to -PI to PI range
                while (torsoAngle > Math.PI) torsoAngle -= Math.PI * 2;
                while (torsoAngle < -Math.PI) torsoAngle += Math.PI * 2;

                // Clamp torso rotation to reasonable range (about 60 degrees each way from pelvis)
                mech.targetTorsoTwist = Math.max(-1.0, Math.min(1.0, torsoAngle));

                // Smooth interpolation for torso rotation
                mech.torsoTwist = BABYLON.Scalar.Lerp(mech.torsoTwist, mech.targetTorsoTwist, dt * 5);
                mech.torso.rotation.y = mech.torsoTwist;

                // Diagnostic: Log torso tracking calculations
                if (shouldLog) {
                    dbg(`${name}: torso dx=${dx.toFixed(2)} dz=${dz.toFixed(2)} angleToEnemy=${(angleToEnemy * 180/Math.PI).toFixed(1)}Â°`, 'torso');
                    dbg(`${name}: torso pelvisYaw=${(pelvisYaw * 180/Math.PI).toFixed(1)}Â° worldAngle=${(worldTorsoAngle * 180/Math.PI).toFixed(1)}Â° localAngle=${(torsoAngle * 180/Math.PI).toFixed(1)}Â° actual=${(mech.torsoTwist * 180/Math.PI).toFixed(1)}Â°`, 'torso');
                }

                // Head follows torso but can look even more toward enemy
                if (mech.head) {
                    mech.head.rotation.y = mech.torsoTwist * 1.2;
                }
            }

            // =============================================
            // LEGS/FEET - NO LEFT/RIGHT ROTATION
            // =============================================
            // Legs and feet should NOT rotate left/right independently
            // They are rigidly attached to the pelvis which handles all Y rotation
            // Feet can only pitch up/down (X rotation) to stay flat on ground

            // Initialize foot pitch tracker if not set
            if (mech.leftFootPitch === undefined) mech.leftFootPitch = 0;
            if (mech.rightFootPitch === undefined) mech.rightFootPitch = 0;

            // Ensure legGroups have no Y rotation (they follow pelvis)
            if (mech.leftLeg.legGroup) {
                mech.leftLeg.legGroup.rotation.y = 0;
                mech.rightLeg.legGroup.rotation.y = 0;
            }

            // Feet should stay HORIZONTAL to ground regardless of pelvis tilt
            // Counter-rotate feet to compensate for pelvis X rotation (forward/back tilt)
            if (mech.leftLeg.footGroup) {
                const body = mech.pelvisAggregate.body;
                const quat = body.transformNode.rotationQuaternion;
                if (quat) {
                    const euler = quat.toEulerAngles();
                    // Counter-rotate feet on X axis to cancel pelvis forward/back tilt
                    // The foot is parented through ankle->lowerLeg->knee->upperLeg->hip->legGroup->pelvis
                    // We need to cancel out the pelvis tilt to keep feet flat
                    const pelvisTiltX = euler.x;  // Forward/back tilt
                    const pelvisTiltZ = euler.z;  // Left/right tilt

                    // Counter-rotate both feet to stay horizontal
                    // Negative pelvisTiltX because we want to cancel it out
                    mech.leftLeg.footGroup.rotation.x = -pelvisTiltX;
                    mech.rightLeg.footGroup.rotation.x = -pelvisTiltX;

                    // Z tilt affects left/right feet differently
                    // Left foot needs more counter-rotation when tilting left
                    // This is simplified - in reality legs would bend to compensate
                    mech.leftLeg.footGroup.rotation.z = -pelvisTiltZ * 0.5;
                    mech.rightLeg.footGroup.rotation.z = -pelvisTiltZ * 0.5;
                }

                // Never any Y rotation on feet
                mech.leftLeg.footGroup.rotation.y = 0;
                mech.rightLeg.footGroup.rotation.y = 0;
            }
        }

        // ============================================
        // HYBRID ARCHITECTURE: No active stabilization needed!
        // In WALKING mode (ANIMATED), the body is kinematic - no tipping possible
        // In RAGDOLL mode (DYNAMIC), physics handles everything naturally
        // This function is kept for legacy compatibility but does minimal work
        // ============================================
        function stabilize(mech, dt) {
            // In hybrid mode, stabilization is handled by the state machine
            // This function is called but does nothing in walking mode
            // Ragdoll and recovery are handled by updateRagdoll() and updateRecovery()
        }

        // ============================================
        // GOAL-BASED MECH AI SYSTEM
        // Each mech has goals that combine into movement:
        // 1. Range Goal: Move to optimal weapon range
        // 2. Avoidance Goal: Stay away from other mechs (unless melee)
        // 3. Boundary Goal: Stay inside arena
        // 4. Strafe Goal: Lateral movement when other goals satisfied
        // ============================================
        function updateAI(mech, dt) {
            const name = mech.isPlayer ? 'P' : 'E';
            const shouldLog = gameTime - lastDebugTime > DEBUG_INTERVAL;

            if (!mech.ai.enabled) {
                if (shouldLog) dbg(`${name}: AI disabled`, 'warn');
                return;
            }
            if (mech.currentHP <= 0) {
                if (shouldLog) dbg(`${name}: HP=0, skip AI`, 'warn');
                return;
            }
            if (mech.staggerTime > 0) {
                if (shouldLog) dbg(`${name}: staggered (${mech.staggerTime.toFixed(2)}s)`, 'warn');
                return;
            }

            // Get or find target
            let target = mech.ai.target;
            if (!target || target.currentHP <= 0 || target.isDestroyed) {
                target = findNewTarget(mech);
                mech.ai.target = target;
            }
            if (!target) {
                if (shouldLog) dbg(`${name}: no valid target`, 'warn');
                mech.isWalking = false;
                return;
            }

            const body = mech.pelvisAggregate.body;
            const myPos = mech.pelvis.getAbsolutePosition();
            const targetPos = target.pelvis.getAbsolutePosition();
            const distance = BABYLON.Vector3.Distance(myPos, targetPos);

            // Log physics state periodically
            if (shouldLog) {
                const vel = body.getLinearVelocity();
                dbg(`${name}: pos=(${myPos.x.toFixed(1)},${myPos.y.toFixed(1)},${myPos.z.toFixed(1)}) dist=${distance.toFixed(1)}`, 'phys');
            }

            // ============================================
            // GOAL 1: RANGE - Move toward optimal weapon range
            // ============================================
            const optimalRange = mech.optimalRange || 10;
            const rangeTolerance = 2.0;  // Acceptable range variance
            let rangeGoal = new BABYLON.Vector3(0, 0, 0);
            let rangeUrgency = 0;

            const rangeError = distance - optimalRange;
            if (Math.abs(rangeError) > rangeTolerance) {
                // Direction toward/away from target based on range error
                const toTarget = targetPos.subtract(myPos);
                toTarget.y = 0;
                toTarget.normalize();

                // Positive rangeError = too far, need to move closer
                // Negative rangeError = too close, need to back up
                rangeUrgency = Math.min(1.0, Math.abs(rangeError) / 8.0);
                rangeGoal = toTarget.scale(Math.sign(rangeError) * rangeUrgency);
            }

            // ============================================
            // GOAL 2: AVOIDANCE - Stay away from other mechs
            // Importance scales with inverse square of distance
            // ============================================
            let avoidGoal = new BABYLON.Vector3(0, 0, 0);
            let avoidUrgency = 0;
            const avoidRadius = 6.0;  // Start avoiding at this distance
            const minSeparation = 3.0;  // Minimum desired distance

            // Check all mechs for avoidance
            allMechs.forEach(other => {
                if (other === mech || other.isDestroyed || other.currentHP <= 0) return;

                const otherPos = other.pelvis.getAbsolutePosition();
                const toOther = otherPos.subtract(myPos);
                toOther.y = 0;
                const mechDist = toOther.length();

                if (mechDist < avoidRadius && mechDist > 0.1) {
                    // Skip avoidance for melee mechs toward their target
                    if (mech.isMelee && other === target && mechDist > minSeparation * 0.5) {
                        return;  // Melee mech wants to be close to target
                    }

                    // Inverse square falloff - very strong when close, zero at avoidRadius
                    const normalizedDist = (mechDist - minSeparation) / (avoidRadius - minSeparation);
                    const clampedDist = Math.max(0.1, Math.min(1.0, normalizedDist));
                    const avoidStrength = 1.0 / (clampedDist * clampedDist) - 1.0;

                    // Push away from this mech
                    const awayDir = toOther.normalize().scale(-1);
                    avoidGoal.addInPlace(awayDir.scale(Math.min(avoidStrength, 3.0)));
                    avoidUrgency = Math.max(avoidUrgency, 1.0 - clampedDist);
                }
            });

            // Normalize avoidance if it got too strong
            if (avoidGoal.length() > 1.5) {
                avoidGoal.normalize().scaleInPlace(1.5);
            }

            // ============================================
            // GOAL 3: BOUNDARY - Stay inside arena
            // ============================================
            let boundaryGoal = new BABYLON.Vector3(0, 0, 0);
            let boundaryUrgency = 0;
            const softBoundaryX = 14;  // Start pushing back
            const softBoundaryZ = 6;

            // X boundaries
            if (myPos.x < -softBoundaryX) {
                const depth = (-softBoundaryX - myPos.x) / 4;
                boundaryGoal.x = Math.min(2.0, 0.5 + depth);
                boundaryUrgency = Math.max(boundaryUrgency, Math.min(1.0, depth));
            } else if (myPos.x > softBoundaryX) {
                const depth = (myPos.x - softBoundaryX) / 4;
                boundaryGoal.x = -Math.min(2.0, 0.5 + depth);
                boundaryUrgency = Math.max(boundaryUrgency, Math.min(1.0, depth));
            }

            // Z boundaries
            if (myPos.z < -softBoundaryZ) {
                const depth = (-softBoundaryZ - myPos.z) / 2;
                boundaryGoal.z = Math.min(2.0, 0.5 + depth);
                boundaryUrgency = Math.max(boundaryUrgency, Math.min(1.0, depth));
            } else if (myPos.z > softBoundaryZ) {
                const depth = (myPos.z - softBoundaryZ) / 2;
                boundaryGoal.z = -Math.min(2.0, 0.5 + depth);
                boundaryUrgency = Math.max(boundaryUrgency, Math.min(1.0, depth));
            }

            // ============================================
            // GOAL 4: STRAFE - Lateral movement when stable
            // More aggressive strafing when at ideal range
            // ============================================
            let strafeGoal = new BABYLON.Vector3(0, 0, 0);

            // Initialize strafe timer if needed
            if (!mech.ai.strafeTimer) mech.ai.strafeTimer = 0;
            if (!mech.ai.currentStrafeDir) mech.ai.currentStrafeDir = 0;

            // Can strafe when not urgently avoiding boundaries
            const canStrafe = avoidUrgency < 0.6 && boundaryUrgency < 0.4;

            // Strafe more aggressively when at ideal range (rangeUrgency is low)
            const atIdealRange = rangeUrgency < 0.2;

            if (canStrafe) {
                mech.ai.strafeTimer -= dt;
                if (mech.ai.strafeTimer <= 0) {
                    // Always strafe when at ideal range, high chance otherwise
                    const strafeChance = atIdealRange ? 0.95 : 0.7;
                    if (Math.random() < strafeChance) {
                        // Higher intensity when at ideal range
                        const intensity = atIdealRange ? (0.6 + Math.random() * 0.4) : (0.3 + Math.random() * 0.5);
                        mech.ai.currentStrafeDir = (Math.random() < 0.5 ? -1 : 1) * intensity;
                    } else {
                        mech.ai.currentStrafeDir = 0;  // Brief pause
                    }
                    // Shorter timer when at ideal range for more dynamic movement
                    mech.ai.strafeTimer = atIdealRange ? (0.5 + Math.random() * 1.0) : (1.0 + Math.random() * 2.0);
                }

                // Calculate strafe direction (perpendicular to target)
                if (Math.abs(mech.ai.currentStrafeDir) > 0.1) {
                    const toTarget = targetPos.subtract(myPos);
                    toTarget.y = 0;
                    toTarget.normalize();
                    // Cross product with up to get perpendicular
                    const strafeDir = new BABYLON.Vector3(-toTarget.z, 0, toTarget.x);
                    // Stronger strafe when at ideal range
                    const strafeMultiplier = atIdealRange ? 1.0 : 0.6;
                    strafeGoal = strafeDir.scale(mech.ai.currentStrafeDir * strafeMultiplier);
                }
            }

            // ============================================
            // COMBINE GOALS with priority weighting
            // ============================================
            // Weights: boundary > avoidance > range > strafe
            // Strafe weight increases when at ideal range
            const boundaryWeight = 2.0;
            const avoidWeight = 1.5;
            const rangeWeight = 1.0;
            const strafeWeight = atIdealRange ? 1.2 : 0.5;  // Much higher strafe weight at ideal range

            let desiredVelocity = new BABYLON.Vector3(0, 0, 0);
            desiredVelocity.addInPlace(boundaryGoal.scale(boundaryWeight));
            desiredVelocity.addInPlace(avoidGoal.scale(avoidWeight));
            desiredVelocity.addInPlace(rangeGoal.scale(rangeWeight));
            desiredVelocity.addInPlace(strafeGoal.scale(strafeWeight));

            // ============================================
            // CONVERT TO MECH-RELATIVE MOVEMENT
            // ============================================
            const pelvisQuat = body.transformNode.rotationQuaternion;
            let mechForward = new BABYLON.Vector3(1, 0, 0);
            let mechRight = new BABYLON.Vector3(0, 0, 1);
            if (pelvisQuat) {
                const rotMatrix = new BABYLON.Matrix();
                pelvisQuat.toRotationMatrix(rotMatrix);
                mechForward = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(1, 0, 0), rotMatrix);
                mechForward.y = 0;
                mechForward.normalize();
                mechRight = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(0, 0, 1), rotMatrix);
                mechRight.y = 0;
                mechRight.normalize();
            }

            // Project desired velocity onto mech's forward and right axes
            const forwardComponent = desiredVelocity.x * mechForward.x + desiredVelocity.z * mechForward.z;
            const rightComponent = desiredVelocity.x * mechRight.x + desiredVelocity.z * mechRight.z;

            // Set movement parameters
            const velocityMagnitude = desiredVelocity.length();
            mech.isWalking = velocityMagnitude > 0.15;
            mech.walkDirection = Math.max(-1, Math.min(1, forwardComponent));
            mech.ai.strafeAmount = Math.max(-1, Math.min(1, rightComponent));

            if (shouldLog) {
                dbg(`${name}: goals range=${rangeUrgency.toFixed(2)} avoid=${avoidUrgency.toFixed(2)} bound=${boundaryUrgency.toFixed(2)}`, 'ai');
                dbg(`${name}: walk=${mech.walkDirection.toFixed(2)} strafe=${mech.ai.strafeAmount.toFixed(2)}`, 'ai');
            }

            // ============================================
            // WEAPON FIRING (separate from movement)
            // Skip AI weapon firing for player mech when in piloting mode (user controls weapons)
            // ============================================
            const skipWeaponFiring = mech.isPlayer && pilotingModeActive;
            if (!skipWeaponFiring && gameTime - mech.ai.lastDecision > AI_CONFIG.decisionInterval) {
                mech.ai.lastDecision = gameTime;

                const now = Date.now();
                const mechKey = mech.name + '_' + (mech.isPlayer ? 'p' : 'e');
                if (!mechCooldowns[mechKey]) mechCooldowns[mechKey] = { erlaser: 0, lrm: 0, ac: 0, hatchet: 0 };
                const cooldowns = mechCooldowns[mechKey];

                if (mech.isMelee) {
                    const meleeRange = WEAPONS.hatchet.range;
                    if (distance <= meleeRange && now >= cooldowns.hatchet) {
                        fireWeapon(mech, 'hatchet');
                        cooldowns.hatchet = now + COOLDOWN_TIMES.hatchet;
                    } else if (distance <= 15 && now >= cooldowns.erlaser) {
                        fireWeapon(mech, 'erlaser');
                        cooldowns.erlaser = now + COOLDOWN_TIMES.erlaser;
                    }
                } else if (mech.loadoutWeapons && mech.loadoutWeapons.length > 0) {
                    // Fire weapons from loadout only
                    if (distance <= 18 && distance >= 3) {
                        for (const loadoutWpn of mech.loadoutWeapons) {
                            const wpnKey = loadoutWpn.itemId;
                            if (!cooldowns[wpnKey]) cooldowns[wpnKey] = 0;
                            if (now >= cooldowns[wpnKey]) {
                                fireLoadoutWeapon(mech, loadoutWpn);
                                const weaponCooldown = (loadoutWpn.battle && loadoutWpn.battle.cooldown) || 2000;
                                cooldowns[wpnKey] = now + weaponCooldown;
                                break;
                            }
                        }
                    }
                } else {
                    // Fallback to default weapons for AI enemies without loadout
                    if (distance <= 18 && distance >= 3) {
                        const weaponPriority = ['erlaser', 'ac', 'lrm'];
                        for (const wtype of weaponPriority) {
                            if (now >= cooldowns[wtype]) {
                                fireWeapon(mech, wtype);
                                cooldowns[wtype] = now + COOLDOWN_TIMES[wtype];
                                break;
                            }
                        }
                    }
                }
            }

            // === FULL BODY ROTATION TOWARD TARGET (KINEMATIC MODE) ===
            // The whole mech (pelvis/legs) should always try to face the target
            // In ANIMATED mode, we set angular velocity directly instead of applying impulses
            const quat = body.transformNode.rotationQuaternion;
            if (quat && mech.mechState === MechState.WALKING && !mech.isDestroyed) {
                const euler = quat.toEulerAngles();
                const currentYaw = euler.y;  // Current facing direction

                // Calculate desired facing angle (toward target)
                const dx = targetPos.x - myPos.x;
                const dz = targetPos.z - myPos.z;
                const angleToTarget = Math.atan2(dz, dx);  // Angle in XZ plane

                // Convert to body rotation (mesh faces +Z, so we need baseAngle offset)
                const baseAngle = Math.PI / 2;  // 90Â° offset because mesh faces +Z
                const desiredYaw = baseAngle - angleToTarget;

                // Calculate rotation error (shortest path)
                let yawError = desiredYaw - currentYaw;
                // Normalize to [-PI, PI]
                while (yawError > Math.PI) yawError -= 2 * Math.PI;
                while (yawError < -Math.PI) yawError += 2 * Math.PI;

                // Store the desired rotation for the kinematic walking function
                mech.ai.desiredYawError = yawError;

                if (shouldLog) {
                    dbg(`${name}: BODY ROTATE yaw=${(currentYaw * 57.3).toFixed(0)}Â° target=${(desiredYaw * 57.3).toFixed(0)}Â° err=${(yawError * 57.3).toFixed(0)}Â°`, 'torso');
                }
            }

            // Note: lastDebugTime is updated in the main render loop after all subsystems log
        }

        // ============================================
        // COMBAT
        // ============================================
        // Legacy weapon firing - only used for melee and default demo battles
        // For loadout-based mechs, use fireLoadoutWeapon instead
        function fireWeapon(mech, type) {
            try {
                const from = mech;
                const to = mech.ai.target;
                if (!from || !to || to.isDestroyed) return;

                log(`[FIRE] ${from.name} attempting ${type}...`);

                const weapon = WEAPONS[type];
                if (!weapon) {
                    log(`[ERROR] Unknown weapon type: ${type}`, 'error');
                    return;
                }

                from.recoilRecovery = weapon.recoil;
                from.lastFiredArm = from.lastFiredArm === 'left' ? 'right' : 'left';

                // Validate required properties
                if (!from.pelvis || !to.pelvis) {
                    log(`[ERROR] Missing pelvis: from=${!!from.pelvis} to=${!!to.pelvis}`, 'error');
                    return;
                }

                // Apply recoil in opposite direction of target
                const toTarget = to.pelvis.getAbsolutePosition().subtract(from.pelvis.getAbsolutePosition()).normalize();
                from.pelvisAggregate.body.applyImpulse(
                    toTarget.scale(-weapon.knockback * 0.25),
                    from.pelvis.getAbsolutePosition()
                );

                if (weapon.isMelee) {
                    if (fireMelee(from, to, weapon)) {
                        log(`${from.name} swings ${weapon.name}!`);
                        triggerCinematicAction(from, 'fire');
                    }
                } else if (weapon.isBeam) {
                    fireBeam(from, to, weapon);
                    log(`${from.name} fires ${weapon.name}!`);
                    triggerCinematicAction(from, 'fire');
                } else if (weapon.isCluster) {
                    fireCluster(from, to, weapon);
                    log(`${from.name} fires ${weapon.name}!`);
                    triggerCinematicAction(from, 'fire');
                } else {
                    fireProjectile(from, to, weapon);
                    log(`${from.name} fires ${weapon.name}!`);
                    triggerCinematicAction(from, 'fire');
                }
            } catch (e) {
                log(`[FIRE ERROR] ${e.message}`, 'error');
                console.error('fireWeapon error:', e);
            }
        }

        // Fire a weapon from loadout data (uses actual weapon stats)
        // For player mechs, this may trigger the minigame
        function fireLoadoutWeapon(mech, loadoutWeapon) {
            try {
                const from = mech;
                const to = mech.ai.target;
                if (!from || !to || to.isDestroyed) return;

                // Check if this is a player mech and should trigger minigame
                if (from.isPlayer && !minigameState.active) {
                    // Check cooldown - only trigger if enough time has passed since last minigame
                    const timeSinceLastMinigame = performance.now() - minigameState.lastMinigameEndTime;
                    if (timeSinceLastMinigame >= MINIGAME_CONFIG.cooldownMs) {
                        // Roll for minigame trigger
                        if (Math.random() < MINIGAME_CONFIG.triggerChance) {
                            // Start the minigame instead of firing immediately
                            if (startWeaponMinigame(from, loadoutWeapon, to)) {
                                return; // Minigame started, weapon will fire after
                            }
                        }
                    }
                }

                // Normal fire (no minigame or enemy mech)
                fireLoadoutWeaponWithMultiplier(mech, loadoutWeapon, to, 1.0);
            } catch (e) {
                log(`[LOADOUT FIRE ERROR] ${e.message}`, 'error');
                console.error('fireLoadoutWeapon error:', e);
            }
        }

        // Fire a weapon with a damage multiplier (called after minigame or directly)
        function fireLoadoutWeaponWithMultiplier(mech, loadoutWeapon, target, damageMultiplier) {
            try {
                const from = mech;
                const to = target || mech.ai.target;
                if (!from || !to || to.isDestroyed) return;

                const wpnName = loadoutWeapon.name || loadoutWeapon.itemId;
                const battleProps = loadoutWeapon.battle || {};
                const baseDamage = loadoutWeapon.damage || 10;
                const finalDamage = Math.round(baseDamage * damageMultiplier);

                if (damageMultiplier !== 1.0) {
                    log(`[LOADOUT FIRE] ${from.name} fires ${wpnName} (${baseDamage} Ã— ${damageMultiplier} = ${finalDamage} damage)`);
                } else {
                    log(`[LOADOUT FIRE] ${from.name} fires ${wpnName} (${finalDamage} damage)`);
                }

                // Build weapon object from loadout data with modified damage
                const weapon = {
                    name: wpnName,
                    damage: finalDamage,
                    knockback: battleProps.knockback || 15,
                    recoil: battleProps.recoil || 0.15,
                    projectileSpeed: battleProps.projectileSpeed || 40,
                    projectileSize: battleProps.projectileSize || 0.12,
                    isBeam: battleProps.isBeam || false,
                    isCluster: battleProps.isCluster || false,
                    isProjectile: battleProps.isProjectile || (!battleProps.isBeam && !battleProps.isCluster),
                    beamDuration: battleProps.beamDuration || 180,
                    clusterCount: battleProps.clusterCount || 6,
                    color: battleProps.color ? new BABYLON.Color3(battleProps.color[0], battleProps.color[1], battleProps.color[2]) : new BABYLON.Color3(1, 0.8, 0.2)
                };

                from.recoilRecovery = weapon.recoil;
                from.lastFiredArm = from.lastFiredArm === 'left' ? 'right' : 'left';

                // Validate required properties
                if (!from.pelvis || !to.pelvis) {
                    log(`[ERROR] Missing pelvis: from=${!!from.pelvis} to=${!!to.pelvis}`, 'error');
                    return;
                }

                // Apply recoil in opposite direction of target
                const toTarget = to.pelvis.getAbsolutePosition().subtract(from.pelvis.getAbsolutePosition()).normalize();
                from.pelvisAggregate.body.applyImpulse(
                    toTarget.scale(-weapon.knockback * 0.25),
                    from.pelvis.getAbsolutePosition()
                );

                // Fire based on weapon type
                if (weapon.isBeam) {
                    fireBeam(from, to, weapon);
                    log(`${from.name} fires ${weapon.name}!`);
                    triggerCinematicAction(from, 'fire');
                } else if (weapon.isCluster) {
                    fireCluster(from, to, weapon);
                    log(`${from.name} fires ${weapon.name}!`);
                    triggerCinematicAction(from, 'fire');
                } else {
                    // Default to projectile
                    fireProjectile(from, to, weapon);
                    log(`${from.name} fires ${weapon.name}!`);
                    triggerCinematicAction(from, 'fire');
                }
            } catch (e) {
                log(`[LOADOUT FIRE ERROR] ${e.message}`, 'error');
                console.error('fireLoadoutWeaponWithMultiplier error:', e);
            }
        }

        function fireProjectile(from, to, weapon) {
            try {
                log(`[PROJ] Starting fireProjectile...`);
                const arm = from.lastFiredArm === 'left' ? from.leftArm : from.rightArm;

                // Validate arm structure
                if (!arm) {
                    log(`[ERROR] No arm found: lastFiredArm=${from.lastFiredArm}`, 'error');
                    return;
                }
                if (!arm.weaponPod) {
                    log(`[ERROR] No weaponPod on arm. Arm keys: ${Object.keys(arm).join(',')}`, 'error');
                    return;
                }
                if (!to.torso) {
                    log(`[ERROR] No torso on target`, 'error');
                    return;
                }

                const start = arm.weaponPod.getAbsolutePosition();
                start.z += 0.5;
                const target = to.torso.getAbsolutePosition();
                target.x += (Math.random() - 0.5) * 0.4;
                target.y += (Math.random() - 0.5) * 0.4;

                // Validate positions
                if (isNaN(start.x) || isNaN(target.x)) {
                    log(`[ERROR] NaN position: start=${start} target=${target}`, 'error');
                    return;
                }

                const dir = target.subtract(start).normalize();
                const projSize = weapon.projectileSize || 0.1;

                // Determine projectile type based on weapon characteristics
                const isMissileWeapon = weapon.name && (weapon.name.toLowerCase().includes('missile') || weapon.name.toLowerCase().includes('rocket'));
                const isBallistic = weapon.projectileSpeed > 40 || (weapon.name && (weapon.name.toLowerCase().includes('railgun') || weapon.name.toLowerCase().includes('cannon') || weapon.name.toLowerCase().includes('gun')));

                let proj;
                let projectileData = { weapon, target: to, firedAt: Date.now() };

                if (isMissileWeapon) {
                    // MISSILE: Long narrow tube with nose cone and engine
                    // Create parent container for missile parts
                    proj = new BABYLON.TransformNode('missile' + Date.now(), scene);
                    proj.position = start.clone();

                    // Main body - long narrow cylinder
                    const body = BABYLON.MeshBuilder.CreateCylinder('missileBody' + Date.now(), {
                        height: 0.5, diameter: 0.06, tessellation: 8
                    }, scene);
                    body.parent = proj;
                    const bodyMat = new BABYLON.StandardMaterial('missileBodyMat' + Date.now(), scene);
                    bodyMat.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.45);
                    bodyMat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                    body.material = bodyMat;

                    // Nose cone - pointed tip at front
                    const nose = BABYLON.MeshBuilder.CreateCylinder('missileNose' + Date.now(), {
                        height: 0.15, diameterTop: 0, diameterBottom: 0.06, tessellation: 8
                    }, scene);
                    nose.position.y = 0.325;  // Position at front of body
                    nose.parent = proj;
                    const noseMat = new BABYLON.StandardMaterial('missileNoseMat' + Date.now(), scene);
                    noseMat.diffuseColor = new BABYLON.Color3(0.6, 0.2, 0.1);  // Reddish tip
                    noseMat.emissiveColor = new BABYLON.Color3(0.2, 0.05, 0);
                    nose.material = noseMat;

                    // Engine section - darker cylinder at back
                    const engine = BABYLON.MeshBuilder.CreateCylinder('missileEngine' + Date.now(), {
                        height: 0.12, diameter: 0.07, tessellation: 8
                    }, scene);
                    engine.position.y = -0.31;  // Position at back
                    engine.parent = proj;
                    const engineMat = new BABYLON.StandardMaterial('missileEngineMat' + Date.now(), scene);
                    engineMat.diffuseColor = new BABYLON.Color3(0.15, 0.15, 0.18);
                    engineMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                    engine.material = engineMat;

                    // Engine glow/exhaust
                    const engineGlow = BABYLON.MeshBuilder.CreateSphere('engineGlow' + Date.now(), { diameter: 0.08 }, scene);
                    engineGlow.position.y = -0.38;
                    engineGlow.parent = proj;
                    const glowMat = new BABYLON.StandardMaterial('glowMat' + Date.now(), scene);
                    glowMat.emissiveColor = new BABYLON.Color3(1, 0.5, 0.1);
                    glowMat.alpha = 0.9;
                    glowMat.disableLighting = true;
                    engineGlow.material = glowMat;

                    // Orient missile toward target
                    proj.lookAt(target);
                    proj.rotation.x += Math.PI / 2;  // Point forward

                    // Store body mesh for physics (we'll attach aggregate to body)
                    projectileData.missileBody = body;
                    projectileData.isMissile = true;
                    projectileData.currentSpeed = weapon.projectileSpeed * 0.3;  // Start slow
                    projectileData.maxSpeed = weapon.projectileSpeed * 1.5;  // Accelerate to faster
                    projectileData.acceleration = weapon.projectileSpeed * 2;  // Acceleration rate
                    projectileData.direction = dir.clone();
                    projectileData.lastSmokeTime = Date.now();
                    projectileData.engineGlow = engineGlow;

                } else if (isBallistic) {
                    // BALLISTIC: Fast elongated bullet/tracer
                    proj = BABYLON.MeshBuilder.CreateCylinder('bullet' + Date.now(), {
                        height: 0.25, diameter: 0.04, tessellation: 6
                    }, scene);
                    proj.position = start.clone();
                    proj.lookAt(target);
                    proj.rotation.x += Math.PI / 2;

                    const mat = new BABYLON.StandardMaterial('bulletMat' + Date.now(), scene);
                    mat.emissiveColor = weapon.color;
                    mat.alpha = 0.95;
                    proj.material = mat;

                    // Add tracer glow
                    const tracer = BABYLON.MeshBuilder.CreateCylinder('tracer' + Date.now(), {
                        height: 0.35, diameter: 0.08, tessellation: 6
                    }, scene);
                    tracer.position = new BABYLON.Vector3(0, 0, 0);
                    tracer.parent = proj;
                    const tracerMat = new BABYLON.StandardMaterial('tracerMat' + Date.now(), scene);
                    tracerMat.emissiveColor = weapon.color;
                    tracerMat.alpha = 0.4;
                    tracer.material = tracerMat;

                    projectileData.isBallistic = true;
                    // Ballistic rounds are FAST
                    projectileData.speed = weapon.projectileSpeed * 2;

                } else {
                    // DEFAULT: Energy bolt (glowing sphere)
                    proj = BABYLON.MeshBuilder.CreateSphere('proj' + Date.now(), { diameter: projSize * 2 }, scene);
                    proj.position = start.clone();

                    const mat = new BABYLON.StandardMaterial('projMat' + Date.now(), scene);
                    mat.emissiveColor = weapon.color;
                    mat.alpha = 0.9;
                    proj.material = mat;

                    // Add outer glow
                    const glow = BABYLON.MeshBuilder.CreateSphere('glow' + Date.now(), { diameter: projSize * 4 }, scene);
                    glow.parent = proj;
                    const glowMat = new BABYLON.StandardMaterial('glowMat' + Date.now(), scene);
                    glowMat.emissiveColor = weapon.color;
                    glowMat.alpha = 0.25;
                    glow.material = glowMat;

                    projectileData.isEnergyBolt = true;
                }

                // For missiles, attach physics to the body mesh; for others, use proj directly
                const physicsTarget = projectileData.isMissile ? projectileData.missileBody : proj;
                // Set restitution to 0 for missiles so they don't bounce
                const restitution = projectileData.isMissile ? 0 : 0.1;
                const agg = new BABYLON.PhysicsAggregate(physicsTarget, BABYLON.PhysicsShapeType.SPHERE,
                    { mass: 0.8, friction: 0, restitution: restitution }, scene);

                // Disable projectile-to-projectile collisions
                agg.shape.filterMembershipMask = 4;
                agg.shape.filterCollideMask = 1 | 2;

                // Disable gravity for missiles and energy bolts (fly straight)
                if (projectileData.isMissile || projectileData.isEnergyBolt) {
                    agg.body.setGravityFactor(0);
                }

                // Set initial velocity
                const initialSpeed = projectileData.isMissile ? projectileData.currentSpeed :
                                    projectileData.isBallistic ? projectileData.speed :
                                    weapon.projectileSpeed;
                agg.body.setLinearVelocity(dir.scale(initialSpeed));

                projectileData.mesh = proj;
                projectileData.aggregate = agg;
                projectiles.push(projectileData);
                createMuzzleFlash(start, weapon.color);
                log(`[PROJ] Projectile created successfully`);
            } catch (e) {
                log(`[PROJ ERROR] ${e.message}`, 'error');
                console.error('fireProjectile error:', e);
            }
        }

        function fireBeam(from, to, weapon) {
            try {
                log(`[BEAM] Starting fireBeam...`);
                const arm = from.lastFiredArm === 'left' ? from.leftArm : from.rightArm;

                // Validate arm structure
                if (!arm) {
                    log(`[ERROR] No arm found: lastFiredArm=${from.lastFiredArm}`, 'error');
                    return;
                }
                if (!arm.weaponPod) {
                    log(`[ERROR] No weaponPod on arm. Arm keys: ${Object.keys(arm).join(',')}`, 'error');
                    return;
                }
                if (!to.torso) {
                    log(`[ERROR] No torso on target`, 'error');
                    return;
                }

                const start = arm.weaponPod.getAbsolutePosition();
                start.z += 0.6;
                const end = to.torso.getAbsolutePosition();

                // Validate positions and check for degenerate path
                if (isNaN(start.x) || isNaN(end.x)) {
                    log(`[ERROR] NaN position: start=${start} end=${end}`, 'error');
                    return;
                }
                const dist = BABYLON.Vector3.Distance(start, end);
                if (dist < 0.1) {
                    log(`[ERROR] Beam path too short: ${dist}`, 'error');
                    return;
                }

                log(`[BEAM] Creating tube: dist=${dist.toFixed(2)}`);

                // Create main beam core
                const beam = BABYLON.MeshBuilder.CreateTube('beam' + Date.now(), {
                    path: [start, end], radius: 0.08, updatable: false
                }, scene);
                const mat = new BABYLON.StandardMaterial('beamMat' + Date.now(), scene);
                mat.emissiveColor = weapon.color;
                mat.alpha = 0.95;
                mat.disableLighting = true;
                beam.material = mat;

                // Create outer glow tube
                const beamGlow = BABYLON.MeshBuilder.CreateTube('beamGlow' + Date.now(), {
                    path: [start, end], radius: 0.2, updatable: false
                }, scene);
                const glowMat = new BABYLON.StandardMaterial('beamGlowMat' + Date.now(), scene);
                glowMat.emissiveColor = weapon.color;
                glowMat.alpha = 0.25;
                glowMat.disableLighting = true;
                beamGlow.material = glowMat;

                // Create even larger outer halo
                const beamHalo = BABYLON.MeshBuilder.CreateTube('beamHalo' + Date.now(), {
                    path: [start, end], radius: 0.35, updatable: false
                }, scene);
                const haloMat = new BABYLON.StandardMaterial('beamHaloMat' + Date.now(), scene);
                haloMat.emissiveColor = weapon.color;
                haloMat.alpha = 0.1;
                haloMat.disableLighting = true;
                beamHalo.material = haloMat;

                beams.push({
                    mesh: beam, material: mat,
                    glow: beamGlow, glowMat: glowMat,
                    halo: beamHalo, haloMat: haloMat,
                    createdAt: Date.now(), duration: weapon.beamDuration
                });
                applyDamage(to, weapon, from.isPlayer ? 1 : -1);
                createImpact(end.clone(), weapon.color);
                log(`[BEAM] Beam created successfully`);
            } catch (e) {
                log(`[BEAM ERROR] ${e.message}`, 'error');
                console.error('fireBeam error:', e);
            }
        }

        function fireCluster(from, to, weapon) {
            try {
                log(`[CLUSTER] Starting fireCluster...`);

                // Validate pods exist
                if (!from.leftPod || !from.rightPod) {
                    log(`[ERROR] Missing pods: left=${!!from.leftPod} right=${!!from.rightPod}`, 'error');
                    return;
                }
                if (!to.torso) {
                    log(`[ERROR] No torso on target`, 'error');
                    return;
                }

                // Use shoulder missile launchers (leftPod/rightPod) instead of arm weapons
                const usePod = from.lastFiredArm === 'left' ? from.leftPod : from.rightPod;
                from.lastFiredArm = from.lastFiredArm === 'left' ? 'right' : 'left';  // Alternate pods

                const podPos = usePod.getAbsolutePosition();
                const target = to.torso.getAbsolutePosition();

                // Validate positions
                if (isNaN(podPos.x) || isNaN(target.x)) {
                    log(`[ERROR] NaN position in cluster: pod=${podPos} target=${target}`, 'error');
                    return;
                }

            for (let i = 0; i < weapon.clusterCount; i++) {
                setTimeout(() => {
                    // Calculate tube position within the missile rack (5x4 grid)
                    const row = Math.floor(i / 5) % 4;
                    const col = i % 5;

                    // Offset from pod center to simulate missiles coming from individual tubes
                    const tubeOffset = new BABYLON.Vector3(
                        (col - 2) * 0.13,   // X spread across columns
                        (row - 1.5) * 0.16, // Y spread across rows
                        0.7                  // Forward from pod center
                    );

                    // Transform offset to world space based on pod orientation
                    const worldMatrix = usePod.getWorldMatrix();
                    const start = BABYLON.Vector3.TransformCoordinates(tubeOffset, worldMatrix);

                    const spread = target.clone();
                    spread.x += (Math.random() - 0.5) * 2;
                    spread.y += (Math.random() - 0.5) * 1.5;
                    spread.z += (Math.random() - 0.5) * 1;

                    const dir = spread.subtract(start).normalize();
                    dir.y += 0.18;  // Arc upward slightly
                    dir.normalize();

                    const missile = BABYLON.MeshBuilder.CreateBox('missile' + Date.now() + i, {
                        width: 0.06, height: 0.06, depth: 0.18
                    }, scene);
                    missile.position = start.clone();
                    missile.lookAt(spread);

                    const mat = new BABYLON.StandardMaterial('missileMat' + Date.now(), scene);
                    mat.emissiveColor = weapon.color.scale(0.6);
                    missile.material = mat;

                    const agg = new BABYLON.PhysicsAggregate(missile, BABYLON.PhysicsShapeType.BOX,
                        { mass: 0.25, friction: 0, restitution: 0 }, scene);

                    // Disable projectile-to-projectile collisions
                    agg.shape.filterMembershipMask = 4;  // Projectile group
                    agg.shape.filterCollideMask = 1 | 2;  // Collide with ground (1) and mechs (2), not projectiles (4)

                    agg.body.setLinearVelocity(dir.scale(weapon.projectileSpeed));

                    projectiles.push({
                        mesh: missile, aggregate: agg,
                        weapon: { ...weapon, damage: weapon.damage / weapon.clusterCount },
                        target: to, firedAt: Date.now(), isMissile: true
                    });

                    // Create small muzzle flash at each tube
                    createMuzzleFlash(start, weapon.color);
                }, i * 40);
            }
                log(`[CLUSTER] Cluster missiles launched`);
            } catch (e) {
                log(`[CLUSTER ERROR] ${e.message}`, 'error');
                console.error('fireCluster error:', e);
            }
        }

        function fireMelee(from, to, weapon) {
            try {
                log(`[MELEE] ${from.name} swinging hatchet!`);

                // Check melee range
                const fromPos = from.pelvis.getAbsolutePosition();
                const toPos = to.pelvis.getAbsolutePosition();
                const dist = BABYLON.Vector3.Distance(fromPos, toPos);

                if (dist > weapon.range) {
                    log(`[MELEE] Target too far: ${dist.toFixed(1)} > ${weapon.range}`, 'warn');
                    return false;
                }

                // Create melee swing visual effect
                const swingStart = from.leftArm.weaponPod ? from.leftArm.weaponPod.getAbsolutePosition() : fromPos.clone();
                const swingEnd = to.torso.getAbsolutePosition();

                // Orange arc flash for hatchet swing
                const arc = BABYLON.MeshBuilder.CreateTube('meleeArc' + Date.now(), {
                    path: [swingStart, swingEnd],
                    radius: 0.15,
                    updatable: false
                }, scene);
                const arcMat = new BABYLON.StandardMaterial('arcMat' + Date.now(), scene);
                arcMat.emissiveColor = weapon.color;
                arcMat.alpha = 0.9;
                arc.material = arcMat;

                // Fade and remove arc quickly
                let arcAlpha = 0.9;
                const arcFade = setInterval(() => {
                    arcAlpha -= 0.15;
                    if (arcAlpha <= 0) {
                        clearInterval(arcFade);
                        arc.dispose();
                    } else {
                        arcMat.alpha = arcAlpha;
                    }
                }, 30);

                // Apply damage with massive knockback
                applyDamage(to, weapon, from.isPlayer ? 1 : -1);

                // Extra knockback for melee
                const knockDir = toPos.subtract(fromPos).normalize();
                knockDir.y = 0.3;  // Slight upward
                to.pelvisAggregate.body.applyImpulse(knockDir.scale(weapon.knockback * 0.8), toPos);

                // Create impact sparks
                createImpact(swingEnd.clone(), weapon.color);
                createImpact(swingEnd.clone(), new BABYLON.Color3(1, 0.8, 0.2));

                log(`[MELEE] HATCHET HIT! ${to.name} takes ${weapon.damage} damage!`, 'warn');
                return true;
            } catch (e) {
                log(`[MELEE ERROR] ${e.message}`, 'error');
                console.error('fireMelee error:', e);
                return false;
            }
        }

        function applyDamage(mech, weapon, dirSign) {
            // Skip if mech is already destroyed or recovering
            if (mech.isDestroyed) return;
            if (mech.mechState === MechState.RECOVERING) return;  // Don't damage during recovery

            let actualDamage = weapon.damage;
            const isEnergyWeapon = weapon.isBeam || false;
            const isBallistic = weapon.isProjectile || weapon.isMissile || false;

            // Energy weapons hit energy shields first
            if (isEnergyWeapon && mech.energyShieldHP > 0) {
                const shieldAbsorbed = Math.min(mech.energyShieldHP, actualDamage);
                mech.energyShieldHP -= shieldAbsorbed;
                actualDamage -= shieldAbsorbed;
                if (shieldAbsorbed > 0) {
                    log(`${mech.name}'s shield absorbs ${shieldAbsorbed} energy damage!`, 'info');
                    // Create shield flash effect
                    createShieldFlash(mech);
                }
                if (actualDamage <= 0) return;  // All damage absorbed by shield
            }

            // Ballistic/missile weapons are reduced by damage reduction armor
            if (isBallistic && mech.damageReduction > 0) {
                const reduced = Math.min(mech.damageReduction, actualDamage - 1);  // Always deal at least 1 damage
                actualDamage = Math.max(1, actualDamage - reduced);
                if (reduced > 0) {
                    log(`${mech.name}'s armor absorbs ${reduced} damage!`, 'info');
                }
            }

            mech.currentHP -= actualDamage;
            if (mech.currentHP < 0) mech.currentHP = 0;

            const knockback = weapon.knockback;
            const impactDir = new BABYLON.Vector3(dirSign, 0, 0);
            mech.impactDirection = impactDir;

            // Trigger cinematic camera to track damaged mech
            triggerCinematicAction(mech, 'damage');

            // Check for destruction first
            if (mech.currentHP <= 0 && !mech.isDestroyed) {
                log(`${mech.name} DESTROYED!`, 'error');
                triggerDestruction(mech);
                return;
            }

            // HYBRID DAMAGE SYSTEM: Determine flinch vs ragdoll based on knockback and stability

            // Reduce stability based on knockback
            mech.stability -= knockback * 0.8;
            if (mech.stability < 0) mech.stability = 0;

            dbg(`${mech.isPlayer ? 'P' : 'E'} ${mech.name}: Hit! KB=${knockback} Stability=${mech.stability.toFixed(0)}`, 'phys');

            // Case 1: Massive hit - immediate ragdoll regardless of stability
            if (knockback >= STABILITY_CONFIG.knockdownThreshold) {
                const hitForce = impactDir.scale(knockback * 1.5);
                hitForce.y = knockback * 0.3;  // Some upward lift
                triggerRagdoll(mech, hitForce);
                log(`${mech.name} KNOCKED DOWN!`, 'warn');
                return;
            }

            // Case 2: Stability depleted - ragdoll
            if (mech.stability <= 0 && mech.mechState === MechState.WALKING) {
                const hitForce = impactDir.scale(knockback * 1.2);
                hitForce.y = knockback * 0.2;
                triggerRagdoll(mech, hitForce);
                log(`${mech.name} STABILITY BROKEN!`, 'warn');
                return;
            }

            // Case 3: Medium hit - flinch and stagger
            if (knockback >= STABILITY_CONFIG.flinchThreshold) {
                mech.flinchIntensity = Math.min(1.0, knockback / 25);
                mech.staggerTime = 0.3;  // Brief pause
                log(`${mech.name} staggers!`, 'warn');

                // Small camera shake for medium hits
                triggerCameraShake(0.2, 0.15);
            } else {
                // Case 4: Small hit - minor flinch only
                mech.flinchIntensity = Math.min(0.5, knockback / 30);
            }

            // Visual flash effect for any hit
            createImpactSparks(mech.torso.getAbsolutePosition(), impactDir);
        }

        function updateProjectiles(dt) {
            const now = Date.now();
            projectiles = projectiles.filter(p => {
                try {
                    // Helper to dispose projectile (handles missiles with multiple parts)
                    const disposeProjectile = () => {
                        if (p.isMissile && p.missileBody) {
                            // Dispose the parent TransformNode which disposes all children
                            if (p.mesh && p.mesh.dispose) p.mesh.dispose();
                        } else {
                            p.mesh.dispose();
                        }
                    };

                    // Get position - for missiles use body position, for others use mesh position
                    const getPosition = () => {
                        if (p.isMissile && p.missileBody) {
                            return p.missileBody.getAbsolutePosition();
                        }
                        return p.mesh.position;
                    };

                    // Check timeout - use spawnTime if available (piloting mode), otherwise firedAt
                    const spawnTime = p.spawnTime || p.firedAt;
                    const timeout = p.timeout || 3500;
                    if (now - spawnTime > timeout) { disposeProjectile(); return false; }

                    const projPos = getPosition();

                    // Handle piloting mode projectiles (no specific target, check all enemies)
                    if (!p.target && p.targetPosition) {
                        // Move projectile based on velocity
                        if (p.velocity) {
                            p.mesh.position.addInPlace(p.velocity.scale(dt));
                        }

                        // Check collision with all mechs that aren't the owner
                        const enemies = allMechs.filter(m => m && !m.isDestroyed && m !== p.owner && m.isPlayer !== p.owner.isPlayer);
                        for (const enemy of enemies) {
                            if (!enemy.torso) continue;
                            const dist = BABYLON.Vector3.Distance(projPos, enemy.torso.getAbsolutePosition());
                            if (dist < 2.0) {  // Slightly larger hitbox for piloting mode
                                applyDamage(enemy, p.weapon, enemy.isPlayer ? -1 : 1);
                                log(`[PILOT HIT] ${enemy.name} -${p.weapon.damage} (${enemy.currentHP}/${enemy.maxHP})`, 'warn');
                                createImpact(projPos.clone(), p.weapon.color);
                                disposeProjectile();
                                return false;
                            }
                        }

                        // Check for ground hit
                        if (projPos.y < 0.3) {
                            const groundPos = projPos.clone();
                            groundPos.y = 0.1;
                            createDustPlume(groundPos);
                            disposeProjectile();
                            return false;
                        }

                        // Out of bounds
                        if (Math.abs(projPos.x) > 22 || Math.abs(projPos.z) > 15) {
                            disposeProjectile();
                            return false;
                        }

                        return true;
                    }

                    // Standard projectile with specific target
                    if (!p.target || !p.target.torso) {
                        log(`[WARN] Projectile has invalid target, removing`, 'warn');
                        disposeProjectile();
                        return false;
                    }

                    const dist = BABYLON.Vector3.Distance(projPos, p.target.torso.getAbsolutePosition());
                    if (dist < 1.6) {
                        applyDamage(p.target, p.weapon, p.target.isPlayer ? -1 : 1);
                        log(`HIT! ${p.target.name} -${p.weapon.damage} (${p.target.currentHP}/${p.target.maxHP})`, 'warn');
                        createImpact(projPos.clone(), p.weapon.color);
                        disposeProjectile();
                        return false;
                    }

                    // Check for ground hit - create dust plume
                    if (projPos.y < 0.3) {
                        const groundPos = projPos.clone();
                        groundPos.y = 0.1;
                        createDustPlume(groundPos);
                        disposeProjectile();
                        return false;
                    }

                    // Out of bounds - destroy immediately (no bouncing)
                    if (Math.abs(projPos.x) > 22 || Math.abs(projPos.z) > 15) {
                        disposeProjectile();
                        return false;
                    }

                    // Handle missile acceleration and smoke trails
                    if (p.isMissile) {
                        // Accelerate missile
                        if (p.currentSpeed < p.maxSpeed) {
                            p.currentSpeed += p.acceleration * dt;
                            if (p.currentSpeed > p.maxSpeed) p.currentSpeed = p.maxSpeed;
                        }

                        // Update velocity to fly straight toward target
                        if (p.aggregate && p.aggregate.body && p.target && p.target.torso && p.missileBody) {
                            const targetPos = p.target.torso.getAbsolutePosition();
                            const currentPos = p.missileBody.getAbsolutePosition();
                            const dirToTarget = targetPos.subtract(currentPos).normalize();

                            // Set velocity directly toward target
                            p.aggregate.body.setLinearVelocity(dirToTarget.scale(p.currentSpeed));

                            // Sync TransformNode position with physics body
                            p.mesh.position.copyFrom(currentPos);

                            // Update mesh rotation to face target
                            p.mesh.lookAt(targetPos);
                            p.mesh.rotation.x += Math.PI / 2;  // Adjust for cylinder orientation
                        }

                        // Create smoke trail more frequently
                        if (now - p.lastSmokeTime > 30) {  // Every 30ms
                            createMissileSmoke(projPos.clone());
                            p.lastSmokeTime = now;
                        }

                        // Flicker engine glow
                        if (p.engineGlow && p.engineGlow.material) {
                            const flicker = 0.7 + Math.random() * 0.3;
                            p.engineGlow.material.emissiveColor = new BABYLON.Color3(1 * flicker, 0.5 * flicker, 0.1 * flicker);
                        }
                    }

                    return true;
                } catch (e) {
                    console.error('[PROJECTILE ERROR]', e);
                    try { disposeProjectile(); } catch (e2) {}
                    return false;
                }
            });
        }

        // Create missile smoke trail particle
        function createMissileSmoke(pos) {
            const smoke = BABYLON.MeshBuilder.CreateSphere('smoke' + Date.now(), { diameter: 0.15 }, scene);
            smoke.position = pos;

            const mat = new BABYLON.StandardMaterial('smokeMat' + Date.now(), scene);
            mat.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.4);
            mat.emissiveColor = new BABYLON.Color3(0.3, 0.25, 0.2);
            mat.alpha = 0.6;
            smoke.material = mat;

            // Animate smoke: expand and fade
            let smokeLife = 0;
            const smokeUpdate = scene.onBeforeRenderObservable.add(() => {
                smokeLife += scene.getEngine().getDeltaTime() / 1000;
                const scale = 1 + smokeLife * 3;  // Expand
                smoke.scaling = new BABYLON.Vector3(scale, scale, scale);
                mat.alpha = Math.max(0, 0.6 - smokeLife * 1.5);  // Fade

                if (smokeLife > 0.5) {
                    scene.onBeforeRenderObservable.remove(smokeUpdate);
                    smoke.dispose();
                }
            });
        }

        function updateBeams() {
            const now = Date.now();
            beams = beams.filter(b => {
                const age = now - b.createdAt;
                if (age > b.duration) {
                    b.mesh.dispose();
                    if (b.glow) b.glow.dispose();
                    if (b.halo) b.halo.dispose();
                    return false;
                }
                const fadeRatio = 1 - age / b.duration;
                b.material.alpha = 0.95 * fadeRatio;
                if (b.glowMat) b.glowMat.alpha = 0.25 * fadeRatio;
                if (b.haloMat) b.haloMat.alpha = 0.1 * fadeRatio;
                return true;
            });
        }

        // ============================================
        // EFFECTS
        // ============================================
        function createMuzzleFlash(pos, color) {
            const flash = BABYLON.MeshBuilder.CreateSphere('flash', { diameter: 0.35 }, scene);
            flash.position = pos;
            const mat = new BABYLON.StandardMaterial('flashMat', scene);
            mat.emissiveColor = color;
            mat.disableLighting = true;
            flash.material = mat;

            let a = 1;
            const int = setInterval(() => {
                a -= 0.18;
                if (a <= 0) { clearInterval(int); flash.dispose(); }
                else flash.scaling.setAll(a);
            }, 16);
        }

        function createImpact(pos, color) {
            const ps = new BABYLON.ParticleSystem('impact', 60, scene);
            ps.particleTexture = new BABYLON.Texture('https://assets.babylonjs.com/textures/flare.png', scene);
            ps.emitter = pos;
            ps.color1 = new BABYLON.Color4(color.r, color.g, color.b, 1);
            ps.color2 = new BABYLON.Color4(color.r * 0.5, color.g * 0.5, color.b * 0.5, 1);
            ps.colorDead = new BABYLON.Color4(0.15, 0.1, 0, 0);
            ps.minSize = 0.08; ps.maxSize = 0.35;
            ps.minLifeTime = 0.12; ps.maxLifeTime = 0.35;
            ps.emitRate = 250; ps.manualEmitCount = 40;
            ps.minEmitPower = 3; ps.maxEmitPower = 7;
            ps.direction1 = new BABYLON.Vector3(-1, 1, -1);
            ps.direction2 = new BABYLON.Vector3(1, 1.5, 1);
            ps.gravity = new BABYLON.Vector3(0, -10, 0);
            ps.start();
            ps.targetStopDuration = 0.18;
            ps.disposeOnStop = true;
        }

        function createSmoke(pos) {
            const s = BABYLON.MeshBuilder.CreateSphere('smoke', { diameter: 0.08 }, scene);
            s.position = pos;
            const mat = new BABYLON.StandardMaterial('smokeMat', scene);
            mat.diffuseColor = new BABYLON.Color3(0.35, 0.35, 0.35);
            mat.alpha = 0.45;
            s.material = mat;

            let life = 0.4;
            const int = setInterval(() => {
                life -= 0.04;
                if (life <= 0) { clearInterval(int); s.dispose(); }
                else { s.scaling.scaleInPlace(1.06); mat.alpha = life; }
            }, 45);
        }

        function createDustPlume(pos) {
            // Create a particle system for dust/dirt kicked up by projectile hitting ground
            const ps = new BABYLON.ParticleSystem('dustPlume', 40, scene);
            ps.particleTexture = new BABYLON.Texture('https://assets.babylonjs.com/textures/flare.png', scene);
            ps.emitter = pos;

            // Brown/tan dust colors
            ps.color1 = new BABYLON.Color4(0.6, 0.5, 0.35, 0.8);
            ps.color2 = new BABYLON.Color4(0.5, 0.4, 0.3, 0.6);
            ps.colorDead = new BABYLON.Color4(0.4, 0.35, 0.25, 0);

            ps.minSize = 0.15;
            ps.maxSize = 0.45;
            ps.minLifeTime = 0.3;
            ps.maxLifeTime = 0.8;

            ps.emitRate = 200;
            ps.manualEmitCount = 25;

            ps.minEmitPower = 1;
            ps.maxEmitPower = 3;

            // Spray upward and outward
            ps.direction1 = new BABYLON.Vector3(-1, 2, -1);
            ps.direction2 = new BABYLON.Vector3(1, 4, 1);

            ps.gravity = new BABYLON.Vector3(0, -6, 0);

            ps.start();
            ps.targetStopDuration = 0.15;
            ps.disposeOnStop = true;
        }

        function triggerDestruction(mech) {
            const pos = mech.pelvis.getAbsolutePosition();
            const mechName = mech.isPlayer ? 'TIMBER WOLF' : 'DIRE WOLF';

            // ========================================
            // SCREEN FLASH - bright orange/white (with guaranteed cleanup)
            // ========================================
            const flashPlane = BABYLON.MeshBuilder.CreatePlane('explosionFlash_' + Date.now(), { size: 100 }, scene);
            flashPlane.position = camera.position.add(camera.getForwardRay().direction.scale(5));
            flashPlane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
            const flashMat = new BABYLON.StandardMaterial('flashMat_' + Date.now(), scene);
            flashMat.emissiveColor = new BABYLON.Color3(1, 0.6, 0.2);
            flashMat.disableLighting = true;
            flashMat.alpha = 0.7;
            flashPlane.material = flashMat;

            // Use requestAnimationFrame for smoother fade and guaranteed cleanup
            const flashStartTime = performance.now();
            const flashDuration = 500; // ms
            function fadeFlash() {
                const elapsed = performance.now() - flashStartTime;
                const progress = elapsed / flashDuration;
                if (progress >= 1 || !flashPlane || flashPlane.isDisposed()) {
                    // Guaranteed cleanup
                    if (flashPlane && !flashPlane.isDisposed()) {
                        flashPlane.dispose();
                    }
                    if (flashMat && !flashMat.isDisposed) {
                        flashMat.dispose();
                    }
                    return;
                }
                flashMat.alpha = 0.7 * (1 - progress);
                requestAnimationFrame(fadeFlash);
            }
            requestAnimationFrame(fadeFlash);

            // Failsafe: force dispose after 1 second no matter what
            setTimeout(() => {
                if (flashPlane && !flashPlane.isDisposed()) {
                    flashPlane.dispose();
                }
            }, 1000);

            // ========================================
            // CAMERA SHAKE
            // ========================================
            const originalCamPos = camera.position.clone();
            let shakeTime = 0;
            const shakeInterval = setInterval(() => {
                shakeTime += 30;
                if (shakeTime > 1500) {
                    clearInterval(shakeInterval);
                    camera.position = originalCamPos;
                } else {
                    const intensity = 0.5 * (1 - shakeTime / 1500);
                    camera.position = originalCamPos.add(new BABYLON.Vector3(
                        (Math.random() - 0.5) * intensity,
                        (Math.random() - 0.5) * intensity * 0.5,
                        (Math.random() - 0.5) * intensity
                    ));
                }
            }, 30);

            // ========================================
            // MASSIVE CHAIN EXPLOSIONS
            // ========================================
            // Initial big explosion at center
            for (let i = 0; i < 3; i++) {
                createImpact(pos.clone(), new BABYLON.Color3(1, 0.4, 0));
            }

            // Ring of explosions spreading outward
            for (let i = 0; i < 16; i++) {
                setTimeout(() => {
                    const angle = (Math.PI * 2 * i) / 16;
                    const dist = 1.5 + Math.random() * 1.5;
                    createImpact(pos.add(new BABYLON.Vector3(
                        Math.cos(angle) * dist,
                        Math.random() * 2,
                        Math.sin(angle) * dist * 0.5
                    )), Math.random() > 0.5 ? COLORS.thruster : new BABYLON.Color3(1, 0.6, 0));
                }, i * 60);
            }

            // Delayed secondary explosions
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    createImpact(pos.add(new BABYLON.Vector3(
                        (Math.random() - 0.5) * 4,
                        Math.random() * 3,
                        (Math.random() - 0.5) * 2
                    )), new BABYLON.Color3(1, 0.3 + Math.random() * 0.4, 0));
                }, 500 + i * 100);
            }

            // ========================================
            // MAKE MECH COLLAPSE DRAMATICALLY
            // ========================================
            // Mark as destroyed so state machine and AI don't interfere
            mech.isDestroyed = true;
            mech.destroyedTimer = 0;  // Track time since destruction for friction ramping
            mech.mechState = MechState.RAGDOLL;
            mech.ai.enabled = false;
            mech.isWalking = false;

            const body = mech.pelvisAggregate.body;

            // HYBRID: Switch to DYNAMIC mode so physics can take over for dramatic fall
            body.setMotionType(BABYLON.PhysicsMotionType.DYNAMIC);

            // Set proper mass and very low damping for dramatic physics
            body.setMassProperties({ mass: mech.stats.mass || 75 });
            body.setLinearDamping(0.05);
            body.setAngularDamping(0.1);

            // Get the impact direction from the last damage
            const impactDir = mech.impactDirection || new BABYLON.Vector3(1, 0, 0);

            // Inherit velocity from kinematic movement
            const inheritedVel = mech.lastKinematicVelocity || new BABYLON.Vector3(0, 0, 0);
            body.setLinearVelocity(inheritedVel);

            // DRAMATIC EXPLOSION KNOCKBACK - 5x impulse for massive launch
            const explosionForce = impactDir.scale(-400);  // 5x: Away from impact direction
            explosionForce.y = 300 + Math.random() * 200;    // 5x: Strong upward lift
            explosionForce.x += (Math.random() - 0.5) * 150;
            explosionForce.z += (Math.random() - 0.5) * 100;

            body.applyImpulse(explosionForce, pos);

            // No spinning - just let physics handle natural tumbling
            const fallDirection = (Math.random() > 0.5) ? 1 : -1;

            // DRAMATIC LIMB FLINGING - 5x force for limbs
            const destructionHitForce = impactDir.scale(300);
            destructionHitForce.y = 150;
            flingLimbs(mech, destructionHitForce);

            // Additional limb chaos for destruction - more extreme than normal ragdoll
            destroyedLimbChaos(mech);

            // Continue applying downward force to ensure it falls
            let collapseTime = 0;
            const collapseInterval = setInterval(() => {
                collapseTime += 50;
                if (collapseTime > 1200 || !mech.pelvisAggregate.body) {
                    clearInterval(collapseInterval);
                    return;
                }
                // Just downward force, no spinning
                body.applyImpulse(
                    new BABYLON.Vector3(0, -15, 0),
                    mech.pelvis.getAbsolutePosition()
                );
            }, 50);

            log(`ðŸ’€ðŸ’€ðŸ’€ ${mech.name} HAS BEEN DESTROYED! ðŸ’€ðŸ’€ðŸ’€`, 'error');
        }

        // ============================================
        // CONTROLS
        // ============================================
        function toggleWalking(isPlayer) {
            const mech = isPlayer ? playerMech : enemyMech;
            if (!mech) return;
            mech.isWalking = !mech.isWalking;
            log(`${mech.name} ${mech.isWalking ? 'walking' : 'stopped'}`);
        }

        function resetScene() {
            // Disable AI battle mode
            autoFireEnabled = false;
            battleEnded = false;
            const btn = document.getElementById('autoFireBtn');
            btn.textContent = 'AI Battle: OFF';
            btn.style.background = 'rgba(255, 200, 0, 0.3)';
            btn.style.borderColor = '#ffcc00';
            btn.style.color = '#ffcc00';

            // Starting positions for each team (4 mechs per side)
            const playerPositions = [
                { x: -7, y: 3.5, z: 0 },
                { x: -8, y: 3.0, z: 2 },
                { x: -10, y: 3.2, z: 4 },
                { x: -10, y: 3.0, z: -3 }
            ];
            const enemyPositions = [
                { x: 7, y: 3.8, z: 0 },
                { x: 8, y: 3.0, z: -2 },
                { x: 10, y: 3.2, z: 4 },
                { x: 10, y: 3.0, z: -3 }
            ];

            // Reset player mechs
            playerMechs.forEach((mech, i) => {
                if (!mech) return;
                const pos = playerPositions[i] || playerPositions[0];
                mech.pelvis.position = new BABYLON.Vector3(pos.x, pos.y, pos.z);
                // HYBRID: Reset to ANIMATED mode for kinematic walking
                mech.pelvisAggregate.body.setMotionType(BABYLON.PhysicsMotionType.ANIMATED);
                mech.pelvisAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                mech.pelvisAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());
                mech.pelvisAggregate.body.setAngularDamping(STABILITY_CONFIG.mechAngularDamping);
                mech.pelvisAggregate.body.setLinearDamping(STABILITY_CONFIG.mechLinearDamping);
                mech.currentHP = mech.maxHP;
                mech.isWalking = false;
                mech.isDestroyed = false;
                mech.destroyedTimer = 0;
                // HYBRID state reset
                mech.mechState = MechState.WALKING;
                mech.stability = STABILITY_CONFIG.maxStability;
                mech.ragdollSettleTimer = 0;
                mech.recoveryTimer = 0;
                mech.flinchIntensity = 0;
                mech.lastKinematicVelocity = new BABYLON.Vector3(0, 0, 0);
                mech.impactRecovery = 0;
                mech.recoilRecovery = 0;
                mech.torso.rotation.setAll(0);
                mech.ai.enabled = false;
                mech.ai.state = 'idle';
                mech.ai.target = null;
                mech.ai.lastDecision = 0;
                mech.ai.strafeDir = 0;
                mech.ai.strafeEndTime = 0;
                mech.ai.strafeAmount = 0;
                mech.ai.desiredYawError = 0;
            });

            // Reset enemy mechs
            enemyMechs.forEach((mech, i) => {
                if (!mech) return;
                const pos = enemyPositions[i] || enemyPositions[0];
                mech.pelvis.position = new BABYLON.Vector3(pos.x, pos.y, pos.z);
                // HYBRID: Reset to ANIMATED mode for kinematic walking
                mech.pelvisAggregate.body.setMotionType(BABYLON.PhysicsMotionType.ANIMATED);
                mech.pelvisAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                mech.pelvisAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());
                mech.pelvisAggregate.body.setAngularDamping(STABILITY_CONFIG.mechAngularDamping);
                mech.pelvisAggregate.body.setLinearDamping(STABILITY_CONFIG.mechLinearDamping);
                mech.currentHP = mech.maxHP;
                mech.isWalking = false;
                mech.isDestroyed = false;
                mech.destroyedTimer = 0;
                // HYBRID state reset
                mech.mechState = MechState.WALKING;
                mech.stability = STABILITY_CONFIG.maxStability;
                mech.ragdollSettleTimer = 0;
                mech.recoveryTimer = 0;
                mech.flinchIntensity = 0;
                mech.lastKinematicVelocity = new BABYLON.Vector3(0, 0, 0);
                mech.impactRecovery = 0;
                mech.recoilRecovery = 0;
                mech.torso.rotation.setAll(0);
                mech.ai.enabled = false;
                mech.ai.state = 'idle';
                mech.ai.target = null;
                mech.ai.lastDecision = 0;
                mech.ai.strafeDir = 0;
                mech.ai.strafeEndTime = 0;
                mech.ai.strafeAmount = 0;
                mech.ai.desiredYawError = 0;
            });

            projectiles.forEach(p => p.mesh.dispose());
            projectiles = [];
            beams.forEach(b => b.mesh.dispose());
            beams = [];

            // Reset cooldowns for all mechs
            Object.keys(mechCooldowns).forEach(key => {
                mechCooldowns[key] = { erlaser: 0, lrm: 0, ac: 0 };
            });

            log('Scene reset');
        }

        // ============================================
        // RETURN TO LOADOUT
        // ============================================
        function returnToLoadout() {
            // Clear the battle config
            localStorage.removeItem('battleConfig');

            // If running in an iframe, notify parent window
            if (window.parent !== window) {
                window.parent.postMessage({ type: 'battleEnd' }, '*');
            } else {
                // Navigate back to the loadout screen (standalone mode)
                window.location.href = 'index.html';
            }
        }

        // ============================================
        // AI BATTLE SYSTEM
        // ============================================
        function toggleAutoFire() {
            autoFireEnabled = !autoFireEnabled;
            const btn = document.getElementById('autoFireBtn');

            if (autoFireEnabled) {
                btn.textContent = 'AI Battle: ON';
                btn.style.background = 'rgba(0, 255, 136, 0.4)';
                btn.style.borderColor = '#00ff88';
                btn.style.color = '#00ff88';
                battleEnded = false;  // Allow AI loop to run again
                log('AI ENABLED - mechs will fight autonomously!');

                // Clear debug logs for fresh start
                debugLogs.length = 0;
                lastDebugTime = 0;
                dbg('=== AI BATTLE STARTED ===', 'ai');

                // Enable AI on all mechs with proper initialization
                allMechs.forEach(mech => {
                    if (!mech || mech.isDestroyed) return;
                    mech.ai.enabled = true;
                    // Melee mechs start charging immediately!
                    mech.ai.state = mech.isMelee ? 'charging' : 'advancing';
                    mech.ai.target = findNewTarget(mech);  // Find initial target
                    mech.ai.lastDecision = gameTime;
                    mech.isWalking = true;
                    mech.walkDirection = mech.isPlayer ? 1 : -1;
                    dbg(`${mech.name} init: ai.enabled=${mech.ai.enabled} state=${mech.ai.state} target=${mech.ai.target?.name}`, 'ai');
                });

                log(`Battle started: ${playerMechs.length} vs ${enemyMechs.length} mechs!`);
            } else {
                btn.textContent = 'AI Battle: OFF';
                btn.style.background = 'rgba(255, 200, 0, 0.3)';
                btn.style.borderColor = '#ffcc00';
                btn.style.color = '#ffcc00';
                battleEnded = true;  // Stop the AI loop
                log('AI DISABLED');

                // Disable AI on all mechs
                allMechs.forEach(mech => {
                    if (!mech) return;
                    mech.ai.enabled = false;
                    mech.ai.state = 'idle';
                    mech.isWalking = false;
                });
            }
        }

        // ============================================
        // CINEMATIC CAMERA SYSTEM
        // ============================================
        function toggleCinematicCamera() {
            cinematicEnabled = !cinematicEnabled;
            const btn = document.getElementById('cinematicBtn');

            if (cinematicEnabled) {
                btn.textContent = 'Cinematic: ON';
                btn.style.background = 'rgba(136, 100, 255, 0.4)';
                btn.style.borderColor = '#8864ff';
                btn.style.color = '#8864ff';

                // Detach regular camera controls
                camera.detachControl();

                // Initialize cinematic state
                cinematicState.mode = 'sweep';
                cinematicState.transitionTime = 0;
                cinematicState.orbitAngle = camera.alpha;
                cinematicState.sweepPhase = 0;

                // Pick a random alive mech to start tracking
                const aliveMechs = allMechs.filter(m => m && !m.isDestroyed);
                if (aliveMechs.length > 0) {
                    cinematicState.target = aliveMechs[Math.floor(Math.random() * aliveMechs.length)];
                }

                log('Cinematic camera ENABLED');
            } else {
                btn.textContent = 'Cinematic: OFF';
                btn.style.background = 'rgba(0, 255, 136, 0.2)';
                btn.style.borderColor = '#00ff88';
                btn.style.color = '#00ff88';

                // Re-attach regular camera controls
                camera.attachControl(document.getElementById('renderCanvas'), true);
                log('Cinematic camera DISABLED');
            }
        }

        function triggerCinematicAction(mech, actionType) {
            // Called when interesting action happens (weapon fire, damage, destruction)
            if (!cinematicEnabled) return;

            cinematicState.actionTarget = mech;
            cinematicState.actionTime = gameTime;

            // Switch to action mode if the action is interesting enough
            if (actionType === 'fire' && Math.random() < 0.3) {
                cinematicState.mode = 'action';
                cinematicState.target = mech;
                cinematicState.transitionTime = 0;
                cinematicState.modeDuration = 2;  // Quick action shot
            } else if (actionType === 'damage' && Math.random() < 0.4) {
                cinematicState.mode = 'track';
                cinematicState.target = mech;
                cinematicState.transitionTime = 0;
                cinematicState.modeDuration = 3;
            }
        }

        function updateCinematicCamera(dt) {
            if (!cinematicEnabled) return;

            const state = cinematicState;
            state.transitionTime += dt;

            // Get alive mechs
            const aliveMechs = allMechs.filter(m => m && !m.isDestroyed);
            if (aliveMechs.length === 0) return;

            // Make sure target is still valid
            if (!state.target || state.target.isDestroyed) {
                state.target = aliveMechs[Math.floor(Math.random() * aliveMechs.length)];
            }

            // Mode transitions
            if (state.transitionTime > state.modeDuration) {
                state.transitionTime = 0;

                // Pick next mode with weighted random
                const roll = Math.random();
                if (roll < 0.35) {
                    state.mode = 'orbit';
                    state.modeDuration = 5 + Math.random() * 3;
                    state.orbitRadius = 10 + Math.random() * 8;
                    state.orbitHeight = 5 + Math.random() * 6;
                } else if (roll < 0.6) {
                    state.mode = 'track';
                    state.modeDuration = 4 + Math.random() * 2;
                    // Pick a new random target
                    state.target = aliveMechs[Math.floor(Math.random() * aliveMechs.length)];
                } else if (roll < 0.85) {
                    state.mode = 'sweep';
                    state.modeDuration = 6 + Math.random() * 4;
                    state.sweepPhase = 0;
                } else {
                    state.mode = 'action';
                    state.modeDuration = 3 + Math.random() * 2;
                    // Find mech with most enemies nearby for action shot
                    let bestMech = state.target;
                    let maxEnemies = 0;
                    aliveMechs.forEach(mech => {
                        const enemies = aliveMechs.filter(m => m.isPlayer !== mech.isPlayer);
                        let nearby = 0;
                        enemies.forEach(e => {
                            const d = BABYLON.Vector3.Distance(mech.pelvis.getAbsolutePosition(), e.pelvis.getAbsolutePosition());
                            if (d < 15) nearby++;
                        });
                        if (nearby > maxEnemies) {
                            maxEnemies = nearby;
                            bestMech = mech;
                        }
                    });
                    state.target = bestMech;
                }
            }

            // Calculate camera position based on mode
            let targetPos = state.target.pelvis.getAbsolutePosition();
            let cameraPos;
            let lookAt;

            switch (state.mode) {
                case 'orbit':
                    // Smooth orbit around target
                    state.orbitAngle += dt * 0.4;  // Slow rotation
                    cameraPos = new BABYLON.Vector3(
                        targetPos.x + Math.cos(state.orbitAngle) * state.orbitRadius,
                        targetPos.y + state.orbitHeight,
                        targetPos.z + Math.sin(state.orbitAngle) * state.orbitRadius
                    );
                    lookAt = targetPos.add(new BABYLON.Vector3(0, 2, 0));
                    break;

                case 'track':
                    // Over-the-shoulder tracking shot
                    const forward = state.target.pelvis.getDirection(BABYLON.Vector3.Forward());
                    const right = state.target.pelvis.getDirection(BABYLON.Vector3.Right());
                    cameraPos = targetPos
                        .add(forward.scale(-4))  // Behind
                        .add(right.scale(2))     // To the side
                        .add(new BABYLON.Vector3(0, 3.5, 0));  // Above
                    // Look at target's front
                    lookAt = targetPos.add(forward.scale(5)).add(new BABYLON.Vector3(0, 2.5, 0));
                    break;

                case 'sweep':
                    // Panoramic sweep across the battlefield
                    state.sweepPhase += dt * 0.15;
                    const sweepAngle = state.sweepPhase * Math.PI * 2;
                    const sweepRadius = 18 + Math.sin(state.sweepPhase * 2) * 5;
                    const sweepHeight = 8 + Math.sin(state.sweepPhase * 3) * 4;
                    cameraPos = new BABYLON.Vector3(
                        Math.cos(sweepAngle) * sweepRadius,
                        sweepHeight,
                        Math.sin(sweepAngle) * sweepRadius * 0.5
                    );
                    // Look at battle center or nearest mech
                    lookAt = new BABYLON.Vector3(0, 3, 0);
                    break;

                case 'action':
                    // Low dramatic angle looking up at target
                    const actionForward = state.target.pelvis.getDirection(BABYLON.Vector3.Forward());
                    const actionRight = state.target.pelvis.getDirection(BABYLON.Vector3.Right());
                    const actionSide = Math.sin(state.transitionTime * 2) > 0 ? 1 : -1;
                    cameraPos = targetPos
                        .add(actionForward.scale(3))
                        .add(actionRight.scale(3 * actionSide))
                        .add(new BABYLON.Vector3(0, 1.5, 0));  // Low angle
                    lookAt = targetPos.add(new BABYLON.Vector3(0, 3.5, 0));  // Look up at torso
                    break;
            }

            // Smooth camera movement
            const smoothFactor = 1 - Math.pow(0.1, dt);
            camera.position = BABYLON.Vector3.Lerp(camera.position, cameraPos, smoothFactor);

            // Update camera target using setTarget for smooth look
            const currentTarget = camera.target;
            camera.setTarget(BABYLON.Vector3.Lerp(currentTarget, lookAt, smoothFactor));
        }

        function checkBattleEnd() {
            if (battleEnded) return;  // Already ended
            if (!autoFireEnabled) return;

            // Check if either team is eliminated
            const alivePlayerMechs = getAliveMechs('player');
            const aliveEnemyMechs = getAliveMechs('enemy');

            if (alivePlayerMechs.length === 0 || aliveEnemyMechs.length === 0) {
                battleEnded = true;  // Mark as ended (AI already disabled in triggerDestruction)

                const playerWon = alivePlayerMechs.length > 0;
                const winner = playerWon ? 'PLAYER TEAM' : 'ENEMY TEAM';
                log(`Battle ended! ${winner} WINS!`, 'warn');

                // Delay UI update to allow destruction animation to play
                setTimeout(() => {
                    autoFireEnabled = false;
                    const btn = document.getElementById('autoFireBtn');
                    btn.textContent = 'AI Battle: OFF';
                    btn.style.background = 'rgba(255, 200, 0, 0.3)';
                    btn.style.borderColor = '#ffcc00';
                    btn.style.color = '#ffcc00';

                    // Show victory/defeat overlay
                    showBattleResult(playerWon);
                }, 3000);  // 3 second delay to watch destruction
            }
        }

        function showBattleResult(playerWon) {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.id = 'battleResultOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0, 0, 0, 0.85);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 1000;
            `;

            const resultText = playerWon ? 'VICTORY!' : 'DEFEAT';
            const resultColor = playerWon ? '#00ff88' : '#ff4444';

            overlay.innerHTML = `
                <div style="font-size: 72px; font-weight: bold; color: ${resultColor}; text-shadow: 0 0 30px ${resultColor}; margin-bottom: 30px;">
                    ${resultText}
                </div>
                <div style="font-size: 24px; color: #aaa; margin-bottom: 50px;">
                    ${playerWon ? 'All enemy mechs destroyed!' : 'Your mech was destroyed!'}
                </div>
                <button id="continueToSalvageBtn" style="
                    padding: 15px 40px;
                    font-size: 20px;
                    background: rgba(0, 255, 136, 0.2);
                    border: 2px solid #00ff88;
                    color: #00ff88;
                    cursor: pointer;
                    border-radius: 8px;
                    font-family: monospace;
                ">Continue to Salvage â†’</button>
            `;

            document.body.appendChild(overlay);

            // Handle continue button
            document.getElementById('continueToSalvageBtn').addEventListener('click', () => {
                // Generate salvage rewards
                const rewards = generateSalvageRewards(playerWon);

                // Send to parent with rewards
                if (window.parent !== window) {
                    window.parent.postMessage({
                        type: 'battleEnd',
                        result: playerWon ? 'victory' : 'defeat',
                        rewards: rewards
                    }, '*');
                } else {
                    // Standalone mode
                    localStorage.setItem('battleRewards', JSON.stringify(rewards));
                    window.location.href = 'index.html';
                }
            });
        }

        function generateSalvageRewards(playerWon) {
            const rewards = {
                xp: 0,
                scrap: 0,
                components: []
            };

            if (playerWon) {
                // Victory rewards
                rewards.xp = 50 + Math.floor(Math.random() * 50);  // 50-100 XP
                rewards.scrap = 100 + Math.floor(Math.random() * 150);  // 100-250 scrap

                // 30% chance for a component
                if (Math.random() < 0.3) {
                    const componentIds = ['railgun_mk1', 'laser_array', 'armor_plate', 'reactor_core', 'targeting_computer', 'heat_sink'];
                    const randomComponent = componentIds[Math.floor(Math.random() * componentIds.length)];
                    rewards.components.push(randomComponent);
                }
            } else {
                // Defeat rewards (consolation)
                rewards.xp = 10 + Math.floor(Math.random() * 20);  // 10-30 XP
                rewards.scrap = 25 + Math.floor(Math.random() * 50);  // 25-75 scrap
            }

            return rewards;
        }

        function updateUI() {
            // Triangle count
            const triCount = document.getElementById('triCount');
            if (triCount && scene) {
                triCount.textContent = scene.getActiveIndices() / 3 | 0;
            }

            // Calculate team HP totals
            let playerTotalHP = 0, playerMaxHP = 0, playerAlive = 0;
            let enemyTotalHP = 0, enemyMaxHP = 0, enemyAlive = 0;

            playerMechs.forEach(mech => {
                if (!mech) return;
                playerMaxHP += mech.maxHP;
                playerTotalHP += Math.max(0, mech.currentHP);
                if (mech.currentHP > 0 && !mech.isDestroyed) playerAlive++;
            });

            enemyMechs.forEach(mech => {
                if (!mech) return;
                enemyMaxHP += mech.maxHP;
                enemyTotalHP += Math.max(0, mech.currentHP);
                if (mech.currentHP > 0 && !mech.isDestroyed) enemyAlive++;
            });

            // Player team status
            if (playerMaxHP > 0) {
                document.getElementById('playerHP').style.width = (playerTotalHP / playerMaxHP * 100) + '%';
                document.getElementById('playerHPText').textContent = `Team HP: ${playerTotalHP}/${playerMaxHP} (${playerAlive} alive)`;

                let stateText = playerAlive === 0 ? 'ELIMINATED' : `${playerAlive} mechs fighting`;
                document.getElementById('playerState').textContent = stateText;
            }

            // Enemy team status
            if (enemyMaxHP > 0) {
                document.getElementById('enemyHP').style.width = (enemyTotalHP / enemyMaxHP * 100) + '%';
                document.getElementById('enemyHPText').textContent = `Team HP: ${enemyTotalHP}/${enemyMaxHP} (${enemyAlive} alive)`;

                let stateText = enemyAlive === 0 ? 'ELIMINATED' : `${enemyAlive} mechs fighting`;
                document.getElementById('enemyState').textContent = stateText;
            }
        }

        // ============================================
        // USER PILOTING MODE SYSTEM
        // ============================================
        function initPilotingMode() {
            if (!userPilotingMode) return;

            pilotingModeActive = true;
            log('User piloting mode ENABLED - cockpit view active');

            // Reset aim state
            pilotingState.targetYaw = 0;
            pilotingState.targetPitch = -0.1;  // Aim down slightly by default
            pilotingState.currentYaw = 0;
            pilotingState.currentPitch = -0.1;

            // Show cockpit HUD elements
            document.getElementById('cockpitCrosshair').classList.add('active');
            document.getElementById('cockpitFrame').classList.add('active');
            document.getElementById('pilotingInstruction').classList.add('active');

            // Hide the instruction after 5 seconds
            setTimeout(() => {
                document.getElementById('pilotingInstruction').classList.remove('active');
            }, 5000);

            // Detach regular camera controls
            camera.detachControl();

            // Disable depth of field for clearer cockpit view
            if (scene.miniaturePipeline) {
                scene.miniaturePipeline.depthOfFieldEnabled = false;
            }

            // Disable cinematic mode if it was enabled
            if (cinematicEnabled) {
                toggleCinematicCamera();
            }

            // Initialize weapon cooldowns for player mech
            if (playerMechs.length > 0 && playerMechs[0].loadoutWeapons) {
                playerMechs[0].loadoutWeapons.forEach(wpn => {
                    pilotingState.weaponCooldowns[wpn.itemId] = 0;
                });
            }

            // Set up mouse/touch event handlers for aim and fire
            const canvas = document.getElementById('renderCanvas');

            // Click to fire at crosshair (center of screen)
            canvas.addEventListener('click', handlePilotingClick);

            // Mouse move to aim torso (no click required)
            canvas.addEventListener('mousemove', handlePilotingMouseMove);

            // Touch handlers - tap to fire, drag to aim
            canvas.addEventListener('touchstart', handlePilotingTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handlePilotingTouchMove, { passive: false });
            canvas.addEventListener('touchend', handlePilotingTouchEnd, { passive: false });

            // Set up zoom controls (mouse wheel)
            canvas.addEventListener('wheel', handlePilotingZoom, { passive: false });

            // Initial weapon indicator render
            renderWeaponIndicators();
        }

        function handlePilotingZoom(event) {
            if (!pilotingModeActive) return;
            event.preventDefault();

            const zoomSpeed = 0.001;
            pilotingState.zoomLevel -= event.deltaY * zoomSpeed;
            pilotingState.zoomLevel = Math.max(pilotingState.minZoom, Math.min(pilotingState.maxZoom, pilotingState.zoomLevel));
        }

        // Click handler for firing weapons at crosshair (center of screen)
        function handlePilotingClick(event) {
            if (!pilotingModeActive || battleEnded || minigameState.active) return;

            const now = performance.now();
            if (now - pilotingState.lastClickTime < pilotingState.clickCooldown) return;
            pilotingState.lastClickTime = now;

            // Fire weapons at screen center (where crosshair is)
            const canvas = document.getElementById('renderCanvas');
            const rect = canvas.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            firePlayerWeaponsAtScreenPosition(centerX, centerY);
            showFireEffect(centerX, centerY);
        }

        // Mouse move handler - torso follows mouse position
        function handlePilotingMouseMove(event) {
            if (!pilotingModeActive) return;

            const canvas = document.getElementById('renderCanvas');
            const rect = canvas.getBoundingClientRect();

            // Calculate mouse position relative to canvas center (-1 to 1 range)
            const relX = ((event.clientX - rect.left) / rect.width - 0.5) * 2;
            const relY = ((event.clientY - rect.top) / rect.height - 0.5) * 2;

            // Convert to target angles (yaw and pitch)
            // Horizontal: mouse right = torso turns right (positive yaw)
            pilotingState.targetYaw = relX * pilotingState.maxYaw;
            // Vertical: mouse up = look up (positive pitch)
            pilotingState.targetPitch = -relY * pilotingState.maxPitch;
        }

        // Touch handlers
        let lastPinchDistance = 0;
        let lastTouchX = 0;
        let lastTouchY = 0;
        let touchStartTime = 0;

        function handlePilotingTouchStart(event) {
            if (!pilotingModeActive) return;
            event.preventDefault();

            if (event.touches.length === 1) {
                lastTouchX = event.touches[0].clientX;
                lastTouchY = event.touches[0].clientY;
                touchStartTime = performance.now();

                // Update aim to touch position
                updateTouchAim(lastTouchX, lastTouchY);
            }
            lastPinchDistance = 0;
        }

        function handlePilotingTouchMove(event) {
            if (!pilotingModeActive) return;
            event.preventDefault();

            // Two-finger pinch for zoom
            if (event.touches.length === 2) {
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (lastPinchDistance > 0) {
                    const delta = distance - lastPinchDistance;
                    pilotingState.zoomLevel += delta * 0.005;
                    pilotingState.zoomLevel = Math.max(pilotingState.minZoom, Math.min(pilotingState.maxZoom, pilotingState.zoomLevel));
                }
                lastPinchDistance = distance;
                return;
            }

            // Single finger - update aim position
            if (event.touches.length === 1) {
                lastTouchX = event.touches[0].clientX;
                lastTouchY = event.touches[0].clientY;
                updateTouchAim(lastTouchX, lastTouchY);
            }
        }

        function handlePilotingTouchEnd(event) {
            if (!pilotingModeActive) return;
            event.preventDefault();

            // Quick tap fires weapons at crosshair
            const tapDuration = performance.now() - touchStartTime;
            if (tapDuration < 300 && !battleEnded && !minigameState.active) {
                const now = performance.now();
                if (now - pilotingState.lastClickTime >= pilotingState.clickCooldown) {
                    pilotingState.lastClickTime = now;

                    // Fire at center (crosshair)
                    const canvas = document.getElementById('renderCanvas');
                    const rect = canvas.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;

                    firePlayerWeaponsAtScreenPosition(centerX, centerY);
                    showFireEffect(centerX, centerY);
                }
            }

            lastPinchDistance = 0;
        }

        function updateTouchAim(touchX, touchY) {
            const canvas = document.getElementById('renderCanvas');
            const rect = canvas.getBoundingClientRect();

            // Calculate touch position relative to canvas center (-1 to 1 range)
            const relX = ((touchX - rect.left) / rect.width - 0.5) * 2;
            const relY = ((touchY - rect.top) / rect.height - 0.5) * 2;

            // Convert to target angles
            pilotingState.targetYaw = relX * pilotingState.maxYaw;
            pilotingState.targetPitch = -relY * pilotingState.maxPitch;
        }

        function showFireEffect(x, y) {
            const effect = document.createElement('div');
            effect.className = 'fire-effect';
            effect.style.left = x + 'px';
            effect.style.top = y + 'px';
            document.body.appendChild(effect);

            setTimeout(() => effect.remove(), 400);
        }

        function firePlayerWeaponsAtScreenPosition(screenX, screenY) {
            const playerMech = playerMechs.find(m => m && !m.isDestroyed);
            if (!playerMech || !playerMech.loadoutWeapons) return;

            // Convert client coordinates to canvas-relative coordinates
            const canvas = document.getElementById('renderCanvas');
            const rect = canvas.getBoundingClientRect();
            const canvasX = screenX - rect.left;
            const canvasY = screenY - rect.top;

            // Convert canvas position to world position using raycasting
            const pickResult = scene.pick(canvasX, canvasY);
            let targetPosition;

            if (pickResult.hit) {
                targetPosition = pickResult.pickedPoint;
            } else {
                // If no hit, create a target position in the direction of the click
                const ray = scene.createPickingRay(canvasX, canvasY, BABYLON.Matrix.Identity(), camera);
                targetPosition = ray.origin.add(ray.direction.scale(20));
            }

            // Fire all ready weapons at the target position
            const now = performance.now();
            let firedAny = false;

            playerMech.loadoutWeapons.forEach(wpn => {
                const wpnKey = wpn.itemId;
                const cooldown = pilotingState.weaponCooldowns[wpnKey] || 0;

                if (now >= cooldown) {
                    // Fire this weapon at the target position
                    fireWeaponAtPosition(playerMech, wpn, targetPosition);

                    // Set cooldown
                    const weaponCooldown = (wpn.battle && wpn.battle.cooldown) || 2000;
                    pilotingState.weaponCooldowns[wpnKey] = now + weaponCooldown;
                    firedAny = true;
                }
            });

            if (firedAny) {
                updateWeaponIndicators();
            }
        }

        function fireWeaponAtPosition(mech, loadoutWeapon, targetPos) {
            try {
                const from = mech;
                if (!from || from.isDestroyed) return;

                const wpnName = loadoutWeapon.name || loadoutWeapon.itemId;
                const battleProps = loadoutWeapon.battle || {};
                const baseDamage = loadoutWeapon.damage || 10;

                log(`[PILOT FIRE] ${from.name} fires ${wpnName} at target position`);

                // Build weapon object from loadout data
                const weapon = {
                    name: wpnName,
                    damage: baseDamage,
                    knockback: battleProps.knockback || 15,
                    recoil: battleProps.recoil || 0.15,
                    projectileSpeed: battleProps.projectileSpeed || 40,
                    projectileSize: battleProps.projectileSize || 0.12,
                    isBeam: battleProps.isBeam || false,
                    isCluster: battleProps.isCluster || false,
                    isProjectile: battleProps.isProjectile || (!battleProps.isBeam && !battleProps.isCluster),
                    beamDuration: battleProps.beamDuration || 180,
                    clusterCount: battleProps.clusterCount || 6,
                    color: battleProps.color ? new BABYLON.Color3(battleProps.color[0], battleProps.color[1], battleProps.color[2]) : new BABYLON.Color3(1, 0.8, 0.2)
                };

                from.recoilRecovery = weapon.recoil;
                from.lastFiredArm = from.lastFiredArm === 'left' ? 'right' : 'left';

                // Get arm for firing
                const arm = from.lastFiredArm === 'left' ? from.leftArm : from.rightArm;
                if (!arm || !arm.weaponPod) return;

                const firePoint = arm.weaponPod.getAbsolutePosition();

                // Apply recoil
                const toTarget = targetPos.subtract(firePoint).normalize();
                if (from.pelvisAggregate && from.pelvisAggregate.body) {
                    from.pelvisAggregate.body.applyImpulse(
                        toTarget.scale(-weapon.knockback * 0.25),
                        from.pelvis.getAbsolutePosition()
                    );
                }

                // Fire based on weapon type
                if (weapon.isBeam) {
                    fireBeamAtPosition(from, targetPos, weapon);
                } else if (weapon.isCluster) {
                    fireClusterAtPosition(from, targetPos, weapon);
                } else {
                    fireProjectileAtPosition(from, targetPos, weapon);
                }

                triggerCinematicAction(from, 'fire');
            } catch (e) {
                log(`[PILOT FIRE ERROR] ${e.message}`, 'error');
                console.error('fireWeaponAtPosition error:', e);
            }
        }

        function fireProjectileAtPosition(from, targetPos, weapon) {
            const arm = from.lastFiredArm === 'left' ? from.leftArm : from.rightArm;
            if (!arm || !arm.weaponPod) return;

            const firePoint = arm.weaponPod.getAbsolutePosition();
            const direction = targetPos.subtract(firePoint).normalize();

            // Add slight spread
            const spread = 0.02;
            direction.x += (Math.random() - 0.5) * spread;
            direction.y += (Math.random() - 0.5) * spread;
            direction.z += (Math.random() - 0.5) * spread;
            direction.normalize();

            // Create projectile
            const projectile = BABYLON.MeshBuilder.CreateSphere('proj', {
                diameter: weapon.projectileSize * 2
            }, scene);
            projectile.position = firePoint.clone();

            const mat = new BABYLON.StandardMaterial('projMat', scene);
            mat.emissiveColor = weapon.color || new BABYLON.Color3(1, 0.8, 0.2);
            mat.disableLighting = true;
            projectile.material = mat;

            projectiles.push({
                mesh: projectile,
                velocity: direction.scale(weapon.projectileSpeed),
                owner: from,
                weapon: weapon,
                targetPosition: targetPos,
                spawnTime: performance.now(),
                timeout: 3500
            });
        }

        function fireBeamAtPosition(from, targetPos, weapon) {
            const arm = from.lastFiredArm === 'left' ? from.leftArm : from.rightArm;
            if (!arm || !arm.weaponPod) return;

            const firePoint = arm.weaponPod.getAbsolutePosition();

            // Find enemies along the beam path and apply damage
            const enemies = allMechs.filter(m => m && !m.isDestroyed && m !== from && m.isPlayer !== from.isPlayer);
            let hitEnemy = null;
            let hitDistance = Infinity;
            let hitPoint = targetPos;

            for (const enemy of enemies) {
                if (!enemy.torso) continue;
                const enemyPos = enemy.torso.getAbsolutePosition();

                // Check if enemy is near the beam line
                const beamDir = targetPos.subtract(firePoint).normalize();
                const toEnemy = enemyPos.subtract(firePoint);
                const projLength = BABYLON.Vector3.Dot(toEnemy, beamDir);

                if (projLength > 0) {
                    const closestPoint = firePoint.add(beamDir.scale(projLength));
                    const distToBeam = BABYLON.Vector3.Distance(enemyPos, closestPoint);

                    if (distToBeam < 2.5 && projLength < hitDistance) {  // Hit radius
                        hitEnemy = enemy;
                        hitDistance = projLength;
                        hitPoint = closestPoint;
                    }
                }
            }

            // Use hit point as beam endpoint if we hit an enemy
            const beamEnd = hitEnemy ? hitPoint : targetPos;
            const distance = BABYLON.Vector3.Distance(firePoint, beamEnd);

            // Create main beam core using tube for better visuals
            const beam = BABYLON.MeshBuilder.CreateTube('beam' + Date.now(), {
                path: [firePoint, beamEnd], radius: 0.08, updatable: false
            }, scene);
            const mat = new BABYLON.StandardMaterial('beamMat' + Date.now(), scene);
            mat.emissiveColor = weapon.color || new BABYLON.Color3(0, 1, 0.5);
            mat.alpha = 0.95;
            mat.disableLighting = true;
            beam.material = mat;

            // Create outer glow
            const beamGlow = BABYLON.MeshBuilder.CreateTube('beamGlow' + Date.now(), {
                path: [firePoint, beamEnd], radius: 0.2, updatable: false
            }, scene);
            const glowMat = new BABYLON.StandardMaterial('beamGlowMat' + Date.now(), scene);
            glowMat.emissiveColor = weapon.color || new BABYLON.Color3(0, 1, 0.5);
            glowMat.alpha = 0.25;
            glowMat.disableLighting = true;
            beamGlow.material = glowMat;

            beams.push({
                mesh: beam, material: mat,
                glow: beamGlow, glowMat: glowMat,
                createdAt: Date.now(), duration: weapon.beamDuration || 180
            });

            // Apply damage if we hit an enemy
            if (hitEnemy) {
                applyDamage(hitEnemy, weapon, from.isPlayer ? 1 : -1);
                log(`[PILOT BEAM HIT] ${hitEnemy.name} -${weapon.damage} (${hitEnemy.currentHP}/${hitEnemy.maxHP})`, 'warn');
                createImpact(hitPoint.clone(), weapon.color || new BABYLON.Color3(0, 1, 0.5));
            }
        }

        function fireClusterAtPosition(from, targetPos, weapon) {
            const arm = from.lastFiredArm === 'left' ? from.leftArm : from.rightArm;
            if (!arm || !arm.weaponPod) return;

            const firePoint = arm.weaponPod.getAbsolutePosition();
            const clusterCount = weapon.clusterCount || 6;

            for (let i = 0; i < clusterCount; i++) {
                setTimeout(() => {
                    if (from.isDestroyed) return;

                    // Add spread to target position
                    const spreadTarget = targetPos.clone();
                    spreadTarget.x += (Math.random() - 0.5) * 2;
                    spreadTarget.y += (Math.random() - 0.5) * 1;
                    spreadTarget.z += (Math.random() - 0.5) * 2;

                    const direction = spreadTarget.subtract(firePoint).normalize();

                    const missile = BABYLON.MeshBuilder.CreateCylinder('missile', {
                        height: 0.4,
                        diameter: 0.1,
                        tessellation: 6
                    }, scene);
                    missile.position = firePoint.clone();
                    missile.rotationQuaternion = BABYLON.Quaternion.FromUnitVectorsToRef(
                        BABYLON.Vector3.Up(),
                        direction,
                        new BABYLON.Quaternion()
                    );

                    const mat = new BABYLON.StandardMaterial('missileMat', scene);
                    mat.emissiveColor = weapon.color || new BABYLON.Color3(1, 0.4, 0.1);
                    mat.disableLighting = true;
                    missile.material = mat;

                    projectiles.push({
                        mesh: missile,
                        velocity: direction.scale(weapon.projectileSpeed * 0.8),
                        owner: from,
                        weapon: { ...weapon, damage: Math.ceil(weapon.damage / clusterCount) },
                        targetPosition: spreadTarget,
                        spawnTime: performance.now(),
                        timeout: 4000,
                        isMissile: true
                    });
                }, i * 50);  // Stagger missile launches
            }
        }

        function renderWeaponIndicators() {
            const container = document.getElementById('weaponIndicators');
            if (!container) return;

            const playerMech = playerMechs.find(m => m && !m.isDestroyed);
            if (!playerMech || !playerMech.loadoutWeapons) {
                container.innerHTML = '<div style="color: #888;">No weapons available</div>';
                return;
            }

            container.innerHTML = '';

            playerMech.loadoutWeapons.forEach(wpn => {
                const indicator = document.createElement('div');
                indicator.className = 'weapon-indicator';
                indicator.dataset.weaponId = wpn.itemId;

                const damage = wpn.damage || 10;
                const shotsPerRound = (wpn.battle && wpn.battle.shotsPerRound) || 1;
                const damageText = shotsPerRound > 1 ? `${damage}x${shotsPerRound}` : damage;

                indicator.innerHTML = `
                    <div class="weapon-indicator-name">${wpn.name || wpn.itemId}</div>
                    <div class="weapon-damage">${damageText}</div>
                    <div class="weapon-cooldown-bar">
                        <div class="weapon-cooldown-fill" style="width: 100%"></div>
                    </div>
                `;

                container.appendChild(indicator);
            });

            updateWeaponIndicators();
        }

        function updateWeaponIndicators() {
            if (!pilotingModeActive) return;

            const now = performance.now();
            const playerMech = playerMechs.find(m => m && !m.isDestroyed);
            if (!playerMech || !playerMech.loadoutWeapons) return;

            // Calculate heat based on weapons on cooldown
            let totalCooldownPercent = 0;
            let weaponCount = 0;

            playerMech.loadoutWeapons.forEach(wpn => {
                const indicator = document.querySelector(`.weapon-indicator[data-weapon-id="${wpn.itemId}"]`);
                if (!indicator) return;

                const cooldown = pilotingState.weaponCooldowns[wpn.itemId] || 0;
                const weaponCooldownTime = (wpn.battle && wpn.battle.cooldown) || 2000;
                const remaining = Math.max(0, cooldown - now);
                const progress = remaining > 0 ? (1 - remaining / weaponCooldownTime) * 100 : 100;

                // Track heat
                totalCooldownPercent += (100 - progress);
                weaponCount++;

                const fill = indicator.querySelector('.weapon-cooldown-fill');
                if (fill) {
                    fill.style.width = progress + '%';
                }

                if (remaining <= 0) {
                    indicator.classList.add('ready');
                    indicator.classList.remove('charging');
                } else {
                    indicator.classList.remove('ready');
                    indicator.classList.add('charging');
                }
            });

            // Update cockpit displays
            const heatDisplay = document.getElementById('cockpitHeat');
            const zoomDisplay = document.getElementById('cockpitZoom');

            if (heatDisplay && weaponCount > 0) {
                const avgHeat = Math.round(totalCooldownPercent / weaponCount);
                heatDisplay.textContent = avgHeat + '%';
                heatDisplay.style.color = avgHeat > 70 ? '#ff4444' : avgHeat > 40 ? '#ffaa00' : '#00ff88';
            }

            if (zoomDisplay) {
                zoomDisplay.textContent = pilotingState.zoomLevel.toFixed(1) + 'x';
            }

            // Update HP bar
            const hpFill = document.getElementById('cockpitHpFill');
            if (hpFill && playerMech) {
                const hpPercent = (playerMech.currentHP / playerMech.maxHP) * 100;
                hpFill.style.width = hpPercent + '%';

                // Change color based on HP level
                if (hpPercent < 25) {
                    hpFill.style.background = '#ff4444';
                    hpFill.style.boxShadow = '0 0 8px #ff4444';
                } else if (hpPercent < 50) {
                    hpFill.style.background = 'linear-gradient(90deg, #ff4444 0%, #ffaa00 100%)';
                    hpFill.style.boxShadow = '0 0 5px #ffaa00';
                } else {
                    hpFill.style.background = 'linear-gradient(90deg, #ffaa00 0%, #00ff66 100%)';
                    hpFill.style.boxShadow = '0 0 5px #00ff66';
                }

                // Make warning button blink when HP is low
                const warnBtn = document.getElementById('warnBtn1');
                if (warnBtn) {
                    if (hpPercent < 30) {
                        warnBtn.classList.add('lit', 'warning-blink');
                    } else {
                        warnBtn.classList.remove('warning-blink');
                    }
                }

                // Update damage indicator light
                const damageIndicator = document.getElementById('damageIndicator');
                if (damageIndicator) {
                    if (hpPercent < 30) {
                        damageIndicator.className = 'indicator-light indicator-red';
                    } else if (hpPercent < 70) {
                        damageIndicator.className = 'indicator-light indicator-amber';
                    } else {
                        damageIndicator.className = 'indicator-light indicator-green';
                    }
                }
            }

            // Update warning lights based on mech status
            const warningArmor = document.getElementById('warningArmor');
            if (warningArmor && playerMech) {
                const hpPercent = playerMech.currentHP / playerMech.maxHP;
                if (hpPercent < 0.3) {
                    warningArmor.classList.add('warning-active');
                } else {
                    warningArmor.classList.remove('warning-active');
                }
            }

            // Update throttle positions based on movement
            const throttleLeft = document.getElementById('throttleLeft');
            const throttleRight = document.getElementById('throttleRight');
            if (throttleLeft && throttleRight && playerMech) {
                const walkDir = playerMech.walkDirection || 0;
                const strafe = playerMech.ai ? playerMech.ai.strafeAmount || 0 : 0;

                // Throttle position based on movement (20% to 80% range)
                const leftPos = 30 + (walkDir + strafe) * 25;
                const rightPos = 30 + (walkDir - strafe) * 25;

                throttleLeft.style.bottom = Math.max(10, Math.min(70, leftPos)) + '%';
                throttleRight.style.bottom = Math.max(10, Math.min(70, rightPos)) + '%';
            }

            // Update radar displays with enemy position
            const radarEnemy = document.getElementById('radarEnemy');
            const radarEnemyMain = document.getElementById('radarEnemyMain');

            if ((radarEnemy || radarEnemyMain) && playerMech && playerMech.torso) {
                // Find nearest enemy
                const enemies = allMechs.filter(m => m && !m.isDestroyed && !m.isPlayer);
                const nearestEnemy = enemies[0];

                if (nearestEnemy && nearestEnemy.torso) {
                    const playerPos = playerMech.torso.getAbsolutePosition();
                    const enemyPos = nearestEnemy.torso.getAbsolutePosition();

                    // Calculate relative position
                    const dx = enemyPos.x - playerPos.x;
                    const dz = enemyPos.z - playerPos.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    // Normalize and scale to radar (clamp to radar bounds)
                    const maxDist = 80; // Max distance for radar
                    const scale = Math.min(dist / maxDist, 1);
                    const angle = Math.atan2(dx, dz);

                    // Convert to radar coordinates (50% is center)
                    const radarX = 50 + Math.sin(angle) * scale * 40;
                    const radarY = 50 - Math.cos(angle) * scale * 40;

                    if (radarEnemy) {
                        radarEnemy.style.left = radarX + '%';
                        radarEnemy.style.top = radarY + '%';
                    }
                    if (radarEnemyMain) {
                        radarEnemyMain.style.left = radarX + '%';
                        radarEnemyMain.style.top = radarY + '%';
                    }
                }
            }
        }

        function updateCockpitCamera(dt) {
            if (!pilotingModeActive) return;

            const playerMech = playerMechs.find(m => m && !m.isDestroyed);
            if (!playerMech) {
                // Player mech destroyed - switch to spectate mode
                pilotingModeActive = false;
                document.getElementById('cockpitCrosshair').classList.remove('active');
                document.getElementById('cockpitFrame').classList.remove('active');

                // Re-enable DOF
                if (scene.miniaturePipeline) {
                    scene.miniaturePipeline.depthOfFieldEnabled = true;
                }

                camera.attachControl(document.getElementById('renderCanvas'), true);
                return;
            }

            // =============================================
            // PHYSICS LAG: Smooth torso movement toward target
            // =============================================
            // Lerp current angles toward target with physics-like lag
            const aimLerp = 1 - Math.pow(0.1, dt * pilotingState.aimSpeed);
            pilotingState.currentYaw = BABYLON.Scalar.Lerp(pilotingState.currentYaw, pilotingState.targetYaw, aimLerp);
            pilotingState.currentPitch = BABYLON.Scalar.Lerp(pilotingState.currentPitch, pilotingState.targetPitch, aimLerp);

            // =============================================
            // TORSO ROTATION: Apply aim to mech torso
            // =============================================
            if (playerMech.torso) {
                // Set torso yaw (horizontal rotation)
                // This overrides the AI torso control for the player mech
                playerMech.torsoTwist = pilotingState.currentYaw;
                playerMech.targetTorsoTwist = pilotingState.currentYaw;
                playerMech.torso.rotation.y = pilotingState.currentYaw;

                // Head follows torso more
                if (playerMech.head) {
                    playerMech.head.rotation.y = pilotingState.currentYaw * 1.1;
                }
            }

            // =============================================
            // CAMERA: Follow torso direction from cockpit
            // =============================================
            const cockpit = playerMech.cockpit || playerMech.head || playerMech.torso;
            if (!cockpit) return;

            // Get cockpit world position
            const cockpitPos = cockpit.getAbsolutePosition();

            // Get mech pelvis forward direction (base orientation)
            const pelvisQuat = playerMech.pelvis.rotationQuaternion;
            let pelvisYaw = 0;
            if (pelvisQuat) {
                const euler = pelvisQuat.toEulerAngles();
                pelvisYaw = euler.y;
            }

            // Calculate camera position - inside cockpit
            const cameraHeight = -0.2;
            const cameraForward = 0.6;

            // Get forward direction from pelvis
            const pelvisForward = new BABYLON.Vector3(
                Math.sin(pelvisYaw),
                0,
                Math.cos(pelvisYaw)
            );

            const cameraPos = cockpitPos.add(new BABYLON.Vector3(0, cameraHeight, 0));
            cameraPos.addInPlace(pelvisForward.scale(cameraForward));

            // Apply zoom via FOV
            const baseFOV = 0.9;
            const targetFOV = baseFOV / pilotingState.zoomLevel;
            camera.fov = camera.fov + (targetFOV - camera.fov) * 0.1;

            // =============================================
            // LOOK DIRECTION: Based on torso aim (with lag)
            // =============================================
            // World yaw = pelvis yaw + torso twist (currentYaw includes the lag)
            const worldYaw = pelvisYaw + pilotingState.currentYaw;

            // Calculate look direction with yaw and pitch
            const lookDistance = 20;
            const pitchCos = Math.cos(pilotingState.currentPitch);
            const pitchSin = Math.sin(pilotingState.currentPitch);

            const lookOffset = new BABYLON.Vector3(
                Math.sin(worldYaw) * pitchCos * lookDistance,
                pitchSin * lookDistance,
                Math.cos(worldYaw) * pitchCos * lookDistance
            );

            const lookAt = cameraPos.add(lookOffset);

            // Smooth camera movement
            const smoothFactor = 1 - Math.pow(0.02, dt);
            camera.position = BABYLON.Vector3.Lerp(camera.position, cameraPos, smoothFactor);
            camera.setTarget(BABYLON.Vector3.Lerp(camera.target, lookAt, smoothFactor * 0.9));

            // Update weapon indicators periodically
            updateWeaponIndicators();
        }

        initEngine();
    </script>
</body>
</html>
