<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BattleTech Arena - AI Combat</title>
    <style>
        body {
            margin: 0;
            padding: 15px;
            background: #1a1a2e;
            font-family: monospace;
            color: #00ff88;
            overflow-x: hidden;
        }
        #renderCanvas {
            width: 100%;
            max-width: 1000px;
            height: 55vh;
            max-height: 450px;
            display: block;
            margin: 0 auto;
            border: 3px solid #00ff88;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            touch-action: none;
        }
        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin: 8px 0;
            font-size: 1.3em;
        }
        #status {
            max-width: 1000px;
            margin: 10px auto;
            padding: 8px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #00ff88;
            border-radius: 8px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        #logs {
            flex: 1;
            min-width: 200px;
            max-height: 100px;
            overflow-y: auto;
            font-size: 10px;
        }
        #mechStatus {
            flex: 1;
            min-width: 280px;
            display: flex;
            gap: 10px;
        }
        .mech-info {
            flex: 1;
            padding: 5px;
            border: 1px solid #00ff88;
            border-radius: 4px;
            font-size: 11px;
        }
        .mech-info.enemy { border-color: #ff4444; }
        .log { margin: 1px 0; padding: 1px 3px; }
        .log.info { color: #00ff88; }
        .log.warn { color: #ffaa00; }
        .log.error { color: #ff4444; }
        #controls {
            text-align: center;
            margin: 8px 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 4px;
        }
        button {
            padding: 6px 12px;
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            border-radius: 5px;
            font-family: monospace;
            font-size: 11px;
        }
        button:hover, button:active {
            background: rgba(0, 255, 136, 0.4);
        }
        button.red {
            border-color: #ff4444;
            color: #ff4444;
            background: rgba(255, 68, 68, 0.2);
        }
        .hp-bar {
            height: 10px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin: 2px 0;
        }
        .hp-fill {
            height: 100%;
            transition: width 0.3s;
        }
        .hp-fill.player { background: linear-gradient(90deg, #00aa55, #00ff88); }
        .hp-fill.enemy { background: linear-gradient(90deg, #aa2222, #ff4444); }
        #polyCount {
            text-align: center;
            font-size: 10px;
            color: #888;
            margin-top: 5px;
        }
        #debugPanel {
            max-width: 1000px;
            margin: 10px auto;
            padding: 8px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #ff8800;
            border-radius: 8px;
            font-size: 10px;
        }
        #debugPanel .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        #debugPanel .title { color: #ff8800; font-weight: bold; }
        #debugLogs {
            max-height: 150px;
            overflow-y: auto;
            font-family: monospace;
            white-space: pre;
            color: #aaa;
            line-height: 1.3;
        }
        #debugLogs .dbg-ai { color: #88ff88; }
        #debugLogs .dbg-phys { color: #88ffff; }
        #debugLogs .dbg-err { color: #ff4444; }
        #debugLogs .dbg-warn { color: #ffaa00; }
        .copy-btn {
            padding: 3px 8px;
            font-size: 10px;
            background: rgba(255, 136, 0, 0.3);
            border: 1px solid #ff8800;
            color: #ff8800;
            cursor: pointer;
            border-radius: 3px;
        }
        .copy-btn:hover { background: rgba(255, 136, 0, 0.5); }
    </style>
</head>
<body>
    <h1>BattleTech Arena <span id="version" style="font-size: 0.6em; color: #888;">v9.3</span></h1>
    <div id="controls">
        <button id="autoFireBtn" onclick="toggleAutoFire()" style="background: rgba(255, 200, 0, 0.3); border-color: #ffcc00; color: #ffcc00;">AI Battle: OFF</button>
        <button onclick="resetScene()">Reset</button>
    </div>
    <canvas id="renderCanvas"></canvas>
    <div id="polyCount">Triangles: <span id="triCount">0</span></div>
    <div id="status">
        <div id="logs"></div>
        <div id="mechStatus">
            <div class="mech-info player">
                <strong style="color: #00ff88;">TIMBER WOLF (Mad Cat)</strong>
                <div class="hp-bar"><div class="hp-fill player" id="playerHP" style="width: 100%"></div></div>
                <div id="playerHPText">HP: 150/150</div>
                <div id="playerState">Idle</div>
            </div>
            <div class="mech-info enemy">
                <strong style="color: #ff4444;">DIRE WOLF (Daishi)</strong>
                <div class="hp-bar"><div class="hp-fill enemy" id="enemyHP" style="width: 100%"></div></div>
                <div id="enemyHPText">HP: 200/200</div>
                <div id="enemyState">Idle</div>
            </div>
        </div>
    </div>

    <div id="debugPanel">
        <div class="header">
            <span class="title">DIAGNOSTIC LOGS</span>
            <button class="copy-btn" onclick="copyDebugLogs()">Copy Logs</button>
        </div>
        <div id="debugLogs"></div>
    </div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>

    <script>
        // Logging
        const logs = [];
        function log(msg, type = 'info') {
            console.log(msg);
            logs.push({ msg, type });
            const logsDiv = document.getElementById('logs');
            if (logsDiv) {
                logsDiv.innerHTML = logs.slice(-10).map(l =>
                    `<div class="log ${l.type}">${l.msg}</div>`
                ).join('');
            }
        }

        // Debug logging system
        const debugLogs = [];
        let lastDebugTime = 0;
        const DEBUG_INTERVAL = 0.5; // Log every 0.5 seconds to avoid spam

        function dbg(msg, category = '') {
            const ts = gameTime.toFixed(2);
            const entry = `[${ts}] ${msg}`;
            debugLogs.push({ msg: entry, cat: category });
            if (debugLogs.length > 100) debugLogs.shift(); // Keep last 100 entries
            updateDebugPanel();
        }

        function updateDebugPanel() {
            const el = document.getElementById('debugLogs');
            if (el) {
                el.innerHTML = debugLogs.slice(-30).map(l => {
                    const cls = l.cat ? `dbg-${l.cat}` : '';
                    return `<span class="${cls}">${l.msg}</span>`;
                }).join('\n');
                el.scrollTop = el.scrollHeight;
            }
        }

        function copyDebugLogs() {
            const text = debugLogs.map(l => l.msg).join('\n');
            navigator.clipboard.writeText(text).then(() => {
                log('Logs copied to clipboard!', 'info');
            }).catch(err => {
                // Fallback for browsers without clipboard API
                const ta = document.createElement('textarea');
                ta.value = text;
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                document.body.removeChild(ta);
                log('Logs copied!', 'info');
            });
        }

        log('Initializing Mad Cat Physics Test...');

        // Globals
        let engine, scene, camera, havokInstance, havokPlugin;
        let playerMech, enemyMech;
        let projectiles = [];
        let beams = [];
        let gameTime = 0;
        let autoFireEnabled = false;
        let autoFireInterval = null;
        let battleEnded = false;  // Flag to stop AI loops when battle is over

        // Weapon cooldowns for AI
        const weaponCooldowns = {
            player: { erlaser: 0, lrm: 0, ac: 0 },
            enemy: { erlaser: 0, lrm: 0, ac: 0 }
        };
        const COOLDOWN_TIMES = { erlaser: 2000, lrm: 3500, ac: 1500 };

        // AI Configuration
        const AI_CONFIG = {
            idealRange: 10,         // Optimal combat distance
            minRange: 6,            // Too close - back up
            maxRange: 13,           // Too far - close in (slightly less than starting distance)
            edgeBoundary: 16,       // X position to start avoiding edges
            edgeForce: 45,          // Force to push away from edges
            moveForce: 150,         // Normal movement force (increased significantly)
            strafeForce: 60,        // Lateral movement force (increased significantly)
            decisionInterval: 0.2,  // How often AI makes decisions (faster for responsiveness)
            strafeChance: 0.15,     // Chance to start strafing each decision
            strafeDuration: 1.5     // How long to strafe before reconsidering
        };

        // Weapons
        const WEAPONS = {
            erlaser: {
                name: 'ER Large Laser',
                damage: 20,
                knockback: 10,
                recoil: 0.2,
                isBeam: true,
                beamDuration: 180,
                color: new BABYLON.Color3(0.2, 1, 0.3)
            },
            lrm: {
                name: 'LRM-20',
                damage: 25,
                knockback: 15,
                recoil: 0.15,
                projectileSpeed: 20,
                isCluster: true,
                clusterCount: 8,
                color: new BABYLON.Color3(1, 0.5, 0.1)
            },
            ac: {
                name: 'UAC/5',
                damage: 18,
                knockback: 8,
                recoil: 0.12,
                projectileSpeed: 35,
                projectileSize: 0.1,
                color: new BABYLON.Color3(1, 0.9, 0.3)
            }
        };

        // Colors
        const COLORS = {
            playerPrimary: new BABYLON.Color3(0.15, 0.35, 0.2),
            playerSecondary: new BABYLON.Color3(0.25, 0.45, 0.3),
            playerAccent: new BABYLON.Color3(0.7, 0.6, 0.1),
            enemyPrimary: new BABYLON.Color3(0.4, 0.12, 0.12),
            enemySecondary: new BABYLON.Color3(0.5, 0.18, 0.18),
            enemyAccent: new BABYLON.Color3(0.25, 0.25, 0.3),
            metal: new BABYLON.Color3(0.35, 0.35, 0.4),
            darkMetal: new BABYLON.Color3(0.12, 0.12, 0.15),
            chrome: new BABYLON.Color3(0.6, 0.6, 0.65),
            cockpit: new BABYLON.Color3(0.1, 0.9, 0.95),
            thruster: new BABYLON.Color3(1, 0.4, 0.1),
            ground: new BABYLON.Color3(0.22, 0.2, 0.18)
        };

        async function initEngine() {
            const canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

            try {
                havokInstance = await HavokPhysics();
                log('Havok initialized');
            } catch (e) {
                log('Havok failed: ' + e.message, 'error');
                return;
            }

            scene = createScene();

            let lastTime = performance.now();
            engine.runRenderLoop(() => {
                if (scene) {
                    const now = performance.now();
                    const dt = (now - lastTime) / 1000;
                    lastTime = now;
                    gameTime += dt;

                    // Only run game logic if battle hasn't ended
                    if (!battleEnded) {
                        updateMechs(dt);
                        updateProjectiles(dt);
                        updateBeams();
                        checkBattleEnd();
                    }
                    updateUI();
                    scene.render();
                }
            });

            window.addEventListener('resize', () => engine.resize());
            log('Scene ready!');

            // Log initial mech state for debugging
            setTimeout(() => {
                if (playerMech) {
                    const pos = playerMech.pelvis.getAbsolutePosition();
                    const body = playerMech.pelvisAggregate.body;
                    const motionTypes = ['STATIC', 'ANIMATED', 'DYNAMIC'];
                    dbg(`P created: pos=(${pos.x.toFixed(1)},${pos.y.toFixed(1)},${pos.z.toFixed(1)})`, 'ai');
                    dbg(`P body: mass=${body.getMassProperties().mass} motion=${motionTypes[body.motionType] || body.motionType}`, 'phys');
                }
                if (enemyMech) {
                    const pos = enemyMech.pelvis.getAbsolutePosition();
                    const body = enemyMech.pelvisAggregate.body;
                    const motionTypes = ['STATIC', 'ANIMATED', 'DYNAMIC'];
                    dbg(`E created: pos=(${pos.x.toFixed(1)},${pos.y.toFixed(1)},${pos.z.toFixed(1)})`, 'ai');
                    dbg(`E body: mass=${body.getMassProperties().mass} motion=${motionTypes[body.motionType] || body.motionType}`, 'phys');
                }
                dbg('Click "AI Battle: OFF" to start battle', 'warn');
            }, 500);
        }

        function createScene() {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.06, 0.06, 0.1);

            havokPlugin = new BABYLON.HavokPlugin(true, havokInstance);
            scene.enablePhysics(new BABYLON.Vector3(0, -18, 0), havokPlugin);

            // Camera
            camera = new BABYLON.ArcRotateCamera('cam', -Math.PI/2, Math.PI/3.2, 24,
                new BABYLON.Vector3(0, 3, 0), scene);
            camera.attachControl(document.getElementById('renderCanvas'), true);
            camera.lowerRadiusLimit = 10;
            camera.upperRadiusLimit = 50;
            camera.wheelPrecision = 30;

            // Lighting
            const hemi = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0, 1, 0), scene);
            hemi.intensity = 0.5;
            hemi.groundColor = new BABYLON.Color3(0.15, 0.12, 0.1);

            const dir = new BABYLON.DirectionalLight('dir', new BABYLON.Vector3(-1, -2.5, 1), scene);
            dir.intensity = 0.9;
            dir.diffuse = new BABYLON.Color3(1, 0.95, 0.85);

            // Fog
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
            scene.fogDensity = 0.008;
            scene.fogColor = new BABYLON.Color3(0.08, 0.08, 0.12);

            createGround(scene);
            createWalls(scene);

            // Create detailed mechs
            playerMech = createMadCatMech(scene, -7, true);
            enemyMech = createDireWolfMech(scene, 7, false);

            return scene;
        }

        function createGround(scene) {
            const ground = BABYLON.MeshBuilder.CreateGround('ground', { width: 40, height: 20 }, scene);
            const mat = new BABYLON.StandardMaterial('groundMat', scene);
            mat.diffuseColor = COLORS.ground;
            mat.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);
            ground.material = mat;
            new BABYLON.PhysicsAggregate(ground, BABYLON.PhysicsShapeType.BOX,
                { mass: 0, friction: 1.0, restitution: 0.05 }, scene);

            // Terrain details
            for (let i = 0; i < 6; i++) {
                const rock = BABYLON.MeshBuilder.CreateBox('rock' + i, {
                    width: 0.6 + Math.random() * 0.8,
                    height: 0.2 + Math.random() * 0.4,
                    depth: 0.6 + Math.random() * 0.8
                }, scene);
                rock.position = new BABYLON.Vector3((Math.random() - 0.5) * 25, 0.15, (Math.random() - 0.5) * 10);
                rock.rotation.y = Math.random() * Math.PI;
                rock.material = mat;
                new BABYLON.PhysicsAggregate(rock, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);
            }
        }

        function createWalls(scene) {
            // Invisible walls - physics only, no rendering
            const walls = [
                { p: [-20, 5, 0], s: [1, 10, 20] },
                { p: [20, 5, 0], s: [1, 10, 20] },
                { p: [0, 5, 10], s: [40, 10, 1] },
                { p: [0, 5, -10], s: [40, 10, 1] }
            ];
            walls.forEach((w, i) => {
                const wall = BABYLON.MeshBuilder.CreateBox('wall' + i, { width: w.s[0], height: w.s[1], depth: w.s[2] }, scene);
                wall.position = new BABYLON.Vector3(...w.p);
                wall.isVisible = false;  // Invisible but still has physics
                new BABYLON.PhysicsAggregate(wall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);
            });
        }

        // ============================================
        // MAD CAT (Timber Wolf) - Highly Detailed
        // ============================================
        function createMadCatMech(scene, xPos, isPlayer) {
            const name = isPlayer ? 'player' : 'enemy';
            const primary = isPlayer ? COLORS.playerPrimary : COLORS.enemyPrimary;
            const secondary = isPlayer ? COLORS.playerSecondary : COLORS.enemySecondary;
            const accent = isPlayer ? COLORS.playerAccent : COLORS.enemyAccent;

            // Materials
            const primaryMat = new BABYLON.StandardMaterial(name + '_primary', scene);
            primaryMat.diffuseColor = primary;
            primaryMat.specularColor = new BABYLON.Color3(0.15, 0.15, 0.15);

            const secondaryMat = new BABYLON.StandardMaterial(name + '_secondary', scene);
            secondaryMat.diffuseColor = secondary;

            const accentMat = new BABYLON.StandardMaterial(name + '_accent', scene);
            accentMat.diffuseColor = accent;
            accentMat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);

            const metalMat = new BABYLON.StandardMaterial(name + '_metal', scene);
            metalMat.diffuseColor = COLORS.metal;
            metalMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
            metalMat.specularPower = 64;

            const darkMat = new BABYLON.StandardMaterial(name + '_dark', scene);
            darkMat.diffuseColor = COLORS.darkMetal;

            const cockpitMat = new BABYLON.StandardMaterial(name + '_cockpit', scene);
            cockpitMat.diffuseColor = COLORS.cockpit;
            cockpitMat.emissiveColor = COLORS.cockpit.scale(0.6);
            cockpitMat.alpha = 0.8;

            const chromeMat = new BABYLON.StandardMaterial(name + '_chrome', scene);
            chromeMat.diffuseColor = COLORS.chrome;
            chromeMat.specularColor = new BABYLON.Color3(0.8, 0.8, 0.8);
            chromeMat.specularPower = 128;

            // === PELVIS / CENTER (Physics body) ===
            const pelvis = BABYLON.MeshBuilder.CreateBox(name + '_pelvis', {
                width: 1.1, height: 0.5, depth: 0.9
            }, scene);
            pelvis.position = new BABYLON.Vector3(xPos, 3.5, 0);  // Spawn height
            pelvis.material = darkMat;

            // Create a taller collision shape to represent the full mech standing height
            // The visual legs extend ~3 units below pelvis, so we use a tall box offset downward
            const pelvisShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -1.5, 0),  // Center offset (shift down to cover legs)
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(1.1, 3.5, 0.9),  // Full standing height
                scene
            );
            const pelvisBody = new BABYLON.PhysicsBody(pelvis, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
            pelvisBody.shape = pelvisShape;
            pelvisBody.setMassProperties({ mass: 75 });
            pelvisBody.setAngularDamping(0.92);
            pelvisBody.setLinearDamping(0.25);

            // Set friction and restitution on the shape
            // Low friction (0.1) allows movement - friction 1.0 was blocking all forces
            pelvisShape.material = { friction: 0.1, restitution: 0.05 };

            const pelvisAgg = { body: pelvisBody, shape: pelvisShape };  // Compatibility wrapper

            // === TORSO - Multi-part ===
            const torsoCore = BABYLON.MeshBuilder.CreateBox(name + '_torsoCore', {
                width: 1.5, height: 1.1, depth: 1.0
            }, scene);
            torsoCore.position.y = 0.75;
            torsoCore.parent = pelvis;
            torsoCore.material = primaryMat;

            // Torso upper section
            const torsoUpper = BABYLON.MeshBuilder.CreateBox(name + '_torsoUpper', {
                width: 1.3, height: 0.5, depth: 0.9
            }, scene);
            torsoUpper.position.y = 0.75;
            torsoUpper.parent = torsoCore;
            torsoUpper.material = secondaryMat;

            // Chest armor plates (angled)
            const chestLeft = BABYLON.MeshBuilder.CreateBox(name + '_chestL', {
                width: 0.5, height: 0.7, depth: 0.2
            }, scene);
            chestLeft.position = new BABYLON.Vector3(-0.35, 0.2, 0.5);
            chestLeft.rotation.x = -0.25;
            chestLeft.rotation.y = 0.15;
            chestLeft.parent = torsoCore;
            chestLeft.material = primaryMat;

            const chestRight = chestLeft.clone(name + '_chestR');
            chestRight.position.x = 0.35;
            chestRight.rotation.y = -0.15;
            chestRight.parent = torsoCore;

            // Center chest detail
            const chestCenter = BABYLON.MeshBuilder.CreateBox(name + '_chestC', {
                width: 0.3, height: 0.5, depth: 0.15
            }, scene);
            chestCenter.position = new BABYLON.Vector3(0, 0.1, 0.55);
            chestCenter.parent = torsoCore;
            chestCenter.material = accentMat;

            // Reactor housing (back)
            const reactor = BABYLON.MeshBuilder.CreateBox(name + '_reactor', {
                width: 0.9, height: 0.8, depth: 0.5
            }, scene);
            reactor.position = new BABYLON.Vector3(0, 0.3, -0.6);
            reactor.parent = torsoCore;
            reactor.material = darkMat;

            // Heat sink fins
            for (let i = 0; i < 4; i++) {
                const fin = BABYLON.MeshBuilder.CreateBox(name + '_fin' + i, {
                    width: 0.08, height: 0.5, depth: 0.35
                }, scene);
                fin.position = new BABYLON.Vector3((i - 1.5) * 0.22, 0, 0.1);
                fin.parent = reactor;
                fin.material = metalMat;
            }

            // Exhaust vents
            for (let i = 0; i < 2; i++) {
                const vent = BABYLON.MeshBuilder.CreateCylinder(name + '_vent' + i, {
                    height: 0.15, diameter: 0.18
                }, scene);
                vent.position = new BABYLON.Vector3((i - 0.5) * 0.35, -0.3, 0.28);
                vent.rotation.x = Math.PI / 2;
                vent.parent = reactor;
                const ventMat = new BABYLON.StandardMaterial(name + '_ventMat' + i, scene);
                ventMat.emissiveColor = COLORS.thruster.scale(0.4);
                vent.material = ventMat;
            }

            // === COCKPIT / HEAD - Detailed ===
            const headBase = BABYLON.MeshBuilder.CreateBox(name + '_headBase', {
                width: 0.6, height: 0.35, depth: 0.5
            }, scene);
            headBase.position = new BABYLON.Vector3(0, 0.55, 0.25);
            headBase.parent = torsoUpper;
            headBase.material = primaryMat;

            // Cockpit canopy (angled)
            const canopy = BABYLON.MeshBuilder.CreateBox(name + '_canopy', {
                width: 0.45, height: 0.25, depth: 0.35
            }, scene);
            canopy.position = new BABYLON.Vector3(0, 0.15, 0.15);
            canopy.rotation.x = -0.4;
            canopy.parent = headBase;
            canopy.material = cockpitMat;

            // Cockpit frame
            const frame1 = BABYLON.MeshBuilder.CreateBox(name + '_frame1', {
                width: 0.5, height: 0.04, depth: 0.3
            }, scene);
            frame1.position = new BABYLON.Vector3(0, 0.28, 0.1);
            frame1.rotation.x = -0.4;
            frame1.parent = headBase;
            frame1.material = darkMat;

            // Sensor pod on top
            const sensor = BABYLON.MeshBuilder.CreateCylinder(name + '_sensor', {
                height: 0.15, diameter: 0.12
            }, scene);
            sensor.position = new BABYLON.Vector3(0, 0.3, -0.1);
            sensor.parent = headBase;
            sensor.material = chromeMat;

            // Antenna
            const antenna = BABYLON.MeshBuilder.CreateCylinder(name + '_antenna', {
                height: 0.35, diameter: 0.04
            }, scene);
            antenna.position = new BABYLON.Vector3(0.2, 0.35, -0.1);
            antenna.parent = headBase;
            antenna.material = metalMat;

            // Chin sensor
            const chin = BABYLON.MeshBuilder.CreateBox(name + '_chin', {
                width: 0.2, height: 0.12, depth: 0.15
            }, scene);
            chin.position = new BABYLON.Vector3(0, -0.15, 0.25);
            chin.parent = headBase;
            chin.material = darkMat;

            // === SHOULDER MISSILE PODS (LRM Racks) ===
            function createMissilePod(side) {
                const xOff = side === 'left' ? -1 : 1;
                const pod = new BABYLON.TransformNode(name + '_' + side + 'Pod', scene);
                pod.parent = torsoUpper;
                pod.position = new BABYLON.Vector3(xOff * 0.85, 0.35, -0.1);

                // Pod base
                const podBase = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodBase', {
                    width: 0.55, height: 0.45, depth: 0.7
                }, scene);
                podBase.parent = pod;
                podBase.material = primaryMat;

                // Missile tubes (4x5 grid)
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 5; col++) {
                        const tube = BABYLON.MeshBuilder.CreateCylinder(name + '_tube_' + side + row + col, {
                            height: 0.12, diameter: 0.08
                        }, scene);
                        tube.rotation.x = Math.PI / 2;
                        tube.position = new BABYLON.Vector3(
                            (col - 2) * 0.1,
                            (row - 1.5) * 0.1,
                            0.38
                        );
                        tube.parent = podBase;
                        tube.material = darkMat;
                    }
                }

                // Pod armor top
                const podTop = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodTop', {
                    width: 0.5, height: 0.12, depth: 0.6
                }, scene);
                podTop.position.y = 0.28;
                podTop.parent = podBase;
                podTop.material = secondaryMat;

                // Side armor
                const podSide = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodSide', {
                    width: 0.1, height: 0.35, depth: 0.55
                }, scene);
                podSide.position.x = xOff * 0.3;
                podSide.parent = podBase;
                podSide.material = accentMat;

                return pod;
            }

            const leftPod = createMissilePod('left');
            const rightPod = createMissilePod('right');

            // === ARMS (Large Laser Pods) ===
            function createArm(side) {
                const xOff = side === 'left' ? -1 : 1;
                const armGroup = new BABYLON.TransformNode(name + '_' + side + 'Arm', scene);
                armGroup.parent = torsoCore;
                armGroup.position = new BABYLON.Vector3(xOff * 0.95, 0.1, 0);

                // Shoulder joint
                const shoulderJoint = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'ShoulderJ', {
                    diameter: 0.32
                }, scene);
                shoulderJoint.parent = armGroup;
                shoulderJoint.material = chromeMat;

                // Upper arm
                const upperArm = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'UpperArm', {
                    width: 0.28, height: 0.55, depth: 0.28
                }, scene);
                upperArm.position = new BABYLON.Vector3(xOff * 0.15, -0.35, 0);
                upperArm.parent = armGroup;
                upperArm.material = primaryMat;

                // Upper arm detail
                const upperDetail = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'UpperDetail', {
                    width: 0.32, height: 0.2, depth: 0.15
                }, scene);
                upperDetail.position = new BABYLON.Vector3(xOff * 0.05, 0, 0.15);
                upperDetail.parent = upperArm;
                upperDetail.material = secondaryMat;

                // Elbow
                const elbow = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Elbow', {
                    diameter: 0.22
                }, scene);
                elbow.position = new BABYLON.Vector3(0, -0.35, 0);
                elbow.parent = upperArm;
                elbow.material = metalMat;

                // Lower arm / weapon pod
                const weaponPod = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'WeaponPod', {
                    width: 0.45, height: 0.75, depth: 0.4
                }, scene);
                weaponPod.position = new BABYLON.Vector3(0, -0.75, 0);
                weaponPod.parent = upperArm;
                weaponPod.material = primaryMat;

                // Weapon pod front plate
                const podFront = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodFront', {
                    width: 0.4, height: 0.5, depth: 0.1
                }, scene);
                podFront.position.z = 0.22;
                podFront.parent = weaponPod;
                podFront.material = secondaryMat;

                // ER Large Laser barrels (2 per arm)
                for (let i = 0; i < 2; i++) {
                    const laserBarrel = BABYLON.MeshBuilder.CreateCylinder(name + '_laser_' + side + i, {
                        height: 0.7, diameter: 0.12
                    }, scene);
                    laserBarrel.rotation.x = Math.PI / 2;
                    laserBarrel.position = new BABYLON.Vector3((i - 0.5) * 0.15, -0.1, 0.5);
                    laserBarrel.parent = weaponPod;
                    laserBarrel.material = chromeMat;

                    // Barrel tip
                    const tip = BABYLON.MeshBuilder.CreateCylinder(name + '_laserTip_' + side + i, {
                        height: 0.08, diameter: 0.15
                    }, scene);
                    tip.rotation.x = Math.PI / 2;
                    tip.position.z = 0.38;
                    tip.parent = laserBarrel;
                    tip.material = darkMat;
                }

                // Weapon pod side detail
                const podSideL = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodSideL', {
                    width: 0.08, height: 0.5, depth: 0.3
                }, scene);
                podSideL.position = new BABYLON.Vector3(-0.22, 0, 0);
                podSideL.parent = weaponPod;
                podSideL.material = accentMat;

                const podSideR = podSideL.clone(name + '_' + side + 'PodSideR');
                podSideR.position.x = 0.22;
                podSideR.parent = weaponPod;

                return { armGroup, upperArm, weaponPod };
            }

            const leftArm = createArm('left');
            const rightArm = createArm('right');

            // === LEGS (Chicken Walker - Detailed) ===
            function createLeg(side) {
                const xOff = side === 'left' ? -1 : 1;

                // Hip joint
                const hip = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Hip', {
                    diameter: 0.38
                }, scene);
                hip.position = new BABYLON.Vector3(xOff * 0.4, -0.3, 0);
                hip.parent = pelvis;
                hip.material = chromeMat;

                // Upper leg (thigh)
                const upperLeg = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'UpperLeg', {
                    width: 0.38, height: 0.85, depth: 0.38
                }, scene);
                upperLeg.position = new BABYLON.Vector3(xOff * 0.4, -0.75, 0.12);
                upperLeg.rotation.x = 0.2;
                upperLeg.parent = pelvis;
                upperLeg.material = primaryMat;

                // Thigh armor (front)
                const thighFront = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ThighFront', {
                    width: 0.42, height: 0.6, depth: 0.12
                }, scene);
                thighFront.position = new BABYLON.Vector3(0, 0.05, 0.22);
                thighFront.parent = upperLeg;
                thighFront.material = secondaryMat;

                // Thigh armor (side)
                const thighSide = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ThighSide', {
                    width: 0.1, height: 0.55, depth: 0.32
                }, scene);
                thighSide.position = new BABYLON.Vector3(xOff * 0.22, 0, 0);
                thighSide.parent = upperLeg;
                thighSide.material = accentMat;

                // Knee (large, detailed)
                const knee = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Knee', {
                    diameter: 0.35
                }, scene);
                knee.position = new BABYLON.Vector3(0, -0.48, 0);
                knee.parent = upperLeg;
                knee.material = metalMat;

                // Knee armor cap
                const kneeCap = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'KneeCap', {
                    width: 0.25, height: 0.2, depth: 0.15
                }, scene);
                kneeCap.position = new BABYLON.Vector3(0, 0, 0.2);
                kneeCap.parent = knee;
                kneeCap.material = primaryMat;

                // Lower leg (shin)
                const lowerLeg = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'LowerLeg', {
                    width: 0.32, height: 0.95, depth: 0.32
                }, scene);
                lowerLeg.position = new BABYLON.Vector3(0, -0.7, -0.15);
                lowerLeg.rotation.x = -0.25;
                lowerLeg.parent = knee;
                lowerLeg.material = primaryMat;

                // Shin armor (front)
                const shinFront = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ShinFront', {
                    width: 0.36, height: 0.7, depth: 0.12
                }, scene);
                shinFront.position = new BABYLON.Vector3(0, 0.05, 0.2);
                shinFront.parent = lowerLeg;
                shinFront.material = secondaryMat;

                // Shin detail lines
                for (let i = 0; i < 3; i++) {
                    const line = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ShinLine' + i, {
                        width: 0.3, height: 0.03, depth: 0.02
                    }, scene);
                    line.position = new BABYLON.Vector3(0, 0.2 - i * 0.2, 0.27);
                    line.parent = lowerLeg;
                    line.material = darkMat;
                }

                // Ankle
                const ankle = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Ankle', {
                    diameter: 0.25
                }, scene);
                ankle.position = new BABYLON.Vector3(0, -0.52, 0);
                ankle.parent = lowerLeg;
                ankle.material = metalMat;

                // Foot (large, clawed)
                const foot = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Foot', {
                    width: 0.45, height: 0.18, depth: 0.75
                }, scene);
                foot.position = new BABYLON.Vector3(0, -0.12, 0.18);
                foot.parent = ankle;
                foot.material = darkMat;

                // Foot armor top
                const footTop = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'FootTop', {
                    width: 0.4, height: 0.1, depth: 0.5
                }, scene);
                footTop.position = new BABYLON.Vector3(0, 0.12, 0);
                footTop.parent = foot;
                footTop.material = primaryMat;

                // Toe claws (3)
                for (let i = 0; i < 3; i++) {
                    const claw = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Claw' + i, {
                        width: 0.1, height: 0.08, depth: 0.22
                    }, scene);
                    claw.position = new BABYLON.Vector3((i - 1) * 0.14, -0.05, 0.45);
                    claw.parent = foot;
                    claw.material = metalMat;
                }

                // Heel spur
                const heel = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Heel', {
                    width: 0.15, height: 0.1, depth: 0.25
                }, scene);
                heel.position = new BABYLON.Vector3(0, -0.02, -0.35);
                heel.rotation.x = 0.3;
                heel.parent = foot;
                heel.material = metalMat;

                return { hip, upperLeg, knee, lowerLeg, ankle, foot };
            }

            const leftLeg = createLeg('left');
            const rightLeg = createLeg('right');

            // Build mech data
            return {
                name: 'TIMBER WOLF',
                pelvis, pelvisAggregate: pelvisAgg,
                torso: torsoCore, head: headBase, cockpit: canopy,
                leftArm, rightArm, leftLeg, rightLeg,
                leftPod, rightPod,
                isPlayer, scale: 1.0,
                stats: { maxHP: 150, mass: 75 },
                currentHP: 150, maxHP: 150,
                isWalking: false, walkCycle: 0, walkSpeed: 2.8,
                walkDirection: isPlayer ? 1 : -1,
                impactRecovery: 0, impactDirection: new BABYLON.Vector3(0,0,0),
                staggerTime: 0, recoilRecovery: 0, lastFiredArm: 'right',
                torsoTwist: 0, targetTorsoTwist: 0,
                // AI state
                ai: {
                    enabled: false,
                    state: 'idle',        // idle, advancing, retreating, optimal, strafing
                    lastDecision: 0,
                    strafeDir: 0,         // -1 left, 0 none, 1 right
                    strafeEndTime: 0
                }
            };
        }

        // ============================================
        // DIRE WOLF (Daishi) - Even More Detailed, Heavier
        // ============================================
        function createDireWolfMech(scene, xPos, isPlayer) {
            const name = isPlayer ? 'player' : 'enemy';
            const primary = isPlayer ? COLORS.playerPrimary : COLORS.enemyPrimary;
            const secondary = isPlayer ? COLORS.playerSecondary : COLORS.enemySecondary;
            const accent = isPlayer ? COLORS.playerAccent : COLORS.enemyAccent;

            // Materials
            const primaryMat = new BABYLON.StandardMaterial(name + '_primary', scene);
            primaryMat.diffuseColor = primary;
            const secondaryMat = new BABYLON.StandardMaterial(name + '_secondary', scene);
            secondaryMat.diffuseColor = secondary;
            const accentMat = new BABYLON.StandardMaterial(name + '_accent', scene);
            accentMat.diffuseColor = accent;
            const metalMat = new BABYLON.StandardMaterial(name + '_metal', scene);
            metalMat.diffuseColor = COLORS.metal;
            metalMat.specularPower = 64;
            const darkMat = new BABYLON.StandardMaterial(name + '_dark', scene);
            darkMat.diffuseColor = COLORS.darkMetal;
            const cockpitMat = new BABYLON.StandardMaterial(name + '_cockpit', scene);
            cockpitMat.diffuseColor = COLORS.cockpit;
            cockpitMat.emissiveColor = COLORS.cockpit.scale(0.5);
            cockpitMat.alpha = 0.8;
            const chromeMat = new BABYLON.StandardMaterial(name + '_chrome', scene);
            chromeMat.diffuseColor = COLORS.chrome;
            chromeMat.specularPower = 128;

            const scale = 1.15; // Bigger mech

            // === PELVIS ===
            const pelvis = BABYLON.MeshBuilder.CreateBox(name + '_pelvis', {
                width: 1.3 * scale, height: 0.55 * scale, depth: 1.0 * scale
            }, scene);
            pelvis.position = new BABYLON.Vector3(xPos, 3.8, 0);  // Spawn height
            pelvis.material = darkMat;

            // Create a taller collision shape to represent the full mech standing height
            // Dire Wolf is bigger (scale 1.15), legs extend ~3.5 units below pelvis
            const pelvisShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -1.7 * scale, 0),  // Center offset (shift down to cover legs)
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(1.3 * scale, 4.0 * scale, 1.0 * scale),  // Full standing height
                scene
            );
            const pelvisBody = new BABYLON.PhysicsBody(pelvis, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
            pelvisBody.shape = pelvisShape;
            pelvisBody.setMassProperties({ mass: 100 });
            pelvisBody.setAngularDamping(0.93);
            pelvisBody.setLinearDamping(0.3);

            // Set friction and restitution on the shape
            // Low friction (0.1) allows movement - friction 1.0 was blocking all forces
            pelvisShape.material = { friction: 0.1, restitution: 0.05 };

            const pelvisAgg = { body: pelvisBody, shape: pelvisShape };  // Compatibility wrapper

            // === MASSIVE TORSO ===
            const torsoCore = BABYLON.MeshBuilder.CreateBox(name + '_torsoCore', {
                width: 1.8 * scale, height: 1.3 * scale, depth: 1.2 * scale
            }, scene);
            torsoCore.position.y = 0.85 * scale;
            torsoCore.parent = pelvis;
            torsoCore.material = primaryMat;

            // Upper torso
            const torsoUpper = BABYLON.MeshBuilder.CreateBox(name + '_torsoUpper', {
                width: 1.6 * scale, height: 0.6 * scale, depth: 1.0 * scale
            }, scene);
            torsoUpper.position.y = 0.85 * scale;
            torsoUpper.parent = torsoCore;
            torsoUpper.material = secondaryMat;

            // Chest armor plates (multiple angled)
            for (let i = 0; i < 3; i++) {
                const chest = BABYLON.MeshBuilder.CreateBox(name + '_chest' + i, {
                    width: 0.45 * scale, height: 0.6 * scale, depth: 0.18 * scale
                }, scene);
                chest.position = new BABYLON.Vector3((i - 1) * 0.45 * scale, 0.15 * scale, 0.55 * scale);
                chest.rotation.x = -0.2;
                chest.parent = torsoCore;
                chest.material = i === 1 ? accentMat : primaryMat;
            }

            // Side torso panels
            for (let side = -1; side <= 1; side += 2) {
                const sidePanel = BABYLON.MeshBuilder.CreateBox(name + '_sidePanel' + side, {
                    width: 0.15 * scale, height: 0.9 * scale, depth: 0.8 * scale
                }, scene);
                sidePanel.position = new BABYLON.Vector3(side * 0.9 * scale, 0.2 * scale, 0);
                sidePanel.parent = torsoCore;
                sidePanel.material = secondaryMat;
            }

            // Large reactor (back)
            const reactor = BABYLON.MeshBuilder.CreateBox(name + '_reactor', {
                width: 1.1 * scale, height: 0.95 * scale, depth: 0.6 * scale
            }, scene);
            reactor.position = new BABYLON.Vector3(0, 0.35 * scale, -0.75 * scale);
            reactor.parent = torsoCore;
            reactor.material = darkMat;

            // Reactor pipes
            for (let i = 0; i < 3; i++) {
                const pipe = BABYLON.MeshBuilder.CreateCylinder(name + '_pipe' + i, {
                    height: 0.8 * scale, diameter: 0.12 * scale
                }, scene);
                pipe.position = new BABYLON.Vector3((i - 1) * 0.35 * scale, 0.1 * scale, 0);
                pipe.rotation.x = 0.15;
                pipe.parent = reactor;
                pipe.material = chromeMat;
            }

            // Exhaust array
            for (let i = 0; i < 4; i++) {
                const exhaust = BABYLON.MeshBuilder.CreateCylinder(name + '_exhaust' + i, {
                    height: 0.18 * scale, diameter: 0.15 * scale
                }, scene);
                exhaust.rotation.x = Math.PI / 2;
                exhaust.position = new BABYLON.Vector3((i - 1.5) * 0.25 * scale, -0.35 * scale, 0.32 * scale);
                exhaust.parent = reactor;
                const exMat = new BABYLON.StandardMaterial(name + '_exMat' + i, scene);
                exMat.emissiveColor = COLORS.thruster.scale(0.3);
                exhaust.material = exMat;
            }

            // === HEAD (Smaller, bunker-style) ===
            const headBase = BABYLON.MeshBuilder.CreateBox(name + '_headBase', {
                width: 0.55 * scale, height: 0.35 * scale, depth: 0.45 * scale
            }, scene);
            headBase.position = new BABYLON.Vector3(0, 0.55 * scale, 0.2 * scale);
            headBase.parent = torsoUpper;
            headBase.material = primaryMat;

            const canopy = BABYLON.MeshBuilder.CreateBox(name + '_canopy', {
                width: 0.4 * scale, height: 0.18 * scale, depth: 0.25 * scale
            }, scene);
            canopy.position = new BABYLON.Vector3(0, 0.1 * scale, 0.15 * scale);
            canopy.rotation.x = -0.35;
            canopy.parent = headBase;
            canopy.material = cockpitMat;

            // Sensor array
            for (let i = 0; i < 2; i++) {
                const sens = BABYLON.MeshBuilder.CreateCylinder(name + '_sens' + i, {
                    height: 0.12 * scale, diameter: 0.08 * scale
                }, scene);
                sens.position = new BABYLON.Vector3((i - 0.5) * 0.2 * scale, 0.22 * scale, 0);
                sens.parent = headBase;
                sens.material = chromeMat;
            }

            // === MASSIVE SHOULDER WEAPON PODS ===
            function createWeaponPod(side) {
                const xOff = side === 'left' ? -1 : 1;
                const pod = new BABYLON.TransformNode(name + '_' + side + 'WeaponPod', scene);
                pod.parent = torsoUpper;
                pod.position = new BABYLON.Vector3(xOff * 1.1 * scale, 0.2 * scale, 0);

                // Main pod body
                const podBody = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodBody', {
                    width: 0.7 * scale, height: 0.65 * scale, depth: 0.9 * scale
                }, scene);
                podBody.parent = pod;
                podBody.material = primaryMat;

                // Pod top armor
                const podTop = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'PodTop', {
                    width: 0.65 * scale, height: 0.15 * scale, depth: 0.85 * scale
                }, scene);
                podTop.position.y = 0.38 * scale;
                podTop.parent = podBody;
                podTop.material = secondaryMat;

                // Missile tubes (5x4)
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 5; c++) {
                        const tube = BABYLON.MeshBuilder.CreateCylinder(name + '_mtube' + side + r + c, {
                            height: 0.1 * scale, diameter: 0.07 * scale
                        }, scene);
                        tube.rotation.x = Math.PI / 2;
                        tube.position = new BABYLON.Vector3(
                            (c - 2) * 0.11 * scale,
                            (r - 1.5) * 0.11 * scale,
                            0.48 * scale
                        );
                        tube.parent = podBody;
                        tube.material = darkMat;
                    }
                }

                // Side weapon (autocannon or laser)
                const sideGun = BABYLON.MeshBuilder.CreateCylinder(name + '_' + side + 'SideGun', {
                    height: 0.8 * scale, diameter: 0.15 * scale
                }, scene);
                sideGun.rotation.x = Math.PI / 2;
                sideGun.position = new BABYLON.Vector3(xOff * 0.32 * scale, -0.15 * scale, 0.55 * scale);
                sideGun.parent = podBody;
                sideGun.material = chromeMat;

                return pod;
            }

            const leftPod = createWeaponPod('left');
            const rightPod = createWeaponPod('right');

            // === ARMS (Heavy weapon mounts) ===
            function createArm(side) {
                const xOff = side === 'left' ? -1 : 1;
                const armGroup = new BABYLON.TransformNode(name + '_' + side + 'Arm', scene);
                armGroup.parent = torsoCore;
                armGroup.position = new BABYLON.Vector3(xOff * 1.1 * scale, 0, 0);

                const shoulder = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Shoulder', {
                    diameter: 0.35 * scale
                }, scene);
                shoulder.parent = armGroup;
                shoulder.material = chromeMat;

                const upperArm = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'UpperArm', {
                    width: 0.32 * scale, height: 0.6 * scale, depth: 0.32 * scale
                }, scene);
                upperArm.position = new BABYLON.Vector3(xOff * 0.12 * scale, -0.38 * scale, 0);
                upperArm.parent = armGroup;
                upperArm.material = primaryMat;

                const elbow = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Elbow', {
                    diameter: 0.25 * scale
                }, scene);
                elbow.position.y = -0.38 * scale;
                elbow.parent = upperArm;
                elbow.material = metalMat;

                // Massive weapon pod
                const weaponPod = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ArmWeapon', {
                    width: 0.5 * scale, height: 0.85 * scale, depth: 0.45 * scale
                }, scene);
                weaponPod.position = new BABYLON.Vector3(0, -0.8 * scale, 0);
                weaponPod.parent = upperArm;
                weaponPod.material = primaryMat;

                // Quad laser barrels
                for (let r = 0; r < 2; r++) {
                    for (let c = 0; c < 2; c++) {
                        const barrel = BABYLON.MeshBuilder.CreateCylinder(name + '_barrel' + side + r + c, {
                            height: 0.75 * scale, diameter: 0.1 * scale
                        }, scene);
                        barrel.rotation.x = Math.PI / 2;
                        barrel.position = new BABYLON.Vector3(
                            (c - 0.5) * 0.15 * scale,
                            -0.15 * scale + r * 0.2 * scale,
                            0.55 * scale
                        );
                        barrel.parent = weaponPod;
                        barrel.material = chromeMat;
                    }
                }

                return { armGroup, upperArm, weaponPod };
            }

            const leftArm = createArm('left');
            const rightArm = createArm('right');

            // === LEGS (Heavy, reinforced) ===
            function createLeg(side) {
                const xOff = side === 'left' ? -1 : 1;

                const hip = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Hip', {
                    diameter: 0.42 * scale
                }, scene);
                hip.position = new BABYLON.Vector3(xOff * 0.48 * scale, -0.32 * scale, 0);
                hip.parent = pelvis;
                hip.material = chromeMat;

                const upperLeg = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'UpperLeg', {
                    width: 0.42 * scale, height: 0.95 * scale, depth: 0.42 * scale
                }, scene);
                upperLeg.position = new BABYLON.Vector3(xOff * 0.48 * scale, -0.82 * scale, 0.12 * scale);
                upperLeg.rotation.x = 0.18;
                upperLeg.parent = pelvis;
                upperLeg.material = primaryMat;

                // Thigh armor layers
                const thighArmor = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ThighArmor', {
                    width: 0.48 * scale, height: 0.7 * scale, depth: 0.15 * scale
                }, scene);
                thighArmor.position = new BABYLON.Vector3(0, 0.05 * scale, 0.26 * scale);
                thighArmor.parent = upperLeg;
                thighArmor.material = secondaryMat;

                const knee = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Knee', {
                    diameter: 0.4 * scale
                }, scene);
                knee.position.y = -0.52 * scale;
                knee.parent = upperLeg;
                knee.material = metalMat;

                const kneeCap = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'KneeCap', {
                    width: 0.28 * scale, height: 0.25 * scale, depth: 0.18 * scale
                }, scene);
                kneeCap.position.z = 0.22 * scale;
                kneeCap.parent = knee;
                kneeCap.material = accentMat;

                const lowerLeg = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'LowerLeg', {
                    width: 0.38 * scale, height: 1.05 * scale, depth: 0.38 * scale
                }, scene);
                lowerLeg.position = new BABYLON.Vector3(0, -0.75 * scale, -0.18 * scale);
                lowerLeg.rotation.x = -0.22;
                lowerLeg.parent = knee;
                lowerLeg.material = primaryMat;

                const shinArmor = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'ShinArmor', {
                    width: 0.42 * scale, height: 0.8 * scale, depth: 0.12 * scale
                }, scene);
                shinArmor.position.z = 0.22 * scale;
                shinArmor.parent = lowerLeg;
                shinArmor.material = secondaryMat;

                const ankle = BABYLON.MeshBuilder.CreateSphere(name + '_' + side + 'Ankle', {
                    diameter: 0.28 * scale
                }, scene);
                ankle.position.y = -0.58 * scale;
                ankle.parent = lowerLeg;
                ankle.material = metalMat;

                const foot = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Foot', {
                    width: 0.52 * scale, height: 0.2 * scale, depth: 0.85 * scale
                }, scene);
                foot.position = new BABYLON.Vector3(0, -0.12 * scale, 0.2 * scale);
                foot.parent = ankle;
                foot.material = darkMat;

                const footArmor = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'FootArmor', {
                    width: 0.48 * scale, height: 0.12 * scale, depth: 0.6 * scale
                }, scene);
                footArmor.position.y = 0.14 * scale;
                footArmor.parent = foot;
                footArmor.material = primaryMat;

                for (let i = 0; i < 3; i++) {
                    const claw = BABYLON.MeshBuilder.CreateBox(name + '_' + side + 'Claw' + i, {
                        width: 0.12 * scale, height: 0.1 * scale, depth: 0.28 * scale
                    }, scene);
                    claw.position = new BABYLON.Vector3((i - 1) * 0.16 * scale, -0.06 * scale, 0.52 * scale);
                    claw.parent = foot;
                    claw.material = metalMat;
                }

                return { hip, upperLeg, knee, lowerLeg, ankle, foot };
            }

            const leftLeg = createLeg('left');
            const rightLeg = createLeg('right');

            return {
                name: 'DIRE WOLF',
                pelvis, pelvisAggregate: pelvisAgg,
                torso: torsoCore, head: headBase, cockpit: canopy,
                leftArm, rightArm, leftLeg, rightLeg,
                leftPod, rightPod,
                isPlayer, scale,
                stats: { maxHP: 200, mass: 100 },
                currentHP: 200, maxHP: 200,
                isWalking: false, walkCycle: 0, walkSpeed: 2.2,
                walkDirection: isPlayer ? 1 : -1,
                impactRecovery: 0, impactDirection: new BABYLON.Vector3(0,0,0),
                staggerTime: 0, recoilRecovery: 0, lastFiredArm: 'right',
                torsoTwist: 0, targetTorsoTwist: 0,
                // AI state
                ai: {
                    enabled: false,
                    state: 'idle',        // idle, advancing, retreating, optimal, strafing
                    lastDecision: 0,
                    strafeDir: 0,         // -1 left, 0 none, 1 right
                    strafeEndTime: 0
                }
            };
        }

        // ============================================
        // ANIMATION & PHYSICS
        // ============================================
        function updateMechs(dt) {
            [playerMech, enemyMech].forEach(mech => {
                if (!mech) return;
                updateAI(mech, dt);      // AI controls movement and firing
                updateWalking(mech, dt);
                updateImpact(mech, dt);
                updateRecoil(mech, dt);
                updateTorsoTrack(mech, dt);
                stabilize(mech, dt);
            });
        }

        function updateWalking(mech, dt) {
            if (!mech.isWalking) {
                dampLegs(mech, dt);
                return;
            }

            mech.walkCycle += dt * mech.walkSpeed * 2;
            const cycle = mech.walkCycle;

            const leftPhase = Math.sin(cycle);
            const rightPhase = Math.sin(cycle + Math.PI);

            animateLeg(mech.leftLeg, leftPhase, mech.scale);
            animateLeg(mech.rightLeg, rightPhase, mech.scale);

            const sway = Math.sin(cycle) * 0.025;

            // Walking force - physics engine integrates force, don't multiply by dt
            mech.pelvisAggregate.body.applyForce(
                new BABYLON.Vector3(mech.walkDirection * 120, 0, 0),
                mech.pelvis.getAbsolutePosition()
            );

            const angVel = mech.pelvisAggregate.body.getAngularVelocity();
            mech.pelvisAggregate.body.setAngularVelocity(
                new BABYLON.Vector3(angVel.x * 0.9, angVel.y * 0.9, sway * 2)
            );
        }

        function animateLeg(leg, phase, scale) {
            const swing = phase * 0.22;
            leg.upperLeg.rotation.x = 0.2 + swing;
            const bend = (phase > 0 ? phase : 0) * 0.28;
            leg.lowerLeg.rotation.x = -0.25 - bend;
            leg.foot.rotation.x = -leg.lowerLeg.rotation.x * 0.45;
        }

        function dampLegs(mech, dt) {
            const d = 3 * dt;
            [mech.leftLeg, mech.rightLeg].forEach(leg => {
                leg.upperLeg.rotation.x = BABYLON.Scalar.Lerp(leg.upperLeg.rotation.x, 0.2, d);
                leg.lowerLeg.rotation.x = BABYLON.Scalar.Lerp(leg.lowerLeg.rotation.x, -0.25, d);
                leg.foot.rotation.x = BABYLON.Scalar.Lerp(leg.foot.rotation.x, 0.12, d);
            });
        }

        function updateImpact(mech, dt) {
            if (mech.impactRecovery <= 0) return;
            mech.impactRecovery -= dt * 2.2;
            if (mech.impactRecovery < 0) mech.impactRecovery = 0;

            const tilt = mech.impactRecovery * 0.28;
            mech.torso.rotation.x = mech.impactDirection.z * tilt;
            mech.torso.rotation.z = -mech.impactDirection.x * tilt;

            if (mech.staggerTime > 0) {
                mech.staggerTime -= dt;
                mech.isWalking = false;
            }
        }

        function updateRecoil(mech, dt) {
            if (mech.recoilRecovery <= 0) return;
            mech.recoilRecovery -= dt * 4.5;
            if (mech.recoilRecovery < 0) mech.recoilRecovery = 0;

            const arm = mech.lastFiredArm === 'left' ? mech.leftArm : mech.rightArm;
            arm.armGroup.rotation.x = -mech.recoilRecovery * 0.45;
            mech.torso.rotation.x = Math.max(mech.torso.rotation.x, -mech.recoilRecovery * 0.08);
        }

        function updateTorsoTrack(mech, dt) {
            const target = mech.isPlayer ? enemyMech : playerMech;
            if (!target || target.currentHP <= 0) return;

            const myPos = mech.pelvis.getAbsolutePosition();
            const targetPos = target.pelvis.getAbsolutePosition();
            const dx = targetPos.x - myPos.x;
            const dz = targetPos.z - myPos.z;

            // =============================================
            // TORSO ALWAYS FACES ENEMY
            // =============================================
            // Calculate angle to enemy (in XZ plane)
            // Mechs face along X axis, so we want to rotate Y to face target
            const angleToEnemy = Math.atan2(dz, dx);

            // Player faces right (+X), Enemy faces left (-X)
            // Adjust base angle based on which way mech should face
            const baseAngle = mech.isPlayer ? 0 : Math.PI;
            let torsoAngle = angleToEnemy - baseAngle;

            // Normalize to -PI to PI range
            while (torsoAngle > Math.PI) torsoAngle -= Math.PI * 2;
            while (torsoAngle < -Math.PI) torsoAngle += Math.PI * 2;

            // Clamp torso rotation to reasonable range (about 60 degrees each way)
            mech.targetTorsoTwist = Math.max(-1.0, Math.min(1.0, torsoAngle));

            // Smooth interpolation for torso rotation
            mech.torsoTwist = BABYLON.Scalar.Lerp(mech.torsoTwist, mech.targetTorsoTwist, dt * 5);
            mech.torso.rotation.y = mech.torsoTwist;

            // Head follows torso but can look even more toward enemy
            if (mech.head) {
                mech.head.rotation.y = mech.torsoTwist * 1.2;
            }

            // =============================================
            // LEGS/PELVIS FACE MOVEMENT DIRECTION
            // =============================================
            const vel = mech.pelvisAggregate.body.getLinearVelocity();
            const speed = Math.sqrt(vel.x * vel.x + vel.z * vel.z);

            if (speed > 0.5 && mech.isWalking) {
                // Calculate movement direction angle
                const moveAngle = Math.atan2(vel.z, vel.x);
                let legAngle = moveAngle - baseAngle;

                // Normalize
                while (legAngle > Math.PI) legAngle -= Math.PI * 2;
                while (legAngle < -Math.PI) legAngle += Math.PI * 2;

                // Clamp leg rotation (about 45 degrees each way)
                const targetLegAngle = Math.max(-0.8, Math.min(0.8, legAngle));

                // Initialize pelvisRotation if not set
                if (mech.pelvisRotation === undefined) mech.pelvisRotation = 0;

                // Smooth interpolation for pelvis/leg rotation
                mech.pelvisRotation = BABYLON.Scalar.Lerp(mech.pelvisRotation, targetLegAngle, dt * 4);

                // Apply rotation to legs (they're children of pelvis visual, not physics body)
                // Rotate legs around Y axis to face movement direction
                mech.leftLeg.upperLeg.parent.rotation.y = mech.pelvisRotation * 0.7;
                mech.rightLeg.upperLeg.parent.rotation.y = mech.pelvisRotation * 0.7;
            } else if (!mech.isWalking) {
                // When not walking, gradually return legs to neutral
                if (mech.pelvisRotation !== undefined && Math.abs(mech.pelvisRotation) > 0.01) {
                    mech.pelvisRotation = BABYLON.Scalar.Lerp(mech.pelvisRotation, 0, dt * 3);
                    mech.leftLeg.upperLeg.parent.rotation.y = mech.pelvisRotation * 0.7;
                    mech.rightLeg.upperLeg.parent.rotation.y = mech.pelvisRotation * 0.7;
                }
            }
        }

        function stabilize(mech, dt) {
            const body = mech.pelvisAggregate.body;
            const quat = body.transformNode.rotationQuaternion;
            if (!quat) return;

            const euler = quat.toEulerAngles();
            const maxTilt = 0.28;
            if (Math.abs(euler.x) > maxTilt || Math.abs(euler.z) > maxTilt) {
                body.applyAngularImpulse(new BABYLON.Vector3(
                    -euler.x * 55 * dt, 0, -euler.z * 55 * dt
                ));
            }

            const vel = body.getLinearVelocity();
            if (vel.length() > 5.5) {
                body.setLinearVelocity(vel.normalize().scale(5.5));
            }
        }

        // ============================================
        // MECH AI SYSTEM
        // ============================================
        function updateAI(mech, dt) {
            const name = mech.isPlayer ? 'P' : 'E';

            // Periodic verbose logging
            const shouldLog = gameTime - lastDebugTime > DEBUG_INTERVAL;

            if (!mech.ai.enabled) {
                if (shouldLog) dbg(`${name}: AI disabled`, 'warn');
                return;
            }
            if (mech.currentHP <= 0) {
                if (shouldLog) dbg(`${name}: HP=0, skip AI`, 'warn');
                return;
            }
            if (mech.staggerTime > 0) {
                if (shouldLog) dbg(`${name}: staggered (${mech.staggerTime.toFixed(2)}s)`, 'warn');
                return;
            }

            const target = mech.isPlayer ? enemyMech : playerMech;
            if (!target || target.currentHP <= 0) {
                if (shouldLog) dbg(`${name}: no valid target`, 'warn');
                return;
            }

            const body = mech.pelvisAggregate.body;
            const myPos = mech.pelvis.getAbsolutePosition();
            const targetPos = target.pelvis.getAbsolutePosition();
            const distance = BABYLON.Vector3.Distance(myPos, targetPos);
            const toTarget = targetPos.subtract(myPos).normalize();
            const vel = body.getLinearVelocity();

            // Log physics state periodically
            if (shouldLog) {
                dbg(`${name}: pos=(${myPos.x.toFixed(1)},${myPos.y.toFixed(1)},${myPos.z.toFixed(1)}) vel=(${vel.x.toFixed(2)},${vel.y.toFixed(2)},${vel.z.toFixed(2)}) dist=${distance.toFixed(1)}`, 'phys');
                dbg(`${name}: state=${mech.ai.state} walk=${mech.isWalking} dir=${mech.walkDirection}`, 'ai');
            }

            // Edge avoidance - high priority
            // Note: applyForce() is integrated by physics engine, don't multiply by dt
            let edgeForce = new BABYLON.Vector3(0, 0, 0);
            if (myPos.x < -AI_CONFIG.edgeBoundary) {
                edgeForce.x = AI_CONFIG.edgeForce;
                mech.ai.state = 'edge-avoid';
            } else if (myPos.x > AI_CONFIG.edgeBoundary) {
                edgeForce.x = -AI_CONFIG.edgeForce;
                mech.ai.state = 'edge-avoid';
            }
            if (Math.abs(myPos.z) > 7) {
                edgeForce.z = -Math.sign(myPos.z) * AI_CONFIG.edgeForce * 0.5;
            }

            // Apply edge avoidance force
            if (edgeForce.length() > 0) {
                mech.pelvisAggregate.body.applyForce(edgeForce, myPos);
                if (shouldLog) dbg(`${name}: edge force (${edgeForce.x.toFixed(0)},${edgeForce.z.toFixed(0)})`, 'phys');
            }

            // AI decision making (periodic, not every frame)
            if (gameTime - mech.ai.lastDecision > AI_CONFIG.decisionInterval) {
                mech.ai.lastDecision = gameTime;

                // Determine movement state based on range
                if (distance > AI_CONFIG.maxRange) {
                    mech.ai.state = 'advancing';
                    mech.walkDirection = toTarget.x > 0 ? 1 : -1;
                } else if (distance < AI_CONFIG.minRange) {
                    mech.ai.state = 'retreating';
                    mech.walkDirection = toTarget.x > 0 ? -1 : 1;
                } else {
                    // At optimal range - maybe strafe
                    if (Math.random() < AI_CONFIG.strafeChance) {
                        mech.ai.state = 'strafing';
                        mech.ai.strafeDir = Math.random() < 0.5 ? -1 : 1;
                        mech.ai.strafeEndTime = gameTime + AI_CONFIG.strafeDuration;
                    } else {
                        mech.ai.state = 'optimal';
                    }
                }

                // Fire weapons when in range (increased range for more action)
                if (distance <= 18 && distance >= AI_CONFIG.minRange * 0.5) {
                    const now = Date.now();
                    const side = mech.isPlayer ? 'player' : 'enemy';
                    const weaponPriority = ['erlaser', 'ac', 'lrm'];

                    for (const wtype of weaponPriority) {
                        if (now >= weaponCooldowns[side][wtype]) {
                            fireWeapon(mech.isPlayer, wtype);
                            weaponCooldowns[side][wtype] = now + COOLDOWN_TIMES[wtype];
                            break;
                        }
                    }
                }
            }

            // Check if strafing should end
            if (mech.ai.state === 'strafing' && gameTime > mech.ai.strafeEndTime) {
                mech.ai.state = 'optimal';
                mech.ai.strafeDir = 0;
            }

            // Apply movement based on state
            // Note: applyForce() is integrated by physics engine, don't multiply by dt
            let forceApplied = new BABYLON.Vector3(0, 0, 0);
            switch (mech.ai.state) {
                case 'advancing':
                    mech.isWalking = true;
                    forceApplied = new BABYLON.Vector3(mech.walkDirection * AI_CONFIG.moveForce, 0, 0);
                    body.applyForce(forceApplied, myPos);
                    break;

                case 'retreating':
                    mech.isWalking = true;
                    forceApplied = new BABYLON.Vector3(mech.walkDirection * AI_CONFIG.moveForce * 1.2, 0, 0);
                    body.applyForce(forceApplied, myPos);
                    break;

                case 'strafing':
                    mech.isWalking = true;
                    // Strafe perpendicular to target
                    forceApplied = new BABYLON.Vector3(0, 0, mech.ai.strafeDir * AI_CONFIG.strafeForce);
                    body.applyForce(forceApplied, myPos);
                    // Small adjustment toward ideal range
                    if (distance > AI_CONFIG.idealRange + 1) {
                        body.applyForce(new BABYLON.Vector3(toTarget.x * AI_CONFIG.moveForce * 0.3, 0, 0), myPos);
                    } else if (distance < AI_CONFIG.idealRange - 1) {
                        body.applyForce(new BABYLON.Vector3(-toTarget.x * AI_CONFIG.moveForce * 0.3, 0, 0), myPos);
                    }
                    break;

                case 'optimal':
                    // Small adjustments to stay at ideal range
                    if (distance > AI_CONFIG.idealRange + 2) {
                        mech.isWalking = true;
                        mech.walkDirection = toTarget.x > 0 ? 1 : -1;
                        forceApplied = new BABYLON.Vector3(mech.walkDirection * AI_CONFIG.moveForce * 0.5, 0, 0);
                        body.applyForce(forceApplied, myPos);
                    } else if (distance < AI_CONFIG.idealRange - 2) {
                        mech.isWalking = true;
                        mech.walkDirection = toTarget.x > 0 ? -1 : 1;
                        forceApplied = new BABYLON.Vector3(mech.walkDirection * AI_CONFIG.moveForce * 0.5, 0, 0);
                        body.applyForce(forceApplied, myPos);
                    } else {
                        mech.isWalking = false;
                    }
                    break;

                case 'edge-avoid':
                    mech.isWalking = true;
                    break;

                default:
                    mech.isWalking = false;
            }

            // Log force applied
            if (shouldLog && forceApplied.length() > 0) {
                dbg(`${name}: FORCE (${forceApplied.x.toFixed(0)},${forceApplied.z.toFixed(0)}) state=${mech.ai.state}`, 'phys');
            }

            // Update debug timer at end of second mech's AI update
            if (!mech.isPlayer && shouldLog) {
                lastDebugTime = gameTime;
            }
        }

        // ============================================
        // COMBAT
        // ============================================
        function fireWeapon(isPlayer, type) {
            const from = isPlayer ? playerMech : enemyMech;
            const to = isPlayer ? enemyMech : playerMech;
            if (!from || !to) return;

            const weapon = WEAPONS[type];
            from.recoilRecovery = weapon.recoil;
            from.lastFiredArm = from.lastFiredArm === 'left' ? 'right' : 'left';

            from.pelvisAggregate.body.applyImpulse(
                new BABYLON.Vector3((isPlayer ? -1 : 1) * weapon.knockback * 0.25, 0, 0),
                from.pelvis.getAbsolutePosition()
            );

            if (weapon.isBeam) fireBeam(from, to, weapon);
            else if (weapon.isCluster) fireCluster(from, to, weapon);
            else fireProjectile(from, to, weapon);

            log(`${from.name} fires ${weapon.name}!`);
        }

        function fireProjectile(from, to, weapon) {
            const arm = from.lastFiredArm === 'left' ? from.leftArm : from.rightArm;
            const start = arm.weaponPod.getAbsolutePosition();
            start.z += 0.5;
            const target = to.torso.getAbsolutePosition();
            target.x += (Math.random() - 0.5) * 0.4;
            target.y += (Math.random() - 0.5) * 0.4;

            const dir = target.subtract(start).normalize();
            const proj = BABYLON.MeshBuilder.CreateSphere('proj' + Date.now(), { diameter: weapon.projectileSize * 2 }, scene);
            proj.position = start.clone();

            const mat = new BABYLON.StandardMaterial('projMat' + Date.now(), scene);
            mat.emissiveColor = weapon.color;
            proj.material = mat;

            const agg = new BABYLON.PhysicsAggregate(proj, BABYLON.PhysicsShapeType.SPHERE,
                { mass: 0.8, friction: 0, restitution: 0.1 }, scene);
            agg.body.setLinearVelocity(dir.scale(weapon.projectileSpeed));

            projectiles.push({ mesh: proj, aggregate: agg, weapon, target: to, firedAt: Date.now() });
            createMuzzleFlash(start, weapon.color);
        }

        function fireBeam(from, to, weapon) {
            const arm = from.lastFiredArm === 'left' ? from.leftArm : from.rightArm;
            const start = arm.weaponPod.getAbsolutePosition();
            start.z += 0.6;
            const end = to.torso.getAbsolutePosition();

            const beam = BABYLON.MeshBuilder.CreateTube('beam' + Date.now(), {
                path: [start, end], radius: 0.1, updatable: false
            }, scene);
            const mat = new BABYLON.StandardMaterial('beamMat' + Date.now(), scene);
            mat.emissiveColor = weapon.color;
            mat.alpha = 0.85;
            beam.material = mat;

            beams.push({ mesh: beam, material: mat, createdAt: Date.now(), duration: weapon.beamDuration });
            applyDamage(to, weapon, from.isPlayer ? 1 : -1);
            createImpact(end.clone(), weapon.color);
        }

        function fireCluster(from, to, weapon) {
            const arm = from.lastFiredArm === 'left' ? from.leftArm : from.rightArm;
            const start = arm.weaponPod.getAbsolutePosition();
            const target = to.torso.getAbsolutePosition();

            for (let i = 0; i < weapon.clusterCount; i++) {
                setTimeout(() => {
                    const spread = target.clone();
                    spread.x += (Math.random() - 0.5) * 2;
                    spread.y += (Math.random() - 0.5) * 1.5;
                    spread.z += (Math.random() - 0.5) * 1;

                    const dir = spread.subtract(start).normalize();
                    dir.y += 0.18;
                    dir.normalize();

                    const missile = BABYLON.MeshBuilder.CreateBox('missile' + Date.now() + i, {
                        width: 0.06, height: 0.06, depth: 0.18
                    }, scene);
                    missile.position = start.clone();
                    missile.lookAt(spread);

                    const mat = new BABYLON.StandardMaterial('missileMat' + Date.now(), scene);
                    mat.emissiveColor = weapon.color.scale(0.6);
                    missile.material = mat;

                    const agg = new BABYLON.PhysicsAggregate(missile, BABYLON.PhysicsShapeType.BOX,
                        { mass: 0.25, friction: 0, restitution: 0 }, scene);
                    agg.body.setLinearVelocity(dir.scale(weapon.projectileSpeed));

                    projectiles.push({
                        mesh: missile, aggregate: agg,
                        weapon: { ...weapon, damage: weapon.damage / weapon.clusterCount },
                        target: to, firedAt: Date.now(), isMissile: true
                    });
                }, i * 40);
            }
            createMuzzleFlash(start, weapon.color);
        }

        function applyDamage(mech, weapon, dirSign) {
            mech.currentHP -= weapon.damage;
            if (mech.currentHP < 0) mech.currentHP = 0;

            const impactDir = new BABYLON.Vector3(dirSign, 0, 0);
            mech.pelvisAggregate.body.applyImpulse(impactDir.scale(weapon.knockback), mech.pelvis.getAbsolutePosition());

            mech.impactRecovery = Math.min(1.0, weapon.knockback / 18);
            mech.impactDirection = impactDir;

            if (weapon.damage >= 22) {
                mech.staggerTime = 0.45;
                log(`${mech.name} STAGGERS!`, 'warn');
            }

            mech.pelvisAggregate.body.applyAngularImpulse(new BABYLON.Vector3(
                (Math.random() - 0.5) * weapon.knockback * 0.08,
                (Math.random() - 0.5) * weapon.knockback * 0.04,
                dirSign * weapon.knockback * 0.12
            ));

            if (mech.currentHP <= 0) {
                log(`${mech.name} DESTROYED!`, 'error');
                triggerDestruction(mech);
            }
        }

        function updateProjectiles(dt) {
            const now = Date.now();
            projectiles = projectiles.filter(p => {
                if (now - p.firedAt > 3500) { p.mesh.dispose(); return false; }

                const dist = BABYLON.Vector3.Distance(p.mesh.position, p.target.torso.getAbsolutePosition());
                if (dist < 1.6) {
                    applyDamage(p.target, p.weapon, p.target.isPlayer ? -1 : 1);
                    log(`HIT! ${p.target.name} -${p.weapon.damage} (${p.target.currentHP}/${p.target.maxHP})`, 'warn');
                    createImpact(p.mesh.position.clone(), p.weapon.color);
                    p.mesh.dispose();
                    return false;
                }

                if (p.mesh.position.y < -2 || Math.abs(p.mesh.position.x) > 22) {
                    p.mesh.dispose();
                    return false;
                }

                if (p.isMissile && Math.random() < 0.25) createSmoke(p.mesh.position.clone());
                return true;
            });
        }

        function updateBeams() {
            const now = Date.now();
            beams = beams.filter(b => {
                const age = now - b.createdAt;
                if (age > b.duration) { b.mesh.dispose(); return false; }
                b.material.alpha = 0.85 * (1 - age / b.duration);
                return true;
            });
        }

        // ============================================
        // EFFECTS
        // ============================================
        function createMuzzleFlash(pos, color) {
            const flash = BABYLON.MeshBuilder.CreateSphere('flash', { diameter: 0.35 }, scene);
            flash.position = pos;
            const mat = new BABYLON.StandardMaterial('flashMat', scene);
            mat.emissiveColor = color;
            mat.disableLighting = true;
            flash.material = mat;

            let a = 1;
            const int = setInterval(() => {
                a -= 0.18;
                if (a <= 0) { clearInterval(int); flash.dispose(); }
                else flash.scaling.setAll(a);
            }, 16);
        }

        function createImpact(pos, color) {
            const ps = new BABYLON.ParticleSystem('impact', 60, scene);
            ps.particleTexture = new BABYLON.Texture('https://assets.babylonjs.com/textures/flare.png', scene);
            ps.emitter = pos;
            ps.color1 = new BABYLON.Color4(color.r, color.g, color.b, 1);
            ps.color2 = new BABYLON.Color4(color.r * 0.5, color.g * 0.5, color.b * 0.5, 1);
            ps.colorDead = new BABYLON.Color4(0.15, 0.1, 0, 0);
            ps.minSize = 0.08; ps.maxSize = 0.35;
            ps.minLifeTime = 0.12; ps.maxLifeTime = 0.35;
            ps.emitRate = 250; ps.manualEmitCount = 40;
            ps.minEmitPower = 3; ps.maxEmitPower = 7;
            ps.direction1 = new BABYLON.Vector3(-1, 1, -1);
            ps.direction2 = new BABYLON.Vector3(1, 1.5, 1);
            ps.gravity = new BABYLON.Vector3(0, -10, 0);
            ps.start();
            ps.targetStopDuration = 0.18;
            ps.disposeOnStop = true;
        }

        function createSmoke(pos) {
            const s = BABYLON.MeshBuilder.CreateSphere('smoke', { diameter: 0.08 }, scene);
            s.position = pos;
            const mat = new BABYLON.StandardMaterial('smokeMat', scene);
            mat.diffuseColor = new BABYLON.Color3(0.35, 0.35, 0.35);
            mat.alpha = 0.45;
            s.material = mat;

            let life = 0.4;
            const int = setInterval(() => {
                life -= 0.04;
                if (life <= 0) { clearInterval(int); s.dispose(); }
                else { s.scaling.scaleInPlace(1.06); mat.alpha = life; }
            }, 45);
        }

        function triggerDestruction(mech) {
            const pos = mech.pelvis.getAbsolutePosition();
            const mechName = mech.isPlayer ? 'TIMBER WOLF' : 'DIRE WOLF';

            // ========================================
            // SCREEN FLASH - bright orange/white
            // ========================================
            const flashPlane = BABYLON.MeshBuilder.CreatePlane('flash', { size: 100 }, scene);
            flashPlane.position = camera.position.add(camera.getForwardRay().direction.scale(5));
            flashPlane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
            const flashMat = new BABYLON.StandardMaterial('flashMat', scene);
            flashMat.emissiveColor = new BABYLON.Color3(1, 0.6, 0.2);
            flashMat.disableLighting = true;
            flashMat.alpha = 0.8;
            flashPlane.material = flashMat;

            let flashAlpha = 0.8;
            const flashFade = setInterval(() => {
                flashAlpha -= 0.04;
                if (flashAlpha <= 0) {
                    clearInterval(flashFade);
                    flashPlane.dispose();
                } else {
                    flashMat.alpha = flashAlpha;
                }
            }, 30);

            // ========================================
            // CAMERA SHAKE
            // ========================================
            const originalCamPos = camera.position.clone();
            let shakeTime = 0;
            const shakeInterval = setInterval(() => {
                shakeTime += 30;
                if (shakeTime > 1500) {
                    clearInterval(shakeInterval);
                    camera.position = originalCamPos;
                } else {
                    const intensity = 0.5 * (1 - shakeTime / 1500);
                    camera.position = originalCamPos.add(new BABYLON.Vector3(
                        (Math.random() - 0.5) * intensity,
                        (Math.random() - 0.5) * intensity * 0.5,
                        (Math.random() - 0.5) * intensity
                    ));
                }
            }, 30);

            // ========================================
            // MASSIVE CHAIN EXPLOSIONS
            // ========================================
            // Initial big explosion at center
            for (let i = 0; i < 3; i++) {
                createImpact(pos.clone(), new BABYLON.Color3(1, 0.4, 0));
            }

            // Ring of explosions spreading outward
            for (let i = 0; i < 16; i++) {
                setTimeout(() => {
                    const angle = (Math.PI * 2 * i) / 16;
                    const dist = 1.5 + Math.random() * 1.5;
                    createImpact(pos.add(new BABYLON.Vector3(
                        Math.cos(angle) * dist,
                        Math.random() * 2,
                        Math.sin(angle) * dist * 0.5
                    )), Math.random() > 0.5 ? COLORS.thruster : new BABYLON.Color3(1, 0.6, 0));
                }, i * 60);
            }

            // Delayed secondary explosions
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    createImpact(pos.add(new BABYLON.Vector3(
                        (Math.random() - 0.5) * 4,
                        Math.random() * 3,
                        (Math.random() - 0.5) * 2
                    )), new BABYLON.Color3(1, 0.3 + Math.random() * 0.4, 0));
                }, 500 + i * 100);
            }

            // ========================================
            // DRAMATIC "DESTROYED!" TEXT
            // ========================================
            const destroyedText = document.createElement('div');
            destroyedText.textContent = `${mechName} DESTROYED!`;
            destroyedText.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 72px;
                font-weight: bold;
                font-family: monospace;
                color: ${mech.isPlayer ? '#ff4444' : '#00ff88'};
                text-shadow: 0 0 30px ${mech.isPlayer ? '#ff0000' : '#00ff00'},
                             0 0 60px ${mech.isPlayer ? '#ff0000' : '#00ff00'},
                             4px 4px 0 #000;
                z-index: 9999;
                pointer-events: none;
                animation: destroyPulse 0.15s ease-in-out infinite;
            `;
            document.body.appendChild(destroyedText);

            // Add animation keyframes
            if (!document.getElementById('destroy-animation-style')) {
                const style = document.createElement('style');
                style.id = 'destroy-animation-style';
                style.textContent = `
                    @keyframes destroyPulse {
                        0%, 100% { transform: translate(-50%, -50%) scale(1); }
                        50% { transform: translate(-50%, -50%) scale(1.05); }
                    }
                `;
                document.head.appendChild(style);
            }

            // Fade out and remove text
            let textOpacity = 1;
            setTimeout(() => {
                const fadeText = setInterval(() => {
                    textOpacity -= 0.03;
                    if (textOpacity <= 0) {
                        clearInterval(fadeText);
                        destroyedText.remove();
                    } else {
                        destroyedText.style.opacity = textOpacity;
                        // Float upward
                        const currentTop = parseFloat(destroyedText.style.top) || 50;
                        destroyedText.style.top = (currentTop - 0.5) + '%';
                    }
                }, 30);
            }, 1500);

            // ========================================
            // MAKE MECH COLLAPSE DRAMATICALLY
            // ========================================
            mech.pelvisAggregate.body.setLinearDamping(0.08);
            mech.pelvisAggregate.body.setAngularDamping(0.08);

            // Massive angular impulse to make it spin and fall
            mech.pelvisAggregate.body.applyAngularImpulse(new BABYLON.Vector3(
                (Math.random() - 0.5) * 50,
                (Math.random() - 0.5) * 25,
                (Math.random() - 0.5) * 50
            ));

            // Strong upward then falling impulse
            mech.pelvisAggregate.body.applyImpulse(
                new BABYLON.Vector3(
                    (Math.random() - 0.5) * 15,
                    8 + Math.random() * 5,
                    (Math.random() - 0.5) * 8
                ),
                mech.pelvis.getAbsolutePosition()
            );

            log(` ${mechName} HAS BEEN DESTROYED! `, 'error');
        }

        // ============================================
        // CONTROLS
        // ============================================
        function toggleWalking(isPlayer) {
            const mech = isPlayer ? playerMech : enemyMech;
            if (!mech) return;
            mech.isWalking = !mech.isWalking;
            log(`${mech.name} ${mech.isWalking ? 'walking' : 'stopped'}`);
        }

        function resetScene() {
            // Disable AI battle mode
            autoFireEnabled = false;
            const btn = document.getElementById('autoFireBtn');
            btn.textContent = 'AI Battle: OFF';
            btn.style.background = 'rgba(255, 200, 0, 0.3)';
            btn.style.borderColor = '#ffcc00';
            btn.style.color = '#ffcc00';

            if (playerMech) {
                playerMech.pelvis.position = new BABYLON.Vector3(-7, 3.5, 0);
                playerMech.pelvisAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                playerMech.pelvisAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());
                playerMech.pelvisAggregate.body.setAngularDamping(0.92);
                playerMech.pelvisAggregate.body.setLinearDamping(0.25);
                playerMech.currentHP = playerMech.maxHP;
                playerMech.isWalking = false;
                playerMech.impactRecovery = 0;
                playerMech.recoilRecovery = 0;
                playerMech.torso.rotation.setAll(0);
                // Reset AI state
                playerMech.ai.enabled = false;
                playerMech.ai.state = 'idle';
                playerMech.ai.lastDecision = 0;
                playerMech.ai.strafeDir = 0;
                playerMech.ai.strafeEndTime = 0;
            }
            if (enemyMech) {
                enemyMech.pelvis.position = new BABYLON.Vector3(7, 3.8, 0);
                enemyMech.pelvisAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                enemyMech.pelvisAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());
                enemyMech.pelvisAggregate.body.setAngularDamping(0.93);
                enemyMech.pelvisAggregate.body.setLinearDamping(0.3);
                enemyMech.currentHP = enemyMech.maxHP;
                enemyMech.isWalking = false;
                enemyMech.impactRecovery = 0;
                enemyMech.recoilRecovery = 0;
                enemyMech.torso.rotation.setAll(0);
                // Reset AI state
                enemyMech.ai.enabled = false;
                enemyMech.ai.state = 'idle';
                enemyMech.ai.lastDecision = 0;
                enemyMech.ai.strafeDir = 0;
                enemyMech.ai.strafeEndTime = 0;
            }

            projectiles.forEach(p => p.mesh.dispose());
            projectiles = [];
            beams.forEach(b => b.mesh.dispose());
            beams = [];

            // Reset cooldowns
            weaponCooldowns.player = { erlaser: 0, lrm: 0, ac: 0 };
            weaponCooldowns.enemy = { erlaser: 0, lrm: 0, ac: 0 };

            log('Scene reset');
        }

        // ============================================
        // AI BATTLE SYSTEM
        // ============================================
        function toggleAutoFire() {
            autoFireEnabled = !autoFireEnabled;
            const btn = document.getElementById('autoFireBtn');

            if (autoFireEnabled) {
                btn.textContent = 'AI Battle: ON';
                btn.style.background = 'rgba(0, 255, 136, 0.4)';
                btn.style.borderColor = '#00ff88';
                btn.style.color = '#00ff88';
                battleEnded = false;  // Allow AI loop to run again
                log('AI ENABLED - mechs will fight autonomously!');

                // Clear debug logs for fresh start
                debugLogs.length = 0;
                lastDebugTime = 0;
                dbg('=== AI BATTLE STARTED ===', 'ai');

                // Enable AI on both mechs with proper initialization
                if (playerMech) {
                    playerMech.ai.enabled = true;
                    playerMech.ai.state = 'advancing';
                    playerMech.ai.lastDecision = gameTime; // Prevent immediate state override
                    playerMech.isWalking = true;
                    playerMech.walkDirection = 1; // Start moving toward enemy
                    const pos = playerMech.pelvis.getAbsolutePosition();
                    const body = playerMech.pelvisAggregate.body;
                    dbg(`P init: pos=(${pos.x.toFixed(1)},${pos.y.toFixed(1)}) ai.enabled=${playerMech.ai.enabled} state=${playerMech.ai.state}`, 'ai');
                    dbg(`P body: mass=${body.getMassProperties().mass} type=${body.motionType}`, 'phys');
                }
                if (enemyMech) {
                    enemyMech.ai.enabled = true;
                    enemyMech.ai.state = 'advancing';
                    enemyMech.ai.lastDecision = gameTime; // Prevent immediate state override
                    enemyMech.isWalking = true;
                    enemyMech.walkDirection = -1; // Start moving toward player
                    const pos = enemyMech.pelvis.getAbsolutePosition();
                    const body = enemyMech.pelvisAggregate.body;
                    dbg(`E init: pos=(${pos.x.toFixed(1)},${pos.y.toFixed(1)}) ai.enabled=${enemyMech.ai.enabled} state=${enemyMech.ai.state}`, 'ai');
                    dbg(`E body: mass=${body.getMassProperties().mass} type=${body.motionType}`, 'phys');
                }
            } else {
                btn.textContent = 'AI Battle: OFF';
                btn.style.background = 'rgba(255, 200, 0, 0.3)';
                btn.style.borderColor = '#ffcc00';
                btn.style.color = '#ffcc00';
                battleEnded = true;  // Stop the AI loop
                log('AI DISABLED');

                // Disable AI on both mechs
                if (playerMech) {
                    playerMech.ai.enabled = false;
                    playerMech.ai.state = 'idle';
                    playerMech.isWalking = false;
                }
                if (enemyMech) {
                    enemyMech.ai.enabled = false;
                    enemyMech.ai.state = 'idle';
                    enemyMech.isWalking = false;
                }
            }
        }

        function checkBattleEnd() {
            if (battleEnded) return;  // Already ended
            if (!autoFireEnabled || !playerMech || !enemyMech) return;
            if (playerMech.currentHP <= 0 || enemyMech.currentHP <= 0) {
                battleEnded = true;  // Stop all AI loops
                autoFireEnabled = false;
                const btn = document.getElementById('autoFireBtn');
                btn.textContent = 'AI Battle: OFF';
                btn.style.background = 'rgba(255, 200, 0, 0.3)';
                btn.style.borderColor = '#ffcc00';
                btn.style.color = '#ffcc00';

                if (playerMech) playerMech.ai.enabled = false;
                if (enemyMech) enemyMech.ai.enabled = false;

                const winner = playerMech.currentHP > 0 ? 'TIMBER WOLF' : 'DIRE WOLF';
                log(`Battle ended! ${winner} WINS!`, 'warn');
            }
        }

        function updateUI() {
            // Triangle count
            const triCount = document.getElementById('triCount');
            if (triCount && scene) {
                triCount.textContent = scene.getActiveIndices() / 3 | 0;
            }

            // Calculate distance between mechs
            let distance = 0;
            if (playerMech && enemyMech) {
                distance = BABYLON.Vector3.Distance(
                    playerMech.pelvis.getAbsolutePosition(),
                    enemyMech.pelvis.getAbsolutePosition()
                );
            }

            if (playerMech) {
                document.getElementById('playerHP').style.width = (playerMech.currentHP / playerMech.maxHP * 100) + '%';
                document.getElementById('playerHPText').textContent = `HP: ${playerMech.currentHP}/${playerMech.maxHP}`;

                let stateText = '';
                if (playerMech.currentHP <= 0) {
                    stateText = 'DESTROYED';
                } else if (playerMech.staggerTime > 0) {
                    stateText = 'Staggered!';
                } else if (playerMech.ai.enabled) {
                    stateText = playerMech.ai.state.toUpperCase();
                } else {
                    stateText = playerMech.isWalking ? 'Walking' : 'Idle';
                }
                document.getElementById('playerState').textContent = stateText;
            }
            if (enemyMech) {
                document.getElementById('enemyHP').style.width = (enemyMech.currentHP / enemyMech.maxHP * 100) + '%';
                document.getElementById('enemyHPText').textContent = `HP: ${enemyMech.currentHP}/${enemyMech.maxHP}`;

                let stateText = '';
                if (enemyMech.currentHP <= 0) {
                    stateText = 'DESTROYED';
                } else if (enemyMech.staggerTime > 0) {
                    stateText = 'Staggered!';
                } else if (enemyMech.ai.enabled) {
                    stateText = `${enemyMech.ai.state.toUpperCase()} (${distance.toFixed(1)}m)`;
                } else {
                    stateText = enemyMech.isWalking ? 'Walking' : 'Idle';
                }
                document.getElementById('enemyState').textContent = stateText;
            }
        }

        initEngine();
    </script>
</body>
</html>
