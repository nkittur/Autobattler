<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>BattleTech Arena - MechBuilder</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            padding: 0;
            background: #0a0a12;
            font-family: 'Courier New', monospace;
            color: #00ff88;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        /* ============================================
           GAME CONTAINER
           ============================================ */
        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        /* ============================================
           MECHBUILDER UI OVERLAY
           ============================================ */
        #mechBuilderUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
        }

        /* Top bar - Stats Panel */
        #statsPanel {
            pointer-events: auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: linear-gradient(180deg, rgba(0,20,10,0.95) 0%, rgba(0,20,10,0.7) 100%);
            border-bottom: 2px solid #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.3);
        }

        .stat-group {
            display: flex;
            gap: 30px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .stat-label {
            font-size: 10px;
            color: #00aa66;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-bar {
            width: 150px;
            height: 16px;
            background: rgba(0,0,0,0.6);
            border: 1px solid #00ff88;
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }

        .stat-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .stat-fill.weight {
            background: linear-gradient(90deg, #00ff88, #88ffaa);
        }

        .stat-fill.energy {
            background: linear-gradient(90deg, #00aaff, #88ddff);
        }

        .stat-fill.over-limit {
            background: linear-gradient(90deg, #ff4444, #ff8888);
        }

        .stat-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            color: #fff;
            text-shadow: 0 0 4px #000;
        }

        #gameTitle {
            font-size: 18px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            letter-spacing: 2px;
        }

        #battleReadyBtn {
            pointer-events: auto;
            padding: 12px 30px;
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #battleReadyBtn:hover:not(:disabled) {
            background: rgba(0, 255, 136, 0.4);
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
        }

        #battleReadyBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #666;
            color: #666;
        }

        #battleReadyBtn.ready {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(0,255,136,0.3); }
            50% { box-shadow: 0 0 25px rgba(0,255,136,0.7); }
        }

        /* Middle area - Grid Overlays */
        #gridOverlayContainer {
            flex: 1;
            position: relative;
            pointer-events: none;
        }

        .mech-grid-overlay {
            position: absolute;
            pointer-events: auto;
            display: grid;
            gap: 2px;
            padding: 4px;
            background: rgba(0, 20, 10, 0.9);
            border: 2px solid rgba(0, 255, 136, 0.6);
            border-radius: 4px;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }

        .grid-cell {
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 136, 0.15);
            border: 1px solid rgba(0, 255, 136, 0.5);
            border-radius: 2px;
            transition: all 0.2s ease;
        }

        .grid-cell:hover {
            background: rgba(0, 255, 136, 0.25);
            border-color: #00ff88;
        }

        .grid-cell.valid-drop {
            background: rgba(0, 255, 136, 0.4);
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0,255,136,0.5);
        }

        .grid-cell.invalid-drop {
            background: rgba(255, 68, 68, 0.4);
            border-color: #ff4444;
            box-shadow: 0 0 10px rgba(255,68,68,0.5);
        }

        .grid-cell.occupied {
            background: rgba(0, 170, 255, 0.3);
            border-color: #00aaff;
        }

        .grid-label {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #00aa66;
            text-transform: uppercase;
            letter-spacing: 1px;
            white-space: nowrap;
        }

        /* Bottom area - The Bench (Hand) */
        #benchContainer {
            pointer-events: auto;
            padding: 15px 20px;
            background: linear-gradient(0deg, rgba(0,20,10,0.95) 0%, rgba(0,20,10,0.7) 100%);
            border-top: 2px solid #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.3);
        }

        #benchLabel {
            font-size: 12px;
            color: #00aa66;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        #bench {
            display: flex;
            gap: 15px;
            overflow-x: auto;
            padding: 10px 0;
            min-height: 100px;
        }

        .bench-item {
            flex-shrink: 0;
            width: 80px;
            height: 80px;
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: grab;
            transition: all 0.2s ease;
            position: relative;
        }

        .bench-item:hover {
            background: rgba(0, 255, 136, 0.2);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,255,136,0.3);
        }

        .bench-item:active {
            cursor: grabbing;
        }

        .bench-item.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .bench-item .item-icon {
            font-size: 28px;
            margin-bottom: 4px;
        }

        .bench-item .item-name {
            font-size: 9px;
            color: #00ff88;
            text-align: center;
            padding: 0 4px;
        }

        .bench-item .item-shape {
            display: none;  /* Hidden, replaced by visual grid */
        }

        .bench-item .shape-preview {
            display: grid;
            gap: 1px;
            margin-top: 4px;
        }

        .bench-item .shape-cell {
            width: 10px;
            height: 10px;
            background: currentColor;
            opacity: 0.6;
            border-radius: 1px;
        }

        .bench-item .shape-cell.empty {
            background: transparent;
        }

        .bench-item.weapon { border-color: #ff6644; }
        .bench-item.weapon .item-icon { color: #ff6644; }
        .bench-item.armor { border-color: #4488ff; }
        .bench-item.armor .item-icon { color: #4488ff; }
        .bench-item.reactor { border-color: #ffaa00; }
        .bench-item.reactor .item-icon { color: #ffaa00; }
        .bench-item.system { border-color: #aa44ff; }
        .bench-item.system .item-icon { color: #aa44ff; }

        /* Drag ghost element */
        #dragGhost {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.9;
            transform: translate(-50%, -50%) scale(1.1);
            transition: transform 0.1s ease;
        }

        #dragGhost .ghost-grid {
            display: grid;
            gap: 2px;
            padding: 4px;
            background: rgba(0, 255, 136, 0.3);
            border: 2px solid #00ff88;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
        }

        #dragGhost .ghost-cell {
            width: 38px;
            height: 38px;
            background: rgba(0, 255, 136, 0.5);
            border: 1px solid #00ff88;
            border-radius: 2px;
        }

        #dragGhost.invalid .ghost-grid {
            background: rgba(255, 68, 68, 0.3);
            border-color: #ff4444;
            box-shadow: 0 0 20px rgba(255,68,68,0.5);
        }

        #dragGhost.invalid .ghost-cell {
            background: rgba(255, 68, 68, 0.5);
            border-color: #ff4444;
        }

        /* Placed items on grid */
        .placed-item {
            position: absolute;
            display: grid;
            gap: 2px;
            padding: 2px;
            background: rgba(0, 170, 255, 0.2);
            border: 2px solid #00aaff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .placed-item:hover {
            background: rgba(0, 170, 255, 0.3);
            box-shadow: 0 0 10px rgba(0,170,255,0.5);
        }

        .placed-item .placed-cell {
            width: 36px;
            height: 36px;
            background: rgba(0, 170, 255, 0.3);
            border: 1px solid rgba(0, 170, 255, 0.6);
            border-radius: 2px;
        }

        .placed-item.weapon { border-color: #ff6644; background: rgba(255,102,68,0.2); }
        .placed-item.weapon .placed-cell { background: rgba(255,102,68,0.3); border-color: rgba(255,102,68,0.6); }
        .placed-item.armor { border-color: #4488ff; background: rgba(68,136,255,0.2); }
        .placed-item.armor .placed-cell { background: rgba(68,136,255,0.3); border-color: rgba(68,136,255,0.6); }
        .placed-item.reactor { border-color: #ffaa00; background: rgba(255,170,0,0.2); }
        .placed-item.reactor .placed-cell { background: rgba(255,170,0,0.3); border-color: rgba(255,170,0,0.6); }
        .placed-item.system { border-color: #aa44ff; background: rgba(170,68,255,0.2); }
        .placed-item.system .placed-cell { background: rgba(170,68,255,0.3); border-color: rgba(170,68,255,0.6); }

        /* Instructions overlay */
        #instructions {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,20,10,0.9);
            border: 1px solid #00aa66;
            border-radius: 6px;
            padding: 10px 20px;
            font-size: 11px;
            color: #00aa66;
            text-align: center;
            pointer-events: none;
        }

        /* Hidden during battle */
        .battle-mode #mechBuilderUI {
            display: none;
        }

        /* ============================================
           BATTLE UI (from original)
           ============================================ */
        #battleUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
        }

        .battle-mode #battleUI {
            display: block;
        }

        #battleControls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }

        #battleControls button {
            padding: 8px 16px;
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
        }

        #battleControls button:hover {
            background: rgba(0, 255, 136, 0.4);
        }

        #battleStatus {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            border: 2px solid #00ff88;
            border-radius: 8px;
            padding: 10px 20px;
            display: flex;
            gap: 20px;
            pointer-events: auto;
        }

        .team-status {
            text-align: center;
        }

        .team-status.player { color: #00ff88; }
        .team-status.enemy { color: #ff4444; }

        .hp-bar {
            width: 150px;
            height: 12px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin: 4px 0;
        }

        .hp-fill {
            height: 100%;
            transition: width 0.3s;
        }

        .hp-fill.player { background: linear-gradient(90deg, #00aa55, #00ff88); }
        .hp-fill.enemy { background: linear-gradient(90deg, #aa2222, #ff4444); }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="renderCanvas"></canvas>

        <!-- MechBuilder UI Overlay -->
        <div id="mechBuilderUI">
            <!-- Top Stats Panel -->
            <div id="statsPanel">
                <div class="stat-group">
                    <div class="stat-item">
                        <span class="stat-label">Weight</span>
                        <div class="stat-bar">
                            <div class="stat-fill weight" id="weightFill" style="width: 0%"></div>
                            <span class="stat-text" id="weightText">0 / 100</span>
                        </div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Energy</span>
                        <div class="stat-bar">
                            <div class="stat-fill energy" id="energyFill" style="width: 0%"></div>
                            <span class="stat-text" id="energyText">0 / 50</span>
                        </div>
                    </div>
                </div>

                <div id="gameTitle">MECHBUILDER</div>

                <button id="battleReadyBtn" disabled>Battle Ready</button>
            </div>

            <!-- Grid Overlay Container (positioned over 3D mech) -->
            <div id="gridOverlayContainer">
                <!-- Grids will be dynamically positioned here -->
            </div>

            <!-- Bottom Bench (Hand) -->
            <div id="benchContainer">
                <div id="benchLabel">Equipment Bench - Drag items to mech slots</div>
                <div id="bench">
                    <!-- Items populated by JS -->
                </div>
            </div>

            <div id="instructions">
                Drag equipment from the bench onto the mech's grid slots â€¢ Click placed items to return them
            </div>
        </div>

        <!-- Battle UI Overlay (hidden during builder) -->
        <div id="battleUI">
            <div id="battleControls">
                <button id="autoFireBtn" onclick="toggleAutoFire()">AI Battle: OFF</button>
                <button id="cinematicBtn" onclick="toggleCinematicCamera()">Cinematic: OFF</button>
                <button onclick="returnToBuilder()">Back to Builder</button>
            </div>

            <div id="battleStatus">
                <div class="team-status player">
                    <strong>PLAYER TEAM</strong>
                    <div class="hp-bar"><div class="hp-fill player" id="playerHP" style="width: 100%"></div></div>
                    <div id="playerHPText">HP: 150/150</div>
                </div>
                <div class="team-status enemy">
                    <strong>ENEMY TEAM</strong>
                    <div class="hp-bar"><div class="hp-fill enemy" id="enemyHP" style="width: 100%"></div></div>
                    <div id="enemyHPText">HP: 200/200</div>
                </div>
            </div>
        </div>

        <!-- Drag Ghost (hidden until dragging) -->
        <div id="dragGhost" style="display: none;"></div>
    </div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>

    <script>
        // ============================================
        // GAME STATE & PHASE MANAGEMENT
        // ============================================
        const GamePhase = {
            MECHBUILDER: 'mechbuilder',
            BATTLE: 'battle'
        };

        let currentPhase = GamePhase.MECHBUILDER;
        let engine, scene, camera, havokInstance, havokPlugin;
        let builderCamera, battleCamera;
        let gameTime = 0;

        // ============================================
        // MECHBUILDER DATA STRUCTURES
        // ============================================

        // Mech Chassis Definition
        const MECH_CHASSIS = {
            id: 'starter_chassis',
            name: 'Timber Wolf Chassis',
            maxWeight: 100,
            baseEnergy: 50,
            slots: {
                torso: { cols: 3, rows: 3, position: { x: 0.5, y: 0.6 } },      // Center of screen
                leftArm: { cols: 2, rows: 4, position: { x: 0.25, y: 0.55 } },  // Left side
                rightArm: { cols: 2, rows: 4, position: { x: 0.75, y: 0.55 } }, // Right side
                leftLeg: { cols: 2, rows: 2, position: { x: 0.35, y: 0.85 } },  // Lower left
                rightLeg: { cols: 2, rows: 2, position: { x: 0.65, y: 0.85 } }  // Lower right
            }
        };

        // Item Definitions (The Deck)
        const ITEM_DATABASE = {
            railgun_mk1: {
                id: 'railgun_mk1',
                name: 'Rusty Railgun',
                type: 'WEAPON',
                category: 'weapon',
                icon: 'ðŸ”«',
                gridShape: [[1], [1], [1], [1]],  // 1x4 Vertical
                gridDimensions: { w: 1, h: 4 },
                stats: {
                    weight: 25,
                    energyDraw: 15,
                    damage: 100
                },
                constraints: {
                    validSlots: ['leftArm', 'rightArm']
                }
            },
            laser_array: {
                id: 'laser_array',
                name: 'ER Laser Array',
                type: 'WEAPON',
                category: 'weapon',
                icon: 'âš¡',
                gridShape: [[1, 1], [1, 1]],  // 2x2 Square
                gridDimensions: { w: 2, h: 2 },
                stats: {
                    weight: 18,
                    energyDraw: 20,
                    damage: 80
                },
                constraints: {
                    validSlots: ['torso', 'leftArm', 'rightArm']
                }
            },
            armor_plate: {
                id: 'armor_plate',
                name: 'Heavy Armor',
                type: 'ARMOR',
                category: 'armor',
                icon: 'ðŸ›¡ï¸',
                gridShape: [[1, 1], [1, 1]],  // 2x2 Square
                gridDimensions: { w: 2, h: 2 },
                stats: {
                    weight: 30,
                    energyDraw: 0,
                    armorBonus: 50
                },
                constraints: {
                    validSlots: ['torso', 'leftLeg', 'rightLeg']
                }
            },
            reactor_core: {
                id: 'reactor_core',
                name: 'Fusion Reactor',
                type: 'REACTOR',
                category: 'reactor',
                icon: 'âš›ï¸',
                gridShape: [[1], [1]],  // 1x2 Vertical
                gridDimensions: { w: 1, h: 2 },
                stats: {
                    weight: 20,
                    energyDraw: -30,  // Negative = provides energy
                    heatCapacity: 25
                },
                constraints: {
                    validSlots: ['torso']
                }
            },
            targeting_computer: {
                id: 'targeting_computer',
                name: 'Targeting System',
                type: 'SYSTEM',
                category: 'system',
                icon: 'ðŸŽ¯',
                gridShape: [[1]],  // 1x1 Single
                gridDimensions: { w: 1, h: 1 },
                stats: {
                    weight: 5,
                    energyDraw: 8,
                    accuracyBonus: 15
                },
                constraints: {
                    validSlots: ['torso', 'leftArm', 'rightArm']
                }
            }
        };

        // Current hand (drawn items)
        let currentHand = [];

        // Loadout state (items placed on mech)
        let loadoutState = {
            mechId: MECH_CHASSIS.id,
            equipment: []  // Array of { itemId, slot, position: {x, y}, rotation }
        };

        // Grid occupation tracking
        let gridOccupation = {};  // slot -> 2D array of item IDs or null

        // ============================================
        // 2D GRID DATA STRUCTURE CLASS
        // ============================================
        class InventoryGrid {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.cells = [];
                for (let y = 0; y < height; y++) {
                    this.cells[y] = [];
                    for (let x = 0; x < width; x++) {
                        this.cells[y][x] = null;  // null = empty, string = item ID
                    }
                }
            }

            canPlaceItem(item, posX, posY) {
                const shape = item.gridShape;
                const h = shape.length;
                const w = shape[0].length;

                // Check bounds
                if (posX < 0 || posY < 0 || posX + w > this.width || posY + h > this.height) {
                    return false;
                }

                // Check each cell of the shape
                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        if (shape[dy][dx] === 1) {
                            if (this.cells[posY + dy][posX + dx] !== null) {
                                return false;  // Cell occupied
                            }
                        }
                    }
                }
                return true;
            }

            placeItem(item, posX, posY, instanceId) {
                const shape = item.gridShape;
                const h = shape.length;
                const w = shape[0].length;

                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        if (shape[dy][dx] === 1) {
                            this.cells[posY + dy][posX + dx] = instanceId;
                        }
                    }
                }
            }

            removeItem(instanceId) {
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        if (this.cells[y][x] === instanceId) {
                            this.cells[y][x] = null;
                        }
                    }
                }
            }

            isCellOccupied(x, y) {
                if (x < 0 || y < 0 || x >= this.width || y >= this.height) return true;
                return this.cells[y][x] !== null;
            }
        }

        // Initialize grids for each slot
        function initializeGrids() {
            gridOccupation = {};
            for (const [slotName, slotDef] of Object.entries(MECH_CHASSIS.slots)) {
                gridOccupation[slotName] = new InventoryGrid(slotDef.cols, slotDef.rows);
            }
        }

        // ============================================
        // DECK / HAND SYSTEM
        // ============================================
        function drawHand(count = 5) {
            currentHand = [];
            const allItemIds = Object.keys(ITEM_DATABASE);

            // Separate items by category to ensure variety
            const weaponIds = allItemIds.filter(id => ITEM_DATABASE[id].category === 'weapon');
            const otherIds = allItemIds.filter(id => ITEM_DATABASE[id].category !== 'weapon');

            // Guarantee at least 2 weapons
            const guaranteedWeapons = 2;
            for (let i = 0; i < guaranteedWeapons && i < count; i++) {
                const randomId = weaponIds[Math.floor(Math.random() * weaponIds.length)];
                currentHand.push({
                    instanceId: `item_${Date.now()}_${i}`,
                    itemId: randomId,
                    ...ITEM_DATABASE[randomId]
                });
            }

            // Fill rest with random items
            for (let i = guaranteedWeapons; i < count; i++) {
                const randomId = allItemIds[Math.floor(Math.random() * allItemIds.length)];
                currentHand.push({
                    instanceId: `item_${Date.now()}_${i}`,
                    itemId: randomId,
                    ...ITEM_DATABASE[randomId]
                });
            }

            return currentHand;
        }

        // ============================================
        // DRAG & DROP SYSTEM
        // ============================================
        let dragState = {
            isDragging: false,
            item: null,
            sourceType: null,  // 'bench' or 'grid'
            sourceSlot: null,
            sourcePosition: null,
            startX: 0,
            startY: 0
        };

        let gridElements = {};  // Store references to grid DOM elements
        let placedItemElements = {};  // Store references to placed item DOM elements

        function initDragAndDrop() {
            const bench = document.getElementById('bench');
            const dragGhost = document.getElementById('dragGhost');

            // Touch/Mouse event handlers
            document.addEventListener('mousedown', handleDragStart);
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);

            document.addEventListener('touchstart', handleDragStart, { passive: false });
            document.addEventListener('touchmove', handleDragMove, { passive: false });
            document.addEventListener('touchend', handleDragEnd);
        }

        function handleDragStart(e) {
            const touch = e.touches ? e.touches[0] : e;
            const target = document.elementFromPoint(touch.clientX, touch.clientY);

            // Check if we clicked on a bench item
            const benchItem = target.closest('.bench-item');
            if (benchItem) {
                e.preventDefault();
                const instanceId = benchItem.dataset.instanceId;
                const item = currentHand.find(i => i.instanceId === instanceId);
                if (item) {
                    startDrag(item, 'bench', null, null, touch.clientX, touch.clientY);
                    benchItem.classList.add('dragging');
                }
                return;
            }

            // Check if we clicked on a placed item
            const placedItem = target.closest('.placed-item');
            if (placedItem) {
                e.preventDefault();
                const instanceId = placedItem.dataset.instanceId;
                const equipment = loadoutState.equipment.find(eq => eq.instanceId === instanceId);
                if (equipment) {
                    const item = { ...ITEM_DATABASE[equipment.itemId], instanceId };
                    startDrag(item, 'grid', equipment.slot, equipment.position, touch.clientX, touch.clientY);

                    // Remove from grid temporarily
                    removeItemFromGrid(instanceId, equipment.slot);
                    placedItem.style.opacity = '0.3';
                }
                return;
            }
        }

        function startDrag(item, sourceType, sourceSlot, sourcePosition, x, y) {
            dragState = {
                isDragging: true,
                item: item,
                sourceType: sourceType,
                sourceSlot: sourceSlot,
                sourcePosition: sourcePosition,
                startX: x,
                startY: y
            };

            // Create ghost element
            const ghost = document.getElementById('dragGhost');
            ghost.innerHTML = createGhostHTML(item);
            ghost.style.display = 'block';
            ghost.style.left = x + 'px';
            ghost.style.top = y + 'px';
        }

        function createGhostHTML(item) {
            const shape = item.gridShape;
            const h = shape.length;
            const w = shape[0].length;

            let cellsHTML = '';
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    if (shape[y][x] === 1) {
                        cellsHTML += '<div class="ghost-cell"></div>';
                    }
                }
            }

            return `<div class="ghost-grid" style="grid-template-columns: repeat(${w}, 38px);">${cellsHTML}</div>`;
        }

        function handleDragMove(e) {
            if (!dragState.isDragging) return;
            e.preventDefault();

            const touch = e.touches ? e.touches[0] : e;
            const ghost = document.getElementById('dragGhost');
            ghost.style.left = touch.clientX + 'px';
            ghost.style.top = touch.clientY + 'px';

            // Check for valid drop target
            const dropInfo = getDropTarget(touch.clientX, touch.clientY);
            updateDropHighlight(dropInfo);

            // Update ghost validity
            if (dropInfo && dropInfo.valid) {
                ghost.classList.remove('invalid');
            } else if (dropInfo) {
                ghost.classList.add('invalid');
            }
        }

        function handleDragEnd(e) {
            if (!dragState.isDragging) return;

            const touch = e.changedTouches ? e.changedTouches[0] : e;
            const dropInfo = getDropTarget(touch.clientX, touch.clientY);

            if (dropInfo && dropInfo.valid) {
                // Place item on grid
                placeItemOnGrid(dragState.item, dropInfo.slot, dropInfo.gridX, dropInfo.gridY);

                // Remove from bench if it came from there
                if (dragState.sourceType === 'bench') {
                    const idx = currentHand.findIndex(i => i.instanceId === dragState.item.instanceId);
                    if (idx !== -1) currentHand.splice(idx, 1);
                }
            } else if (dragState.sourceType === 'grid') {
                // Return to original position
                placeItemOnGrid(
                    dragState.item,
                    dragState.sourceSlot,
                    dragState.sourcePosition.x,
                    dragState.sourcePosition.y
                );
            }

            // Cleanup
            cleanupDrag();
            renderBench();
            renderGridItems();
            updateStats();
        }

        function cleanupDrag() {
            document.querySelectorAll('.bench-item.dragging').forEach(el => el.classList.remove('dragging'));
            document.querySelectorAll('.placed-item').forEach(el => el.style.opacity = '1');
            document.querySelectorAll('.grid-cell').forEach(el => {
                el.classList.remove('valid-drop', 'invalid-drop');
            });

            const ghost = document.getElementById('dragGhost');
            ghost.style.display = 'none';
            ghost.classList.remove('invalid');

            dragState = {
                isDragging: false,
                item: null,
                sourceType: null,
                sourceSlot: null,
                sourcePosition: null,
                startX: 0,
                startY: 0
            };
        }

        function getDropTarget(clientX, clientY) {
            if (!dragState.item) return null;

            // Check each grid
            for (const [slotName, gridEl] of Object.entries(gridElements)) {
                const rect = gridEl.getBoundingClientRect();
                // Account for label offset (label is at top: -20px)
                const labelOffset = 20;
                const adjustedTop = rect.top + labelOffset;

                if (clientX >= rect.left && clientX <= rect.right &&
                    clientY >= adjustedTop && clientY <= rect.bottom) {

                    // Calculate grid cell position
                    const cellSize = 42;  // 40px + 2px gap
                    const localX = clientX - rect.left - 4;  // Account for padding
                    const localY = clientY - adjustedTop - 4;  // Account for label and padding

                    const item = dragState.item;
                    const shape = item.gridShape;
                    const itemW = shape[0].length;
                    const itemH = shape.length;

                    // Calculate raw grid position, then center the item on cursor
                    let gridX = Math.floor(localX / cellSize) - Math.floor(itemW / 2);
                    let gridY = Math.floor(localY / cellSize) - Math.floor(itemH / 2);

                    // Clamp to valid bounds
                    const slotDef = MECH_CHASSIS.slots[slotName];
                    gridX = Math.max(0, Math.min(gridX, slotDef.cols - itemW));
                    gridY = Math.max(0, Math.min(gridY, slotDef.rows - itemH));

                    // Check if item can be placed at this position
                    const grid = gridOccupation[slotName];
                    const canPlace = grid.canPlaceItem(item, gridX, gridY);

                    // Check slot constraints
                    const validSlot = !item.constraints.validSlots ||
                                      item.constraints.validSlots.includes(slotName);

                    return {
                        slot: slotName,
                        gridX: gridX,
                        gridY: gridY,
                        valid: canPlace && validSlot
                    };
                }
            }

            return null;
        }

        function updateDropHighlight(dropInfo) {
            // Clear all highlights
            document.querySelectorAll('.grid-cell').forEach(el => {
                el.classList.remove('valid-drop', 'invalid-drop');
            });

            if (!dropInfo || !dragState.item) return;

            const gridEl = gridElements[dropInfo.slot];
            if (!gridEl) return;

            const item = dragState.item;
            const shape = item.gridShape;
            const cells = gridEl.querySelectorAll('.grid-cell');
            const slotDef = MECH_CHASSIS.slots[dropInfo.slot];

            // Highlight cells that would be covered
            for (let dy = 0; dy < shape.length; dy++) {
                for (let dx = 0; dx < shape[0].length; dx++) {
                    if (shape[dy][dx] === 1) {
                        const cellX = dropInfo.gridX + dx;
                        const cellY = dropInfo.gridY + dy;

                        // Check bounds before calculating index
                        if (cellX < 0 || cellX >= slotDef.cols || cellY < 0 || cellY >= slotDef.rows) {
                            continue;  // Skip out-of-bounds cells
                        }

                        const cellIdx = cellY * slotDef.cols + cellX;

                        if (cellIdx >= 0 && cellIdx < cells.length) {
                            cells[cellIdx].classList.add(dropInfo.valid ? 'valid-drop' : 'invalid-drop');
                        }
                    }
                }
            }
        }

        function placeItemOnGrid(item, slot, gridX, gridY) {
            const instanceId = item.instanceId;

            // Add to loadout state
            loadoutState.equipment.push({
                instanceId: instanceId,
                itemId: item.id || item.itemId,
                slot: slot,
                position: { x: gridX, y: gridY },
                rotation: 0
            });

            // Mark grid cells as occupied
            gridOccupation[slot].placeItem(item, gridX, gridY, instanceId);
        }

        function removeItemFromGrid(instanceId, slot) {
            // Remove from loadout
            const idx = loadoutState.equipment.findIndex(eq => eq.instanceId === instanceId);
            if (idx !== -1) {
                loadoutState.equipment.splice(idx, 1);
            }

            // Clear grid cells
            gridOccupation[slot].removeItem(instanceId);
        }

        // Click to remove placed item
        function handlePlacedItemClick(instanceId) {
            const equipment = loadoutState.equipment.find(eq => eq.instanceId === instanceId);
            if (!equipment) return;

            const item = { ...ITEM_DATABASE[equipment.itemId], instanceId };

            // Remove from grid
            removeItemFromGrid(instanceId, equipment.slot);

            // Add back to bench
            currentHand.push(item);

            renderBench();
            renderGridItems();
            updateStats();
        }

        // ============================================
        // UI RENDERING
        // ============================================
        function renderBench() {
            const bench = document.getElementById('bench');
            bench.innerHTML = '';

            currentHand.forEach(item => {
                const el = document.createElement('div');
                el.className = `bench-item ${item.category}`;
                el.dataset.instanceId = item.instanceId;

                // Build shape preview HTML
                const shape = item.gridShape;
                const w = shape[0].length;
                const h = shape.length;
                let shapeHTML = `<div class="shape-preview" style="grid-template-columns: repeat(${w}, 10px);">`;
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const filled = shape[y][x] === 1;
                        shapeHTML += `<div class="shape-cell${filled ? '' : ' empty'}"></div>`;
                    }
                }
                shapeHTML += '</div>';

                el.innerHTML = `
                    <span class="item-icon">${item.icon}</span>
                    <span class="item-name">${item.name}</span>
                    ${shapeHTML}
                `;
                bench.appendChild(el);
            });
        }

        function renderGridOverlays() {
            const container = document.getElementById('gridOverlayContainer');
            container.innerHTML = '';
            gridElements = {};

            const containerRect = container.getBoundingClientRect();

            for (const [slotName, slotDef] of Object.entries(MECH_CHASSIS.slots)) {
                const gridEl = document.createElement('div');
                gridEl.className = 'mech-grid-overlay';
                gridEl.dataset.slot = slotName;
                gridEl.style.gridTemplateColumns = `repeat(${slotDef.cols}, 40px)`;

                // Position based on relative coords
                const left = slotDef.position.x * containerRect.width - (slotDef.cols * 21);
                const top = slotDef.position.y * containerRect.height - (slotDef.rows * 21);
                gridEl.style.left = left + 'px';
                gridEl.style.top = top + 'px';

                // Add label
                const label = document.createElement('span');
                label.className = 'grid-label';
                label.textContent = slotName.replace(/([A-Z])/g, ' $1').trim();
                gridEl.appendChild(label);

                // Create grid cells
                for (let y = 0; y < slotDef.rows; y++) {
                    for (let x = 0; x < slotDef.cols; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.x = x;
                        cell.dataset.y = y;
                        gridEl.appendChild(cell);
                    }
                }

                container.appendChild(gridEl);
                gridElements[slotName] = gridEl;
            }
        }

        function renderGridItems() {
            // Remove old placed items
            document.querySelectorAll('.placed-item').forEach(el => el.remove());

            // Update cell states
            for (const [slotName, gridEl] of Object.entries(gridElements)) {
                const cells = gridEl.querySelectorAll('.grid-cell');
                const grid = gridOccupation[slotName];
                const slotDef = MECH_CHASSIS.slots[slotName];

                cells.forEach((cell, idx) => {
                    const x = idx % slotDef.cols;
                    const y = Math.floor(idx / slotDef.cols);
                    cell.classList.toggle('occupied', grid.isCellOccupied(x, y));
                });
            }

            // Render placed items
            loadoutState.equipment.forEach(eq => {
                const item = ITEM_DATABASE[eq.itemId];
                const gridEl = gridElements[eq.slot];
                if (!gridEl || !item) return;

                const placedEl = document.createElement('div');
                placedEl.className = `placed-item ${item.category}`;
                placedEl.dataset.instanceId = eq.instanceId;

                const shape = item.gridShape;
                const w = shape[0].length;
                const h = shape.length;

                placedEl.style.gridTemplateColumns = `repeat(${w}, 36px)`;
                placedEl.style.left = (4 + eq.position.x * 42) + 'px';
                placedEl.style.top = (24 + eq.position.y * 42) + 'px';  // Account for label

                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        if (shape[dy][dx] === 1) {
                            const cell = document.createElement('div');
                            cell.className = 'placed-cell';
                            placedEl.appendChild(cell);
                        }
                    }
                }

                // Click to remove
                placedEl.addEventListener('click', (e) => {
                    if (!dragState.isDragging) {
                        handlePlacedItemClick(eq.instanceId);
                    }
                });

                gridEl.appendChild(placedEl);
            });
        }

        function updateStats() {
            let totalWeight = 0;
            let totalEnergyDraw = 0;

            loadoutState.equipment.forEach(eq => {
                const item = ITEM_DATABASE[eq.itemId];
                if (item && item.stats) {
                    totalWeight += item.stats.weight || 0;
                    totalEnergyDraw += item.stats.energyDraw || 0;
                }
            });

            const maxWeight = MECH_CHASSIS.maxWeight;
            const maxEnergy = MECH_CHASSIS.baseEnergy;

            // Update weight bar
            const weightFill = document.getElementById('weightFill');
            const weightText = document.getElementById('weightText');
            const weightPercent = Math.min((totalWeight / maxWeight) * 100, 100);
            weightFill.style.width = weightPercent + '%';
            weightText.textContent = `${totalWeight} / ${maxWeight}`;
            weightFill.classList.toggle('over-limit', totalWeight > maxWeight);

            // Update energy bar (energy draw vs available energy)
            const energyFill = document.getElementById('energyFill');
            const energyText = document.getElementById('energyText');
            const effectiveEnergy = Math.max(0, totalEnergyDraw);  // Negative draw = energy provided
            const energyPercent = Math.min((effectiveEnergy / maxEnergy) * 100, 100);
            energyFill.style.width = energyPercent + '%';
            energyText.textContent = `${effectiveEnergy} / ${maxEnergy}`;
            energyFill.classList.toggle('over-limit', effectiveEnergy > maxEnergy);

            // Update battle ready button
            const btn = document.getElementById('battleReadyBtn');
            const isValid = totalWeight <= maxWeight && effectiveEnergy <= maxEnergy && loadoutState.equipment.length > 0;
            btn.disabled = !isValid;
            btn.classList.toggle('ready', isValid);
        }

        // ============================================
        // 3D SCENE - MECHBUILDER VIEW
        // ============================================
        let builderMech = null;
        let outlineMaterial = null;

        function createBuilderScene() {
            // Create orthographic camera for blueprint view
            const aspectRatio = engine.getRenderWidth() / engine.getRenderHeight();
            const orthoSize = 4;

            builderCamera = new BABYLON.ArcRotateCamera('builderCam',
                -Math.PI/2, Math.PI/2.5, 10,
                new BABYLON.Vector3(0, 1.5, 0), scene);
            builderCamera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
            builderCamera.orthoLeft = -orthoSize * aspectRatio;
            builderCamera.orthoRight = orthoSize * aspectRatio;
            builderCamera.orthoTop = orthoSize;
            builderCamera.orthoBottom = -orthoSize;
            builderCamera.attachControl(document.getElementById('renderCanvas'), true);

            // Ambient lighting for builder
            const hemi = new BABYLON.HemisphericLight('builderHemi', new BABYLON.Vector3(0, 1, 0), scene);
            hemi.intensity = 0.8;
            hemi.groundColor = new BABYLON.Color3(0.1, 0.2, 0.15);

            // Create outline/holographic material
            outlineMaterial = new BABYLON.StandardMaterial('outlineMat', scene);
            outlineMaterial.diffuseColor = new BABYLON.Color3(0, 0.4, 0.3);
            outlineMaterial.emissiveColor = new BABYLON.Color3(0, 0.8, 0.5);
            outlineMaterial.specularColor = new BABYLON.Color3(0, 1, 0.7);
            outlineMaterial.alpha = 0.7;
            outlineMaterial.wireframe = false;

            // Create dark background plane
            const bgPlane = BABYLON.MeshBuilder.CreatePlane('bgPlane', { size: 50 }, scene);
            bgPlane.position.z = 5;
            const bgMat = new BABYLON.StandardMaterial('bgMat', scene);
            bgMat.diffuseColor = new BABYLON.Color3(0.02, 0.04, 0.03);
            bgMat.emissiveColor = new BABYLON.Color3(0.01, 0.02, 0.015);
            bgPlane.material = bgMat;

            // Create grid floor for reference
            const gridSize = 10;
            const gridLines = [];
            for (let i = -gridSize; i <= gridSize; i++) {
                gridLines.push([new BABYLON.Vector3(i, 0, -gridSize), new BABYLON.Vector3(i, 0, gridSize)]);
                gridLines.push([new BABYLON.Vector3(-gridSize, 0, i), new BABYLON.Vector3(gridSize, 0, i)]);
            }
            const gridMesh = BABYLON.MeshBuilder.CreateLineSystem('grid', { lines: gridLines }, scene);
            gridMesh.color = new BABYLON.Color3(0, 0.3, 0.2);
            gridMesh.alpha = 0.3;

            // Create the mech model for builder view
            builderMech = createBuilderMechModel();

            scene.activeCamera = builderCamera;
        }

        function createBuilderMechModel() {
            // Create a simplified mech silhouette for the builder
            const mech = new BABYLON.TransformNode('builderMech', scene);

            // Torso (main body)
            const torso = BABYLON.MeshBuilder.CreateBox('torso', {
                width: 1.2, height: 1.0, depth: 0.8
            }, scene);
            torso.position.y = 2.2;
            torso.parent = mech;
            torso.material = outlineMaterial;

            // Torso upper
            const torsoUpper = BABYLON.MeshBuilder.CreateBox('torsoUpper', {
                width: 1.4, height: 0.5, depth: 0.9
            }, scene);
            torsoUpper.position.y = 0.6;
            torsoUpper.parent = torso;
            torsoUpper.material = outlineMaterial;

            // Head/cockpit
            const head = BABYLON.MeshBuilder.CreateBox('head', {
                width: 0.5, height: 0.4, depth: 0.5
            }, scene);
            head.position.y = 0.9;
            head.parent = torso;
            head.material = outlineMaterial;

            // Cockpit glass
            const cockpit = BABYLON.MeshBuilder.CreateBox('cockpit', {
                width: 0.4, height: 0.15, depth: 0.1
            }, scene);
            cockpit.position = new BABYLON.Vector3(0, 0, 0.28);
            cockpit.parent = head;
            const cockpitMat = new BABYLON.StandardMaterial('cockpitMat', scene);
            cockpitMat.diffuseColor = new BABYLON.Color3(0, 0.5, 0.5);
            cockpitMat.emissiveColor = new BABYLON.Color3(0, 0.8, 0.9);
            cockpitMat.alpha = 0.9;
            cockpit.material = cockpitMat;

            // Left Arm
            const leftArm = createBuilderArm('left', -0.9, torso);

            // Right Arm
            const rightArm = createBuilderArm('right', 0.9, torso);

            // Pelvis
            const pelvis = BABYLON.MeshBuilder.CreateBox('pelvis', {
                width: 0.9, height: 0.4, depth: 0.6
            }, scene);
            pelvis.position.y = 1.5;
            pelvis.parent = mech;
            pelvis.material = outlineMaterial;

            // Left Leg
            const leftLeg = createBuilderLeg('left', -0.4, pelvis);

            // Right Leg
            const rightLeg = createBuilderLeg('right', 0.4, pelvis);

            // Add edge rendering for holographic effect
            addEdgeRendering(mech);

            return mech;
        }

        function createBuilderArm(side, xOffset, parent) {
            const arm = new BABYLON.TransformNode(side + 'Arm', scene);
            arm.position.x = xOffset;
            arm.position.y = 0.3;
            arm.parent = parent;

            // Shoulder
            const shoulder = BABYLON.MeshBuilder.CreateSphere(side + 'Shoulder', {
                diameter: 0.4
            }, scene);
            shoulder.parent = arm;
            shoulder.material = outlineMaterial;

            // Upper arm
            const upperArm = BABYLON.MeshBuilder.CreateBox(side + 'UpperArm', {
                width: 0.25, height: 0.6, depth: 0.25
            }, scene);
            upperArm.position.y = -0.4;
            upperArm.parent = arm;
            upperArm.material = outlineMaterial;

            // Lower arm / weapon housing
            const lowerArm = BABYLON.MeshBuilder.CreateBox(side + 'LowerArm', {
                width: 0.35, height: 0.8, depth: 0.4
            }, scene);
            lowerArm.position.y = -1.0;
            lowerArm.parent = arm;
            lowerArm.material = outlineMaterial;

            return arm;
        }

        function createBuilderLeg(side, xOffset, parent) {
            const leg = new BABYLON.TransformNode(side + 'Leg', scene);
            leg.position.x = xOffset;
            leg.position.y = -0.2;
            leg.parent = parent;

            // Hip joint
            const hip = BABYLON.MeshBuilder.CreateSphere(side + 'Hip', {
                diameter: 0.3
            }, scene);
            hip.parent = leg;
            hip.material = outlineMaterial;

            // Upper leg (thigh)
            const upperLeg = BABYLON.MeshBuilder.CreateBox(side + 'UpperLeg', {
                width: 0.25, height: 0.5, depth: 0.3
            }, scene);
            upperLeg.position.y = -0.35;
            upperLeg.rotation.x = 0.3;
            upperLeg.parent = leg;
            upperLeg.material = outlineMaterial;

            // Knee
            const knee = BABYLON.MeshBuilder.CreateSphere(side + 'Knee', {
                diameter: 0.25
            }, scene);
            knee.position.y = -0.6;
            knee.position.z = 0.15;
            knee.parent = leg;
            knee.material = outlineMaterial;

            // Lower leg (shin)
            const lowerLeg = BABYLON.MeshBuilder.CreateBox(side + 'LowerLeg', {
                width: 0.3, height: 0.7, depth: 0.35
            }, scene);
            lowerLeg.position.y = -1.0;
            lowerLeg.position.z = 0.05;
            lowerLeg.rotation.x = -0.2;
            lowerLeg.parent = leg;
            lowerLeg.material = outlineMaterial;

            // Foot
            const foot = BABYLON.MeshBuilder.CreateBox(side + 'Foot', {
                width: 0.35, height: 0.15, depth: 0.5
            }, scene);
            foot.position.y = -1.45;
            foot.position.z = 0.1;
            foot.parent = leg;
            foot.material = outlineMaterial;

            return leg;
        }

        function addEdgeRendering(rootNode) {
            // Add edge rendering to all meshes
            const meshes = rootNode.getChildMeshes();
            meshes.forEach(mesh => {
                mesh.enableEdgesRendering();
                mesh.edgesWidth = 2.0;
                mesh.edgesColor = new BABYLON.Color4(0, 1, 0.6, 1);
            });
        }

        // ============================================
        // PHASE TRANSITIONS
        // ============================================
        function startBattle() {
            if (loadoutState.equipment.length === 0) {
                alert('Equip at least one item before battle!');
                return;
            }

            currentPhase = GamePhase.BATTLE;
            document.body.classList.add('battle-mode');

            // Serialize loadout for battle
            const loadoutJSON = JSON.stringify(loadoutState, null, 2);
            console.log('Battle Loadout:', loadoutJSON);

            // TODO: Initialize battle scene with loadout
            // For now, just switch UI
            console.log('Starting battle with loadout:', loadoutState);
        }

        function returnToBuilder() {
            currentPhase = GamePhase.MECHBUILDER;
            document.body.classList.remove('battle-mode');
            scene.activeCamera = builderCamera;
        }

        // Battle UI functions (stubs for now)
        let autoFireEnabled = false;
        let cinematicEnabled = false;

        function toggleAutoFire() {
            autoFireEnabled = !autoFireEnabled;
            const btn = document.getElementById('autoFireBtn');
            btn.textContent = autoFireEnabled ? 'AI Battle: ON' : 'AI Battle: OFF';
            btn.style.background = autoFireEnabled ? 'rgba(255, 68, 68, 0.3)' : 'rgba(0, 255, 136, 0.2)';
        }

        function toggleCinematicCamera() {
            cinematicEnabled = !cinematicEnabled;
            const btn = document.getElementById('cinematicBtn');
            btn.textContent = cinematicEnabled ? 'Cinematic: ON' : 'Cinematic: OFF';
        }

        // ============================================
        // ENGINE INITIALIZATION
        // ============================================
        async function initEngine() {
            const canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, {
                preserveDrawingBuffer: true,
                stencil: true,
                antialias: true
            });

            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.02, 0.04, 0.03, 1);

            // Initialize MechBuilder
            createBuilderScene();
            initializeGrids();

            // Draw initial hand
            drawHand(5);

            // Render UI
            renderBench();
            renderGridOverlays();
            renderGridItems();
            updateStats();

            // Initialize drag and drop
            initDragAndDrop();

            // Battle ready button
            document.getElementById('battleReadyBtn').addEventListener('click', startBattle);

            // Main render loop
            engine.runRenderLoop(() => {
                if (scene) {
                    scene.render();
                }
            });

            // Handle window resize
            window.addEventListener('resize', () => {
                engine.resize();
                // Re-render grid overlays on resize
                if (currentPhase === GamePhase.MECHBUILDER) {
                    setTimeout(() => {
                        renderGridOverlays();
                        renderGridItems();
                    }, 100);
                }
            });

            console.log('MechBuilder initialized!');
        }

        // Start the game
        initEngine();
    </script>
</body>
</html>
