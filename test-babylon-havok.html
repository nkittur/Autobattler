<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon.js + Havok Physics Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            font-family: monospace;
            color: #00ff88;
            overflow: auto;
            min-height: 100vh;
        }
        #renderCanvas {
            width: 100%;
            max-width: 900px;
            height: 50vh;
            max-height: 350px;
            display: block;
            margin: 0 auto;
            border: 3px solid #00ff88;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }
        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }
        #status {
            max-width: 900px;
            margin: 20px auto;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #00ff88;
            border-radius: 8px;
        }
        .log {
            font-size: 12px;
            margin: 2px 0;
            padding: 2px 5px;
        }
        .log.info { color: #00ff88; }
        .log.warn { color: #ffaa00; }
        .log.error { color: #ff4444; }
    </style>
</head>
<body>
    <h1>Babylon.js + Havok Physics Test</h1>
    <canvas id="renderCanvas"></canvas>
    <div id="status">
        <div id="logs"></div>
    </div>

    <!-- Babylon.js Core -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <!-- Havok Physics -->
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>

    <script>
        // Logging system
        const logs = [];
        function log(msg, type = 'info') {
            console.log(msg);
            logs.push({ msg, type });
            const logsDiv = document.getElementById('logs');
            logsDiv.innerHTML = logs.slice(-15).map(l =>
                `<div class="log ${l.type}">${l.msg}</div>`
            ).join('');
        }

        log('Initializing Babylon.js + Havok Physics...', 'info');

        // Global references
        let engine, scene, camera, havokInstance, havokPlugin;
        let playerMech, enemyMech;
        let projectiles = [];
        let laserBeams = [];

        // Colors
        const COLORS = {
            player: new BABYLON.Color3(0, 1, 0.53),     // #00ff88
            enemy: new BABYLON.Color3(1, 0.27, 0.27),   // #ff4444
            ground: new BABYLON.Color3(0.29, 0.29, 0.42), // #4a4a6a
            projectile: new BABYLON.Color3(1, 0.67, 0),  // #ffaa00
            laser: new BABYLON.Color3(1, 0, 0),          // Red
            explosion: new BABYLON.Color3(1, 0.4, 0)     // #ff6600
        };

        // Initialize Babylon.js and Havok
        async function initEngine() {
            const canvas = document.getElementById('renderCanvas');

            // Create Babylon engine
            engine = new BABYLON.Engine(canvas, true, {
                preserveDrawingBuffer: true,
                stencil: true
            });

            log('Babylon Engine created', 'info');

            // Initialize Havok Physics
            try {
                havokInstance = await HavokPhysics();
                log('Havok Physics initialized!', 'info');
            } catch (error) {
                log('Failed to load Havok: ' + error.message, 'error');
                return;
            }

            // Create scene
            scene = createScene();

            // Start render loop
            engine.runRenderLoop(() => {
                if (scene) {
                    scene.render();
                    updateProjectiles();
                    updateLaserBeams();
                    stabilizeMechs();
                }
            });

            // Handle resize
            window.addEventListener('resize', () => engine.resize());

            log('Scene created and render loop started!', 'info');
        }

        function createScene() {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.05, 0.05, 0.12); // Dark background

            // Create Havok physics plugin
            havokPlugin = new BABYLON.HavokPlugin(true, havokInstance);
            scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), havokPlugin);
            log('Physics enabled with Havok', 'info');

            // Create camera - fixed isometric-style view
            camera = new BABYLON.ArcRotateCamera(
                'camera',
                -Math.PI / 2,  // Alpha (horizontal rotation)
                Math.PI / 4,   // Beta (vertical angle - 45 degree isometric)
                18,            // Radius (distance)
                new BABYLON.Vector3(0, 3.5, 0), // Target (centered on mechs)
                scene
            );
            camera.attachControl(document.getElementById('renderCanvas'), true);
            camera.lowerRadiusLimit = 10;
            camera.upperRadiusLimit = 40;

            // Lighting
            const hemisphericLight = new BABYLON.HemisphericLight(
                'hemiLight',
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            hemisphericLight.intensity = 0.7;

            const directionalLight = new BABYLON.DirectionalLight(
                'dirLight',
                new BABYLON.Vector3(-1, -2, 1),
                scene
            );
            directionalLight.intensity = 0.5;

            // Create ground
            createGround(scene);

            // Create boundary walls
            createWalls(scene);

            // Create mechs (spawned at x position, they will drop to ground)
            try {
                playerMech = createMech(scene, -5, true);
                enemyMech = createMech(scene, 5, false);
                log('Scene fully initialized with mechs!', 'info');
            } catch (error) {
                log('CRITICAL ERROR creating mechs: ' + error.message, 'error');
                console.error('Full error:', error);
            }
            return scene;
        }

        function createGround(scene) {
            const ground = BABYLON.MeshBuilder.CreateGround('ground', {
                width: 30,
                height: 15
            }, scene);

            const groundMat = new BABYLON.StandardMaterial('groundMat', scene);
            groundMat.diffuseColor = COLORS.ground;
            groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            ground.material = groundMat;

            // Add physics to ground (static body)
            const groundAggregate = new BABYLON.PhysicsAggregate(
                ground,
                BABYLON.PhysicsShapeType.BOX,
                { mass: 0, friction: 0.8, restitution: 0.1 },
                scene
            );

            log('Ground created with physics', 'info');
            return ground;
        }

        function createWalls(scene) {
            // Create invisible boundary walls
            const wallHeight = 8;
            const wallThickness = 1;
            const arenaWidth = 30;
            const arenaDepth = 15;

            const wallMat = new BABYLON.StandardMaterial('wallMat', scene);
            wallMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.4);
            wallMat.alpha = 0.3;

            // Left wall
            const leftWall = BABYLON.MeshBuilder.CreateBox('leftWall', {
                width: wallThickness, height: wallHeight, depth: arenaDepth
            }, scene);
            leftWall.position = new BABYLON.Vector3(-arenaWidth/2, wallHeight/2, 0);
            leftWall.material = wallMat;
            new BABYLON.PhysicsAggregate(leftWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

            // Right wall
            const rightWall = BABYLON.MeshBuilder.CreateBox('rightWall', {
                width: wallThickness, height: wallHeight, depth: arenaDepth
            }, scene);
            rightWall.position = new BABYLON.Vector3(arenaWidth/2, wallHeight/2, 0);
            rightWall.material = wallMat;
            new BABYLON.PhysicsAggregate(rightWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

            // Front wall
            const frontWall = BABYLON.MeshBuilder.CreateBox('frontWall', {
                width: arenaWidth, height: wallHeight, depth: wallThickness
            }, scene);
            frontWall.position = new BABYLON.Vector3(0, wallHeight/2, arenaDepth/2);
            frontWall.material = wallMat;
            new BABYLON.PhysicsAggregate(frontWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

            // Back wall
            const backWall = BABYLON.MeshBuilder.CreateBox('backWall', {
                width: arenaWidth, height: wallHeight, depth: wallThickness
            }, scene);
            backWall.position = new BABYLON.Vector3(0, wallHeight/2, -arenaDepth/2);
            backWall.material = wallMat;
            new BABYLON.PhysicsAggregate(backWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

            log('Boundary walls created', 'info');
        }

        function createMech(scene, xPos, isPlayer) {
            try {
                const color = isPlayer ? COLORS.player : COLORS.enemy;
                const mechName = isPlayer ? 'player' : 'enemy';

                log(`Creating ${mechName} mech...`, 'info');

                // Create parent transform node (non-physics, just for grouping)
                const mechRoot = new BABYLON.TransformNode(`${mechName}_root`, scene);
                mechRoot.position = new BABYLON.Vector3(xPos, 0, 0);

                // Create materials
                const bodyMat = new BABYLON.StandardMaterial(`${mechName}_bodyMat`, scene);
                bodyMat.diffuseColor = color;
                bodyMat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                bodyMat.emissiveColor = color.scale(0.2);

                const darkMat = new BABYLON.StandardMaterial(`${mechName}_darkMat`, scene);
                darkMat.diffuseColor = color.scale(0.5);

                const jointMat = new BABYLON.StandardMaterial(`${mechName}_jointMat`, scene);
                jointMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                jointMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);

                const spawnY = 3.5; // Spawn height

                log(`Creating ${mechName} torso...`, 'info');

                // === TORSO (Main physics body) ===
                const torso = BABYLON.MeshBuilder.CreateBox(`${mechName}_torso`, {
                    width: 1.2, height: 1.5, depth: 0.8
                }, scene);
                torso.position = new BABYLON.Vector3(xPos, spawnY, 0);
                // Don't rotate physics bodies - causes constraint issues
                torso.material = bodyMat;

                // Add physics to torso
                const torsoAggregate = new BABYLON.PhysicsAggregate(
                    torso,
                    BABYLON.PhysicsShapeType.BOX,
                    { mass: 80, friction: 1.0, restitution: 0.05 },
                    scene
                );

                log(`${mechName} torso created with physics`, 'info');

                // Lock X/Z rotation for upright stability
                torsoAggregate.body.setMassProperties({
                    inertia: new BABYLON.Vector3(Infinity, 1, Infinity)
                });

                // Add damping to reduce oscillation
                torsoAggregate.body.setLinearDamping(0.1);
                torsoAggregate.body.setAngularDamping(0.5);

            // === HEAD ===
            const head = BABYLON.MeshBuilder.CreateBox(`${mechName}_head`, {
                width: 0.6, height: 0.5, depth: 0.5
            }, scene);
            head.position = new BABYLON.Vector3(0, 1.2, 0);
            head.parent = torso;
            head.material = bodyMat;

            // Visor
            const visor = BABYLON.MeshBuilder.CreateBox(`${mechName}_visor`, {
                width: 0.5, height: 0.15, depth: 0.1
            }, scene);
            visor.position = new BABYLON.Vector3(0, 0.1, 0.25);
            visor.parent = head;
            const visorMat = new BABYLON.StandardMaterial(`${mechName}_visorMat`, scene);
            visorMat.diffuseColor = new BABYLON.Color3(1, 0.2, 0);
            visorMat.emissiveColor = new BABYLON.Color3(1, 0.2, 0);
            visor.material = visorMat;

            // === ARMS ===
            const createArm = (side) => {
                const xSign = side === 'left' ? -1 : 1;
                const xOffset = xSign * 0.9;

                // Shoulder joint (visual only, parented to torso)
                const shoulder = BABYLON.MeshBuilder.CreateSphere(`${mechName}_${side}Shoulder`, {
                    diameter: 0.3
                }, scene);
                shoulder.position = new BABYLON.Vector3(xOffset, 0.65, 0);
                shoulder.parent = torso;
                shoulder.material = jointMat;

                // Upper arm (HAS PHYSICS - not parented!)
                const upperArm = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}UpperArm`, {
                    width: 0.25, height: 0.6, depth: 0.25
                }, scene);
                // Position so top of arm aligns with shoulder at spawnY + 0.65
                // Arm is 0.6 tall, so center should be at 0.65 - 0.3 = 0.35 above spawnY
                upperArm.position = new BABYLON.Vector3(xPos + xOffset, spawnY + 0.35, 0);
                // Don't rotate physics bodies - causes constraint issues
                upperArm.material = darkMat;

                // Add physics to arm
                const armAggregate = new BABYLON.PhysicsAggregate(
                    upperArm,
                    BABYLON.PhysicsShapeType.BOX,
                    { mass: 3, friction: 0.3, restitution: 0.1 },
                    scene
                );

                // Add damping to arms
                armAggregate.body.setLinearDamping(0.3);
                armAggregate.body.setAngularDamping(0.5);

                // Connect arm to torso with ball and socket joint
                let armConstraint = null;
                try {
                    armConstraint = new BABYLON.PhysicsConstraint(
                        BABYLON.PhysicsConstraintType.BALL_AND_SOCKET,
                        {
                            pivotA: new BABYLON.Vector3(xOffset, 0.65, 0),  // Pivot on torso (shoulder position)
                            pivotB: new BABYLON.Vector3(0, 0.3, 0),  // Pivot on arm (top of arm, half-height)
                            collision: false,  // Disable collision between connected bodies
                            axisA: new BABYLON.Vector3(0, 1, 0),
                            axisB: new BABYLON.Vector3(0, 1, 0),
                            maxAngle: Math.PI / 2  // Limit rotation to 90 degrees
                        },
                        scene
                    );
                    torsoAggregate.body.addConstraint(armAggregate.body, armConstraint);
                    log(`${side} arm constraint created`, 'info');
                } catch (e) {
                    log(`Error creating ${side} arm constraint: ${e.message}`, 'error');
                }

                // Lower arm / weapon (parented to upper arm for simplicity)
                const weapon = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}Weapon`, {
                    width: 0.2, height: 0.8, depth: 0.2
                }, scene);
                weapon.position = new BABYLON.Vector3(0, -0.7, 0);
                weapon.parent = upperArm;
                weapon.material = jointMat;

                // Weapon barrel
                const barrel = BABYLON.MeshBuilder.CreateCylinder(`${mechName}_${side}Barrel`, {
                    height: 0.4, diameter: 0.12
                }, scene);
                barrel.rotation.x = Math.PI / 2;
                barrel.position = new BABYLON.Vector3(0, -0.3, 0.25);
                barrel.parent = weapon;
                barrel.material = jointMat;

                return { upperArm, armAggregate, armConstraint, shoulder, weapon, barrel };
            };

            const leftArm = createArm('left');
            const rightArm = createArm('right');

            // === LEGS ===
            const createLeg = (side) => {
                const xSign = side === 'left' ? -1 : 1;
                const xOffset = xSign * 0.4;

                // Hip joint (visual only, parented to torso)
                const hip = BABYLON.MeshBuilder.CreateSphere(`${mechName}_${side}Hip`, {
                    diameter: 0.25
                }, scene);
                hip.position = new BABYLON.Vector3(xOffset, -0.85, 0);
                hip.parent = torso;
                hip.material = jointMat;

                // Upper leg (HAS PHYSICS - not parented!)
                const upperLeg = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}UpperLeg`, {
                    width: 0.3, height: 0.7, depth: 0.3
                }, scene);
                // Position so top of leg aligns with hip at spawnY - 0.85
                // Leg is 0.7 tall, so center should be at -0.85 - 0.35 = -1.2 from spawnY
                upperLeg.position = new BABYLON.Vector3(xPos + xOffset, spawnY - 1.2, 0);
                // Don't rotate physics bodies - causes constraint issues
                upperLeg.material = bodyMat;

                // Add physics to leg
                const legAggregate = new BABYLON.PhysicsAggregate(
                    upperLeg,
                    BABYLON.PhysicsShapeType.BOX,
                    { mass: 8, friction: 0.8, restitution: 0.05 },
                    scene
                );

                // Add damping to legs for stability
                legAggregate.body.setLinearDamping(0.2);
                legAggregate.body.setAngularDamping(0.7);

                // Connect leg to torso with ball and socket joint
                let legConstraint = null;
                try {
                    legConstraint = new BABYLON.PhysicsConstraint(
                        BABYLON.PhysicsConstraintType.BALL_AND_SOCKET,
                        {
                            pivotA: new BABYLON.Vector3(xOffset, -0.85, 0),  // Pivot on torso (hip position)
                            pivotB: new BABYLON.Vector3(0, 0.35, 0),  // Pivot on leg (top of leg, half-height)
                            collision: false,  // Disable collision between connected bodies
                            axisA: new BABYLON.Vector3(0, 1, 0),
                            axisB: new BABYLON.Vector3(0, 1, 0),
                            maxAngle: Math.PI / 6  // Limit rotation to 30 degrees for stability
                        },
                        scene
                    );
                    torsoAggregate.body.addConstraint(legAggregate.body, legConstraint);
                    log(`${side} leg constraint created`, 'info');
                } catch (e) {
                    log(`Error creating ${side} leg constraint: ${e.message}`, 'error');
                }

                // Knee joint (visual, parented to upper leg)
                const knee = BABYLON.MeshBuilder.CreateSphere(`${mechName}_${side}Knee`, {
                    diameter: 0.2
                }, scene);
                knee.position = new BABYLON.Vector3(0, -0.45, 0);
                knee.parent = upperLeg;
                knee.material = jointMat;

                // Lower leg (parented to upper leg)
                const lowerLeg = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}LowerLeg`, {
                    width: 0.25, height: 0.6, depth: 0.25
                }, scene);
                lowerLeg.position = new BABYLON.Vector3(0, -0.85, 0);
                lowerLeg.parent = upperLeg;
                lowerLeg.material = darkMat;

                // Foot (parented to lower leg)
                const foot = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}Foot`, {
                    width: 0.35, height: 0.15, depth: 0.5
                }, scene);
                foot.position = new BABYLON.Vector3(0, -0.38, 0.1);
                foot.parent = lowerLeg;
                foot.material = jointMat;

                return { hip, upperLeg, legAggregate, legConstraint, knee, lowerLeg, foot };
            };

            const leftLeg = createLeg('left');
            const rightLeg = createLeg('right');

            // === SHOULDER ARMOR ===
            const createShoulderArmor = (side) => {
                const xOffset = side === 'left' ? -0.85 : 0.85;
                const shoulderArmor = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}ShoulderArmor`, {
                    width: 0.5, height: 0.35, depth: 0.6
                }, scene);
                shoulderArmor.position = new BABYLON.Vector3(xOffset, 0.8, 0);
                shoulderArmor.parent = torso;
                shoulderArmor.material = bodyMat;
                return shoulderArmor;
            };

            createShoulderArmor('left');
            createShoulderArmor('right');

            // Store mech data
            const mechData = {
                root: mechRoot,
                torso: torso,
                torsoAggregate: torsoAggregate,
                head: head,
                visor: visor,
                leftArm: leftArm,
                rightArm: rightArm,
                leftLeg: leftLeg,
                rightLeg: rightLeg,
                isPlayer: isPlayer,
                currentHP: 100,
                maxHP: 100,
                color: color
            };

                // Ensure all meshes are visible
                torso.isVisible = true;
                head.isVisible = true;
                visor.isVisible = true;
                leftArm.upperArm.isVisible = true;
                rightArm.upperArm.isVisible = true;
                leftLeg.upperLeg.isVisible = true;
                rightLeg.upperLeg.isVisible = true;

                log(`${isPlayer ? 'Player' : 'Enemy'} mech created at torso: (${torso.position.x.toFixed(1)}, ${torso.position.y.toFixed(1)}, ${torso.position.z.toFixed(1)})`, 'info');
                return mechData;
            } catch (error) {
                log(`ERROR creating ${isPlayer ? 'player' : 'enemy'} mech: ${error.message}`, 'error');
                console.error('Mech creation error:', error);
                throw error;
            }
        }

        // === PROJECTILE SYSTEM ===
        function firePlayerProjectile() {
            if (!playerMech || !enemyMech) return;
            createProjectile(playerMech, enemyMech, 15);
        }

        function fireEnemyProjectile() {
            if (!playerMech || !enemyMech) return;
            createProjectile(enemyMech, playerMech, 12);
        }

        // Arm raising animation for firing
        function raiseArmsToFire(mech) {
            const leftArm = mech.leftArm.upperArm;
            const rightArm = mech.rightArm.upperArm;

            // Store original rotations if not already stored
            if (!leftArm.originalRotation) {
                leftArm.originalRotation = leftArm.rotation.clone();
                rightArm.originalRotation = rightArm.rotation.clone();
            }

            // Raise arms forward to firing position
            leftArm.rotation.z = -Math.PI / 3; // Raise left arm
            rightArm.rotation.z = Math.PI / 3; // Raise right arm

            // Lower arms back after a short delay
            setTimeout(() => {
                leftArm.rotation.z = leftArm.originalRotation.z;
                rightArm.rotation.z = rightArm.originalRotation.z;
            }, 300);
        }

        function createProjectile(fromMech, toMech, damage) {
            // Raise arms to firing position
            raiseArmsToFire(fromMech);

            // Get world positions (torso is parented to collisionBody, so use absolute position)
            const startPos = fromMech.torso.getAbsolutePosition().clone();
            startPos.y += 0.3; // Fire from weapon height

            const targetPos = toMech.torso.getAbsolutePosition().clone();

            log(`PROJECTILE: from (${startPos.x.toFixed(1)}, ${startPos.y.toFixed(1)}, ${startPos.z.toFixed(1)}) to (${targetPos.x.toFixed(1)}, ${targetPos.y.toFixed(1)}, ${targetPos.z.toFixed(1)})`, 'info');

            // Calculate direction
            const direction = targetPos.subtract(startPos).normalize();
            const angle = Math.atan2(direction.x, direction.z);

            // Create elongated projectile (bullet/energy bolt shape)
            const projectile = BABYLON.MeshBuilder.CreateCylinder('projectile_' + Date.now(), {
                height: 0.8,
                diameter: 0.25,
                tessellation: 8
            }, scene);
            projectile.position = startPos.clone();

            // Rotate to point in direction of travel
            projectile.rotation.x = Math.PI / 2;
            projectile.rotation.y = angle;

            // Projectile material with intense glow
            const projMat = new BABYLON.StandardMaterial('projMat_' + Date.now(), scene);
            projMat.diffuseColor = COLORS.projectile;
            projMat.emissiveColor = COLORS.projectile.scale(1.5); // Brighter glow
            projMat.specularColor = new BABYLON.Color3(1, 1, 1);
            projectile.material = projMat;

            // Create glowing trail effect
            const trail = BABYLON.MeshBuilder.CreateCylinder('trail_' + Date.now(), {
                height: 1.5,
                diameter: 0.15,
                tessellation: 8
            }, scene);
            trail.position = new BABYLON.Vector3(0, -0.5, 0);
            trail.parent = projectile;
            const trailMat = new BABYLON.StandardMaterial('trailMat_' + Date.now(), scene);
            trailMat.diffuseColor = COLORS.projectile;
            trailMat.emissiveColor = COLORS.projectile;
            trailMat.alpha = 0.6;
            trail.material = trailMat;

            // Add physics to projectile
            const projAggregate = new BABYLON.PhysicsAggregate(
                projectile,
                BABYLON.PhysicsShapeType.SPHERE,
                { mass: 0.3, friction: 0, restitution: 0.2 },
                scene
            );

            // Apply high velocity for fast, impactful shot
            const speed = 45;
            const velocity = direction.scale(speed);
            projAggregate.body.setLinearVelocity(velocity);

            // Store projectile data
            projectiles.push({
                mesh: projectile,
                aggregate: projAggregate,
                damage: damage,
                target: toMech,
                firedAt: Date.now(),
                fromPlayer: fromMech.isPlayer
            });

            log(`${fromMech.isPlayer ? 'Player' : 'Enemy'} fired projectile!`, 'info');
        }

        function updateProjectiles() {
            const now = Date.now();

            projectiles = projectiles.filter(proj => {
                // Remove old projectiles (after 5 seconds)
                if (now - proj.firedAt > 5000) {
                    proj.mesh.dispose();
                    return false;
                }

                // Check for collision with target - check all body parts
                const projPos = proj.mesh.position;

                // Check which body part was hit
                let hitPart = null;
                let hitPartName = 'torso';
                let minDist = Infinity;

                // Check torso
                const torsoPos = proj.target.torso.getAbsolutePosition();
                let dist = BABYLON.Vector3.Distance(projPos, torsoPos);
                if (dist < 1.2) {
                    hitPart = proj.target.torso;
                    hitPartName = 'torso';
                    minDist = dist;
                }

                // Check head
                const headPos = proj.target.head.getAbsolutePosition();
                dist = BABYLON.Vector3.Distance(projPos, headPos);
                if (dist < 0.6 && dist < minDist) {
                    hitPart = proj.target.head;
                    hitPartName = 'head';
                    minDist = dist;
                }

                // Check arms
                const leftArmPos = proj.target.leftArm.upperArm.getAbsolutePosition();
                dist = BABYLON.Vector3.Distance(projPos, leftArmPos);
                if (dist < 0.8 && dist < minDist) {
                    hitPart = proj.target.leftArm.upperArm;
                    hitPartName = 'left arm';
                    minDist = dist;
                }

                const rightArmPos = proj.target.rightArm.upperArm.getAbsolutePosition();
                dist = BABYLON.Vector3.Distance(projPos, rightArmPos);
                if (dist < 0.8 && dist < minDist) {
                    hitPart = proj.target.rightArm.upperArm;
                    hitPartName = 'right arm';
                    minDist = dist;
                }

                // Check legs
                const leftLegPos = proj.target.leftLeg.upperLeg.getAbsolutePosition();
                dist = BABYLON.Vector3.Distance(projPos, leftLegPos);
                if (dist < 0.8 && dist < minDist) {
                    hitPart = proj.target.leftLeg.upperLeg;
                    hitPartName = 'left leg';
                    minDist = dist;
                }

                const rightLegPos = proj.target.rightLeg.upperLeg.getAbsolutePosition();
                dist = BABYLON.Vector3.Distance(projPos, rightLegPos);
                if (dist < 0.8 && dist < minDist) {
                    hitPart = proj.target.rightLeg.upperLeg;
                    hitPartName = 'right leg';
                    minDist = dist;
                }

                if (hitPart) {
                    // Hit a body part!
                    proj.target.currentHP -= proj.damage;
                    log(`HIT ${hitPartName}! ${proj.fromPlayer ? 'Enemy' : 'Player'} takes ${proj.damage} damage! (${proj.target.currentHP}/${proj.target.maxHP} HP)`, 'warn');

                    // Create impact effect at hit location
                    createImpactEffect(projPos.clone());

                    // Flash the specific part that was hit
                    flashMeshOnHit(hitPart);

                    // Apply force to specific body part
                    if (hitPartName !== 'torso' && hitPartName !== 'head') {
                        const hitDir = projPos.subtract(hitPart.getAbsolutePosition()).normalize();

                        // Apply impulse to the specific limb's physics body
                        let limbAggregate = null;
                        if (hitPartName === 'left arm') limbAggregate = proj.target.leftArm.armAggregate;
                        else if (hitPartName === 'right arm') limbAggregate = proj.target.rightArm.armAggregate;
                        else if (hitPartName === 'left leg') limbAggregate = proj.target.leftLeg.legAggregate;
                        else if (hitPartName === 'right leg') limbAggregate = proj.target.rightLeg.legAggregate;

                        if (limbAggregate) {
                            const limbImpulse = hitDir.scale(20); // Strong impulse for dramatic swing
                            limbAggregate.body.applyImpulse(limbImpulse, hitPart.getAbsolutePosition());
                            log(`Applied impulse to ${hitPartName}`, 'info');
                        }
                    }

                    // Torso hit - apply knockback
                    if (hitPartName === 'torso') {
                        const targetWorldPos = proj.target.torso.position;
                        const knockbackDir = projPos.subtract(targetWorldPos).normalize().scale(-1);
                        proj.target.torsoAggregate.body.applyImpulse(
                            knockbackDir.scale(6), // Moderate knockback
                            targetWorldPos
                        );
                    }

                    proj.mesh.dispose();
                    return false;
                }

                // Check if projectile is out of bounds
                if (projPos.y < -5 || Math.abs(projPos.x) > 20 || Math.abs(projPos.z) > 10) {
                    proj.mesh.dispose();
                    return false;
                }

                return true;
            });
        }

        // === LASER BEAM SYSTEM ===
        function fireLaser(isPlayer) {
            const fromMech = isPlayer ? playerMech : enemyMech;
            const toMech = isPlayer ? enemyMech : playerMech;

            // Raise arms to firing position
            raiseArmsToFire(fromMech);

            // Get world positions (torso is parented to collisionBody, so use absolute position)
            const startPos = fromMech.torso.getAbsolutePosition().clone();
            startPos.y += 0.3;

            const endPos = toMech.torso.getAbsolutePosition().clone();

            log(`LASER: from (${startPos.x.toFixed(1)}, ${startPos.y.toFixed(1)}, ${startPos.z.toFixed(1)}) to (${endPos.x.toFixed(1)}, ${endPos.y.toFixed(1)}, ${endPos.z.toFixed(1)})`, 'info');

            // Create main laser beam (thick and bright)
            const points = [startPos, endPos];
            const laserBeam = BABYLON.MeshBuilder.CreateTube('laser_' + Date.now(), {
                path: points,
                radius: 0.2,
                updatable: false
            }, scene);

            // Laser material with intense glow
            const laserMat = new BABYLON.StandardMaterial('laserMat_' + Date.now(), scene);
            laserMat.diffuseColor = COLORS.laser;
            laserMat.emissiveColor = COLORS.laser.scale(2); // Very bright
            laserMat.alpha = 0.9;
            laserBeam.material = laserMat;

            // Create outer glow layer
            const glowBeam = BABYLON.MeshBuilder.CreateTube('laserGlow_' + Date.now(), {
                path: points,
                radius: 0.35,
                updatable: false
            }, scene);
            const glowMat = new BABYLON.StandardMaterial('glowMat_' + Date.now(), scene);
            glowMat.diffuseColor = COLORS.laser;
            glowMat.emissiveColor = COLORS.laser.scale(0.8);
            glowMat.alpha = 0.4;
            glowBeam.material = glowMat;

            // Detect which body part was hit by checking end position
            let hitPart = toMech.torso;
            let hitPartName = 'torso';
            let minDist = BABYLON.Vector3.Distance(endPos, toMech.torso.getAbsolutePosition());

            // Check head
            let dist = BABYLON.Vector3.Distance(endPos, toMech.head.getAbsolutePosition());
            if (dist < minDist) {
                hitPart = toMech.head;
                hitPartName = 'head';
                minDist = dist;
            }

            // Check arms
            dist = BABYLON.Vector3.Distance(endPos, toMech.leftArm.upperArm.getAbsolutePosition());
            if (dist < minDist) {
                hitPart = toMech.leftArm.upperArm;
                hitPartName = 'left arm';
                minDist = dist;
            }

            dist = BABYLON.Vector3.Distance(endPos, toMech.rightArm.upperArm.getAbsolutePosition());
            if (dist < minDist) {
                hitPart = toMech.rightArm.upperArm;
                hitPartName = 'right arm';
                minDist = dist;
            }

            // Check legs
            dist = BABYLON.Vector3.Distance(endPos, toMech.leftLeg.upperLeg.getAbsolutePosition());
            if (dist < minDist) {
                hitPart = toMech.leftLeg.upperLeg;
                hitPartName = 'left leg';
                minDist = dist;
            }

            dist = BABYLON.Vector3.Distance(endPos, toMech.rightLeg.upperLeg.getAbsolutePosition());
            if (dist < minDist) {
                hitPart = toMech.rightLeg.upperLeg;
                hitPartName = 'right leg';
            }

            // Apply damage immediately (laser is instant)
            const damage = 10;
            toMech.currentHP -= damage;
            log(`LASER HIT ${hitPartName}! ${isPlayer ? 'Enemy' : 'Player'} takes ${damage} damage! (${toMech.currentHP}/${toMech.maxHP} HP)`, 'warn');

            // Store both beams for fadeout
            laserBeams.push({
                mesh: laserBeam,
                glowMesh: glowBeam,
                material: laserMat,
                glowMaterial: glowMat,
                createdAt: Date.now(),
                duration: 200 // ms
            });

            // Create impact at target
            createImpactEffect(endPos.clone());

            // Flash the specific part that was hit
            flashMeshOnHit(hitPart);

            // Apply force to specific body part
            if (hitPartName !== 'torso' && hitPartName !== 'head') {
                const hitDir = endPos.subtract(hitPart.getAbsolutePosition()).normalize();

                // Apply impulse to the specific limb's physics body
                let limbAggregate = null;
                if (hitPartName === 'left arm') limbAggregate = toMech.leftArm.armAggregate;
                else if (hitPartName === 'right arm') limbAggregate = toMech.rightArm.armAggregate;
                else if (hitPartName === 'left leg') limbAggregate = toMech.leftLeg.legAggregate;
                else if (hitPartName === 'right leg') limbAggregate = toMech.rightLeg.legAggregate;

                if (limbAggregate) {
                    const limbImpulse = hitDir.scale(12); // Medium impulse for laser
                    limbAggregate.body.applyImpulse(limbImpulse, hitPart.getAbsolutePosition());
                }
            }

            // Torso hit - apply knockback
            if (hitPartName === 'torso') {
                const laserDir = endPos.subtract(startPos).normalize();
                toMech.torsoAggregate.body.applyImpulse(
                    laserDir.scale(4),
                    toMech.torso.position
                );
            }
        }

        function updateLaserBeams() {
            const now = Date.now();

            laserBeams = laserBeams.filter(beam => {
                const age = now - beam.createdAt;

                if (age > beam.duration) {
                    beam.mesh.dispose();
                    beam.glowMesh.dispose();
                    return false;
                }

                // Fade out both beams
                const fadeProgress = age / beam.duration;
                beam.material.alpha = 0.9 * (1 - fadeProgress);
                beam.glowMaterial.alpha = 0.4 * (1 - fadeProgress);
                return true;
            });
        }

        // Debug: Log mech positions periodically
        let lastDebugTime = 0;
        function debugMechPositions() {
            const now = Date.now();
            if (now - lastDebugTime < 3000) return; // Log every 3 seconds
            lastDebugTime = now;

            if (playerMech) {
                const pos = playerMech.torso.getAbsolutePosition();
                log(`Player at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`, 'info');
            }
            if (enemyMech) {
                const pos = enemyMech.torso.getAbsolutePosition();
                log(`Enemy at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`, 'info');
            }
        }

        // Active stabilization system to keep mechs standing upright
        function stabilizeMechs() {
            if (!playerMech || !enemyMech) return;

            debugMechPositions();

            [playerMech, enemyMech].forEach(mech => {
                // Apply corrective forces to legs to keep them vertical and supporting the torso
                const leftLeg = mech.leftLeg;
                const rightLeg = mech.rightLeg;
                const torso = mech.torso;

                // Get leg positions relative to torso
                const leftLegPos = leftLeg.upperLeg.getAbsolutePosition();
                const rightLegPos = rightLeg.upperLeg.getAbsolutePosition();
                const torsoPos = torso.getAbsolutePosition();

                // Only apply stabilization if torso is at reasonable height (not flying away)
                if (torsoPos.y < 10 && torsoPos.y > -5) {
                    // Apply strong upward force on legs to counter gravity and support torso
                    // Total mech mass ~102kg, gravity = 9.81, so need ~500N per leg
                    const legSupportForce = 500;
                    leftLeg.legAggregate.body.applyForce(
                        new BABYLON.Vector3(0, legSupportForce, 0),
                        leftLegPos
                    );
                    rightLeg.legAggregate.body.applyForce(
                        new BABYLON.Vector3(0, legSupportForce, 0),
                        rightLegPos
                    );
                }

                // Apply strong corrective torque to legs to keep them vertical
                const leftLegAngVel = leftLeg.legAggregate.body.getAngularVelocity();
                const rightLegAngVel = rightLeg.legAggregate.body.getAngularVelocity();

                // Strong damping torque to reduce angular velocity and prevent rotation
                leftLeg.legAggregate.body.applyTorque(leftLegAngVel.scale(-20));
                rightLeg.legAggregate.body.applyTorque(rightLegAngVel.scale(-20));

                // Keep legs from drifting away from torso
                const leftLegToTorso = torsoPos.subtract(leftLegPos);
                const rightLegToTorso = torsoPos.subtract(rightLegPos);

                // Only correct horizontal drift, not vertical
                leftLegToTorso.y = 0;
                rightLegToTorso.y = 0;

                // Apply strong centering force if legs drift
                if (leftLegToTorso.length() > 0.3) {
                    leftLeg.legAggregate.body.applyForce(
                        leftLegToTorso.normalize().scale(50),
                        leftLegPos
                    );
                }
                if (rightLegToTorso.length() > 0.3) {
                    rightLeg.legAggregate.body.applyForce(
                        rightLegToTorso.normalize().scale(50),
                        rightLegPos
                    );
                }
            });
        }

        // === EFFECTS ===

        function flashMeshOnHit(mesh) {
            // Store original material properties
            const material = mesh.material;
            if (!material) return;

            const originalEmissive = material.emissiveColor ? material.emissiveColor.clone() : new BABYLON.Color3(0, 0, 0);
            const originalDiffuse = material.diffuseColor ? material.diffuseColor.clone() : new BABYLON.Color3(1, 1, 1);

            // Flash bright red/white
            material.emissiveColor = new BABYLON.Color3(1, 0.3, 0.3);
            material.diffuseColor = new BABYLON.Color3(1.8, 0.8, 0.8);

            // Quick fade back through orange to original
            setTimeout(() => {
                if (material) {
                    material.emissiveColor = new BABYLON.Color3(1, 0.5, 0);
                    material.diffuseColor = new BABYLON.Color3(1.5, 1, 0.8);
                }
            }, 50);

            // Restore original colors after a short delay
            setTimeout(() => {
                if (material) {
                    material.emissiveColor = originalEmissive;
                    material.diffuseColor = originalDiffuse;
                }
            }, 150);
        }


        function createImpactEffect(position) {
            // Create particle system for impact
            const particleSystem = new BABYLON.ParticleSystem('impact_' + Date.now(), 100, scene);

            // Texture (procedural)
            particleSystem.particleTexture = new BABYLON.Texture('https://assets.babylonjs.com/textures/flare.png', scene);

            // Emitter
            particleSystem.emitter = position;
            particleSystem.minEmitBox = new BABYLON.Vector3(-0.2, -0.2, -0.2);
            particleSystem.maxEmitBox = new BABYLON.Vector3(0.2, 0.2, 0.2);

            // Colors - bright orange/yellow explosion
            particleSystem.color1 = new BABYLON.Color4(1, 0.8, 0, 1);
            particleSystem.color2 = new BABYLON.Color4(1, 0.3, 0, 1);
            particleSystem.colorDead = new BABYLON.Color4(0.3, 0.1, 0, 0);

            // Size - larger particles
            particleSystem.minSize = 0.15;
            particleSystem.maxSize = 0.5;

            // Lifetime
            particleSystem.minLifeTime = 0.15;
            particleSystem.maxLifeTime = 0.4;

            // Emission - burst of particles
            particleSystem.emitRate = 300;
            particleSystem.manualEmitCount = 60;

            // Speed - faster explosion
            particleSystem.minEmitPower = 3;
            particleSystem.maxEmitPower = 8;
            particleSystem.updateSpeed = 0.015;

            // Direction - spherical burst
            particleSystem.direction1 = new BABYLON.Vector3(-1, -0.5, -1);
            particleSystem.direction2 = new BABYLON.Vector3(1, 1, 1);

            // Gravity
            particleSystem.gravity = new BABYLON.Vector3(0, -8, 0);

            // Add glow/blend mode for more dramatic effect
            particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;

            // Start and auto-dispose
            particleSystem.start();
            particleSystem.targetStopDuration = 0.4;
            particleSystem.disposeOnStop = true;
        }

        function resetScene() {
            const resetHeight = 3.5;

            // Reset player mech
            if (playerMech) {
                playerMech.torso.position = new BABYLON.Vector3(-5, resetHeight, 0);
                playerMech.torsoAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                playerMech.torsoAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());

                // Reset arms
                playerMech.leftArm.upperArm.position = new BABYLON.Vector3(-5 - 0.9, resetHeight + 0.35, 0);
                playerMech.leftArm.armAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                playerMech.leftArm.armAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());

                playerMech.rightArm.upperArm.position = new BABYLON.Vector3(-5 + 0.9, resetHeight + 0.35, 0);
                playerMech.rightArm.armAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                playerMech.rightArm.armAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());

                // Reset legs
                playerMech.leftLeg.upperLeg.position = new BABYLON.Vector3(-5 - 0.4, resetHeight - 1.2, 0);
                playerMech.leftLeg.legAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                playerMech.leftLeg.legAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());

                playerMech.rightLeg.upperLeg.position = new BABYLON.Vector3(-5 + 0.4, resetHeight - 1.2, 0);
                playerMech.rightLeg.legAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                playerMech.rightLeg.legAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());

                playerMech.currentHP = playerMech.maxHP;
            }

            // Reset enemy mech
            if (enemyMech) {
                enemyMech.torso.position = new BABYLON.Vector3(5, resetHeight, 0);
                enemyMech.torsoAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                enemyMech.torsoAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());

                // Reset arms
                enemyMech.leftArm.upperArm.position = new BABYLON.Vector3(5 - 0.9, resetHeight + 0.35, 0);
                enemyMech.leftArm.armAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                enemyMech.leftArm.armAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());

                enemyMech.rightArm.upperArm.position = new BABYLON.Vector3(5 + 0.9, resetHeight + 0.35, 0);
                enemyMech.rightArm.armAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                enemyMech.rightArm.armAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());

                // Reset legs
                enemyMech.leftLeg.upperLeg.position = new BABYLON.Vector3(5 - 0.4, resetHeight - 1.2, 0);
                enemyMech.leftLeg.legAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                enemyMech.leftLeg.legAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());

                enemyMech.rightLeg.upperLeg.position = new BABYLON.Vector3(5 + 0.4, resetHeight - 1.2, 0);
                enemyMech.rightLeg.legAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                enemyMech.rightLeg.legAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());

                enemyMech.currentHP = enemyMech.maxHP;
            }

            // Clear projectiles
            projectiles.forEach(p => p.mesh.dispose());
            projectiles = [];

            // Clear laser beams
            laserBeams.forEach(b => b.mesh.dispose());
            laserBeams = [];

            log('Scene reset!', 'info');
        }

        // Auto-fire weapons periodically
        function startAutoFire() {
            setInterval(() => {
                if (playerMech && enemyMech && playerMech.currentHP > 0 && enemyMech.currentHP > 0) {
                    // Randomly fire weapons
                    if (Math.random() > 0.7) {
                        createProjectile(playerMech, enemyMech, 15);
                    }
                    if (Math.random() > 0.7) {
                        createProjectile(enemyMech, playerMech, 12);
                    }
                    if (Math.random() > 0.8) {
                        fireLaser(true);
                    }
                    if (Math.random() > 0.8) {
                        fireLaser(false);
                    }
                }
            }, 1000); // Fire every second
        }

        // Initialize when page loads
        initEngine().then(() => {
            // Start auto-fire after scene is initialized
            setTimeout(startAutoFire, 2000);
            log('Auto-fire enabled!', 'info');
        });
    </script>
</body>
</html>
