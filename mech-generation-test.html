<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mech Generation Test - Iconic Silhouettes</title>
    <style>
        body {
            margin: 0;
            padding: 15px;
            background: #1a1a2e;
            font-family: monospace;
            color: #00ff88;
            overflow-x: hidden;
        }
        #canvasContainer {
            position: relative;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }
        #renderCanvas {
            width: 100%;
            height: 70vh;
            max-height: 600px;
            display: block;
            border: 3px solid #00ff88;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            touch-action: none;
        }
        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin: 8px 0;
            font-size: 1.3em;
        }
        #controls {
            text-align: center;
            margin: 10px 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
        }
        button {
            padding: 8px 16px;
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            transition: background 0.2s;
        }
        button:hover {
            background: rgba(0, 255, 136, 0.4);
        }
        button.active {
            background: rgba(0, 255, 136, 0.5);
        }
        #stats {
            max-width: 1200px;
            margin: 10px auto;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #00ff88;
            border-radius: 8px;
        }
        #stats h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }
        #mechList {
            max-width: 1200px;
            margin: 10px auto;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #4488ff;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
        }
        #mechList h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #4488ff;
        }
        .mech-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            margin: 3px 0;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            font-size: 11px;
        }
        .mech-entry:hover {
            background: rgba(0,0,0,0.5);
        }
        .mech-name {
            font-weight: bold;
        }
        .mech-parts {
            color: #888;
            font-size: 10px;
        }
        .color-swatch {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 5px;
            vertical-align: middle;
        }
        #polyCount {
            text-align: center;
            font-size: 11px;
            color: #888;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1>Mech Generation - Iconic Silhouettes</h1>

    <div id="controls">
        <button onclick="generateNewMechs()">Regenerate All</button>
        <button onclick="addSingleMech()">Add Mech</button>
        <button onclick="clearAllMechs()">Clear All</button>
        <button onclick="toggleAnimation()" id="animToggle">Pause</button>
        <button onclick="toggleWireframe()" id="wireframeToggle">Wireframe</button>
        <button onclick="cycleCamera()">Camera</button>
    </div>

    <div id="canvasContainer">
        <canvas id="renderCanvas"></canvas>
    </div>

    <div id="polyCount">Triangles: <span id="triCount">0</span> | Meshes: <span id="drawCalls">0</span> | FPS: <span id="fps">0</span></div>

    <div id="stats">
        <h3>Stats</h3>
        <div class="stat-row">
            <span>Total Mechs:</span>
            <span id="mechCount">0</span>
        </div>
        <div class="stat-row">
            <span>Meshes Per Mech:</span>
            <span id="partsPerMech">~80</span>
        </div>
    </div>

    <div id="mechList">
        <h3>Generated Mechs</h3>
        <div id="mechListContent"></div>
    </div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>

    <script>
        // ============================================
        // UTILITY FUNCTIONS
        // ============================================

        const rand = (min, max) => min + Math.random() * (max - min);
        const randInt = (min, max) => Math.floor(rand(min, max + 1));
        const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
        const chance = (pct) => Math.random() < pct;

        // ============================================
        // MECH ARCHETYPE DEFINITIONS
        // ============================================

        // These define the general proportions and style tendencies
        const ARCHETYPES = {
            madcat: {
                name: 'Timber Wolf',
                torsoStyle: 'timberwolf',
                legStyle: 'digitigrade',
                shoulderStyle: 'missiles',
                armStyle: 'energy',
                headStyle: 'integrated',
                stance: 'wide',
                heightMult: 1.0
            },
            atlas: {
                name: 'Assault',
                torsoStyle: 'blocky',
                legStyle: 'heavy',
                shoulderStyle: 'armor',
                armStyle: 'ballistic',
                headStyle: 'skull',
                stance: 'wide',
                heightMult: 1.2
            },
            raven: {
                name: 'Light Scout',
                torsoStyle: 'narrow',
                legStyle: 'reverse',
                shoulderStyle: 'minimal',
                armStyle: 'light',
                headStyle: 'sensor',
                stance: 'narrow',
                heightMult: 0.85
            },
            marauder: {
                name: 'Heavy Fire',
                torsoStyle: 'hunched',
                legStyle: 'digitigrade',
                shoulderStyle: 'cannons',
                armStyle: 'ppc',
                headStyle: 'cockpit',
                stance: 'medium',
                heightMult: 1.1
            },
            catapult: {
                name: 'Missile Boat',
                torsoStyle: 'missileboat',
                legStyle: 'digitigrade',
                shoulderStyle: 'lrm',
                armStyle: 'stub',
                headStyle: 'integrated',
                stance: 'medium',
                heightMult: 0.95
            }
        };

        // Team colors
        const TEAM_COLORS = [
            { primary: [0.25, 0.45, 0.25], secondary: [0.15, 0.3, 0.15], accent: [0.8, 0.6, 0.2], name: 'Jade Falcon' },
            { primary: [0.5, 0.2, 0.2], secondary: [0.35, 0.12, 0.12], accent: [0.9, 0.7, 0.3], name: 'Wolf' },
            { primary: [0.2, 0.25, 0.5], secondary: [0.12, 0.15, 0.35], accent: [0.7, 0.7, 0.8], name: 'Steiner' },
            { primary: [0.45, 0.35, 0.2], secondary: [0.3, 0.22, 0.12], accent: [0.6, 0.5, 0.3], name: 'Desert' },
            { primary: [0.35, 0.35, 0.38], secondary: [0.2, 0.2, 0.22], accent: [0.5, 0.8, 0.5], name: 'Steel' },
            { primary: [0.5, 0.5, 0.45], secondary: [0.35, 0.35, 0.3], accent: [0.3, 0.5, 0.7], name: 'Arctic' },
            { primary: [0.15, 0.15, 0.2], secondary: [0.08, 0.08, 0.12], accent: [0.8, 0.2, 0.2], name: 'Shadow' },
            { primary: [0.4, 0.3, 0.2], secondary: [0.25, 0.18, 0.1], accent: [0.9, 0.5, 0.2], name: 'Rust' }
        ];

        // ============================================
        // GLOBAL STATE
        // ============================================

        let canvas, engine, scene, camera;
        let mechs = [];
        let animationPaused = false;
        let wireframeMode = false;
        let cameraMode = 0;
        let groundSize = 40;

        // ============================================
        // COMPOUND SHAPE BUILDER
        // ============================================

        /**
         * Creates compound shapes from multiple primitives
         * This is the core of creating interesting silhouettes
         */
        class ShapeBuilder {
            constructor(scene, materials, mechId) {
                this.scene = scene;
                this.mats = materials;
                this.mechId = mechId;
                this.partCount = 0;
            }

            // Create a unique name for each part
            name(base) {
                return `${this.mechId}_${base}_${this.partCount++}`;
            }

            // Basic box with optional taper
            box(w, h, d, parent, mat = 'primary') {
                const mesh = BABYLON.MeshBuilder.CreateBox(this.name('box'), {
                    width: w, height: h, depth: d
                }, this.scene);
                mesh.material = this.mats[mat];
                if (parent) mesh.parent = parent;
                return mesh;
            }

            // Tapered box (wider at bottom or top)
            taperedBox(wBot, wTop, h, d, parent, mat = 'primary') {
                // Create using ribbon or just approximate with box
                const mesh = BABYLON.MeshBuilder.CreateCylinder(this.name('taper'), {
                    diameterBottom: wBot,
                    diameterTop: wTop,
                    height: h,
                    tessellation: 4
                }, this.scene);
                mesh.rotation.y = Math.PI / 4;
                mesh.material = this.mats[mat];
                if (parent) mesh.parent = parent;
                return mesh;
            }

            cylinder(diameter, height, parent, mat = 'metal') {
                const mesh = BABYLON.MeshBuilder.CreateCylinder(this.name('cyl'), {
                    diameter: diameter,
                    height: height,
                    tessellation: 12
                }, this.scene);
                mesh.material = this.mats[mat];
                if (parent) mesh.parent = parent;
                return mesh;
            }

            sphere(diameter, parent, mat = 'dark') {
                const mesh = BABYLON.MeshBuilder.CreateSphere(this.name('sph'), {
                    diameter: diameter,
                    segments: 8
                }, this.scene);
                mesh.material = this.mats[mat];
                if (parent) mesh.parent = parent;
                return mesh;
            }

            // Angled plate for armor
            angledPlate(w, h, d, angle, parent, mat = 'secondary') {
                const mesh = this.box(w, h, d, parent, mat);
                mesh.rotation.x = angle;
                return mesh;
            }
        }

        // ============================================
        // MECH GENERATOR - ICONIC SILHOUETTES
        // ============================================

        class MechGenerator {
            constructor(scene) {
                this.scene = scene;
                this.mechCount = 0;
            }

            createMaterials(colors, mechId) {
                const mats = {};

                mats.primary = new BABYLON.StandardMaterial(`${mechId}_primary`, this.scene);
                mats.primary.diffuseColor = new BABYLON.Color3(...colors.primary);
                mats.primary.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);

                mats.secondary = new BABYLON.StandardMaterial(`${mechId}_secondary`, this.scene);
                mats.secondary.diffuseColor = new BABYLON.Color3(...colors.secondary);
                mats.secondary.specularColor = new BABYLON.Color3(0.15, 0.15, 0.15);

                mats.accent = new BABYLON.StandardMaterial(`${mechId}_accent`, this.scene);
                mats.accent.diffuseColor = new BABYLON.Color3(...colors.accent);
                mats.accent.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);

                mats.metal = new BABYLON.StandardMaterial(`${mechId}_metal`, this.scene);
                mats.metal.diffuseColor = new BABYLON.Color3(0.35, 0.35, 0.4);
                mats.metal.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                mats.metal.specularPower = 32;

                mats.dark = new BABYLON.StandardMaterial(`${mechId}_dark`, this.scene);
                mats.dark.diffuseColor = new BABYLON.Color3(0.12, 0.12, 0.15);

                mats.glow = new BABYLON.StandardMaterial(`${mechId}_glow`, this.scene);
                mats.glow.diffuseColor = new BABYLON.Color3(0.2, 0.8, 0.5);
                mats.glow.emissiveColor = new BABYLON.Color3(0.1, 0.4, 0.25);

                mats.missile = new BABYLON.StandardMaterial(`${mechId}_missile`, this.scene);
                mats.missile.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.28);

                return mats;
            }

            generate(position) {
                const mechId = `mech_${this.mechCount++}`;
                const archetype = pick(Object.values(ARCHETYPES));
                const colors = pick(TEAM_COLORS);
                const scale = rand(0.9, 1.1) * archetype.heightMult;

                const mats = this.createMaterials(colors, mechId);
                const builder = new ShapeBuilder(this.scene, mats, mechId);

                // Root node
                const root = new BABYLON.TransformNode(mechId, this.scene);
                root.position = position;
                root.scaling = new BABYLON.Vector3(scale, scale, scale);

                // Skeleton for animation
                const skeleton = {};

                // Build from ground up
                const legData = this.buildLegs(builder, skeleton, archetype);
                this.buildTorso(builder, skeleton, archetype, legData.pelvisHeight);
                this.buildArms(builder, skeleton, archetype);
                this.buildShoulders(builder, skeleton, archetype);
                this.buildHead(builder, skeleton, archetype);

                // Parent pelvis to root
                skeleton.pelvis.parent = root;

                return {
                    id: mechId,
                    root: root,
                    skeleton: skeleton,
                    archetype: archetype,
                    colors: colors,
                    animPhase: rand(0, Math.PI * 2),
                    walkSpeed: rand(0.7, 1.0),
                    targetPos: this.randomPos(),
                    legData: legData
                };
            }

            // ============================================
            // LEG GENERATION - The key to mech silhouette
            // ============================================

            buildLegs(builder, skeleton, arch) {
                // Determine leg style parameters
                const style = this.getLegStyle(arch.legStyle);

                // Calculate stance width based on archetype
                const stanceWidth = arch.stance === 'wide' ? 0.6 :
                                   arch.stance === 'narrow' ? 0.35 : 0.45;

                // Create pelvis/hip structure
                const pelvis = this.buildPelvis(builder, style, stanceWidth);
                skeleton.pelvis = pelvis;

                // Build each leg
                ['left', 'right'].forEach((side, idx) => {
                    const xMult = idx === 0 ? -1 : 1;
                    this.buildLeg(builder, skeleton, side, xMult, style, stanceWidth, pelvis);
                });

                return {
                    pelvisHeight: style.pelvisHeight,
                    style: style
                };
            }

            getLegStyle(styleName) {
                const styles = {
                    digitigrade: {
                        // Classic Mad Cat chicken legs
                        thighLength: rand(0.5, 0.65),
                        thighWidth: rand(0.28, 0.38),
                        thighAngle: rand(40, 55),
                        shinLength: rand(0.75, 0.95),
                        shinWidth: rand(0.22, 0.32),
                        shinAngle: rand(-50, -38),
                        kneeSize: rand(0.25, 0.35),
                        kneeForward: rand(0.1, 0.2),
                        footLength: rand(0.5, 0.7),
                        footStyle: pick(['talon', 'split', 'raptor']),
                        hasCalfBulge: true,
                        pelvisHeight: 1.8
                    },
                    reverse: {
                        // More extreme reverse joint
                        thighLength: rand(0.4, 0.5),
                        thighWidth: rand(0.22, 0.3),
                        thighAngle: rand(55, 70),
                        shinLength: rand(0.9, 1.1),
                        shinWidth: rand(0.18, 0.26),
                        shinAngle: rand(-60, -45),
                        kneeSize: rand(0.2, 0.28),
                        kneeForward: rand(0.15, 0.25),
                        footLength: rand(0.55, 0.75),
                        footStyle: pick(['talon', 'raptor']),
                        hasCalfBulge: false,
                        pelvisHeight: 1.6
                    },
                    heavy: {
                        // Atlas-style heavy legs
                        thighLength: rand(0.55, 0.7),
                        thighWidth: rand(0.4, 0.55),
                        thighAngle: rand(15, 30),
                        shinLength: rand(0.6, 0.75),
                        shinWidth: rand(0.35, 0.48),
                        shinAngle: rand(-25, -12),
                        kneeSize: rand(0.35, 0.45),
                        kneeForward: rand(0.05, 0.12),
                        footLength: rand(0.45, 0.6),
                        footStyle: pick(['platform', 'heavy', 'block']),
                        hasCalfBulge: false,
                        pelvisHeight: 1.5
                    }
                };
                return styles[styleName] || styles.digitigrade;
            }

            buildPelvis(builder, style, stanceWidth) {
                const pelvis = new BABYLON.TransformNode(builder.name('pelvis'), this.scene);
                pelvis.position.y = style.pelvisHeight;

                // Main pelvis block
                const pelvisCore = builder.box(0.9, 0.35, 0.55, pelvis, 'secondary');

                // Hip housings - bulky blocks on sides
                [-1, 1].forEach(side => {
                    const hipHousing = builder.box(0.25, 0.3, 0.4, pelvis, 'primary');
                    hipHousing.position.x = side * (0.45 + stanceWidth * 0.3);
                    hipHousing.position.y = -0.05;

                    // Lower hip extension
                    const hipLower = builder.box(0.2, 0.15, 0.35, hipHousing, 'secondary');
                    hipLower.position.y = -0.2;
                });

                // Rear pelvis armor
                const rearPlate = builder.box(0.7, 0.25, 0.15, pelvis, 'secondary');
                rearPlate.position.z = -0.3;
                rearPlate.position.y = 0.05;

                return pelvis;
            }

            buildLeg(builder, skeleton, side, xMult, style, stanceWidth, pelvis) {
                // Hip joint node
                const hipJoint = new BABYLON.TransformNode(builder.name(`${side}Hip`), this.scene);
                hipJoint.parent = pelvis;
                hipJoint.position.x = xMult * stanceWidth;
                hipJoint.position.y = -0.15;
                skeleton[`${side}Hip`] = hipJoint;

                // === THIGH ===
                const thigh = new BABYLON.TransformNode(builder.name(`${side}Thigh`), this.scene);
                thigh.parent = hipJoint;
                thigh.rotation.x = style.thighAngle * Math.PI / 180;
                skeleton[`${side}Thigh`] = thigh;

                // Thigh is built from multiple blocks for silhouette
                const thighMain = builder.box(
                    style.thighWidth,
                    style.thighLength,
                    style.thighWidth * 1.1,
                    thigh, 'primary'
                );
                thighMain.position.y = -style.thighLength / 2;

                // Thigh armor plates
                const thighFront = builder.box(
                    style.thighWidth * 0.8,
                    style.thighLength * 0.7,
                    0.08,
                    thigh, 'secondary'
                );
                thighFront.position.y = -style.thighLength * 0.4;
                thighFront.position.z = style.thighWidth * 0.6;

                // Inner thigh detail
                const thighInner = builder.box(
                    0.08,
                    style.thighLength * 0.6,
                    style.thighWidth * 0.7,
                    thigh, 'dark'
                );
                thighInner.position.y = -style.thighLength * 0.5;
                thighInner.position.x = -xMult * style.thighWidth * 0.5;

                // === KNEE ===
                const kneeJoint = new BABYLON.TransformNode(builder.name(`${side}Knee`), this.scene);
                kneeJoint.parent = thigh;
                kneeJoint.position.y = -style.thighLength;
                skeleton[`${side}Knee`] = kneeJoint;

                // Knee is a complex joint that projects forward
                const kneeCore = builder.sphere(style.kneeSize, kneeJoint, 'metal');

                // Knee housing - the forward-projecting knee cap
                const kneeCap = builder.box(
                    style.kneeSize * 1.2,
                    style.kneeSize * 1.4,
                    style.kneeSize * 0.8,
                    kneeJoint, 'primary'
                );
                kneeCap.position.z = style.kneeForward + style.kneeSize * 0.3;
                kneeCap.position.y = style.kneeSize * 0.1;

                // Knee side guards
                [-1, 1].forEach(kSide => {
                    const kneeGuard = builder.box(0.06, style.kneeSize * 1.2, style.kneeSize * 0.6, kneeJoint, 'secondary');
                    kneeGuard.position.x = kSide * style.kneeSize * 0.7;
                    kneeGuard.position.z = style.kneeForward * 0.5;
                });

                // === SHIN ===
                const shin = new BABYLON.TransformNode(builder.name(`${side}Shin`), this.scene);
                shin.parent = kneeJoint;
                shin.rotation.x = style.shinAngle * Math.PI / 180;
                skeleton[`${side}Shin`] = shin;

                // Shin main structure - tapers down
                const shinMain = builder.box(
                    style.shinWidth,
                    style.shinLength,
                    style.shinWidth * 1.2,
                    shin, 'primary'
                );
                shinMain.position.y = -style.shinLength / 2;

                // Shin front armor
                const shinFront = builder.box(
                    style.shinWidth * 0.75,
                    style.shinLength * 0.85,
                    0.1,
                    shin, 'secondary'
                );
                shinFront.position.y = -style.shinLength * 0.45;
                shinFront.position.z = style.shinWidth * 0.65;

                // Calf bulge (for digitigrade)
                if (style.hasCalfBulge) {
                    const calfBulge = builder.box(
                        style.shinWidth * 0.9,
                        style.shinLength * 0.5,
                        style.shinWidth * 0.6,
                        shin, 'secondary'
                    );
                    calfBulge.position.y = -style.shinLength * 0.25;
                    calfBulge.position.z = -style.shinWidth * 0.7;

                    // Calf detail
                    const calfDetail = builder.box(
                        style.shinWidth * 0.5,
                        style.shinLength * 0.35,
                        0.08,
                        shin, 'dark'
                    );
                    calfDetail.position.y = -style.shinLength * 0.3;
                    calfDetail.position.z = -style.shinWidth * 1.0;
                }

                // Lower shin taper
                const shinLower = builder.box(
                    style.shinWidth * 0.7,
                    style.shinLength * 0.25,
                    style.shinWidth * 0.9,
                    shin, 'primary'
                );
                shinLower.position.y = -style.shinLength * 0.85;

                // === ANKLE ===
                const ankleJoint = new BABYLON.TransformNode(builder.name(`${side}Ankle`), this.scene);
                ankleJoint.parent = shin;
                ankleJoint.position.y = -style.shinLength;
                skeleton[`${side}Ankle`] = ankleJoint;

                const ankleCore = builder.sphere(style.shinWidth * 0.5, ankleJoint, 'metal');

                // === FOOT ===
                this.buildFoot(builder, skeleton, side, style, ankleJoint);
            }

            buildFoot(builder, skeleton, side, style, ankleJoint) {
                const foot = new BABYLON.TransformNode(builder.name(`${side}Foot`), this.scene);
                foot.parent = ankleJoint;
                skeleton[`${side}Foot`] = foot;

                const footLen = style.footLength;
                const footStyle = style.footStyle;

                if (footStyle === 'talon' || footStyle === 'raptor') {
                    // Bird-like talon foot - long and forward-projecting

                    // Heel section
                    const heel = builder.box(0.15, 0.1, 0.2, foot, 'primary');
                    heel.position.y = -0.1;
                    heel.position.z = -0.1;

                    // Heel spur
                    const heelSpur = builder.box(0.08, 0.06, 0.18, foot, 'dark');
                    heelSpur.position.y = -0.12;
                    heelSpur.position.z = -0.22;
                    heelSpur.rotation.x = 0.3;

                    // Mid foot
                    const midFoot = builder.box(0.18, 0.08, footLen * 0.4, foot, 'primary');
                    midFoot.position.y = -0.12;
                    midFoot.position.z = footLen * 0.15;

                    // Toes - 2 or 3 forward-projecting claws
                    const numToes = footStyle === 'raptor' ? 3 : 2;
                    const toeSpread = footStyle === 'raptor' ? 0.12 : 0.1;

                    for (let t = 0; t < numToes; t++) {
                        const toeX = (t - (numToes - 1) / 2) * toeSpread;

                        // Toe base
                        const toeBase = builder.box(0.07, 0.06, footLen * 0.35, foot, 'secondary');
                        toeBase.position.x = toeX;
                        toeBase.position.y = -0.13;
                        toeBase.position.z = footLen * 0.4;

                        // Toe claw
                        const toeClaw = builder.box(0.05, 0.04, footLen * 0.25, foot, 'dark');
                        toeClaw.position.x = toeX;
                        toeClaw.position.y = -0.14;
                        toeClaw.position.z = footLen * 0.65;
                        toeClaw.rotation.x = 0.15;
                    }

                } else if (footStyle === 'split') {
                    // Split-toe foot
                    const heelBlock = builder.box(0.2, 0.12, 0.15, foot, 'primary');
                    heelBlock.position.y = -0.1;
                    heelBlock.position.z = -0.05;

                    // Two large toe sections
                    [-1, 1].forEach((toeSide, idx) => {
                        const toe = builder.box(0.12, 0.08, footLen * 0.6, foot, 'primary');
                        toe.position.x = toeSide * 0.1;
                        toe.position.y = -0.12;
                        toe.position.z = footLen * 0.25;

                        const toeEnd = builder.box(0.1, 0.06, footLen * 0.2, foot, 'secondary');
                        toeEnd.position.x = toeSide * 0.1;
                        toeEnd.position.y = -0.13;
                        toeEnd.position.z = footLen * 0.55;
                    });

                } else if (footStyle === 'platform' || footStyle === 'heavy' || footStyle === 'block') {
                    // Heavy platform foot for assault mechs
                    const footWidth = footStyle === 'heavy' ? 0.45 : 0.35;

                    // Main foot platform
                    const platform = builder.box(footWidth, 0.12, footLen * 0.8, foot, 'primary');
                    platform.position.y = -0.1;
                    platform.position.z = footLen * 0.2;

                    // Heel
                    const heel = builder.box(footWidth * 0.8, 0.1, 0.15, foot, 'secondary');
                    heel.position.y = -0.1;
                    heel.position.z = -0.1;

                    // Front edge
                    const frontEdge = builder.box(footWidth * 0.9, 0.08, 0.1, foot, 'secondary');
                    frontEdge.position.y = -0.11;
                    frontEdge.position.z = footLen * 0.55;

                    // Toe guards
                    if (footStyle === 'heavy') {
                        [-1, 1].forEach(side => {
                            const guard = builder.box(0.08, 0.1, footLen * 0.3, foot, 'dark');
                            guard.position.x = side * footWidth * 0.5;
                            guard.position.y = -0.08;
                            guard.position.z = footLen * 0.35;
                        });
                    }
                }
            }

            // ============================================
            // TORSO GENERATION
            // ============================================

            buildTorso(builder, skeleton, arch, pelvisHeight) {
                const style = this.getTorsoStyle(arch.torsoStyle);

                // Lower torso connects to pelvis
                const torsoLower = new BABYLON.TransformNode(builder.name('torsoLower'), this.scene);
                torsoLower.parent = skeleton.pelvis;
                torsoLower.position.y = 0.2;
                skeleton.torso = torsoLower;

                // Build lower torso structure
                const lowerCore = builder.box(style.lowerWidth, style.lowerHeight, style.depth, torsoLower, 'primary');
                lowerCore.position.y = style.lowerHeight / 2;

                // Waist armor
                const waistFront = builder.box(style.lowerWidth * 0.9, style.lowerHeight * 0.4, 0.1, torsoLower, 'secondary');
                waistFront.position.y = style.lowerHeight * 0.3;
                waistFront.position.z = style.depth / 2 + 0.05;

                // Waist twist joint
                const waistJoint = builder.cylinder(style.lowerWidth * 0.5, 0.12, torsoLower, 'dark');
                waistJoint.position.y = style.lowerHeight + 0.06;

                // Upper torso
                const torsoUpper = new BABYLON.TransformNode(builder.name('torsoUpper'), this.scene);
                torsoUpper.parent = torsoLower;
                torsoUpper.position.y = style.lowerHeight + 0.1;
                skeleton.torsoUpper = torsoUpper;

                // Upper torso main body
                const upperCore = builder.box(style.upperWidth, style.upperHeight, style.upperDepth, torsoUpper, 'primary');
                upperCore.position.y = style.upperHeight / 2;

                // Cockpit/chest area
                if (style.hasCockpit) {
                    const cockpitBulge = builder.box(
                        style.upperWidth * 0.5,
                        style.upperHeight * 0.4,
                        0.2,
                        torsoUpper, 'secondary'
                    );
                    cockpitBulge.position.y = style.upperHeight * 0.6;
                    cockpitBulge.position.z = style.upperDepth / 2 + 0.1;
                    cockpitBulge.rotation.x = -0.2;

                    // Cockpit glass
                    const cockpitGlass = builder.box(
                        style.upperWidth * 0.3,
                        style.upperHeight * 0.2,
                        0.08,
                        cockpitBulge, 'glow'
                    );
                    cockpitGlass.position.z = 0.12;
                }

                // Integrated cockpit (Timber Wolf / Catapult style - no separate head)
                if (style.integratedCockpit) {
                    // Main cockpit housing that projects forward from upper torso
                    const cockpitHousing = builder.box(
                        style.upperWidth * 0.45,
                        style.upperHeight * 0.5,
                        style.upperDepth * 0.5,
                        torsoUpper, 'secondary'
                    );
                    cockpitHousing.position.y = style.upperHeight * 0.75;
                    cockpitHousing.position.z = style.upperDepth * 0.35;

                    // Forward-angled cockpit canopy
                    const canopy = builder.box(
                        style.upperWidth * 0.35,
                        style.upperHeight * 0.35,
                        style.upperDepth * 0.35,
                        cockpitHousing, 'primary'
                    );
                    canopy.position.y = style.upperHeight * 0.1;
                    canopy.position.z = style.upperDepth * 0.3;
                    canopy.rotation.x = -0.25;

                    // Cockpit glass/visor
                    const visor = builder.box(
                        style.upperWidth * 0.3,
                        style.upperHeight * 0.18,
                        0.08,
                        canopy, 'glow'
                    );
                    visor.position.y = style.upperHeight * 0.05;
                    visor.position.z = style.upperDepth * 0.2;

                    // Side sensor panels
                    [-1, 1].forEach(side => {
                        const sensorPanel = builder.box(
                            0.08,
                            style.upperHeight * 0.25,
                            style.upperDepth * 0.2,
                            cockpitHousing, 'dark'
                        );
                        sensorPanel.position.x = side * style.upperWidth * 0.22;
                        sensorPanel.position.y = style.upperHeight * 0.05;
                        sensorPanel.position.z = style.upperDepth * 0.15;
                    });

                    // Top sensor/antenna array
                    const sensorArray = builder.box(
                        style.upperWidth * 0.2,
                        0.08,
                        style.upperDepth * 0.15,
                        cockpitHousing, 'metal'
                    );
                    sensorArray.position.y = style.upperHeight * 0.28;
                    sensorArray.position.z = style.upperDepth * 0.1;
                }

                // Chest vents
                if (style.hasVents) {
                    [-1, 1].forEach(side => {
                        for (let v = 0; v < 3; v++) {
                            const vent = builder.box(0.15, 0.04, 0.08, torsoUpper, 'dark');
                            vent.position.x = side * style.upperWidth * 0.35;
                            vent.position.y = style.upperHeight * 0.3 + v * 0.08;
                            vent.position.z = style.upperDepth / 2 + 0.02;
                        }
                    });
                }

                // Back armor/engine
                const backPlate = builder.box(style.upperWidth * 0.85, style.upperHeight * 0.8, 0.15, torsoUpper, 'secondary');
                backPlate.position.y = style.upperHeight * 0.45;
                backPlate.position.z = -style.upperDepth / 2 - 0.08;

                // Engine exhaust
                [-1, 1].forEach(side => {
                    const exhaust = builder.cylinder(0.12, 0.2, torsoUpper, 'dark');
                    exhaust.position.x = side * style.upperWidth * 0.3;
                    exhaust.position.y = style.upperHeight * 0.3;
                    exhaust.position.z = -style.upperDepth / 2 - 0.15;
                    exhaust.rotation.x = Math.PI / 2;
                });

                // Shoulder mounts
                const shoulderY = style.upperHeight * 0.85;
                skeleton.shoulderMountL = new BABYLON.TransformNode(builder.name('shoulderMountL'), this.scene);
                skeleton.shoulderMountL.parent = torsoUpper;
                skeleton.shoulderMountL.position.set(-style.upperWidth / 2 - 0.1, shoulderY, 0);

                skeleton.shoulderMountR = new BABYLON.TransformNode(builder.name('shoulderMountR'), this.scene);
                skeleton.shoulderMountR.parent = torsoUpper;
                skeleton.shoulderMountR.position.set(style.upperWidth / 2 + 0.1, shoulderY, 0);

                // Arm mounts (lower than shoulder mounts)
                const armY = style.upperHeight * 0.5;
                skeleton.armMountL = new BABYLON.TransformNode(builder.name('armMountL'), this.scene);
                skeleton.armMountL.parent = torsoUpper;
                skeleton.armMountL.position.set(-style.upperWidth / 2 - 0.05, armY, 0);

                skeleton.armMountR = new BABYLON.TransformNode(builder.name('armMountR'), this.scene);
                skeleton.armMountR.parent = torsoUpper;
                skeleton.armMountR.position.set(style.upperWidth / 2 + 0.05, armY, 0);
            }

            getTorsoStyle(styleName) {
                const styles = {
                    bulbous: {
                        lowerWidth: rand(0.8, 1.0),
                        lowerHeight: rand(0.35, 0.45),
                        depth: rand(0.6, 0.75),
                        upperWidth: rand(1.1, 1.35),
                        upperHeight: rand(0.7, 0.85),
                        upperDepth: rand(0.7, 0.85),
                        hasCockpit: true,
                        hasVents: true,
                        integratedCockpit: false
                    },
                    blocky: {
                        lowerWidth: rand(1.0, 1.2),
                        lowerHeight: rand(0.4, 0.5),
                        depth: rand(0.7, 0.85),
                        upperWidth: rand(1.2, 1.45),
                        upperHeight: rand(0.85, 1.0),
                        upperDepth: rand(0.8, 0.95),
                        hasCockpit: true,
                        hasVents: true,
                        integratedCockpit: false
                    },
                    narrow: {
                        lowerWidth: rand(0.6, 0.75),
                        lowerHeight: rand(0.3, 0.4),
                        depth: rand(0.5, 0.6),
                        upperWidth: rand(0.8, 0.95),
                        upperHeight: rand(0.55, 0.7),
                        upperDepth: rand(0.55, 0.65),
                        hasCockpit: false,
                        hasVents: false,
                        integratedCockpit: false
                    },
                    hunched: {
                        lowerWidth: rand(0.85, 1.0),
                        lowerHeight: rand(0.35, 0.45),
                        depth: rand(0.65, 0.8),
                        upperWidth: rand(1.15, 1.35),
                        upperHeight: rand(0.6, 0.75),
                        upperDepth: rand(0.85, 1.0),
                        hasCockpit: true,
                        hasVents: true,
                        integratedCockpit: false
                    },
                    rounded: {
                        lowerWidth: rand(0.75, 0.9),
                        lowerHeight: rand(0.35, 0.45),
                        depth: rand(0.6, 0.75),
                        upperWidth: rand(1.0, 1.2),
                        upperHeight: rand(0.65, 0.8),
                        upperDepth: rand(0.7, 0.85),
                        hasCockpit: true,
                        hasVents: false,
                        integratedCockpit: false
                    },
                    // Timber Wolf style - wide shoulders, integrated cockpit in chest
                    timberwolf: {
                        lowerWidth: rand(0.85, 1.0),
                        lowerHeight: rand(0.35, 0.45),
                        depth: rand(0.65, 0.8),
                        upperWidth: rand(1.2, 1.4),
                        upperHeight: rand(0.75, 0.9),
                        upperDepth: rand(0.8, 0.95),
                        hasCockpit: false,
                        hasVents: true,
                        integratedCockpit: true
                    },
                    // Missile boat style - rounded, low profile, integrated cockpit
                    missileboat: {
                        lowerWidth: rand(0.8, 0.95),
                        lowerHeight: rand(0.3, 0.4),
                        depth: rand(0.6, 0.75),
                        upperWidth: rand(1.1, 1.3),
                        upperHeight: rand(0.6, 0.75),
                        upperDepth: rand(0.75, 0.9),
                        hasCockpit: false,
                        hasVents: false,
                        integratedCockpit: true
                    }
                };
                return styles[styleName] || styles.bulbous;
            }

            // ============================================
            // SHOULDER GENERATION - Signature look
            // ============================================

            buildShoulders(builder, skeleton, arch) {
                const style = this.getShoulderStyle(arch.shoulderStyle);

                ['L', 'R'].forEach((side, idx) => {
                    const mount = skeleton[`shoulderMount${side}`];
                    const xMult = idx === 0 ? -1 : 1;

                    if (style.type === 'missiles') {
                        this.buildMissilePod(builder, mount, xMult, style);
                    } else if (style.type === 'cannons') {
                        this.buildCannonMount(builder, mount, xMult, style);
                    } else if (style.type === 'lrm') {
                        this.buildLRMPod(builder, mount, xMult, style);
                    } else if (style.type === 'armor') {
                        this.buildArmorShoulder(builder, mount, xMult, style);
                    } else {
                        this.buildMinimalShoulder(builder, mount, xMult, style);
                    }
                });
            }

            getShoulderStyle(styleName) {
                const styles = {
                    missiles: {
                        type: 'missiles',
                        width: rand(0.35, 0.5),
                        height: rand(0.5, 0.7),
                        depth: rand(0.4, 0.55),
                        angle: rand(0.15, 0.35),
                        rows: randInt(2, 4),
                        cols: randInt(2, 3)
                    },
                    cannons: {
                        type: 'cannons',
                        width: rand(0.3, 0.4),
                        height: rand(0.3, 0.45),
                        barrelLength: rand(0.6, 0.9),
                        barrelDiameter: rand(0.1, 0.15)
                    },
                    lrm: {
                        type: 'lrm',
                        width: rand(0.45, 0.6),
                        height: rand(0.55, 0.75),
                        depth: rand(0.5, 0.65),
                        angle: rand(0.2, 0.4),
                        tubes: randInt(8, 15)
                    },
                    armor: {
                        type: 'armor',
                        width: rand(0.35, 0.5),
                        height: rand(0.4, 0.55),
                        layers: randInt(2, 3)
                    },
                    minimal: {
                        type: 'minimal',
                        width: rand(0.2, 0.3),
                        height: rand(0.2, 0.3)
                    }
                };
                return styles[styleName] || styles.missiles;
            }

            buildMissilePod(builder, mount, xMult, style) {
                // Main pod housing
                const pod = builder.box(style.width, style.height, style.depth, mount, 'secondary');
                pod.position.x = xMult * style.width * 0.5;
                pod.position.y = style.height * 0.3;
                pod.rotation.z = xMult * style.angle;
                pod.rotation.x = -0.1;

                // Missile cell grid
                const cellW = style.width * 0.8 / style.cols;
                const cellH = style.height * 0.8 / style.rows;

                for (let r = 0; r < style.rows; r++) {
                    for (let c = 0; c < style.cols; c++) {
                        const cell = builder.box(cellW * 0.8, cellH * 0.8, 0.08, pod, 'dark');
                        cell.position.x = (c - (style.cols - 1) / 2) * cellW;
                        cell.position.y = (r - (style.rows - 1) / 2) * cellH;
                        cell.position.z = style.depth / 2 + 0.02;
                    }
                }

                // Pod frame
                const frameTop = builder.box(style.width * 1.05, 0.06, style.depth * 0.9, pod, 'primary');
                frameTop.position.y = style.height / 2 + 0.03;

                const frameSide = builder.box(0.06, style.height, style.depth * 0.9, pod, 'primary');
                frameSide.position.x = xMult * style.width / 2;
            }

            buildLRMPod(builder, mount, xMult, style) {
                // Larger angled pod for LRM
                const pod = builder.box(style.width, style.height, style.depth, mount, 'secondary');
                pod.position.x = xMult * style.width * 0.4;
                pod.position.y = style.height * 0.35;
                pod.rotation.z = xMult * style.angle;
                pod.rotation.x = -0.15;

                // Tube grid
                const tubeRadius = 0.04;
                const tubesPerRow = Math.ceil(Math.sqrt(style.tubes));
                for (let i = 0; i < style.tubes; i++) {
                    const row = Math.floor(i / tubesPerRow);
                    const col = i % tubesPerRow;
                    const tube = builder.cylinder(tubeRadius * 2, 0.1, pod, 'dark');
                    tube.position.x = (col - tubesPerRow / 2) * tubeRadius * 2.5;
                    tube.position.y = (row - tubesPerRow / 2) * tubeRadius * 2.5;
                    tube.position.z = style.depth / 2 + 0.02;
                    tube.rotation.x = Math.PI / 2;
                }

                // Pod cap
                const cap = builder.box(style.width * 0.9, 0.08, style.depth * 0.7, pod, 'primary');
                cap.position.y = style.height / 2 + 0.04;
            }

            buildCannonMount(builder, mount, xMult, style) {
                // Shoulder cannon (PPC/AC style)
                const housing = builder.box(style.width, style.height, style.width, mount, 'secondary');
                housing.position.x = xMult * style.width * 0.4;
                housing.position.y = style.height * 0.3;

                // Barrel
                const barrel = builder.cylinder(style.barrelDiameter, style.barrelLength, housing, 'metal');
                barrel.rotation.x = Math.PI / 2;
                barrel.position.z = style.width / 2 + style.barrelLength / 2;

                // Barrel shroud
                const shroud = builder.cylinder(style.barrelDiameter * 1.5, style.barrelLength * 0.4, housing, 'primary');
                shroud.rotation.x = Math.PI / 2;
                shroud.position.z = style.width / 2 + style.barrelLength * 0.15;

                // Muzzle
                const muzzle = builder.cylinder(style.barrelDiameter * 1.3, 0.08, housing, 'dark');
                muzzle.rotation.x = Math.PI / 2;
                muzzle.position.z = style.width / 2 + style.barrelLength + 0.02;
            }

            buildArmorShoulder(builder, mount, xMult, style) {
                // Layered armor plates
                for (let l = 0; l < style.layers; l++) {
                    const layerW = style.width * (1 - l * 0.15);
                    const layerH = style.height * (1 - l * 0.1);
                    const plate = builder.box(layerW, layerH, 0.08, mount, l === 0 ? 'primary' : 'secondary');
                    plate.position.x = xMult * (style.width * 0.3 + l * 0.05);
                    plate.position.y = style.height * 0.3 + l * 0.05;
                    plate.rotation.z = xMult * (0.2 + l * 0.1);
                }
            }

            buildMinimalShoulder(builder, mount, xMult, style) {
                const plate = builder.box(style.width, style.height, 0.1, mount, 'secondary');
                plate.position.x = xMult * style.width * 0.3;
                plate.position.y = style.height * 0.3;
                plate.rotation.z = xMult * 0.15;
            }

            // ============================================
            // ARM GENERATION
            // ============================================

            buildArms(builder, skeleton, arch) {
                const style = this.getArmStyle(arch.armStyle);

                ['L', 'R'].forEach((side, idx) => {
                    const mount = skeleton[`armMount${side}`];
                    const xMult = idx === 0 ? -1 : 1;
                    const fullSide = idx === 0 ? 'left' : 'right';

                    // Upper arm joint
                    const upperArmJoint = new BABYLON.TransformNode(builder.name(`${fullSide}UpperArmJoint`), this.scene);
                    upperArmJoint.parent = mount;
                    skeleton[`${fullSide}UpperArm`] = upperArmJoint;

                    // Upper arm structure
                    const upperArm = builder.box(style.upperWidth, style.upperLength, style.upperWidth, upperArmJoint, 'primary');
                    upperArm.position.y = -style.upperLength / 2;
                    upperArm.position.x = xMult * 0.05;

                    // Shoulder joint cover
                    const shoulderCover = builder.sphere(style.upperWidth * 1.2, upperArmJoint, 'secondary');
                    shoulderCover.position.x = xMult * 0.05;
                    shoulderCover.scaling.y = 0.7;

                    // Elbow joint
                    const elbowJoint = new BABYLON.TransformNode(builder.name(`${fullSide}ElbowJoint`), this.scene);
                    elbowJoint.parent = upperArmJoint;
                    elbowJoint.position.y = -style.upperLength;
                    elbowJoint.position.x = xMult * 0.05;
                    skeleton[`${fullSide}LowerArm`] = elbowJoint;

                    const elbowBall = builder.sphere(style.upperWidth * 0.9, elbowJoint, 'metal');

                    // Lower arm / weapon
                    if (style.type === 'energy' || style.type === 'ppc') {
                        this.buildEnergyArm(builder, elbowJoint, xMult, style);
                    } else if (style.type === 'ballistic') {
                        this.buildBallisticArm(builder, elbowJoint, xMult, style);
                    } else if (style.type === 'stub') {
                        this.buildStubArm(builder, elbowJoint, xMult, style);
                    } else {
                        this.buildLightArm(builder, elbowJoint, xMult, style);
                    }
                });
            }

            getArmStyle(styleName) {
                const styles = {
                    energy: {
                        type: 'energy',
                        upperWidth: rand(0.22, 0.3),
                        upperLength: rand(0.45, 0.55),
                        lowerWidth: rand(0.25, 0.35),
                        lowerLength: rand(0.5, 0.65),
                        barrelLength: rand(0.4, 0.6)
                    },
                    ppc: {
                        type: 'ppc',
                        upperWidth: rand(0.25, 0.35),
                        upperLength: rand(0.5, 0.6),
                        lowerWidth: rand(0.3, 0.4),
                        lowerLength: rand(0.55, 0.7),
                        barrelLength: rand(0.5, 0.8)
                    },
                    ballistic: {
                        type: 'ballistic',
                        upperWidth: rand(0.28, 0.38),
                        upperLength: rand(0.5, 0.6),
                        lowerWidth: rand(0.32, 0.42),
                        lowerLength: rand(0.55, 0.7),
                        barrelLength: rand(0.5, 0.7)
                    },
                    stub: {
                        type: 'stub',
                        upperWidth: rand(0.2, 0.28),
                        upperLength: rand(0.4, 0.5),
                        lowerWidth: rand(0.18, 0.25),
                        lowerLength: rand(0.25, 0.35)
                    },
                    light: {
                        type: 'light',
                        upperWidth: rand(0.15, 0.22),
                        upperLength: rand(0.4, 0.5),
                        lowerWidth: rand(0.12, 0.18),
                        lowerLength: rand(0.4, 0.5),
                        barrelLength: rand(0.3, 0.45)
                    }
                };
                return styles[styleName] || styles.energy;
            }

            buildEnergyArm(builder, elbowJoint, xMult, style) {
                // Forearm housing
                const forearm = builder.box(style.lowerWidth, style.lowerLength, style.lowerWidth * 1.1, elbowJoint, 'primary');
                forearm.position.y = -style.lowerLength / 2;

                // Energy coils
                for (let c = 0; c < 2; c++) {
                    const coil = builder.cylinder(style.lowerWidth * 0.3, style.lowerLength * 0.25, forearm, 'accent');
                    coil.position.y = -style.lowerLength * 0.15 + c * style.lowerLength * 0.35;
                    coil.position.z = style.lowerWidth * 0.5;
                }

                // Barrel
                const barrel = builder.cylinder(style.lowerWidth * 0.4, style.barrelLength, forearm, 'metal');
                barrel.rotation.x = Math.PI / 2;
                barrel.position.y = -style.lowerLength / 2;
                barrel.position.z = style.lowerWidth * 0.5 + style.barrelLength / 2;

                // Muzzle
                const muzzle = builder.cylinder(style.lowerWidth * 0.5, 0.08, barrel, 'dark');
                muzzle.position.y = style.barrelLength / 2;
            }

            buildBallisticArm(builder, elbowJoint, xMult, style) {
                // Heavier forearm
                const forearm = builder.box(style.lowerWidth, style.lowerLength, style.lowerWidth * 1.2, elbowJoint, 'primary');
                forearm.position.y = -style.lowerLength / 2;

                // Ammo housing
                const ammoBox = builder.box(style.lowerWidth * 0.8, style.lowerLength * 0.5, style.lowerWidth * 0.6, forearm, 'secondary');
                ammoBox.position.z = -style.lowerWidth * 0.7;
                ammoBox.position.y = -style.lowerLength * 0.1;

                // Multiple barrels
                const barrelCount = randInt(1, 3);
                for (let b = 0; b < barrelCount; b++) {
                    const barrel = builder.cylinder(0.06, style.barrelLength, forearm, 'metal');
                    barrel.rotation.x = Math.PI / 2;
                    barrel.position.y = -style.lowerLength / 2;
                    barrel.position.z = style.lowerWidth * 0.5 + style.barrelLength / 2;
                    barrel.position.x = (b - (barrelCount - 1) / 2) * 0.1;
                }
            }

            buildStubArm(builder, elbowJoint, xMult, style) {
                // Short stubby arm (for missile boat mechs)
                const forearm = builder.box(style.lowerWidth, style.lowerLength, style.lowerWidth, elbowJoint, 'primary');
                forearm.position.y = -style.lowerLength / 2;

                // End cap
                const cap = builder.box(style.lowerWidth * 1.1, 0.08, style.lowerWidth * 1.1, forearm, 'secondary');
                cap.position.y = -style.lowerLength / 2;
            }

            buildLightArm(builder, elbowJoint, xMult, style) {
                // Light arm with small weapon
                const forearm = builder.box(style.lowerWidth, style.lowerLength, style.lowerWidth, elbowJoint, 'primary');
                forearm.position.y = -style.lowerLength / 2;

                // Small barrel
                const barrel = builder.cylinder(0.05, style.barrelLength, forearm, 'metal');
                barrel.rotation.x = Math.PI / 2;
                barrel.position.y = -style.lowerLength / 2;
                barrel.position.z = style.lowerWidth * 0.4 + style.barrelLength / 2;
            }

            // ============================================
            // HEAD GENERATION
            // ============================================

            buildHead(builder, skeleton, arch) {
                const style = this.getHeadStyle(arch.headStyle);

                // Skip head building for integrated cockpit styles (Timber Wolf, Catapult)
                if (style.type === 'integrated') {
                    skeleton.head = skeleton.torsoUpper; // Point to torso for animation compatibility
                    return;
                }

                const torsoUpper = skeleton.torsoUpper;

                const head = new BABYLON.TransformNode(builder.name('head'), this.scene);
                head.parent = torsoUpper;
                head.position.y = 0.85;
                head.position.z = style.forward;
                skeleton.head = head;

                if (style.type === 'angular') {
                    this.buildAngularHead(builder, head, style);
                } else if (style.type === 'skull') {
                    this.buildSkullHead(builder, head, style);
                } else if (style.type === 'sensor') {
                    this.buildSensorHead(builder, head, style);
                } else if (style.type === 'cockpit') {
                    this.buildCockpitHead(builder, head, style);
                } else {
                    this.buildDomeHead(builder, head, style);
                }
            }

            getHeadStyle(styleName) {
                const styles = {
                    angular: {
                        type: 'angular',
                        width: rand(0.4, 0.55),
                        height: rand(0.35, 0.45),
                        forward: rand(0.1, 0.2)
                    },
                    skull: {
                        type: 'skull',
                        width: rand(0.5, 0.65),
                        height: rand(0.45, 0.55),
                        forward: rand(0.05, 0.15)
                    },
                    sensor: {
                        type: 'sensor',
                        width: rand(0.35, 0.45),
                        height: rand(0.25, 0.35),
                        forward: rand(0.05, 0.15)
                    },
                    cockpit: {
                        type: 'cockpit',
                        width: rand(0.4, 0.5),
                        height: rand(0.3, 0.4),
                        forward: rand(0.15, 0.25)
                    },
                    dome: {
                        type: 'dome',
                        width: rand(0.4, 0.5),
                        height: rand(0.3, 0.4),
                        forward: rand(0.08, 0.18)
                    },
                    // Integrated cockpit - no separate head, cockpit is in torso
                    integrated: {
                        type: 'integrated'
                    }
                };
                return styles[styleName] || styles.angular;
            }

            buildAngularHead(builder, head, style) {
                // Main head block
                const headMain = builder.box(style.width, style.height, style.width * 0.8, head, 'primary');
                headMain.position.y = style.height / 2;

                // Visor
                const visor = builder.box(style.width * 0.9, style.height * 0.35, 0.08, head, 'glow');
                visor.position.y = style.height * 0.55;
                visor.position.z = style.width * 0.4;

                // Antenna
                if (chance(0.6)) {
                    [-1, 1].forEach(side => {
                        const antenna = builder.box(0.04, style.height * 0.5, 0.04, head, 'metal');
                        antenna.position.x = side * style.width * 0.45;
                        antenna.position.y = style.height * 0.9;
                        antenna.rotation.z = side * 0.3;
                    });
                }
            }

            buildSkullHead(builder, head, style) {
                // Skull-like head (Atlas style)
                const headMain = builder.box(style.width, style.height, style.width * 0.7, head, 'primary');
                headMain.position.y = style.height / 2;

                // Eye sockets
                [-1, 1].forEach(side => {
                    const eye = builder.box(style.width * 0.25, style.height * 0.25, 0.1, head, 'dark');
                    eye.position.x = side * style.width * 0.25;
                    eye.position.y = style.height * 0.6;
                    eye.position.z = style.width * 0.35;

                    // Eye glow
                    const eyeGlow = builder.box(style.width * 0.15, style.height * 0.12, 0.05, head, 'glow');
                    eyeGlow.position.x = side * style.width * 0.25;
                    eyeGlow.position.y = style.height * 0.6;
                    eyeGlow.position.z = style.width * 0.38;
                });

                // Jaw area
                const jaw = builder.box(style.width * 0.7, style.height * 0.2, style.width * 0.4, head, 'secondary');
                jaw.position.y = style.height * 0.15;
                jaw.position.z = style.width * 0.1;
            }

            buildSensorHead(builder, head, style) {
                // Small sensor cluster
                const dome = builder.sphere(style.width, head, 'primary');
                dome.position.y = style.height / 2;
                dome.scaling.y = style.height / style.width;

                // Sensor band
                const band = builder.cylinder(style.width * 1.1, 0.08, head, 'glow');
                band.position.y = style.height * 0.5;
            }

            buildCockpitHead(builder, head, style) {
                // Visible cockpit (Marauder style)
                const base = builder.box(style.width, style.height * 0.6, style.width * 0.8, head, 'primary');
                base.position.y = style.height * 0.3;

                // Cockpit canopy
                const canopy = builder.box(style.width * 0.7, style.height * 0.5, style.width * 0.5, head, 'glow');
                canopy.position.y = style.height * 0.55;
                canopy.position.z = style.width * 0.2;
                canopy.rotation.x = -0.3;
            }

            buildDomeHead(builder, head, style) {
                // Rounded dome head (Catapult style)
                const dome = builder.sphere(style.width, head, 'primary');
                dome.position.y = style.height / 2;
                dome.scaling.y = style.height / style.width * 0.8;

                // Visor slit
                const visor = builder.box(style.width * 0.8, 0.08, 0.1, head, 'glow');
                visor.position.y = style.height * 0.5;
                visor.position.z = style.width * 0.45;
            }

            randomPos() {
                return new BABYLON.Vector3(
                    rand(-groundSize / 2 + 3, groundSize / 2 - 3),
                    0,
                    rand(-groundSize / 2 + 3, groundSize / 2 - 3)
                );
            }
        }

        // ============================================
        // ANIMATION SYSTEM
        // ============================================

        class MechAnimator {
            constructor() {
                this.time = 0;
            }

            update(dt, mechs) {
                if (animationPaused) return;
                this.time += dt;

                mechs.forEach(mech => {
                    this.animateWalk(mech, dt);
                    this.updateMovement(mech, dt);
                });
            }

            animateWalk(mech, dt) {
                const sk = mech.skeleton;
                const phase = mech.animPhase + this.time * mech.walkSpeed * 4;
                const legStyle = mech.legData.style;

                // Body bob
                if (sk.pelvis) {
                    sk.pelvis.position.y = legStyle.pelvisHeight + Math.abs(Math.sin(phase * 2)) * 0.04;
                }

                // Legs
                ['left', 'right'].forEach((side, idx) => {
                    const p = phase + idx * Math.PI;

                    if (sk[`${side}Thigh`]) {
                        const base = legStyle.thighAngle * Math.PI / 180;
                        sk[`${side}Thigh`].rotation.x = base + Math.sin(p) * 0.2;
                    }

                    if (sk[`${side}Shin`]) {
                        const base = legStyle.shinAngle * Math.PI / 180;
                        sk[`${side}Shin`].rotation.x = base + Math.sin(p - 0.5) * 0.15;
                    }

                    if (sk[`${side}Foot`]) {
                        sk[`${side}Foot`].rotation.x = Math.sin(p - 1) * 0.1;
                    }
                });

                // Arms swing opposite to legs
                ['left', 'right'].forEach((side, idx) => {
                    const p = phase + (idx + 1) * Math.PI;

                    if (sk[`${side}UpperArm`]) {
                        sk[`${side}UpperArm`].rotation.x = Math.sin(p) * 0.15;
                    }
                    if (sk[`${side}LowerArm`]) {
                        sk[`${side}LowerArm`].rotation.x = Math.sin(p) * 0.1 - 0.1;
                    }
                });

                // Torso twist
                if (sk.torso) {
                    sk.torso.rotation.y = Math.sin(phase) * 0.03;
                }
            }

            updateMovement(mech, dt) {
                const root = mech.root;
                const target = mech.targetPos;
                const speed = mech.walkSpeed * 2.5;

                const dx = target.x - root.position.x;
                const dz = target.z - root.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < 1.5) {
                    mech.targetPos = this.randomPos();
                } else {
                    root.position.x += (dx / dist) * speed * dt;
                    root.position.z += (dz / dist) * speed * dt;

                    // Face direction
                    const targetAngle = Math.atan2(dx, dz);
                    let angleDiff = targetAngle - root.rotation.y;
                    if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    root.rotation.y += angleDiff * dt * 2.5;
                }

                // Bounds
                const bounds = groundSize / 2 - 3;
                root.position.x = Math.max(-bounds, Math.min(bounds, root.position.x));
                root.position.z = Math.max(-bounds, Math.min(bounds, root.position.z));
            }

            randomPos() {
                return new BABYLON.Vector3(
                    rand(-groundSize / 2 + 3, groundSize / 2 - 3),
                    0,
                    rand(-groundSize / 2 + 3, groundSize / 2 - 3)
                );
            }
        }

        // ============================================
        // SCENE SETUP
        // ============================================

        let generator;
        let animator;

        function createScene() {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.06, 0.06, 0.1);

            camera = new BABYLON.ArcRotateCamera('cam', -Math.PI / 4, Math.PI / 3, 20,
                new BABYLON.Vector3(0, 2.5, 0), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 4;
            camera.upperRadiusLimit = 60;
            camera.wheelPrecision = 20;

            // Lighting
            const hemi = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0, 1, 0), scene);
            hemi.intensity = 0.5;
            hemi.groundColor = new BABYLON.Color3(0.1, 0.1, 0.12);

            const dir = new BABYLON.DirectionalLight('dir', new BABYLON.Vector3(-0.5, -1, -0.3), scene);
            dir.intensity = 0.9;
            dir.position = new BABYLON.Vector3(15, 25, 15);

            // Ground
            const ground = BABYLON.MeshBuilder.CreateGround('ground', {
                width: groundSize, height: groundSize, subdivisions: 1
            }, scene);
            const groundMat = new BABYLON.StandardMaterial('groundMat', scene);
            groundMat.diffuseColor = new BABYLON.Color3(0.12, 0.14, 0.1);
            groundMat.specularColor = new BABYLON.Color3(0.02, 0.02, 0.02);
            ground.material = groundMat;

            // Grid
            const gridMat = new BABYLON.StandardMaterial('gridMat', scene);
            gridMat.diffuseColor = new BABYLON.Color3(0.18, 0.2, 0.16);
            gridMat.alpha = 0.4;

            for (let i = -groundSize / 2; i <= groundSize / 2; i += 5) {
                const h = BABYLON.MeshBuilder.CreateBox(`gh${i}`, { width: groundSize, height: 0.02, depth: 0.04 }, scene);
                h.position.z = i; h.position.y = 0.01; h.material = gridMat;
                const v = BABYLON.MeshBuilder.CreateBox(`gv${i}`, { width: 0.04, height: 0.02, depth: groundSize }, scene);
                v.position.x = i; v.position.y = 0.01; v.material = gridMat;
            }

            generator = new MechGenerator(scene);
            animator = new MechAnimator();

            generateNewMechs();

            return scene;
        }

        function generateNewMechs() {
            clearAllMechs();

            for (let i = 0; i < 10; i++) {
                const angle = (i / 10) * Math.PI * 2;
                const radius = 6 + rand(0, 10);
                const pos = new BABYLON.Vector3(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
                const mech = generator.generate(pos);
                mech.root.rotation.y = angle + Math.PI;
                mechs.push(mech);
            }

            updateUI();
        }

        function addSingleMech() {
            const mech = generator.generate(animator.randomPos());
            mechs.push(mech);
            updateUI();
        }

        function clearAllMechs() {
            mechs.forEach(m => m.root.dispose());
            mechs = [];
            updateUI();
        }

        function toggleAnimation() {
            animationPaused = !animationPaused;
            document.getElementById('animToggle').textContent = animationPaused ? 'Resume' : 'Pause';
            document.getElementById('animToggle').classList.toggle('active', animationPaused);
        }

        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            scene.meshes.forEach(m => { if (m.material) m.material.wireframe = wireframeMode; });
            document.getElementById('wireframeToggle').classList.toggle('active', wireframeMode);
        }

        function cycleCamera() {
            cameraMode = (cameraMode + 1) % 4;
            switch (cameraMode) {
                case 0: camera.alpha = -Math.PI / 4; camera.beta = Math.PI / 3; camera.radius = 20; break;
                case 1: camera.alpha = 0; camera.beta = 0.1; camera.radius = 40; break;
                case 2: camera.alpha = -Math.PI / 6; camera.beta = Math.PI / 2.3; camera.radius = 12; break;
                case 3: camera.alpha = Math.PI; camera.beta = Math.PI / 2.5; camera.radius = 8; break;
            }
            camera.target = new BABYLON.Vector3(0, 2, 0);
        }

        function updateUI() {
            document.getElementById('mechCount').textContent = mechs.length;
            const container = document.getElementById('mechListContent');
            container.innerHTML = mechs.map((m, i) => `
                <div class="mech-entry">
                    <span>
                        <span class="color-swatch" style="background: rgb(${Math.floor(m.colors.primary[0]*255)},${Math.floor(m.colors.primary[1]*255)},${Math.floor(m.colors.primary[2]*255)})"></span>
                        <span class="mech-name">${m.archetype.name} #${i + 1}</span>
                        <span style="color: #888;">(${m.colors.name})</span>
                    </span>
                </div>
            `).join('');
        }

        // ============================================
        // INIT
        // ============================================

        window.addEventListener('DOMContentLoaded', () => {
            canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, { antialias: true, stencil: true });

            scene = createScene();

            let lastTime = performance.now();
            engine.runRenderLoop(() => {
                const now = performance.now();
                const dt = (now - lastTime) / 1000;
                lastTime = now;

                animator.update(dt, mechs);
                scene.render();

                document.getElementById('triCount').textContent = scene.getActiveIndices().toLocaleString();
                document.getElementById('drawCalls').textContent = scene.getActiveMeshes().length;
                document.getElementById('fps').textContent = engine.getFps().toFixed(0);
            });

            window.addEventListener('resize', () => engine.resize());
        });
    </script>
</body>
</html>
