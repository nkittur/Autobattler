<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Physics Combat Test - Auto-Running (Matches Real Game)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #0d0d1f;
            font-family: monospace;
            color: #00ff88;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #test-canvas {
            display: block;
            border: 2px solid #00ff88;
            max-width: 100vw;
            max-height: 100vh;
            width: 800px;
            height: 450px;
        }
        @media (max-width: 800px) {
            #test-canvas {
                width: 100vw;
                height: 56.25vw; /* 16:9 aspect ratio */
            }
        }
        #status {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            padding: 8px 12px;
            border: 1px solid #00ff88;
            font-size: 10px;
            line-height: 1.4;
            max-width: 200px;
            z-index: 1000;
        }
        .error { color: #ff4444; font-weight: bold; }
        .success { color: #00ff88; font-weight: bold; }
        .warning { color: #ffaa00; font-weight: bold; }
        h1 {
            color: #00ccff;
            margin-bottom: 5px;
            font-size: 11px;
        }
        .big { font-size: 13px; font-weight: bold; }
    </style>
</head>
<body>
    <canvas id="test-canvas" width="800" height="450"></canvas>
    <div id="status">
        <h1>‚öîÔ∏è AUTO BATTLE TEST</h1>
        <div id="info">Initializing...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        console.log('üß™ Physics test starting - MATCHES REAL GAME...');

        const canvas = document.getElementById('test-canvas');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('info');

        // Test state
        const testState = {
            playerHP: 120,
            enemyHP: 80,
            playerMaxHP: 120,
            enemyMaxHP: 80,
            playerShots: 0,
            enemyShots: 0,
            collisions: 0,
            damageApplied: 0,
            projectileCount: 0
        };

        function updateStatus() {
            const hpChange = (testState.playerHP < testState.playerMaxHP) || (testState.enemyHP < testState.enemyMaxHP);
            statusDiv.innerHTML = `
                <div class="success">‚úì Physics Running</div>
                <div class="big">Player HP: <span class="${testState.playerHP < testState.playerMaxHP ? 'warning' : 'success'}">${testState.playerHP}/${testState.playerMaxHP}</span></div>
                <div class="big">Enemy HP: <span class="${testState.enemyHP < testState.enemyMaxHP ? 'warning' : 'success'}">${testState.enemyHP}/${testState.enemyMaxHP}</span></div>
                <hr style="border-color: #00ff88; margin: 5px 0;">
                <div>Player Shots Fired: ${testState.playerShots}</div>
                <div>Enemy Shots Fired: ${testState.enemyShots}</div>
                <div>Active Projectiles: ${testState.projectileCount}</div>
                <div>Collisions Detected: <span class="${testState.collisions > 0 ? 'success' : 'error'}">${testState.collisions}</span></div>
                <div>Total Damage Applied: <span class="${testState.damageApplied > 0 ? 'success' : 'error'}">${testState.damageApplied}</span></div>
                <hr style="border-color: #00ff88; margin: 5px 0;">
                <div style="margin-top: 5px;">
                    ${testState.collisions === 0 && testState.playerShots > 3 ? '<div class="error">‚ö†Ô∏è NO COLLISIONS DETECTED!</div>' : ''}
                    ${testState.damageApplied === 0 && testState.collisions > 0 ? '<div class="error">‚ö†Ô∏è COLLISIONS BUT NO DAMAGE!</div>' : ''}
                    ${hpChange ? '<div class="success">‚úì HP IS CHANGING!</div>' : ''}
                </div>
            `;
        }

        // Matter.js setup
        const Engine = Matter.Engine;
        const World = Matter.World;
        const Bodies = Matter.Bodies;
        const Body = Matter.Body;
        const Events = Matter.Events;
        const Constraint = Matter.Constraint;
        const Composite = Matter.Composite;

        const engine = Engine.create();
        engine.gravity.y = 1.2; // Same as real game
        const world = engine.world;

        // Colors (same as real game)
        const colors = {
            player: '#00ff88',
            enemy: '#ff4444',
            projectile: '#ffaa00',
            background: '#0d0d1f',
            sky: '#1a1a3e',
            terrain: '#4a4a6a'
        };

        // Ground (matches main game: height - groundHeight/2 = 450 - 20 = 430)
        const ground = Bodies.rectangle(400, 430, 800, 40, {
            isStatic: true,
            friction: 0.8,
            label: 'ground',
            render: { fillStyle: colors.terrain }
        });
        World.add(world, ground);

        // Create ARTICULATED mech (matches real game exactly!)
        function createArticulatedMech(x, y, isPlayer) {
            const size = 30;

            // Body parts
            const torso = Bodies.rectangle(x, y, size * 1.2, size * 1.5, {
                density: 0.002,
                friction: 0.8,
                frictionAir: 0.05,
                restitution: 0.1,
                inertia: Infinity, // Can't tip over
                label: isPlayer ? 'player_torso' : 'enemy_torso'
            });

            const head = Bodies.circle(x, y - size, size * 0.5, {
                density: 0.001,
                friction: 0.5,
                frictionAir: 0.03,
                label: isPlayer ? 'player_head' : 'enemy_head'
            });

            const leftArm = Bodies.rectangle(x - size * 0.8, y, size * 0.3, size, {
                density: 0.001,
                friction: 0.5,
                frictionAir: 0.03,
                label: isPlayer ? 'player_arm' : 'enemy_arm'
            });

            const rightArm = Bodies.rectangle(x + size * 0.8, y, size * 0.3, size, {
                density: 0.001,
                friction: 0.5,
                frictionAir: 0.03,
                label: isPlayer ? 'player_arm' : 'enemy_arm'
            });

            const leftLeg = Bodies.rectangle(x - size * 0.3, y + size * 1.2, size * 0.35, size * 0.8, {
                density: 0.002,
                friction: 0.9,
                frictionAir: 0.04,
                label: isPlayer ? 'player_leg' : 'enemy_leg'
            });

            const rightLeg = Bodies.rectangle(x + size * 0.3, y + size * 1.2, size * 0.35, size * 0.8, {
                density: 0.002,
                friction: 0.9,
                frictionAir: 0.04,
                label: isPlayer ? 'player_leg' : 'enemy_leg'
            });

            // Constraints (joints)
            const constraints = [
                Constraint.create({
                    bodyA: head,
                    bodyB: torso,
                    pointA: { x: 0, y: size * 0.3 },
                    pointB: { x: 0, y: -size * 0.7 },
                    stiffness: 0.7,
                    length: 0
                }),
                Constraint.create({
                    bodyA: leftArm,
                    bodyB: torso,
                    pointA: { x: 0, y: -size * 0.4 },
                    pointB: { x: -size * 0.5, y: -size * 0.3 },
                    stiffness: 0.5,
                    length: 0
                }),
                Constraint.create({
                    bodyA: rightArm,
                    bodyB: torso,
                    pointA: { x: 0, y: -size * 0.4 },
                    pointB: { x: size * 0.5, y: -size * 0.3 },
                    stiffness: 0.5,
                    length: 0
                }),
                Constraint.create({
                    bodyA: leftLeg,
                    bodyB: torso,
                    pointA: { x: 0, y: -size * 0.4 },
                    pointB: { x: -size * 0.2, y: size * 0.7 },
                    stiffness: 0.6,
                    length: 0
                }),
                Constraint.create({
                    bodyA: rightLeg,
                    bodyB: torso,
                    pointA: { x: 0, y: -size * 0.4 },
                    pointB: { x: size * 0.2, y: size * 0.7 },
                    stiffness: 0.6,
                    length: 0
                })
            ];

            // Add to world
            const mech = Composite.create();
            Composite.add(mech, [torso, head, leftArm, rightArm, leftLeg, rightLeg, ...constraints]);
            World.add(world, mech);

            return {
                composite: mech,
                torso, head, leftArm, rightArm, leftLeg, rightLeg,
                color: isPlayer ? colors.player : colors.enemy,
                isPlayer
            };
        }

        // Create mechs at proper ground level
        console.log('Creating articulated mechs...');
        // Match main game positions EXACTLY
        const playerMech = createArticulatedMech(200, 300, true);
        const enemyMech = createArticulatedMech(600, 300, false);
        console.log('‚úì Mechs created');

        // Projectiles array
        const projectiles = [];

        // Visual effects
        const muzzleFlashes = []; // {x, y, life}

        // ADAPTIVE TARGETING SYSTEM - learns from misses
        const targetingData = {
            player: { aimAdjustX: 0, aimAdjustY: 0, lastShotX: 0, lastShotY: 0, hits: 0, misses: 0 },
            enemy: { aimAdjustX: 0, aimAdjustY: 0, lastShotX: 0, lastShotY: 0, hits: 0, misses: 0 }
        };

        // BALLISTIC TRAJECTORY SOLVER - accounts for gravity
        function calculateBallisticTrajectory(startX, startY, targetX, targetY, speed, gravity) {
            const dx = targetX - startX;
            const dy = targetY - startY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Time to reach target horizontally
            const timeToTarget = distance / speed;

            // Calculate gravity drop over that time
            // drop = 0.5 * gravity * time^2
            const gravityDrop = 0.5 * gravity * timeToTarget * timeToTarget;

            // Aim ABOVE target to compensate for drop
            const compensatedTargetY = targetY - gravityDrop;

            // Calculate angle to compensated target
            const angle = Math.atan2(compensatedTargetY - startY, dx);

            console.log(`   üìê Ballistic calc: distance=${distance.toFixed(1)}, time=${timeToTarget.toFixed(2)}s, drop=${gravityDrop.toFixed(1)}px`);
            console.log(`   üìê Aiming ${gravityDrop.toFixed(1)}px ABOVE target to compensate for gravity`);

            return angle;
        }

        // Fire projectile with ADAPTIVE BALLISTIC TARGETING
        function fireProjectile(from, to) {
            const centerX = from.torso.position.x;
            const centerY = from.torso.position.y;
            let targetX = to.torso.position.x;
            let targetY = to.torso.position.y;

            const shooterData = from.isPlayer ? targetingData.player : targetingData.enemy;

            // ADAPTIVE CORRECTION: Apply learned adjustments from previous misses
            targetX += shooterData.aimAdjustX;
            targetY += shooterData.aimAdjustY;

            console.log(`üéØ Adaptive aim correction: (${shooterData.aimAdjustX.toFixed(1)}, ${shooterData.aimAdjustY.toFixed(1)})`);
            console.log(`   Hit rate: ${shooterData.hits}/${shooterData.hits + shooterData.misses}`);

            const speed = 8;
            const gravity = 1.2;

            // BALLISTIC TRAJECTORY with gravity compensation
            const angle = calculateBallisticTrajectory(centerX, centerY, targetX, targetY, speed, gravity);

            // Spawn projectile 60px AWAY from mech center (outside body!)
            const spawnOffset = 60;
            const startX = centerX + Math.cos(angle) * spawnOffset;
            const startY = centerY + Math.sin(angle) * spawnOffset;

            const projectile = Bodies.circle(startX, startY, 10, {
                density: 0.01,
                restitution: 0.1,
                friction: 0.05,
                frictionAir: 0.001,
                label: 'bullet',
                collisionFilter: {
                    category: 0x0002,
                    mask: 0xFFFF
                }
            });

            Body.setVelocity(projectile, {
                x: Math.cos(angle) * speed,
                y: Math.sin(angle) * speed
            });

            projectile.damage = 10;
            projectile.fromPlayer = from.isPlayer;
            projectile.shooter = from;
            projectile.targetX = to.torso.position.x; // Store intended target for miss tracking
            projectile.targetY = to.torso.position.y;

            World.add(world, projectile);
            projectiles.push(projectile);

            // Store shot data for adaptive learning
            shooterData.lastShotX = targetX;
            shooterData.lastShotY = targetY;

            // MUZZLE FLASH for visibility!
            muzzleFlashes.push({x: startX, y: startY, life: 10});

            console.log(`üî´ Shot spawned at (${Math.floor(startX)}, ${Math.floor(startY)}) targeting (${Math.floor(targetX)}, ${Math.floor(targetY)})`);
            console.log(`   Velocity: (${(Math.cos(angle) * speed).toFixed(2)}, ${(Math.sin(angle) * speed).toFixed(2)})`);

            if (from.isPlayer) {
                testState.playerShots++;
                console.log(`   Player shot #${testState.playerShots}`);
            } else {
                testState.enemyShots++;
                console.log(`   Enemy shot #${testState.enemyShots}`);
            }
        }

        // Collision detection (FIXED: prevent self-collision)
        Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach(pair => {
                const { bodyA, bodyB } = pair;

                const projectile = projectiles.find(p => p === bodyA || p === bodyB);
                if (!projectile) return;

                const other = bodyA === projectile ? bodyB : bodyA;

                // CRITICAL: Ignore collision with shooter's own body parts
                if (projectile.shooter) {
                    const shooterParts = [
                        projectile.shooter.torso,
                        projectile.shooter.head,
                        projectile.shooter.leftArm,
                        projectile.shooter.rightArm,
                        projectile.shooter.leftLeg,
                        projectile.shooter.rightLeg
                    ];
                    if (shooterParts.includes(other)) {
                        console.log(`   (Ignoring self-collision with shooter's ${other.label})`);
                        return; // Skip this collision
                    }
                }

                console.log(`üí• COLLISION! ${projectile.label} hit ${other.label} at (${Math.floor(other.position.x)}, ${Math.floor(other.position.y)})`);
                testState.collisions++;

                // ADAPTIVE LEARNING: Track hit/miss outcomes
                const shooterData = projectile.fromPlayer ? targetingData.enemy : targetingData.player;

                // Check if hit player
                if (other.label && other.label.includes('player')) {
                    const damage = projectile.damage;
                    testState.playerHP = Math.max(0, testState.playerHP - damage);
                    testState.damageApplied += damage;
                    console.log(`   ‚úì PLAYER HIT! Damage: ${damage}, HP: ${testState.playerHP}`);

                    // LEARNING: Record successful hit
                    shooterData.hits++;
                    console.log(`   üéØ Enemy targeting improved! Hits: ${shooterData.hits}`);

                    World.remove(world, projectile);
                    projectiles.splice(projectiles.indexOf(projectile), 1);
                }
                // Check if hit enemy
                else if (other.label && other.label.includes('enemy')) {
                    const damage = projectile.damage;
                    testState.enemyHP = Math.max(0, testState.enemyHP - damage);
                    testState.damageApplied += damage;
                    console.log(`   ‚úì ENEMY HIT! Damage: ${damage}, HP: ${testState.enemyHP}`);

                    // LEARNING: Record successful hit
                    shooterData.hits++;
                    console.log(`   üéØ Player targeting improved! Hits: ${shooterData.hits}`);

                    World.remove(world, projectile);
                    projectiles.splice(projectiles.indexOf(projectile), 1);
                }
                // MISS: Hit ground or terrain
                else if (other.label === 'ground') {
                    console.log(`   ‚úó MISS! Hit ground at (${Math.floor(projectile.position.x)}, ${Math.floor(projectile.position.y)})`);

                    // LEARNING: Calculate error and adjust aim
                    const errorX = projectile.targetX - projectile.position.x;
                    const errorY = projectile.targetY - projectile.position.y;

                    // Apply 30% of error as correction (gradual learning)
                    const learningRate = 0.3;
                    shooterData.aimAdjustX += errorX * learningRate;
                    shooterData.aimAdjustY += errorY * learningRate;
                    shooterData.misses++;

                    console.log(`   üìä Miss error: (${errorX.toFixed(1)}, ${errorY.toFixed(1)})`);
                    console.log(`   üîß Adjusted aim by: (${(errorX * learningRate).toFixed(1)}, ${(errorY * learningRate).toFixed(1)})`);
                    console.log(`   üìà New aim correction: (${shooterData.aimAdjustX.toFixed(1)}, ${shooterData.aimAdjustY.toFixed(1)})`);

                    World.remove(world, projectile);
                    projectiles.splice(projectiles.indexOf(projectile), 1);
                }
            });
        });

        // Auto-fire
        let lastPlayerShot = 0;
        let lastEnemyShot = 0;
        const fireRate = 2000; // 2 seconds

        function autoFire() {
            const now = Date.now();

            if (now - lastPlayerShot > fireRate && testState.playerHP > 0) {
                fireProjectile(playerMech, enemyMech);
                lastPlayerShot = now;
            }

            if (now - lastEnemyShot > fireRate && testState.enemyHP > 0) {
                fireProjectile(enemyMech, playerMech);
                lastEnemyShot = now;
            }
        }

        // Render (matches real game style)
        function render() {
            // Clear
            ctx.fillStyle = colors.background;
            ctx.fillRect(0, 0, 800, 450);

            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, 450);
            gradient.addColorStop(0, colors.sky);
            gradient.addColorStop(1, colors.background);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 800, 315);

            // Render all bodies
            const allBodies = Composite.allBodies(world);
            allBodies.forEach(body => {
                const vertices = body.vertices;
                ctx.beginPath();
                ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < vertices.length; i++) {
                    ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                ctx.closePath();

                // Color by label
                if (body.label && body.label.includes('player')) {
                    ctx.fillStyle = colors.player;
                } else if (body.label && body.label.includes('enemy')) {
                    ctx.fillStyle = colors.enemy;
                } else if (body.label === 'bullet') {
                    ctx.fillStyle = colors.projectile;
                } else {
                    ctx.fillStyle = body.render.fillStyle || colors.terrain;
                }

                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // MUZZLE FLASHES (shows when mechs fire)
            for (let i = muzzleFlashes.length - 1; i >= 0; i--) {
                const flash = muzzleFlashes[i];
                const opacity = flash.life / 10;

                ctx.save();
                ctx.shadowBlur = 40;
                ctx.shadowColor = '#ffff00';
                ctx.fillStyle = `rgba(255, 255, 0, ${opacity})`;
                ctx.beginPath();
                ctx.arc(flash.x, flash.y, 30 * opacity, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                flash.life--;
                if (flash.life <= 0) {
                    muzzleFlashes.splice(i, 1);
                }
            }

            // SUPER VISIBLE PROJECTILES
            projectiles.forEach(proj => {
                const pos = proj.position;
                const vel = proj.velocity;

                // OUTER MASSIVE GLOW (so you can't miss it!)
                ctx.save();
                ctx.shadowBlur = 60;
                ctx.shadowColor = '#ffff00';
                ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 40, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // MIDDLE GLOW
                ctx.save();
                ctx.shadowBlur = 30;
                ctx.shadowColor = '#ff8800';
                ctx.fillStyle = 'rgba(255, 136, 0, 0.6)';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 25, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // INNER CORE (bright!)
                ctx.save();
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffffff';
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // THICK VELOCITY TRAIL
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 8;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ffff00';
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x - vel.x * 5, pos.y - vel.y * 5);
                ctx.stroke();
                ctx.shadowBlur = 0;

                // DEBUG: Position text
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px monospace';
                ctx.fillText(`SHOT ${Math.floor(pos.x)},${Math.floor(pos.y)}`, pos.x + 20, pos.y - 20);
            });

            // HP bars
            drawHPBar(playerMech.torso.position.x, playerMech.torso.position.y - 60, testState.playerHP, testState.playerMaxHP, colors.player);
            drawHPBar(enemyMech.torso.position.x, enemyMech.torso.position.y - 60, testState.enemyHP, testState.enemyMaxHP, colors.enemy);

            // BIG ON-SCREEN STATUS (for mobile)
            ctx.save();
            ctx.font = 'bold 16px monospace';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#000';

            // Projectiles count (HUGE and bright)
            if (projectiles.length > 0) {
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 24px monospace';
                ctx.fillText(`‚ö° ${projectiles.length} PROJECTILES ACTIVE ‚ö°`, 400, 50);
            }

            ctx.restore();
        }

        function drawHPBar(x, y, current, max, color) {
            const width = 80;
            const height = 8;

            ctx.fillStyle = '#000';
            ctx.fillRect(x - width/2 - 1, y - 1, width + 2, height + 2);

            const hpPercent = current / max;
            const hpWidth = Math.max(0, (width * hpPercent));

            if (hpPercent > 0.6) {
                ctx.fillStyle = '#00ff88';
            } else if (hpPercent > 0.3) {
                ctx.fillStyle = '#ffaa00';
            } else {
                ctx.fillStyle = '#ff4444';
            }

            ctx.fillRect(x - width/2, y, hpWidth, height);

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 10px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(`${Math.floor(current)}/${max}`, x, y - 5);
        }

        // Main loop
        function mainLoop() {
            autoFire();
            Engine.update(engine, 1000 / 60);
            testState.projectileCount = projectiles.length;
            render();
            updateStatus();
            requestAnimationFrame(mainLoop);
        }

        // Start
        console.log('üöÄ Starting auto battle (matches real game)...');
        setTimeout(() => {
            mainLoop();
        }, 500);

        updateStatus();
    </script>
</body>
</html>
