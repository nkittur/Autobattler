<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon.js + Havok Physics Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            font-family: monospace;
            color: #00ff88;
            overflow: auto;
            min-height: 100vh;
        }
        #renderCanvas {
            width: 100%;
            max-width: 900px;
            height: 50vh;
            max-height: 350px;
            display: block;
            margin: 0 auto;
            border: 3px solid #00ff88;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }
        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }
        #status {
            max-width: 900px;
            margin: 20px auto;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #00ff88;
            border-radius: 8px;
        }
        .log {
            font-size: 12px;
            margin: 2px 0;
            padding: 2px 5px;
        }
        .log.info { color: #00ff88; }
        .log.warn { color: #ffaa00; }
        .log.error { color: #ff4444; }
    </style>
</head>
<body>
    <h1>Babylon.js + Havok Physics Test</h1>
    <canvas id="renderCanvas"></canvas>
    <div id="status">
        <div id="logs"></div>
    </div>

    <!-- Babylon.js Core -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <!-- Havok Physics -->
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>

    <script>
        // Logging system
        const logs = [];
        function log(msg, type = 'info') {
            console.log(msg);
            logs.push({ msg, type });
            const logsDiv = document.getElementById('logs');
            logsDiv.innerHTML = logs.slice(-15).map(l =>
                `<div class="log ${l.type}">${l.msg}</div>`
            ).join('');
        }

        log('Initializing Babylon.js + Havok Physics...', 'info');

        // Global references
        let engine, scene, camera, havokInstance, havokPlugin;
        let playerMech, enemyMech;
        let projectiles = [];
        let laserBeams = [];

        // Colors
        const COLORS = {
            player: new BABYLON.Color3(0, 1, 0.53),     // #00ff88
            enemy: new BABYLON.Color3(1, 0.27, 0.27),   // #ff4444
            ground: new BABYLON.Color3(0.29, 0.29, 0.42), // #4a4a6a
            projectile: new BABYLON.Color3(1, 0.67, 0),  // #ffaa00
            laser: new BABYLON.Color3(1, 0, 0),          // Red
            explosion: new BABYLON.Color3(1, 0.4, 0)     // #ff6600
        };

        // Initialize Babylon.js and Havok
        async function initEngine() {
            const canvas = document.getElementById('renderCanvas');

            // Create Babylon engine
            engine = new BABYLON.Engine(canvas, true, {
                preserveDrawingBuffer: true,
                stencil: true
            });

            log('Babylon Engine created', 'info');

            // Initialize Havok Physics
            try {
                havokInstance = await HavokPhysics();
                log('Havok Physics initialized!', 'info');
            } catch (error) {
                log('Failed to load Havok: ' + error.message, 'error');
                return;
            }

            // Create scene
            scene = createScene();

            // Start render loop
            engine.runRenderLoop(() => {
                if (scene) {
                    scene.render();
                    updateProjectiles();
                    updateLaserBeams();
                }
            });

            // Handle resize
            window.addEventListener('resize', () => engine.resize());

            log('Scene created and render loop started!', 'info');
        }

        function createScene() {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.05, 0.05, 0.12); // Dark background

            // Create Havok physics plugin
            havokPlugin = new BABYLON.HavokPlugin(true, havokInstance);
            scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), havokPlugin);
            log('Physics enabled with Havok', 'info');

            // Create camera - fixed isometric-style view
            camera = new BABYLON.ArcRotateCamera(
                'camera',
                -Math.PI / 2,  // Alpha (horizontal rotation)
                Math.PI / 4,   // Beta (vertical angle - 45 degree isometric)
                18,            // Radius (distance)
                new BABYLON.Vector3(0, 3.5, 0), // Target (centered on mechs)
                scene
            );
            camera.attachControl(document.getElementById('renderCanvas'), true);
            camera.lowerRadiusLimit = 10;
            camera.upperRadiusLimit = 40;

            // Lighting
            const hemisphericLight = new BABYLON.HemisphericLight(
                'hemiLight',
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            hemisphericLight.intensity = 0.7;

            const directionalLight = new BABYLON.DirectionalLight(
                'dirLight',
                new BABYLON.Vector3(-1, -2, 1),
                scene
            );
            directionalLight.intensity = 0.5;

            // Create ground
            createGround(scene);

            // Create boundary walls
            createWalls(scene);

            // Create mechs (spawned at x position, they will drop to ground)
            playerMech = createMech(scene, -5, true);
            enemyMech = createMech(scene, 5, false);

            log('Scene fully initialized with mechs!', 'info');
            return scene;
        }

        function createGround(scene) {
            const ground = BABYLON.MeshBuilder.CreateGround('ground', {
                width: 30,
                height: 15
            }, scene);

            const groundMat = new BABYLON.StandardMaterial('groundMat', scene);
            groundMat.diffuseColor = COLORS.ground;
            groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            ground.material = groundMat;

            // Add physics to ground (static body)
            const groundAggregate = new BABYLON.PhysicsAggregate(
                ground,
                BABYLON.PhysicsShapeType.BOX,
                { mass: 0, friction: 0.8, restitution: 0.1 },
                scene
            );

            log('Ground created with physics', 'info');
            return ground;
        }

        function createWalls(scene) {
            // Create invisible boundary walls
            const wallHeight = 8;
            const wallThickness = 1;
            const arenaWidth = 30;
            const arenaDepth = 15;

            const wallMat = new BABYLON.StandardMaterial('wallMat', scene);
            wallMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.4);
            wallMat.alpha = 0.3;

            // Left wall
            const leftWall = BABYLON.MeshBuilder.CreateBox('leftWall', {
                width: wallThickness, height: wallHeight, depth: arenaDepth
            }, scene);
            leftWall.position = new BABYLON.Vector3(-arenaWidth/2, wallHeight/2, 0);
            leftWall.material = wallMat;
            new BABYLON.PhysicsAggregate(leftWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

            // Right wall
            const rightWall = BABYLON.MeshBuilder.CreateBox('rightWall', {
                width: wallThickness, height: wallHeight, depth: arenaDepth
            }, scene);
            rightWall.position = new BABYLON.Vector3(arenaWidth/2, wallHeight/2, 0);
            rightWall.material = wallMat;
            new BABYLON.PhysicsAggregate(rightWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

            // Front wall
            const frontWall = BABYLON.MeshBuilder.CreateBox('frontWall', {
                width: arenaWidth, height: wallHeight, depth: wallThickness
            }, scene);
            frontWall.position = new BABYLON.Vector3(0, wallHeight/2, arenaDepth/2);
            frontWall.material = wallMat;
            new BABYLON.PhysicsAggregate(frontWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

            // Back wall
            const backWall = BABYLON.MeshBuilder.CreateBox('backWall', {
                width: arenaWidth, height: wallHeight, depth: wallThickness
            }, scene);
            backWall.position = new BABYLON.Vector3(0, wallHeight/2, -arenaDepth/2);
            backWall.material = wallMat;
            new BABYLON.PhysicsAggregate(backWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

            log('Boundary walls created', 'info');
        }

        function createMech(scene, xPos, isPlayer) {
            const color = isPlayer ? COLORS.player : COLORS.enemy;
            const mechName = isPlayer ? 'player' : 'enemy';

            // Create parent transform node
            const mechRoot = new BABYLON.TransformNode(`${mechName}_root`, scene);
            mechRoot.position = new BABYLON.Vector3(xPos, 0, 0);

            // Create materials
            const bodyMat = new BABYLON.StandardMaterial(`${mechName}_bodyMat`, scene);
            bodyMat.diffuseColor = color;
            bodyMat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            bodyMat.emissiveColor = color.scale(0.2);

            const darkMat = new BABYLON.StandardMaterial(`${mechName}_darkMat`, scene);
            darkMat.diffuseColor = color.scale(0.5);

            const jointMat = new BABYLON.StandardMaterial(`${mechName}_jointMat`, scene);
            jointMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            jointMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);

            // Calculate mech component heights from feet to torso
            // upperLeg position from torso: -1.35
            // lowerLeg position from upperLeg: -0.85
            // foot position from lowerLeg: -0.38
            // foot half-height: 0.075
            const legOffset = 1.35; // upperLeg center from torso center
            const shinOffset = 0.85; // lowerLeg center from upperLeg center
            const footOffset = 0.38; // foot center from lowerLeg center
            const footHalfHeight = 0.075; // half of foot height (0.15 / 2)

            // Total distance from torso center to foot bottom
            const torsoToFootBottom = legOffset + shinOffset + footOffset + footHalfHeight; // = 2.655

            // Create invisible collision body that extends from torso down to feet
            // This ensures proper ground collision
            const collisionHeight = 1.5 + torsoToFootBottom; // Torso height + distance to feet = 4.155
            const collisionBody = BABYLON.MeshBuilder.CreateBox(`${mechName}_collision`, {
                width: 1.0,
                height: collisionHeight,
                depth: 0.8
            }, scene);

            // Position collision body so its bottom aligns with feet
            // Collision center should be at: feet bottom (0) + half collision height
            const collisionSpawnHeight = collisionHeight / 2 + 0.2; // Slight offset to drop
            collisionBody.position = new BABYLON.Vector3(xPos, collisionSpawnHeight, 0);
            collisionBody.visibility = 0.3; // Semi-transparent for debugging

            // Debug material for collision box
            const debugMat = new BABYLON.StandardMaterial(`${mechName}_debugMat`, scene);
            debugMat.diffuseColor = isPlayer ? new BABYLON.Color3(0, 1, 0) : new BABYLON.Color3(1, 0, 0);
            debugMat.alpha = 0.3;
            debugMat.wireframe = true;
            collisionBody.material = debugMat;

            // Add physics to collision body
            const torsoAggregate = new BABYLON.PhysicsAggregate(
                collisionBody,
                BABYLON.PhysicsShapeType.BOX,
                { mass: 50, friction: 0.8, restitution: 0.1 },
                scene
            );

            // === TORSO (visual - parented to collision body) ===
            const torso = BABYLON.MeshBuilder.CreateBox(`${mechName}_torso`, {
                width: 1.2, height: 1.5, depth: 0.8
            }, scene);
            // Position torso at correct height within collision body
            // Collision body bottom is at -collisionHeight/2 locally
            // Torso center should be at: collision bottom + torsoToFootBottom = -2.0775 + 2.655 = 0.5775
            torso.position = new BABYLON.Vector3(0, -collisionHeight/2 + torsoToFootBottom, 0);
            torso.parent = collisionBody;
            torso.material = bodyMat;

            // === HEAD ===
            const head = BABYLON.MeshBuilder.CreateBox(`${mechName}_head`, {
                width: 0.6, height: 0.5, depth: 0.5
            }, scene);
            head.position = new BABYLON.Vector3(0, 1.2, 0);
            head.parent = torso;
            head.material = bodyMat;

            // Visor
            const visor = BABYLON.MeshBuilder.CreateBox(`${mechName}_visor`, {
                width: 0.5, height: 0.15, depth: 0.1
            }, scene);
            visor.position = new BABYLON.Vector3(0, 0.1, 0.25);
            visor.parent = head;
            const visorMat = new BABYLON.StandardMaterial(`${mechName}_visorMat`, scene);
            visorMat.diffuseColor = new BABYLON.Color3(1, 0.2, 0);
            visorMat.emissiveColor = new BABYLON.Color3(1, 0.2, 0);
            visor.material = visorMat;

            // === ARMS ===
            const createArm = (side) => {
                const xOffset = side === 'left' ? -0.9 : 0.9;

                // Upper arm
                const upperArm = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}UpperArm`, {
                    width: 0.25, height: 0.6, depth: 0.25
                }, scene);
                upperArm.position = new BABYLON.Vector3(xOffset, 0.3, 0);
                upperArm.parent = torso;
                upperArm.material = darkMat;

                // Shoulder joint
                const shoulder = BABYLON.MeshBuilder.CreateSphere(`${mechName}_${side}Shoulder`, {
                    diameter: 0.3
                }, scene);
                shoulder.position = new BABYLON.Vector3(xOffset, 0.65, 0);
                shoulder.parent = torso;
                shoulder.material = jointMat;

                // Lower arm / weapon
                const weapon = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}Weapon`, {
                    width: 0.2, height: 0.8, depth: 0.2
                }, scene);
                weapon.position = new BABYLON.Vector3(0, -0.7, 0);
                weapon.parent = upperArm;
                weapon.material = jointMat;

                // Weapon barrel
                const barrel = BABYLON.MeshBuilder.CreateCylinder(`${mechName}_${side}Barrel`, {
                    height: 0.4, diameter: 0.12
                }, scene);
                barrel.rotation.x = Math.PI / 2;
                barrel.position = new BABYLON.Vector3(0, -0.3, 0.25);
                barrel.parent = weapon;
                barrel.material = jointMat;

                return { upperArm, shoulder, weapon, barrel };
            };

            const leftArm = createArm('left');
            const rightArm = createArm('right');

            // === LEGS ===
            const createLeg = (side) => {
                const xOffset = side === 'left' ? -0.4 : 0.4;

                // Hip joint
                const hip = BABYLON.MeshBuilder.CreateSphere(`${mechName}_${side}Hip`, {
                    diameter: 0.25
                }, scene);
                hip.position = new BABYLON.Vector3(xOffset, -0.85, 0);
                hip.parent = torso;
                hip.material = jointMat;

                // Upper leg
                const upperLeg = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}UpperLeg`, {
                    width: 0.3, height: 0.7, depth: 0.3
                }, scene);
                upperLeg.position = new BABYLON.Vector3(xOffset, -1.35, 0);
                upperLeg.parent = torso;
                upperLeg.material = bodyMat;

                // Knee joint
                const knee = BABYLON.MeshBuilder.CreateSphere(`${mechName}_${side}Knee`, {
                    diameter: 0.2
                }, scene);
                knee.position = new BABYLON.Vector3(0, -0.45, 0);
                knee.parent = upperLeg;
                knee.material = jointMat;

                // Lower leg
                const lowerLeg = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}LowerLeg`, {
                    width: 0.25, height: 0.6, depth: 0.25
                }, scene);
                lowerLeg.position = new BABYLON.Vector3(0, -0.85, 0);
                lowerLeg.parent = upperLeg;
                lowerLeg.material = darkMat;

                // Foot
                const foot = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}Foot`, {
                    width: 0.35, height: 0.15, depth: 0.5
                }, scene);
                foot.position = new BABYLON.Vector3(0, -0.38, 0.1);
                foot.parent = lowerLeg;
                foot.material = jointMat;

                return { hip, upperLeg, knee, lowerLeg, foot };
            };

            const leftLeg = createLeg('left');
            const rightLeg = createLeg('right');

            // === SHOULDER ARMOR ===
            const createShoulderArmor = (side) => {
                const xOffset = side === 'left' ? -0.85 : 0.85;
                const shoulderArmor = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}ShoulderArmor`, {
                    width: 0.5, height: 0.35, depth: 0.6
                }, scene);
                shoulderArmor.position = new BABYLON.Vector3(xOffset, 0.8, 0);
                shoulderArmor.parent = torso;
                shoulderArmor.material = bodyMat;
                return shoulderArmor;
            };

            createShoulderArmor('left');
            createShoulderArmor('right');

            // Store mech data
            const mechData = {
                root: mechRoot,
                collisionBody: collisionBody, // Physics body (invisible)
                torso: torso,                 // Visual torso
                torsoAggregate: torsoAggregate,
                head: head,
                visor: visor,
                leftArm: leftArm,
                rightArm: rightArm,
                leftLeg: leftLeg,
                rightLeg: rightLeg,
                isPlayer: isPlayer,
                currentHP: 100,
                maxHP: 100,
                color: color
            };

            log(`${isPlayer ? 'Player' : 'Enemy'} mech created:`, 'info');
            log(`  Collision body at: (${collisionBody.position.x.toFixed(1)}, ${collisionBody.position.y.toFixed(1)}, ${collisionBody.position.z.toFixed(1)})`, 'info');
            log(`  Torso world pos: (${torso.getAbsolutePosition().x.toFixed(1)}, ${torso.getAbsolutePosition().y.toFixed(1)}, ${torso.getAbsolutePosition().z.toFixed(1)})`, 'info');
            return mechData;
        }

        // === PROJECTILE SYSTEM ===
        function firePlayerProjectile() {
            if (!playerMech || !enemyMech) return;
            createProjectile(playerMech, enemyMech, 15);
        }

        function fireEnemyProjectile() {
            if (!playerMech || !enemyMech) return;
            createProjectile(enemyMech, playerMech, 12);
        }

        function createProjectile(fromMech, toMech, damage) {
            // Get world positions (torso is parented to collisionBody, so use absolute position)
            const startPos = fromMech.torso.getAbsolutePosition().clone();
            startPos.y += 0.3; // Fire from weapon height

            const targetPos = toMech.torso.getAbsolutePosition().clone();

            log(`PROJECTILE: from (${startPos.x.toFixed(1)}, ${startPos.y.toFixed(1)}, ${startPos.z.toFixed(1)}) to (${targetPos.x.toFixed(1)}, ${targetPos.y.toFixed(1)}, ${targetPos.z.toFixed(1)})`, 'info');

            // Calculate direction
            const direction = targetPos.subtract(startPos).normalize();
            const angle = Math.atan2(direction.x, direction.z);

            // Create elongated projectile (bullet/energy bolt shape)
            const projectile = BABYLON.MeshBuilder.CreateCylinder('projectile_' + Date.now(), {
                height: 0.8,
                diameter: 0.25,
                tessellation: 8
            }, scene);
            projectile.position = startPos.clone();

            // Rotate to point in direction of travel
            projectile.rotation.x = Math.PI / 2;
            projectile.rotation.y = angle;

            // Projectile material with intense glow
            const projMat = new BABYLON.StandardMaterial('projMat_' + Date.now(), scene);
            projMat.diffuseColor = COLORS.projectile;
            projMat.emissiveColor = COLORS.projectile.scale(1.5); // Brighter glow
            projMat.specularColor = new BABYLON.Color3(1, 1, 1);
            projectile.material = projMat;

            // Create glowing trail effect
            const trail = BABYLON.MeshBuilder.CreateCylinder('trail_' + Date.now(), {
                height: 1.5,
                diameter: 0.15,
                tessellation: 8
            }, scene);
            trail.position = new BABYLON.Vector3(0, -0.5, 0);
            trail.parent = projectile;
            const trailMat = new BABYLON.StandardMaterial('trailMat_' + Date.now(), scene);
            trailMat.diffuseColor = COLORS.projectile;
            trailMat.emissiveColor = COLORS.projectile;
            trailMat.alpha = 0.6;
            trail.material = trailMat;

            // Add physics to projectile
            const projAggregate = new BABYLON.PhysicsAggregate(
                projectile,
                BABYLON.PhysicsShapeType.SPHERE,
                { mass: 0.3, friction: 0, restitution: 0.2 },
                scene
            );

            // Apply high velocity for fast, impactful shot
            const speed = 45;
            const velocity = direction.scale(speed);
            projAggregate.body.setLinearVelocity(velocity);

            // Store projectile data
            projectiles.push({
                mesh: projectile,
                aggregate: projAggregate,
                damage: damage,
                target: toMech,
                firedAt: Date.now(),
                fromPlayer: fromMech.isPlayer
            });

            log(`${fromMech.isPlayer ? 'Player' : 'Enemy'} fired projectile!`, 'info');
        }

        function updateProjectiles() {
            const now = Date.now();

            projectiles = projectiles.filter(proj => {
                // Remove old projectiles (after 5 seconds)
                if (now - proj.firedAt > 5000) {
                    proj.mesh.dispose();
                    return false;
                }

                // Check for collision with target
                const projPos = proj.mesh.position;
                const targetPos = proj.target.torso.getAbsolutePosition();
                const distance = BABYLON.Vector3.Distance(projPos, targetPos);

                if (distance < 1.5) {
                    // Hit!
                    proj.target.currentHP -= proj.damage;
                    log(`HIT! ${proj.fromPlayer ? 'Enemy' : 'Player'} takes ${proj.damage} damage! (${proj.target.currentHP}/${proj.target.maxHP} HP)`, 'warn');

                    // Create impact effect at hit location
                    createImpactEffect(projPos.clone());

                    // Flash the torso on hit
                    flashMeshOnHit(proj.target.torso);

                    // Shake the mech on hit
                    shakeMechOnHit(proj.target, 0.3);

                    // Apply strong knockback force to target (use collision body position for physics)
                    const targetWorldPos = proj.target.collisionBody.position;
                    const knockbackDir = projPos.subtract(targetWorldPos).normalize().scale(-1);
                    proj.target.torsoAggregate.body.applyImpulse(
                        knockbackDir.scale(15), // Stronger knockback for impactful hits
                        targetWorldPos
                    );

                    proj.mesh.dispose();
                    return false;
                }

                // Check if projectile is out of bounds
                if (projPos.y < -5 || Math.abs(projPos.x) > 20 || Math.abs(projPos.z) > 10) {
                    proj.mesh.dispose();
                    return false;
                }

                return true;
            });
        }

        // === LASER BEAM SYSTEM ===
        function fireLaser(isPlayer) {
            const fromMech = isPlayer ? playerMech : enemyMech;
            const toMech = isPlayer ? enemyMech : playerMech;

            // Get world positions (torso is parented to collisionBody, so use absolute position)
            const startPos = fromMech.torso.getAbsolutePosition().clone();
            startPos.y += 0.3;

            const endPos = toMech.torso.getAbsolutePosition().clone();

            log(`LASER: from (${startPos.x.toFixed(1)}, ${startPos.y.toFixed(1)}, ${startPos.z.toFixed(1)}) to (${endPos.x.toFixed(1)}, ${endPos.y.toFixed(1)}, ${endPos.z.toFixed(1)})`, 'info');

            // Create main laser beam (thick and bright)
            const points = [startPos, endPos];
            const laserBeam = BABYLON.MeshBuilder.CreateTube('laser_' + Date.now(), {
                path: points,
                radius: 0.2,
                updatable: false
            }, scene);

            // Laser material with intense glow
            const laserMat = new BABYLON.StandardMaterial('laserMat_' + Date.now(), scene);
            laserMat.diffuseColor = COLORS.laser;
            laserMat.emissiveColor = COLORS.laser.scale(2); // Very bright
            laserMat.alpha = 0.9;
            laserBeam.material = laserMat;

            // Create outer glow layer
            const glowBeam = BABYLON.MeshBuilder.CreateTube('laserGlow_' + Date.now(), {
                path: points,
                radius: 0.35,
                updatable: false
            }, scene);
            const glowMat = new BABYLON.StandardMaterial('glowMat_' + Date.now(), scene);
            glowMat.diffuseColor = COLORS.laser;
            glowMat.emissiveColor = COLORS.laser.scale(0.8);
            glowMat.alpha = 0.4;
            glowBeam.material = glowMat;

            // Apply damage immediately (laser is instant)
            const damage = 10;
            toMech.currentHP -= damage;
            log(`LASER HIT! ${isPlayer ? 'Enemy' : 'Player'} takes ${damage} damage! (${toMech.currentHP}/${toMech.maxHP} HP)`, 'warn');

            // Store both beams for fadeout
            laserBeams.push({
                mesh: laserBeam,
                glowMesh: glowBeam,
                material: laserMat,
                glowMaterial: glowMat,
                createdAt: Date.now(),
                duration: 200 // ms
            });

            // Create impact at target
            createImpactEffect(endPos.clone());

            // Flash the torso on hit
            flashMeshOnHit(toMech.torso);

            // Shake the mech on hit
            shakeMechOnHit(toMech, 0.25);

            // Apply laser knockback
            const laserDir = endPos.subtract(startPos).normalize();
            toMech.torsoAggregate.body.applyImpulse(
                laserDir.scale(8),
                toMech.collisionBody.position
            );
        }

        function updateLaserBeams() {
            const now = Date.now();

            laserBeams = laserBeams.filter(beam => {
                const age = now - beam.createdAt;

                if (age > beam.duration) {
                    beam.mesh.dispose();
                    beam.glowMesh.dispose();
                    return false;
                }

                // Fade out both beams
                const fadeProgress = age / beam.duration;
                beam.material.alpha = 0.9 * (1 - fadeProgress);
                beam.glowMaterial.alpha = 0.4 * (1 - fadeProgress);
                return true;
            });
        }

        // === EFFECTS ===
        function flashMeshOnHit(mesh) {
            // Store original material properties
            const material = mesh.material;
            if (!material) return;

            const originalEmissive = material.emissiveColor ? material.emissiveColor.clone() : new BABYLON.Color3(0, 0, 0);
            const originalDiffuse = material.diffuseColor ? material.diffuseColor.clone() : new BABYLON.Color3(1, 1, 1);

            // Flash bright red/white
            material.emissiveColor = new BABYLON.Color3(1, 0.3, 0.3);
            material.diffuseColor = new BABYLON.Color3(1.8, 0.8, 0.8);

            // Quick fade back through orange to original
            setTimeout(() => {
                if (material) {
                    material.emissiveColor = new BABYLON.Color3(1, 0.5, 0);
                    material.diffuseColor = new BABYLON.Color3(1.5, 1, 0.8);
                }
            }, 50);

            // Restore original colors after a short delay
            setTimeout(() => {
                if (material) {
                    material.emissiveColor = originalEmissive;
                    material.diffuseColor = originalDiffuse;
                }
            }, 150);
        }

        function shakeMechOnHit(mech, intensity = 0.1) {
            // Apply rapid impulses to create shake effect
            const body = mech.torsoAggregate.body;
            const centerPos = mech.collisionBody.position;

            // Apply 5 rapid impulses in random directions
            let shakeCount = 0;
            const maxShakes = 5;
            const shakeInterval = setInterval(() => {
                if (shakeCount >= maxShakes) {
                    clearInterval(shakeInterval);
                } else {
                    // Random impulse in X and Z directions
                    const impulse = new BABYLON.Vector3(
                        (Math.random() - 0.5) * intensity * 100,
                        0,
                        (Math.random() - 0.5) * intensity * 100
                    );
                    body.applyImpulse(impulse, centerPos);
                    shakeCount++;
                }
            }, 40);
        }

        function createImpactEffect(position) {
            // Create particle system for impact
            const particleSystem = new BABYLON.ParticleSystem('impact_' + Date.now(), 100, scene);

            // Texture (procedural)
            particleSystem.particleTexture = new BABYLON.Texture('https://assets.babylonjs.com/textures/flare.png', scene);

            // Emitter
            particleSystem.emitter = position;
            particleSystem.minEmitBox = new BABYLON.Vector3(-0.2, -0.2, -0.2);
            particleSystem.maxEmitBox = new BABYLON.Vector3(0.2, 0.2, 0.2);

            // Colors - bright orange/yellow explosion
            particleSystem.color1 = new BABYLON.Color4(1, 0.8, 0, 1);
            particleSystem.color2 = new BABYLON.Color4(1, 0.3, 0, 1);
            particleSystem.colorDead = new BABYLON.Color4(0.3, 0.1, 0, 0);

            // Size - larger particles
            particleSystem.minSize = 0.15;
            particleSystem.maxSize = 0.5;

            // Lifetime
            particleSystem.minLifeTime = 0.15;
            particleSystem.maxLifeTime = 0.4;

            // Emission - burst of particles
            particleSystem.emitRate = 300;
            particleSystem.manualEmitCount = 60;

            // Speed - faster explosion
            particleSystem.minEmitPower = 3;
            particleSystem.maxEmitPower = 8;
            particleSystem.updateSpeed = 0.015;

            // Direction - spherical burst
            particleSystem.direction1 = new BABYLON.Vector3(-1, -0.5, -1);
            particleSystem.direction2 = new BABYLON.Vector3(1, 1, 1);

            // Gravity
            particleSystem.gravity = new BABYLON.Vector3(0, -8, 0);

            // Add glow/blend mode for more dramatic effect
            particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;

            // Start and auto-dispose
            particleSystem.start();
            particleSystem.targetStopDuration = 0.4;
            particleSystem.disposeOnStop = true;
        }

        function resetScene() {
            // Reset mech positions
            if (playerMech) {
                const collisionHeight = 1.5 + 1.35 + 0.85 + 0.38 + 0.075; // = 4.155
                const resetHeight = collisionHeight / 2 + 1.0;
                playerMech.collisionBody.position = new BABYLON.Vector3(-5, resetHeight, 0);
                playerMech.torsoAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                playerMech.torsoAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());
                playerMech.currentHP = playerMech.maxHP;
            }
            if (enemyMech) {
                const collisionHeight = 1.5 + 1.35 + 0.85 + 0.38 + 0.075; // = 4.155
                const resetHeight = collisionHeight / 2 + 1.0;
                enemyMech.collisionBody.position = new BABYLON.Vector3(5, resetHeight, 0);
                enemyMech.torsoAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                enemyMech.torsoAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());
                enemyMech.currentHP = enemyMech.maxHP;
            }

            // Clear projectiles
            projectiles.forEach(p => p.mesh.dispose());
            projectiles = [];

            // Clear laser beams
            laserBeams.forEach(b => b.mesh.dispose());
            laserBeams = [];

            log('Scene reset!', 'info');
        }

        // Auto-fire weapons periodically
        function startAutoFire() {
            setInterval(() => {
                if (playerMech && enemyMech && playerMech.currentHP > 0 && enemyMech.currentHP > 0) {
                    // Randomly fire weapons
                    if (Math.random() > 0.7) {
                        createProjectile(playerMech, enemyMech, 15);
                    }
                    if (Math.random() > 0.7) {
                        createProjectile(enemyMech, playerMech, 12);
                    }
                    if (Math.random() > 0.8) {
                        fireLaser(true);
                    }
                    if (Math.random() > 0.8) {
                        fireLaser(false);
                    }
                }
            }, 1000); // Fire every second
        }

        // Initialize when page loads
        initEngine().then(() => {
            // Start auto-fire after scene is initialized
            setTimeout(startAutoFire, 2000);
            log('Auto-fire enabled!', 'info');
        });
    </script>
</body>
</html>
