<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Physics Combat Test v1.19.0 - With Visible Status Log (iPhone Debugging)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #0d0d1f;
            font-family: monospace;
            color: #00ff88;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #test-canvas {
            display: block;
            border: 2px solid #00ff88;
            max-width: 100vw;
            max-height: 100vh;
            width: 800px;
            height: 450px;
        }
        @media (max-width: 800px) {
            #test-canvas {
                width: 100vw;
                height: 56.25vw; /* 16:9 aspect ratio */
            }
        }
        #status {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            padding: 8px 12px;
            border: 1px solid #00ff88;
            font-size: 10px;
            line-height: 1.4;
            max-width: 200px;
            z-index: 1000;
        }
        .error { color: #ff4444; font-weight: bold; }
        .success { color: #00ff88; font-weight: bold; }
        .warning { color: #ffaa00; font-weight: bold; }
        h1 {
            color: #00ccff;
            margin-bottom: 5px;
            font-size: 11px;
        }
        .big { font-size: 13px; font-weight: bold; }
    </style>
</head>
<body>
    <!-- VERSION BADGE - NO JAVASCRIPT NEEDED -->
    <div style="position: absolute; top: 10px; left: 10px; background: #f0f; color: #fff; padding: 10px; font-weight: bold; font-size: 16px; border: 3px solid #fff; z-index: 9999; box-shadow: 0 0 20px #f0f;">
        üî• v1.19.1 - LOOK AT CANVAS FOR YELLOW TEXT üî•
    </div>

    <canvas id="test-canvas" width="800" height="450"></canvas>
    <div id="status">
        <h1>‚öîÔ∏è AUTO BATTLE TEST</h1>
        <div id="info">Initializing...</div>
    </div>

    <div id="status-log" style="position: absolute; bottom: 10px; left: 10px; right: 10px; background:#222; color:#0f0; padding:15px; border-radius:8px; font-family:monospace; font-size:11px; max-height:150px; overflow-y:auto; border:1px solid #0f0;">
        <div style="font-weight:bold; margin-bottom:10px;">üìã INITIALIZATION LOG:</div>
        <div id="status-messages"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        console.log('üß™ Physics test starting - MATCHES REAL GAME...');

        const canvas = document.getElementById('test-canvas');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('info');

        // Visible status logging for iPhone debugging
        function statusLog(message, type = 'info') {
            const statusMessages = document.getElementById('status-messages');
            if (!statusMessages) return;

            const timestamp = new Date().toLocaleTimeString();
            const colors = {
                'info': '#0f0',
                'success': '#0ff',
                'warning': '#ff0',
                'error': '#f00'
            };
            const icons = {
                'info': '‚Ä¢',
                'success': '‚úì',
                'warning': '‚ö†',
                'error': '‚úó'
            };

            const entry = document.createElement('div');
            entry.style.color = colors[type] || '#0f0';
            entry.style.marginBottom = '5px';
            entry.textContent = `[${timestamp}] ${icons[type]} ${message}`;
            statusMessages.appendChild(entry);

            // Auto-scroll to bottom
            statusMessages.parentElement.scrollTop = statusMessages.parentElement.scrollHeight;

            // Also log to console
            console.log(`[STATUS] ${message}`);
        }

        // Test state
        const testState = {
            playerHP: 120,
            enemyHP: 80,
            playerMaxHP: 120,
            enemyMaxHP: 80,
            playerShots: 0,
            enemyShots: 0,
            collisions: 0,
            damageApplied: 0,
            projectileCount: 0
        };

        function updateStatus() {
            const hpChange = (testState.playerHP < testState.playerMaxHP) || (testState.enemyHP < testState.enemyMaxHP);
            statusDiv.innerHTML = `
                <div class="success">‚úì Physics Running</div>
                <div class="big">Player HP: <span class="${testState.playerHP < testState.playerMaxHP ? 'warning' : 'success'}">${testState.playerHP}/${testState.playerMaxHP}</span></div>
                <div class="big">Enemy HP: <span class="${testState.enemyHP < testState.enemyMaxHP ? 'warning' : 'success'}">${testState.enemyHP}/${testState.enemyMaxHP}</span></div>
                <hr style="border-color: #00ff88; margin: 5px 0;">
                <div>Player Shots Fired: ${testState.playerShots}</div>
                <div>Enemy Shots Fired: ${testState.enemyShots}</div>
                <div>Active Projectiles: ${testState.projectileCount}</div>
                <div>Collisions Detected: <span class="${testState.collisions > 0 ? 'success' : 'error'}">${testState.collisions}</span></div>
                <div>Total Damage Applied: <span class="${testState.damageApplied > 0 ? 'success' : 'error'}">${testState.damageApplied}</span></div>
                <hr style="border-color: #00ff88; margin: 5px 0;">
                <div style="margin-top: 5px;">
                    ${testState.collisions === 0 && testState.playerShots > 3 ? '<div class="error">‚ö†Ô∏è NO COLLISIONS DETECTED!</div>' : ''}
                    ${testState.damageApplied === 0 && testState.collisions > 0 ? '<div class="error">‚ö†Ô∏è COLLISIONS BUT NO DAMAGE!</div>' : ''}
                    ${hpChange ? '<div class="success">‚úì HP IS CHANGING!</div>' : ''}
                </div>
            `;
        }

        // Matter.js setup
        statusLog('Setting up Matter.js engine...', 'info');
        const Engine = Matter.Engine;
        const World = Matter.World;
        const Bodies = Matter.Bodies;
        const Body = Matter.Body;
        const Events = Matter.Events;
        const Constraint = Matter.Constraint;
        const Composite = Matter.Composite;

        const engine = Engine.create();
        engine.gravity.y = 1.2; // Same as real game
        const world = engine.world;
        statusLog('Matter.js engine created (gravity: 1.2)', 'success');

        // Colors (same as real game)
        const colors = {
            player: '#00ff88',
            enemy: '#ff4444',
            projectile: '#ffaa00',
            background: '#0d0d1f',
            sky: '#1a1a3e',
            terrain: '#4a4a6a'
        };

        // Ground (matches main game: height - groundHeight/2 = 450 - 20 = 430)
        statusLog('Creating ground terrain...', 'info');
        const ground = Bodies.rectangle(400, 430, 800, 40, {
            isStatic: true,
            friction: 0.8,
            label: 'ground',
            render: { fillStyle: colors.terrain }
        });
        World.add(world, ground);
        statusLog('Ground terrain created at y=430', 'success');

        // Create ARTICULATED mech (matches real game exactly!)
        function createArticulatedMech(x, y, isPlayer) {
            statusLog(`Creating ${isPlayer ? 'PLAYER' : 'ENEMY'} mech at (${x}, ${y})`, 'info');
            const size = 30;

            // Body parts
            const torso = Bodies.rectangle(x, y, size * 1.2, size * 1.5, {
                density: 0.002,
                friction: 0.8,
                frictionAir: 0.05,
                restitution: 0.1,
                inertia: Infinity, // Can't tip over
                label: isPlayer ? 'player_torso' : 'enemy_torso'
            });

            const head = Bodies.circle(x, y - size, size * 0.5, {
                density: 0.001,
                friction: 0.5,
                frictionAir: 0.03,
                label: isPlayer ? 'player_head' : 'enemy_head'
            });

            const leftArm = Bodies.rectangle(x - size * 0.8, y, size * 0.3, size, {
                density: 0.001,
                friction: 0.5,
                frictionAir: 0.03,
                label: isPlayer ? 'player_arm' : 'enemy_arm'
            });

            const rightArm = Bodies.rectangle(x + size * 0.8, y, size * 0.3, size, {
                density: 0.001,
                friction: 0.5,
                frictionAir: 0.03,
                label: isPlayer ? 'player_arm' : 'enemy_arm'
            });

            const leftLeg = Bodies.rectangle(x - size * 0.3, y + size * 1.2, size * 0.35, size * 0.8, {
                density: 0.002,
                friction: 0.9,
                frictionAir: 0.04,
                label: isPlayer ? 'player_leg' : 'enemy_leg'
            });

            const rightLeg = Bodies.rectangle(x + size * 0.3, y + size * 1.2, size * 0.35, size * 0.8, {
                density: 0.002,
                friction: 0.9,
                frictionAir: 0.04,
                label: isPlayer ? 'player_leg' : 'enemy_leg'
            });

            // Constraints (joints)
            const constraints = [
                Constraint.create({
                    bodyA: head,
                    bodyB: torso,
                    pointA: { x: 0, y: size * 0.3 },
                    pointB: { x: 0, y: -size * 0.7 },
                    stiffness: 0.7,
                    length: 0
                }),
                Constraint.create({
                    bodyA: leftArm,
                    bodyB: torso,
                    pointA: { x: 0, y: -size * 0.4 },
                    pointB: { x: -size * 0.5, y: -size * 0.3 },
                    stiffness: 0.5,
                    length: 0
                }),
                Constraint.create({
                    bodyA: rightArm,
                    bodyB: torso,
                    pointA: { x: 0, y: -size * 0.4 },
                    pointB: { x: size * 0.5, y: -size * 0.3 },
                    stiffness: 0.5,
                    length: 0
                }),
                Constraint.create({
                    bodyA: leftLeg,
                    bodyB: torso,
                    pointA: { x: 0, y: -size * 0.4 },
                    pointB: { x: -size * 0.2, y: size * 0.7 },
                    stiffness: 0.6,
                    length: 0
                }),
                Constraint.create({
                    bodyA: rightLeg,
                    bodyB: torso,
                    pointA: { x: 0, y: -size * 0.4 },
                    pointB: { x: size * 0.2, y: size * 0.7 },
                    stiffness: 0.6,
                    length: 0
                })
            ];

            // Add to world
            const mech = Composite.create();
            Composite.add(mech, [torso, head, leftArm, rightArm, leftLeg, rightLeg, ...constraints]);
            World.add(world, mech);

            statusLog(`${isPlayer ? 'PLAYER' : 'ENEMY'} mech created successfully!`, 'success');

            return {
                composite: mech,
                torso, head, leftArm, rightArm, leftLeg, rightLeg,
                color: isPlayer ? colors.player : colors.enemy,
                isPlayer
            };
        }

        // Create mechs at proper ground level
        statusLog('=== CREATING MECHS ===', 'info');
        console.log('Creating articulated mechs...');
        // Match main game positions EXACTLY
        const playerMech = createArticulatedMech(200, 300, true);
        const enemyMech = createArticulatedMech(600, 300, false);
        console.log('‚úì Mechs created');
        statusLog('Both mechs added to world', 'success');

        // Projectiles array
        const projectiles = [];

        // Visual effects
        const muzzleFlashes = []; // {x, y, life}

        // ADAPTIVE TARGETING SYSTEM - learns from misses
        const targetingData = {
            player: { aimAdjustX: 0, aimAdjustY: 0, lastShotX: 0, lastShotY: 0, hits: 0, misses: 0 },
            enemy: { aimAdjustX: 0, aimAdjustY: 0, lastShotX: 0, lastShotY: 0, hits: 0, misses: 0 }
        };

        // SIMPLE DIRECT AIMING - just aim at target
        function calculateBallisticTrajectory(startX, startY, targetX, targetY, speed, gravity) {
            // Aim directly at target
            return Math.atan2(targetY - startY, targetX - startX);
        }

        // Fire projectile with ACCURATE BALLISTIC TARGETING + JITTER
        function fireProjectile(from, to) {
            const centerX = from.torso.position.x;
            const centerY = from.torso.position.y;
            const targetX = to.torso.position.x;
            const targetY = to.torso.position.y;

            // Simple direct aim at target
            const angle = Math.atan2(targetY - centerY, targetX - centerX);

            // Spawn projectile 60px AWAY from mech center (outside body!)
            const spawnOffset = 60;
            const startX = centerX + Math.cos(angle) * spawnOffset;
            const startY = centerY + Math.sin(angle) * spawnOffset;

            const projectile = Bodies.circle(startX, startY, 10, {
                density: 0.01,
                restitution: 0.1,
                friction: 0.05,
                frictionAir: 0.001,
                label: 'bullet',
                collisionFilter: {
                    category: 0x0002,  // Projectile category
                    mask: 0x0001       // ONLY collide with mechs (0x0001), NOT other projectiles (0x0002)
                }
            });

            Body.setVelocity(projectile, {
                x: Math.cos(angle) * speed,
                y: Math.sin(angle) * speed
            });

            projectile.damage = 10;
            projectile.fromPlayer = from.isPlayer;
            projectile.shooter = from;
            // Store ORIGINAL enemy position for adaptive learning
            // Error calculation needs to measure "how far from enemy", not "how close to adjusted aim"
            projectile.targetX = to.torso.position.x;
            projectile.targetY = to.torso.position.y;

            World.add(world, projectile);
            projectiles.push(projectile);

            // Store shot data for adaptive learning
            shooterData.lastShotX = targetX;
            shooterData.lastShotY = targetY;

            // MUZZLE FLASH for visibility!
            muzzleFlashes.push({x: startX, y: startY, life: 10});

            console.log(`üî´ Shot spawned at (${Math.floor(startX)}, ${Math.floor(startY)}) targeting (${Math.floor(targetX)}, ${Math.floor(targetY)})`);
            console.log(`   Velocity: (${(Math.cos(angle) * speed).toFixed(2)}, ${(Math.sin(angle) * speed).toFixed(2)})`);

            if (from.isPlayer) {
                testState.playerShots++;
                console.log(`   Player shot #${testState.playerShots}`);
            } else {
                testState.enemyShots++;
                console.log(`   Enemy shot #${testState.enemyShots}`);
            }
        }

        // Collision detection (FIXED: prevent self-collision)
        statusLog('Setting up collision detection...', 'info');
        Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach(pair => {
                const { bodyA, bodyB } = pair;

                const projectile = projectiles.find(p => p === bodyA || p === bodyB);
                if (!projectile) return;

                const other = bodyA === projectile ? bodyB : bodyA;

                // CRITICAL: Ignore collision with shooter's own body parts
                if (projectile.shooter) {
                    const shooterParts = [
                        projectile.shooter.torso,
                        projectile.shooter.head,
                        projectile.shooter.leftArm,
                        projectile.shooter.rightArm,
                        projectile.shooter.leftLeg,
                        projectile.shooter.rightLeg
                    ];
                    if (shooterParts.includes(other)) {
                        console.log(`   (Ignoring self-collision with shooter's ${other.label})`);
                        return; // Skip this collision
                    }
                }

                console.log(`üí• COLLISION! ${projectile.label} hit ${other.label} at (${Math.floor(other.position.x)}, ${Math.floor(other.position.y)})`);
                testState.collisions++;

                // ADAPTIVE LEARNING: Track hit/miss outcomes
                const shooterData = projectile.fromPlayer ? targetingData.enemy : targetingData.player;

                // Check if hit player
                if (other.label && other.label.includes('player')) {
                    const damage = projectile.damage;
                    testState.playerHP = Math.max(0, testState.playerHP - damage);
                    testState.damageApplied += damage;
                    console.log(`   ‚úì PLAYER HIT! Damage: ${damage}, HP: ${testState.playerHP}`);

                    // LEARNING: Record successful hit
                    shooterData.hits++;
                    console.log(`   üéØ Enemy targeting improved! Hits: ${shooterData.hits}`);

                    World.remove(world, projectile);
                    projectiles.splice(projectiles.indexOf(projectile), 1);
                }
                // Check if hit enemy
                else if (other.label && other.label.includes('enemy')) {
                    const damage = projectile.damage;
                    testState.enemyHP = Math.max(0, testState.enemyHP - damage);
                    testState.damageApplied += damage;
                    console.log(`   ‚úì ENEMY HIT! Damage: ${damage}, HP: ${testState.enemyHP}`);

                    // LEARNING: Record successful hit
                    shooterData.hits++;
                    console.log(`   üéØ Player targeting improved! Hits: ${shooterData.hits}`);

                    World.remove(world, projectile);
                    projectiles.splice(projectiles.indexOf(projectile), 1);
                }
                // MISS: Hit ground or terrain
                else if (other.label === 'ground') {
                    console.log(`   ‚úó MISS! Hit ground at (${Math.floor(projectile.position.x)}, ${Math.floor(projectile.position.y)})`);

                    // Track miss for stats (no adaptive learning - using accurate ballistics now)
                    if (shooterData) {
                        shooterData.misses++;
                        const errorX = projectile.targetX ? projectile.targetX - projectile.position.x : 0;
                        const errorY = projectile.targetY ? projectile.targetY - projectile.position.y : 0;
                        console.log(`   üìä Miss distance from target: (${errorX.toFixed(1)}, ${errorY.toFixed(1)})`);
                    }

                    World.remove(world, projectile);
                    projectiles.splice(projectiles.indexOf(projectile), 1);
                }
            });
        });
        statusLog('Collision detection ready', 'success');

        // INTELLIGENT MOVEMENT AI SYSTEM
        const movementAI = {
            lastPlayerMove: 0,
            lastEnemyMove: 0,
            moveInterval: 3000, // Reconsider movement every 3 seconds

            // Calculate tactical score for a position
            evaluatePosition(mech, enemyMech, x, y) {
                let score = 100;

                // Boundary penalties (CRITICAL - avoid edges!)
                const leftBound = 120;
                const rightBound = 680;
                if (x < leftBound) score -= (leftBound - x) * 5; // Heavy penalty near left
                if (x > rightBound) score -= (x - rightBound) * 5; // Heavy penalty near right
                if (x < 100 || x > 700) score -= 1000; // MASSIVE penalty for danger zone

                // Optimal range scoring (prefer ~350-450px distance)
                const distance = Math.abs(x - enemyMech.torso.position.x);
                const optimalDistance = 400;
                const distanceError = Math.abs(distance - optimalDistance);
                score -= distanceError * 0.3;

                // Height advantage (higher is better, but not too high)
                const heightAdvantage = enemyMech.torso.position.y - y;
                score += heightAdvantage * 0.5;

                // Center preference (stay away from edges)
                const distanceFromCenter = Math.abs(x - 400);
                score -= distanceFromCenter * 0.1;

                return score;
            },

            // Decide where to move
            planMovement(mech, enemyMech) {
                const currentX = mech.torso.position.x;
                const currentY = mech.torso.position.y;
                const currentScore = this.evaluatePosition(mech, enemyMech, currentX, currentY);

                // Test potential movements
                const movements = [
                    { dx: -80, dy: 0, name: 'LEFT' },
                    { dx: 80, dy: 0, name: 'RIGHT' },
                    { dx: -120, dy: 0, name: 'FAR LEFT' },
                    { dx: 120, dy: 0, name: 'FAR RIGHT' },
                    { dx: 0, dy: 0, name: 'STAY' }
                ];

                let bestMove = movements[4]; // Default: stay
                let bestScore = currentScore;

                movements.forEach(move => {
                    const newX = currentX + move.dx;
                    const newY = currentY; // Keep same height
                    const score = this.evaluatePosition(mech, enemyMech, newX, newY);

                    if (score > bestScore + 20) { // Threshold to avoid jittering
                        bestScore = score;
                        bestMove = move;
                    }
                });

                console.log(`ü§ñ ${mech.isPlayer ? 'Player' : 'Enemy'} AI: Current score=${currentScore.toFixed(1)}, Best move=${bestMove.name} (score=${bestScore.toFixed(1)})`);

                return bestMove;
            },

            // Execute discrete jump movement
            executeMove(mech, move) {
                if (move.dx === 0 && move.dy === 0) return; // No movement

                // DISCRETE JUMP - apply impulse force
                const forceMagnitude = 0.12; // Strong impulse
                const forceX = Math.sign(move.dx) * forceMagnitude;

                Body.applyForce(mech.torso, mech.torso.position, {
                    x: forceX,
                    y: -0.02 // Slight upward for hop
                });

                console.log(`   üí® Executing ${move.name}: force=(${forceX.toFixed(3)}, -0.02)`);
            },

            // Enforce strict boundaries
            enforceBoundaries(mech) {
                const pos = mech.torso.position;
                const minX = 100;
                const maxX = 700;

                if (pos.x < minX || pos.x > maxX) {
                    // HARD RESET to safe position
                    const safeX = pos.x < minX ? 150 : 650;
                    Body.setPosition(mech.torso, { x: safeX, y: pos.y });
                    Body.setVelocity(mech.torso, { x: 0, y: 0 });
                    console.log(`‚ö†Ô∏è BOUNDARY VIOLATION! Reset ${mech.isPlayer ? 'player' : 'enemy'} to x=${safeX}`);
                }
            },

            // Main update function
            update() {
                const now = Date.now();

                // Player movement AI
                if (now - this.lastPlayerMove > this.moveInterval && testState.playerHP > 0) {
                    const move = this.planMovement(playerMech, enemyMech);
                    this.executeMove(playerMech, move);
                    this.lastPlayerMove = now;
                }

                // Enemy movement AI
                if (now - this.lastEnemyMove > this.moveInterval && testState.enemyHP > 0) {
                    const move = this.planMovement(enemyMech, playerMech);
                    this.executeMove(enemyMech, move);
                    this.lastEnemyMove = now;
                }

                // Always enforce boundaries
                this.enforceBoundaries(playerMech);
                this.enforceBoundaries(enemyMech);
            }
        };

        // Auto-fire
        let lastPlayerShot = 0;
        let lastEnemyShot = 0;
        const fireRate = 2000; // 2 seconds

        function autoFire() {
            const now = Date.now();

            if (now - lastPlayerShot > fireRate && testState.playerHP > 0) {
                fireProjectile(playerMech, enemyMech);
                lastPlayerShot = now;
            }

            if (now - lastEnemyShot > fireRate && testState.enemyHP > 0) {
                fireProjectile(enemyMech, playerMech);
                lastEnemyShot = now;
            }
        }

        // Render (matches real game style)
        let frameCount = 0;
        function render() {
            frameCount++;

            // VISIBLE DEBUG INFO ON CANVAS
            ctx.fillStyle = colors.background;
            ctx.fillRect(0, 0, 800, 450);

            // DEBUG: Show frame count and mech info
            ctx.fillStyle = '#ff0';
            ctx.font = 'bold 16px monospace';
            ctx.fillText(`FRAME: ${frameCount}`, 10, 30);
            ctx.fillText(`BODIES IN WORLD: ${Composite.allBodies(world).length}`, 10, 50);

            if (playerMech && playerMech.torso) {
                const px = Math.floor(playerMech.torso.position.x);
                const py = Math.floor(playerMech.torso.position.y);
                ctx.fillStyle = colors.player;
                ctx.fillText(`PLAYER: (${px}, ${py})`, 10, 70);
            } else {
                ctx.fillStyle = '#f00';
                ctx.fillText(`PLAYER: NULL/UNDEFINED`, 10, 70);
            }

            if (enemyMech && enemyMech.torso) {
                const ex = Math.floor(enemyMech.torso.position.x);
                const ey = Math.floor(enemyMech.torso.position.y);
                ctx.fillStyle = colors.enemy;
                ctx.fillText(`ENEMY: (${ex}, ${ey})`, 10, 90);
            } else {
                ctx.fillStyle = '#f00';
                ctx.fillText(`ENEMY: NULL/UNDEFINED`, 10, 90);
            }

            // Continue with normal rendering
            ctx.fillStyle = colors.background;

            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, 450);
            gradient.addColorStop(0, colors.sky);
            gradient.addColorStop(1, colors.background);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 800, 315);

            // Render all bodies
            const allBodies = Composite.allBodies(world);
            allBodies.forEach(body => {
                const vertices = body.vertices;
                ctx.beginPath();
                ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < vertices.length; i++) {
                    ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                ctx.closePath();

                // Color by label
                if (body.label && body.label.includes('player')) {
                    ctx.fillStyle = colors.player;
                } else if (body.label && body.label.includes('enemy')) {
                    ctx.fillStyle = colors.enemy;
                } else if (body.label === 'bullet') {
                    ctx.fillStyle = colors.projectile;
                } else {
                    ctx.fillStyle = body.render.fillStyle || colors.terrain;
                }

                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // MUZZLE FLASHES (shows when mechs fire)
            for (let i = muzzleFlashes.length - 1; i >= 0; i--) {
                const flash = muzzleFlashes[i];
                const opacity = flash.life / 10;

                ctx.save();
                ctx.shadowBlur = 40;
                ctx.shadowColor = '#ffff00';
                ctx.fillStyle = `rgba(255, 255, 0, ${opacity})`;
                ctx.beginPath();
                ctx.arc(flash.x, flash.y, 30 * opacity, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                flash.life--;
                if (flash.life <= 0) {
                    muzzleFlashes.splice(i, 1);
                }
            }

            // SUPER VISIBLE PROJECTILES
            projectiles.forEach(proj => {
                const pos = proj.position;
                const vel = proj.velocity;

                // OUTER MASSIVE GLOW (so you can't miss it!)
                ctx.save();
                ctx.shadowBlur = 60;
                ctx.shadowColor = '#ffff00';
                ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 40, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // MIDDLE GLOW
                ctx.save();
                ctx.shadowBlur = 30;
                ctx.shadowColor = '#ff8800';
                ctx.fillStyle = 'rgba(255, 136, 0, 0.6)';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 25, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // INNER CORE (bright!)
                ctx.save();
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffffff';
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // THICK VELOCITY TRAIL
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 8;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ffff00';
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x - vel.x * 5, pos.y - vel.y * 5);
                ctx.stroke();
                ctx.shadowBlur = 0;

                // DEBUG: Position text
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px monospace';
                ctx.fillText(`SHOT ${Math.floor(pos.x)},${Math.floor(pos.y)}`, pos.x + 20, pos.y - 20);
            });

            // HP bars
            drawHPBar(playerMech.torso.position.x, playerMech.torso.position.y - 60, testState.playerHP, testState.playerMaxHP, colors.player);
            drawHPBar(enemyMech.torso.position.x, enemyMech.torso.position.y - 60, testState.enemyHP, testState.enemyMaxHP, colors.enemy);

            // BIG ON-SCREEN STATUS (for mobile)
            ctx.save();
            ctx.font = 'bold 16px monospace';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#000';

            // Projectiles count (HUGE and bright)
            if (projectiles.length > 0) {
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 24px monospace';
                ctx.fillText(`‚ö° ${projectiles.length} PROJECTILES ACTIVE ‚ö°`, 400, 50);
            }

            ctx.restore();
        }

        function drawHPBar(x, y, current, max, color) {
            const width = 80;
            const height = 8;

            ctx.fillStyle = '#000';
            ctx.fillRect(x - width/2 - 1, y - 1, width + 2, height + 2);

            const hpPercent = current / max;
            const hpWidth = Math.max(0, (width * hpPercent));

            if (hpPercent > 0.6) {
                ctx.fillStyle = '#00ff88';
            } else if (hpPercent > 0.3) {
                ctx.fillStyle = '#ffaa00';
            } else {
                ctx.fillStyle = '#ff4444';
            }

            ctx.fillRect(x - width/2, y, hpWidth, height);

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 10px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(`${Math.floor(current)}/${max}`, x, y - 5);
        }

        // Remove projectiles that go off-screen
        function removeOffScreenProjectiles() {
            const margin = 50;
            const minX = -margin;
            const maxX = 800 + margin;
            const minY = -margin;
            const maxY = 600 + margin;

            const toRemove = [];
            projectiles.forEach(projectile => {
                const pos = projectile.position;
                if (pos.x < minX || pos.x > maxX || pos.y < minY || pos.y > maxY) {
                    console.log(`   üóëÔ∏è OFF-SCREEN projectile at (${Math.floor(pos.x)}, ${Math.floor(pos.y)}) - removing`);
                    toRemove.push(projectile);
                }
            });

            toRemove.forEach(projectile => {
                World.remove(world, projectile);
                projectiles.splice(projectiles.indexOf(projectile), 1);
            });
        }

        // Main loop
        function mainLoop() {
            autoFire();
            movementAI.update(); // Intelligent movement with boundary enforcement
            Engine.update(engine, 1000 / 60);
            removeOffScreenProjectiles(); // Clean up projectiles that fly off-screen
            testState.projectileCount = projectiles.length;
            render();
            updateStatus();
            requestAnimationFrame(mainLoop);
        }

        // Start
        statusLog('=== STARTING BATTLE ===', 'info');
        console.log('üöÄ Starting auto battle (matches real game)...');
        setTimeout(() => {
            statusLog('Physics render loop started!', 'success');
            statusLog('‚öîÔ∏è BATTLE RUNNING! ‚öîÔ∏è', 'success');
            mainLoop();
        }, 500);

        updateStatus();
    </script>
</body>
</html>
