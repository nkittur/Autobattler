<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>BattleTech Arena - MechBuilder</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            padding: 0;
            background: #0a0a12;
            font-family: 'Courier New', monospace;
            color: #00ff88;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        /* ============================================
           GAME CONTAINER
           ============================================ */
        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        /* ============================================
           MECHBUILDER UI OVERLAY
           ============================================ */
        #mechBuilderUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
        }

        /* Top bar - Stats Panel */
        #statsPanel {
            pointer-events: auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: linear-gradient(180deg, rgba(0,20,10,0.95) 0%, rgba(0,20,10,0.7) 100%);
            border-bottom: 2px solid #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.3);
        }

        .stat-group {
            display: flex;
            gap: 30px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .stat-label {
            font-size: 10px;
            color: #00aa66;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-bar {
            width: 150px;
            height: 16px;
            background: rgba(0,0,0,0.6);
            border: 1px solid #00ff88;
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }

        .stat-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .stat-fill.weight {
            background: linear-gradient(90deg, #00ff88, #88ffaa);
        }

        .stat-fill.energy {
            background: linear-gradient(90deg, #00aaff, #88ddff);
        }

        .stat-fill.over-limit {
            background: linear-gradient(90deg, #ff4444, #ff8888);
        }

        .stat-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            color: #fff;
            text-shadow: 0 0 4px #000;
        }

        #gameTitle {
            font-size: 18px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            letter-spacing: 2px;
        }

        #battleReadyBtn {
            pointer-events: auto;
            padding: 12px 30px;
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #battleReadyBtn:hover:not(:disabled) {
            background: rgba(0, 255, 136, 0.4);
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
        }

        #battleReadyBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #666;
            color: #666;
        }

        #battleReadyBtn.ready {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(0,255,136,0.3); }
            50% { box-shadow: 0 0 25px rgba(0,255,136,0.7); }
        }

        /* Middle area - Grid Overlays */
        #gridOverlayContainer {
            flex: 1;
            position: relative;
            pointer-events: none;
        }

        .mech-grid-overlay {
            position: absolute;
            pointer-events: auto;
            display: grid;
            gap: 2px;
            padding: 4px;
            background: rgba(0, 20, 10, 0.9);
            border: 2px solid rgba(0, 255, 136, 0.6);
            border-radius: 4px;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
            transition: border-color 0.15s, box-shadow 0.15s;
        }

        .mech-grid-overlay.slot-valid {
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .mech-grid-overlay.slot-invalid {
            border-color: #ff4444;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.4);
            opacity: 0.6;
        }

        .mech-grid-overlay.slot-invalid .grid-label {
            color: #ff6666;
        }

        .grid-cell {
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 136, 0.15);
            border: 1px solid rgba(0, 255, 136, 0.5);
            border-radius: 2px;
            transition: all 0.2s ease;
        }

        .grid-cell:hover {
            background: rgba(0, 255, 136, 0.25);
            border-color: #00ff88;
        }

        .grid-cell.valid-drop {
            background: rgba(0, 255, 136, 0.4);
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0,255,136,0.5);
        }

        .grid-cell.invalid-drop {
            background: rgba(255, 68, 68, 0.4);
            border-color: #ff4444;
            box-shadow: 0 0 10px rgba(255,68,68,0.5);
        }

        .grid-cell.occupied {
            background: rgba(0, 170, 255, 0.3);
            border-color: #00aaff;
        }

        .grid-label {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #00aa66;
            text-transform: uppercase;
            letter-spacing: 1px;
            white-space: nowrap;
        }

        /* Bottom area - The Bench (Hand) */
        #benchContainer {
            pointer-events: auto;
            padding: 15px 20px;
            background: linear-gradient(0deg, rgba(0,20,10,0.95) 0%, rgba(0,20,10,0.7) 100%);
            border-top: 2px solid #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.3);
            transition: border-color 0.15s, box-shadow 0.15s;
        }

        #benchContainer.drop-target {
            border-top-color: #00ffaa;
            box-shadow: 0 0 30px rgba(0,255,170,0.5);
            background: linear-gradient(0deg, rgba(0,40,20,0.95) 0%, rgba(0,30,15,0.8) 100%);
        }

        #benchLabel {
            font-size: 12px;
            color: #00aa66;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        #bench {
            display: flex;
            gap: 15px;
            overflow-x: auto;
            padding: 10px 0;
            min-height: 100px;
        }

        .bench-item {
            flex-shrink: 0;
            width: 80px;
            height: 80px;
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: grab;
            transition: all 0.2s ease;
            position: relative;
        }

        .bench-item:hover {
            background: rgba(0, 255, 136, 0.2);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,255,136,0.3);
        }

        .bench-item:active {
            cursor: grabbing;
        }

        .bench-item.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .bench-item .item-icon {
            font-size: 28px;
            margin-bottom: 4px;
        }

        .bench-item .item-name {
            font-size: 9px;
            color: #00ff88;
            text-align: center;
            padding: 0 4px;
        }

        .bench-item .item-shape {
            display: none;  /* Hidden, replaced by visual grid */
        }

        .bench-item .shape-preview {
            display: grid;
            gap: 1px;
            margin-top: 4px;
        }

        .bench-item .shape-cell {
            width: 10px;
            height: 10px;
            background: currentColor;
            opacity: 0.6;
            border-radius: 1px;
        }

        .bench-item .shape-cell.empty {
            background: transparent;
        }

        .bench-item.weapon { border-color: #ff6644; }
        .bench-item.weapon .item-icon { color: #ff6644; }
        .bench-item.armor { border-color: #4488ff; }
        .bench-item.armor .item-icon { color: #4488ff; }
        .bench-item.reactor { border-color: #ffaa00; }
        .bench-item.reactor .item-icon { color: #ffaa00; }
        .bench-item.system { border-color: #aa44ff; }
        .bench-item.system .item-icon { color: #aa44ff; }

        /* Bench item tooltip */
        .bench-item .bench-tooltip {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 10, 0.95);
            border: 1px solid currentColor;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s, visibility 0.15s;
            z-index: 100;
            pointer-events: none;
        }

        .bench-item:hover .bench-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .bench-item .bench-tooltip .tooltip-name {
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 4px;
        }

        .bench-item .bench-tooltip .tooltip-stats {
            color: #aaa;
        }

        .bench-item .bench-tooltip .tooltip-stats span {
            display: block;
            margin: 2px 0;
        }

        .bench-item .bench-tooltip .tooltip-slots {
            color: #666;
            font-size: 9px;
            margin-top: 4px;
            border-top: 1px solid #333;
            padding-top: 4px;
        }

        /* Mission Selection */
        #missionContainer {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 280px;
            background: rgba(0, 20, 10, 0.9);
            border: 2px solid #00ff88;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 0 20px rgba(0,255,136,0.3);
            pointer-events: auto;
        }

        #missionLabel {
            font-size: 12px;
            color: #00aa66;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 12px;
            text-align: center;
        }

        .mission-card {
            background: rgba(0, 255, 136, 0.05);
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-radius: 6px;
            padding: 10px 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .mission-card:hover {
            background: rgba(0, 255, 136, 0.15);
            border-color: #00ff88;
            transform: translateX(-3px);
        }

        .mission-card.selected {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0,255,136,0.4);
        }

        .mission-card.easy { border-left: 4px solid #44ff44; }
        .mission-card.medium { border-left: 4px solid #ffaa00; }
        .mission-card.hard { border-left: 4px solid #ff4444; }

        .mission-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .mission-name {
            font-size: 13px;
            font-weight: bold;
            color: #00ff88;
        }

        .mission-difficulty {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            text-transform: uppercase;
        }

        .mission-difficulty.easy { background: rgba(68, 255, 68, 0.3); color: #44ff44; }
        .mission-difficulty.medium { background: rgba(255, 170, 0, 0.3); color: #ffaa00; }
        .mission-difficulty.hard { background: rgba(255, 68, 68, 0.3); color: #ff4444; }

        .mission-desc {
            font-size: 10px;
            color: #888;
            margin-bottom: 8px;
        }

        .mission-reward {
            font-size: 10px;
            color: #ffcc00;
        }

        .mission-reward span {
            margin-right: 12px;
        }

        /* Mission enemy tooltip */
        .mission-card .enemy-tooltip {
            position: absolute;
            left: calc(100% + 10px);
            top: 0;
            width: 200px;
            background: rgba(10, 0, 0, 0.95);
            border: 1px solid #ff4444;
            border-radius: 4px;
            padding: 10px;
            font-size: 10px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s, visibility 0.15s;
            z-index: 100;
            pointer-events: none;
        }

        .mission-card:hover .enemy-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .enemy-tooltip .enemy-name {
            font-weight: bold;
            color: #ff6666;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .enemy-tooltip .enemy-chassis {
            color: #888;
            margin-bottom: 8px;
        }

        .enemy-tooltip .enemy-stats {
            color: #aaa;
        }

        .enemy-tooltip .enemy-stats div {
            margin: 3px 0;
        }

        .enemy-tooltip .enemy-equipment {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #333;
            color: #888;
        }

        .enemy-tooltip .enemy-equipment div {
            margin: 2px 0;
        }

        /* Drag ghost element */
        #dragGhost {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.9;
            transform: translate(-50%, -50%) scale(1.1);
            transition: transform 0.1s ease;
        }

        #dragGhost .ghost-grid {
            display: grid;
            gap: 2px;
            padding: 4px;
            background: rgba(0, 255, 136, 0.3);
            border: 2px solid #00ff88;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
        }

        #dragGhost .ghost-cell {
            width: 38px;
            height: 38px;
            background: rgba(0, 255, 136, 0.5);
            border: 1px solid #00ff88;
            border-radius: 2px;
        }

        #dragGhost.invalid .ghost-grid {
            background: rgba(255, 68, 68, 0.3);
            border-color: #ff4444;
            box-shadow: 0 0 20px rgba(255,68,68,0.5);
        }

        #dragGhost.invalid .ghost-cell {
            background: rgba(255, 68, 68, 0.5);
            border-color: #ff4444;
        }

        /* Placed items on grid */
        .placed-item {
            position: absolute;
            display: grid;
            gap: 2px;
            padding: 2px;
            background: rgba(0, 170, 255, 0.2);
            border: 2px solid #00aaff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .placed-item:hover {
            background: rgba(0, 170, 255, 0.4);
            box-shadow: 0 0 15px rgba(0,170,255,0.6);
            z-index: 10;
        }

        .placed-item .placed-cell {
            width: 36px;
            height: 36px;
            background: rgba(0, 170, 255, 0.3);
            border: 1px solid rgba(0, 170, 255, 0.6);
            border-radius: 2px;
        }

        .placed-item.weapon { border-color: #ff6644; background: rgba(255,102,68,0.2); }
        .placed-item.weapon .placed-cell { background: rgba(255,102,68,0.3); border-color: rgba(255,102,68,0.6); }
        .placed-item.armor { border-color: #4488ff; background: rgba(68,136,255,0.2); }
        .placed-item.armor .placed-cell { background: rgba(68,136,255,0.3); border-color: rgba(68,136,255,0.6); }
        .placed-item.reactor { border-color: #ffaa00; background: rgba(255,170,0,0.2); }
        .placed-item.reactor .placed-cell { background: rgba(255,170,0,0.3); border-color: rgba(255,170,0,0.6); }
        .placed-item.system { border-color: #aa44ff; background: rgba(170,68,255,0.2); }
        .placed-item.system .placed-cell { background: rgba(170,68,255,0.3); border-color: rgba(170,68,255,0.6); }

        .placed-item .item-icon-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            opacity: 0.9;
            text-shadow: 0 0 8px rgba(0,0,0,0.8);
            pointer-events: none;
        }

        .placed-item .item-tooltip {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 10, 0.95);
            border: 1px solid currentColor;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 100;
            pointer-events: none;
        }

        .placed-item:hover .item-tooltip,
        .placed-item.show-tooltip .item-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .placed-item .item-tooltip .tooltip-name {
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 4px;
        }

        .placed-item .item-tooltip .tooltip-stats {
            color: #aaa;
        }

        .placed-item .item-tooltip .tooltip-stats span {
            display: block;
            margin: 2px 0;
        }

        .placed-item .item-tooltip .tooltip-hint {
            margin-top: 6px;
            color: #666;
            font-style: italic;
        }

        /* Instructions overlay */
        #instructions {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,20,10,0.9);
            border: 1px solid #00aa66;
            border-radius: 6px;
            padding: 10px 20px;
            font-size: 11px;
            color: #00aa66;
            text-align: center;
            pointer-events: none;
        }

        /* Hidden during battle */
        .battle-mode #mechBuilderUI {
            display: none;
        }

        /* ============================================
           BATTLE UI
           ============================================ */
        #battleUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
        }

        .battle-mode #battleUI {
            display: block;
        }

        .battle-mode #mechBuilderUI {
            display: none;
        }

        #battleHeader {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        #missionTitle {
            font-size: 24px;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 20px rgba(0,255,136,0.5);
        }

        #battleStatus {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            border: 2px solid #00ff88;
            border-radius: 8px;
            padding: 15px 30px;
            display: flex;
            align-items: center;
            gap: 30px;
            pointer-events: auto;
        }

        #battleVS {
            font-size: 24px;
            font-weight: bold;
            color: #ffcc00;
            text-shadow: 0 0 10px rgba(255,204,0,0.5);
        }

        .team-status {
            text-align: center;
            min-width: 180px;
        }

        .team-status.player { color: #00ff88; }
        .team-status.enemy { color: #ff4444; }

        #playerMechName, #enemyMechName {
            font-size: 11px;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        .hp-bar {
            width: 180px;
            height: 16px;
            background: #222;
            border-radius: 3px;
            overflow: hidden;
            margin: 6px 0;
            border: 1px solid #444;
        }

        .hp-fill {
            height: 100%;
            transition: width 0.3s;
        }

        .hp-fill.player { background: linear-gradient(90deg, #00aa55, #00ff88); }
        .hp-fill.enemy { background: linear-gradient(90deg, #aa2222, #ff4444); }

        #battleLog {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            max-height: 200px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #00aa66;
            border-radius: 6px;
            padding: 10px 15px;
            overflow-y: auto;
            pointer-events: auto;
        }

        #battleLogContent {
            font-size: 12px;
            color: #aaa;
        }

        .log-entry {
            margin: 4px 0;
            padding: 4px 0;
            border-bottom: 1px solid #333;
        }

        .log-entry.player-action { color: #00ff88; }
        .log-entry.enemy-action { color: #ff6666; }
        .log-entry.damage { color: #ffaa00; }
        .log-entry.victory { color: #44ff44; font-weight: bold; }
        .log-entry.defeat { color: #ff4444; font-weight: bold; }

        #battleResult {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,20,10,0.95);
            border: 3px solid #00ff88;
            border-radius: 12px;
            padding: 40px 60px;
            text-align: center;
            pointer-events: auto;
            box-shadow: 0 0 50px rgba(0,255,136,0.4);
        }

        #resultTitle {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 0 0 20px currentColor;
        }

        #resultTitle.victory { color: #44ff44; }
        #resultTitle.defeat { color: #ff4444; }

        #resultRewards {
            font-size: 16px;
            color: #ffcc00;
            margin-bottom: 25px;
        }

        #resultRewards div {
            margin: 8px 0;
        }

        #returnToBuilderBtn {
            padding: 12px 30px;
            font-size: 16px;
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            border-radius: 6px;
            font-family: monospace;
            transition: all 0.2s;
        }

        #returnToBuilderBtn:hover {
            background: rgba(0, 255, 136, 0.4);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="renderCanvas"></canvas>

        <!-- MechBuilder UI Overlay -->
        <div id="mechBuilderUI">
            <!-- Top Stats Panel -->
            <div id="statsPanel">
                <div class="stat-group">
                    <div class="stat-item">
                        <span class="stat-label">Weight</span>
                        <div class="stat-bar">
                            <div class="stat-fill weight" id="weightFill" style="width: 0%"></div>
                            <span class="stat-text" id="weightText">0 / 100</span>
                        </div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Energy</span>
                        <div class="stat-bar">
                            <div class="stat-fill energy" id="energyFill" style="width: 0%"></div>
                            <span class="stat-text" id="energyText">0 / 50</span>
                        </div>
                    </div>
                </div>

                <div id="gameTitle">MECHBUILDER</div>

                <button id="battleReadyBtn" disabled>Battle Ready</button>
            </div>

            <!-- Mission Selection Panel -->
            <div id="missionContainer">
                <div id="missionLabel">Select Mission</div>
                <div id="missionList">
                    <!-- Missions populated by JS -->
                </div>
            </div>

            <!-- Grid Overlay Container (positioned over 3D mech) -->
            <div id="gridOverlayContainer">
                <!-- Grids will be dynamically positioned here -->
            </div>

            <!-- Bottom Bench (Hand) -->
            <div id="benchContainer">
                <div id="benchLabel">Equipment Bench - Drag items to mech slots</div>
                <div id="bench">
                    <!-- Items populated by JS -->
                </div>
            </div>

            <div id="instructions">
                Drag equipment from the bench onto the mech's grid slots ‚Ä¢ Click placed items to return them
            </div>
        </div>

        <!-- Battle UI Overlay (hidden during builder) -->
        <div id="battleUI">
            <div id="battleHeader">
                <div id="missionTitle">Mission: Border Patrol</div>
            </div>

            <div id="battleStatus">
                <div class="team-status player">
                    <strong>YOUR MECH</strong>
                    <div id="playerMechName">Timber Wolf</div>
                    <div class="hp-bar"><div class="hp-fill player" id="playerHP" style="width: 100%"></div></div>
                    <div id="playerHPText">HP: 150/150</div>
                </div>
                <div id="battleVS">VS</div>
                <div class="team-status enemy">
                    <strong>ENEMY</strong>
                    <div id="enemyMechName">Scout Mech</div>
                    <div class="hp-bar"><div class="hp-fill enemy" id="enemyHP" style="width: 100%"></div></div>
                    <div id="enemyHPText">HP: 80/80</div>
                </div>
            </div>

            <div id="battleLog">
                <div id="battleLogContent">
                    <!-- Battle events will be logged here -->
                </div>
            </div>

            <div id="battleResult" style="display: none;">
                <div id="resultTitle">VICTORY!</div>
                <div id="resultRewards">
                    <div>üí∞ Credits: +500</div>
                    <div>‚≠ê XP: +100</div>
                </div>
                <button id="returnToBuilderBtn" onclick="returnToBuilder()">Return to Loadout</button>
            </div>
        </div>

        <!-- Drag Ghost (hidden until dragging) -->
        <div id="dragGhost" style="display: none;"></div>

        <!-- Battle UI Overlay (hidden initially) -->
        <div id="battleUI" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; flex-direction: column;">
            <!-- Battle Status Bar -->
            <div style="pointer-events: auto; display: flex; justify-content: space-between; padding: 15px 30px; background: linear-gradient(180deg, rgba(0,20,10,0.95) 0%, rgba(0,20,10,0.7) 100%); border-bottom: 2px solid #00ff88;">
                <!-- Player HP -->
                <div style="flex: 1; max-width: 300px;">
                    <div style="font-size: 14px; color: #00ff88; margin-bottom: 5px;" id="playerName">PLAYER</div>
                    <div style="height: 20px; background: #333; border: 1px solid #00ff88; border-radius: 3px; overflow: hidden;">
                        <div id="playerHP" style="height: 100%; width: 100%; background: linear-gradient(90deg, #00ff88, #44ff88); transition: width 0.3s;"></div>
                    </div>
                </div>
                <!-- VS -->
                <div style="font-size: 24px; color: #ffaa00; padding: 0 30px;">VS</div>
                <!-- Enemy HP -->
                <div style="flex: 1; max-width: 300px;">
                    <div style="font-size: 14px; color: #ff4444; margin-bottom: 5px; text-align: right;" id="enemyName">ENEMY</div>
                    <div style="height: 20px; background: #333; border: 1px solid #ff4444; border-radius: 3px; overflow: hidden;">
                        <div id="enemyHP" style="height: 100%; width: 100%; background: linear-gradient(90deg, #ff4444, #ff6644); transition: width 0.3s;"></div>
                    </div>
                </div>
            </div>

            <!-- Battle Result Overlay -->
            <div id="battleResultOverlay" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); justify-content: center; align-items: center; flex-direction: column; pointer-events: auto;">
                <div id="battleResult" style="font-size: 64px; font-weight: bold; text-shadow: 0 0 30px currentColor;">VICTORY!</div>
                <button onclick="returnToLoadout()" style="margin-top: 30px; padding: 15px 40px; font-size: 18px; background: rgba(0, 255, 136, 0.2); border: 2px solid #00ff88; color: #00ff88; cursor: pointer; border-radius: 5px;">Return to Loadout</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>

    <script>
        // ============================================
        // GAME STATE & PHASE MANAGEMENT
        // ============================================
        const GamePhase = {
            MECHBUILDER: 'mechbuilder',
            BATTLE: 'battle'
        };

        let currentPhase = GamePhase.MECHBUILDER;
        let engine, scene, camera, havokInstance, havokPlugin;
        let builderCamera, battleCamera;
        let gameTime = 0;

        // ============================================
        // MECHBUILDER DATA STRUCTURES
        // ============================================

        // Mech Chassis Definition
        const MECH_CHASSIS = {
            id: 'starter_chassis',
            name: 'Timber Wolf Chassis',
            maxWeight: 100,
            baseEnergy: 50,
            slots: {
                torso: { cols: 3, rows: 3, position: { x: 0.5, y: 0.6 } },      // Center of screen
                leftArm: { cols: 2, rows: 4, position: { x: 0.25, y: 0.55 } },  // Left side
                rightArm: { cols: 2, rows: 4, position: { x: 0.75, y: 0.55 } }, // Right side
                leftLeg: { cols: 2, rows: 2, position: { x: 0.35, y: 0.85 } },  // Lower left
                rightLeg: { cols: 2, rows: 2, position: { x: 0.65, y: 0.85 } }  // Lower right
            }
        };

        // Item Definitions (The Deck)
        const ITEM_DATABASE = {
            railgun_mk1: {
                id: 'railgun_mk1',
                name: 'Rusty Railgun',
                type: 'WEAPON',
                category: 'weapon',
                icon: 'üî´',
                gridShape: [[1], [1], [1], [1]],  // 1x4 Vertical
                gridDimensions: { w: 1, h: 4 },
                stats: {
                    weight: 25,
                    energyDraw: 15,
                    damage: 100
                },
                constraints: {
                    validSlots: ['leftArm', 'rightArm']
                },
                // Battle properties
                battle: {
                    projectileSpeed: 50,
                    projectileSize: 0.15,
                    knockback: 30,
                    recoil: 0.15,
                    cooldown: 1500,
                    color: [1, 0.9, 0.3],  // Yellow-orange
                    isProjectile: true
                }
            },
            laser_array: {
                id: 'laser_array',
                name: 'ER Laser Array',
                type: 'WEAPON',
                category: 'weapon',
                icon: '‚ö°',
                gridShape: [[1, 1], [1, 1]],  // 2x2 Square
                gridDimensions: { w: 2, h: 2 },
                stats: {
                    weight: 18,
                    energyDraw: 20,
                    damage: 80
                },
                constraints: {
                    validSlots: ['torso', 'leftArm', 'rightArm']
                },
                // Battle properties
                battle: {
                    isBeam: true,
                    beamDuration: 200,
                    knockback: 8,
                    recoil: 0.2,
                    cooldown: 2000,
                    color: [0.2, 1, 0.3]  // Green
                }
            },
            armor_plate: {
                id: 'armor_plate',
                name: 'Heavy Armor',
                type: 'ARMOR',
                category: 'armor',
                icon: 'üõ°Ô∏è',
                gridShape: [[1, 1], [1, 1]],  // 2x2 Square
                gridDimensions: { w: 2, h: 2 },
                stats: {
                    weight: 30,
                    energyDraw: 0,
                    armorBonus: 50
                },
                constraints: {
                    validSlots: ['torso', 'leftLeg', 'rightLeg']
                }
            },
            reactor_core: {
                id: 'reactor_core',
                name: 'Fusion Reactor',
                type: 'REACTOR',
                category: 'reactor',
                icon: '‚öõÔ∏è',
                gridShape: [[1], [1]],  // 1x2 Vertical
                gridDimensions: { w: 1, h: 2 },
                stats: {
                    weight: 20,
                    energyDraw: -30,  // Negative = provides energy
                    heatCapacity: 25
                },
                constraints: {
                    validSlots: ['torso']
                }
            },
            targeting_computer: {
                id: 'targeting_computer',
                name: 'Targeting System',
                type: 'SYSTEM',
                category: 'system',
                icon: 'üéØ',
                gridShape: [[1]],  // 1x1 Single
                gridDimensions: { w: 1, h: 1 },
                stats: {
                    weight: 5,
                    energyDraw: 8,
                    accuracyBonus: 15
                },
                constraints: {
                    validSlots: ['torso', 'leftArm', 'rightArm']
                }
            }
        };

        // Mission definitions with enemy mech configurations
        const MISSIONS = {
            patrol: {
                id: 'patrol',
                name: 'Border Patrol',
                difficulty: 'Easy',
                risk: 1,
                reward: { credits: 500, xp: 100 },
                description: 'Light recon mission. Expect minimal resistance.',
                enemyMechs: [{
                    name: 'Scout Mech',
                    chassis: 'Light Frame',
                    maxHealth: 80,
                    equipment: [
                        { itemId: 'laser_array', slot: 'rightArm', position: { x: 0, y: 0 } }
                    ],
                    stats: { weight: 35, energy: 20, damage: 40, armor: 10 }
                }]
            },
            convoy: {
                id: 'convoy',
                name: 'Convoy Assault',
                difficulty: 'Medium',
                risk: 2,
                reward: { credits: 1200, xp: 250 },
                description: 'Intercept enemy supply convoy. Medium resistance expected.',
                enemyMechs: [{
                    name: 'Assault Mech',
                    chassis: 'Medium Frame',
                    maxHealth: 150,
                    equipment: [
                        { itemId: 'railgun_mk1', slot: 'rightArm', position: { x: 0, y: 0 } },
                        { itemId: 'armor_plate', slot: 'torso', position: { x: 0, y: 0 } }
                    ],
                    stats: { weight: 65, energy: 35, damage: 100, armor: 50 }
                }]
            },
            fortress: {
                id: 'fortress',
                name: 'Fortress Breach',
                difficulty: 'Hard',
                risk: 3,
                reward: { credits: 3000, xp: 600 },
                description: 'Assault heavily defended position. Prepare for heavy combat.',
                enemyMechs: [{
                    name: 'Heavy Destroyer',
                    chassis: 'Heavy Frame',
                    maxHealth: 250,
                    equipment: [
                        { itemId: 'railgun_mk1', slot: 'leftArm', position: { x: 0, y: 0 } },
                        { itemId: 'laser_array', slot: 'rightArm', position: { x: 0, y: 0 } },
                        { itemId: 'armor_plate', slot: 'torso', position: { x: 0, y: 0 } },
                        { itemId: 'reactor_core', slot: 'torso', position: { x: 2, y: 0 } }
                    ],
                    stats: { weight: 95, energy: 55, damage: 140, armor: 80 }
                }]
            }
        };

        let selectedMission = null;

        // ============================================
        // PHYSICS BATTLE SYSTEM
        // ============================================
        let battleMechs = [];       // All mechs in battle
        let playerBattleMech = null;
        let enemyBattleMech = null;
        let projectiles = [];       // Active projectiles
        let beams = [];             // Active beam weapons
        let battleActive = false;
        let battleScene = null;     // Separate scene for battle
        let battleGround = null;
        let weaponCooldowns = {};   // Track weapon cooldowns per mech

        // Battle colors
        const BATTLE_COLORS = {
            playerPrimary: new BABYLON.Color3(0.15, 0.35, 0.2),
            playerSecondary: new BABYLON.Color3(0.25, 0.45, 0.3),
            enemyPrimary: new BABYLON.Color3(0.4, 0.12, 0.12),
            enemySecondary: new BABYLON.Color3(0.5, 0.18, 0.18),
            metal: new BABYLON.Color3(0.35, 0.35, 0.4),
            darkMetal: new BABYLON.Color3(0.12, 0.12, 0.15)
        };

        // Mech state machine
        const MechState = {
            WALKING: 'walking',
            RAGDOLL: 'ragdoll',
            RECOVERING: 'recovering'
        };

        // AI Configuration
        const AI_CONFIG = {
            idealRange: 10,
            minRange: 6,
            maxRange: 14,
            moveSpeed: 4,
            turnSpeed: 2,
            strafeChance: 0.4,
            decisionInterval: 0.3
        };

        // Arena bounds
        const ARENA_BOUNDS = {
            minX: -15,
            maxX: 15,
            minZ: -10,
            maxZ: 10
        };

        // Texture URLs
        const TEXTURE_URLS = {
            grass: 'https://i.imgur.com/c3l8U9o.png',
            rustMetal: 'https://assets.babylonjs.com/textures/rustediron2_basecolor.png'
        };

        let BATTLE_TEXTURES = {};

        // ============================================
        // BATTLE SYSTEM FUNCTIONS
        // ============================================

        // Get weapons from loadout
        function getLoadoutWeapons() {
            const weapons = [];
            loadoutState.equipment.forEach(eq => {
                const item = ITEM_DATABASE[eq.itemId];
                if (item && item.type === 'WEAPON' && item.battle) {
                    weapons.push({
                        itemId: eq.itemId,
                        slot: eq.slot,
                        name: item.name,
                        damage: item.stats.damage,
                        battle: item.battle,
                        lastFired: 0
                    });
                }
            });
            return weapons;
        }

        // Create battle scene with physics
        async function createBattleScene() {
            // Initialize Havok if not done
            if (!havokInstance) {
                havokInstance = await HavokPhysics();
            }

            battleScene = new BABYLON.Scene(engine);
            battleScene.clearColor = new BABYLON.Color3(0.5, 0.6, 0.75);

            // Enable physics
            havokPlugin = new BABYLON.HavokPlugin(true, havokInstance);
            battleScene.enablePhysics(new BABYLON.Vector3(0, -18, 0), havokPlugin);

            // Camera
            battleCamera = new BABYLON.ArcRotateCamera('battleCam', -Math.PI/2, Math.PI/3.5, 25,
                new BABYLON.Vector3(0, 2, 0), battleScene);
            battleCamera.attachControl(document.getElementById('renderCanvas'), true);
            battleCamera.lowerRadiusLimit = 10;
            battleCamera.upperRadiusLimit = 50;

            // Lighting
            const hemi = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0, 1, 0), battleScene);
            hemi.intensity = 0.5;

            const sun = new BABYLON.DirectionalLight('sun', new BABYLON.Vector3(-1, -2, -1), battleScene);
            sun.intensity = 1.2;

            // Ground
            battleGround = BABYLON.MeshBuilder.CreateGround('ground', { width: 40, height: 30 }, battleScene);
            const groundMat = new BABYLON.StandardMaterial('groundMat', battleScene);
            groundMat.diffuseColor = new BABYLON.Color3(0.3, 0.4, 0.3);
            battleGround.material = groundMat;
            battleGround.receiveShadows = true;

            // Ground physics
            const groundShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -0.5, 0),
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(40, 1, 30),
                battleScene
            );
            const groundBody = new BABYLON.PhysicsBody(battleGround, BABYLON.PhysicsMotionType.STATIC, false, battleScene);
            groundBody.shape = groundShape;

            return battleScene;
        }

        // Create a battle mech with physics and loadout weapons
        function createBattleMech(scene, xPos, zPos, isPlayer, weapons, maxHP) {
            const name = isPlayer ? 'player' : 'enemy';
            const colors = isPlayer ?
                { primary: BATTLE_COLORS.playerPrimary, secondary: BATTLE_COLORS.playerSecondary } :
                { primary: BATTLE_COLORS.enemyPrimary, secondary: BATTLE_COLORS.enemySecondary };

            // Materials
            const primaryMat = new BABYLON.StandardMaterial(name + '_primary', scene);
            primaryMat.diffuseColor = colors.primary;

            const secondaryMat = new BABYLON.StandardMaterial(name + '_secondary', scene);
            secondaryMat.diffuseColor = colors.secondary;

            const metalMat = new BABYLON.StandardMaterial(name + '_metal', scene);
            metalMat.diffuseColor = BATTLE_COLORS.metal;

            // Pelvis (physics body)
            const pelvis = BABYLON.MeshBuilder.CreateBox(name + '_pelvis', { width: 1.5, height: 0.4, depth: 0.8 }, scene);
            pelvis.position = new BABYLON.Vector3(xPos, 2.5, zPos);
            pelvis.material = new BABYLON.StandardMaterial(name + '_dark', scene);
            pelvis.material.diffuseColor = BATTLE_COLORS.darkMetal;

            // Physics body
            const pelvisShape = new BABYLON.PhysicsShapeBox(
                new BABYLON.Vector3(0, -1, 0),
                new BABYLON.Quaternion(0, 0, 0, 1),
                new BABYLON.Vector3(1.5, 2.5, 0.8),
                scene
            );
            const pelvisBody = new BABYLON.PhysicsBody(pelvis, BABYLON.PhysicsMotionType.ANIMATED, false, scene);
            pelvisBody.shape = pelvisShape;
            pelvisBody.setMassProperties({ mass: 50 });
            pelvisBody.setAngularDamping(5);
            pelvisBody.setLinearDamping(0.5);

            // Torso
            const torso = BABYLON.MeshBuilder.CreateBox(name + '_torso', { width: 1.4, height: 1.0, depth: 0.9 }, scene);
            torso.position.y = 0.6;
            torso.parent = pelvis;
            torso.material = primaryMat;

            // Head
            const head = BABYLON.MeshBuilder.CreateBox(name + '_head', { width: 0.5, height: 0.4, depth: 0.5 }, scene);
            head.position.y = 0.7;
            head.parent = torso;
            head.material = secondaryMat;

            // Arms
            const leftArm = BABYLON.MeshBuilder.CreateBox(name + '_leftArm', { width: 0.35, height: 1.2, depth: 0.35 }, scene);
            leftArm.position = new BABYLON.Vector3(-0.9, 0.1, 0);
            leftArm.parent = torso;
            leftArm.material = metalMat;

            const rightArm = BABYLON.MeshBuilder.CreateBox(name + '_rightArm', { width: 0.35, height: 1.2, depth: 0.35 }, scene);
            rightArm.position = new BABYLON.Vector3(0.9, 0.1, 0);
            rightArm.parent = torso;
            rightArm.material = metalMat;

            // Weapon barrels on arms (visual)
            const leftWeapon = BABYLON.MeshBuilder.CreateCylinder(name + '_leftWpn', { diameter: 0.2, height: 0.7 }, scene);
            leftWeapon.rotation.x = Math.PI / 2;
            leftWeapon.position = new BABYLON.Vector3(0, -0.4, 0.3);
            leftWeapon.parent = leftArm;
            leftWeapon.material = metalMat;

            const rightWeapon = BABYLON.MeshBuilder.CreateCylinder(name + '_rightWpn', { diameter: 0.2, height: 0.7 }, scene);
            rightWeapon.rotation.x = Math.PI / 2;
            rightWeapon.position = new BABYLON.Vector3(0, -0.4, 0.3);
            rightWeapon.parent = rightArm;
            rightWeapon.material = metalMat;

            // Legs
            const leftLeg = BABYLON.MeshBuilder.CreateBox(name + '_leftLeg', { width: 0.3, height: 1.5, depth: 0.3 }, scene);
            leftLeg.position = new BABYLON.Vector3(-0.5, -1.2, 0);
            leftLeg.parent = pelvis;
            leftLeg.material = metalMat;

            const rightLeg = BABYLON.MeshBuilder.CreateBox(name + '_rightLeg', { width: 0.3, height: 1.5, depth: 0.3 }, scene);
            rightLeg.position = new BABYLON.Vector3(0.5, -1.2, 0);
            rightLeg.parent = pelvis;
            rightLeg.material = metalMat;

            return {
                name: name,
                pelvis: pelvis,
                pelvisBody: pelvisBody,
                torso: torso,
                head: head,
                leftArm: leftArm,
                rightArm: rightArm,
                leftWeapon: leftWeapon,
                rightWeapon: rightWeapon,
                leftLeg: leftLeg,
                rightLeg: rightLeg,
                isPlayer: isPlayer,
                maxHP: maxHP,
                currentHP: maxHP,
                weapons: weapons,
                isDestroyed: false,
                walkCycle: 0,
                walkDirection: 0,
                isWalking: false,
                torsoTwist: 0,
                lastFiredArm: 'left',
                ai: {
                    target: null,
                    decisionTimer: 0,
                    strafeAmount: 0
                }
            };
        }

        // Fire a weapon from loadout
        function fireLoadoutWeapon(mech, weaponData, target) {
            const now = performance.now();
            if (now - weaponData.lastFired < weaponData.battle.cooldown) {
                return; // Still on cooldown
            }
            weaponData.lastFired = now;

            const battle = weaponData.battle;
            const fromPos = mech.pelvis.getAbsolutePosition();
            const toPos = target.pelvis.getAbsolutePosition();
            const direction = toPos.subtract(fromPos).normalize();

            // Fire from alternating arms
            const arm = mech.lastFiredArm === 'left' ? mech.rightArm : mech.leftArm;
            mech.lastFiredArm = mech.lastFiredArm === 'left' ? 'right' : 'left';
            const armPos = arm.getAbsolutePosition();

            if (battle.isBeam) {
                // Create beam
                const beamLength = BABYLON.Vector3.Distance(armPos, toPos);
                const beam = BABYLON.MeshBuilder.CreateCylinder('beam_' + Date.now(), {
                    diameter: 0.15,
                    height: beamLength
                }, battleScene);

                const midpoint = armPos.add(toPos).scale(0.5);
                beam.position = midpoint;
                beam.lookAt(toPos);
                beam.rotation.x += Math.PI / 2;

                const beamMat = new BABYLON.StandardMaterial('beamMat', battleScene);
                beamMat.emissiveColor = new BABYLON.Color3(battle.color[0], battle.color[1], battle.color[2]);
                beamMat.alpha = 0.8;
                beam.material = beamMat;

                beams.push({
                    mesh: beam,
                    damage: weaponData.damage,
                    knockback: battle.knockback,
                    target: target,
                    startTime: now,
                    duration: battle.beamDuration,
                    applied: false
                });
            } else {
                // Create projectile
                const projectile = BABYLON.MeshBuilder.CreateSphere('proj_' + Date.now(), {
                    diameter: battle.projectileSize * 2
                }, battleScene);
                projectile.position = armPos.clone();

                const projMat = new BABYLON.StandardMaterial('projMat', battleScene);
                projMat.emissiveColor = new BABYLON.Color3(battle.color[0], battle.color[1], battle.color[2]);
                projectile.material = projMat;

                projectiles.push({
                    mesh: projectile,
                    velocity: direction.scale(battle.projectileSpeed),
                    damage: weaponData.damage,
                    knockback: battle.knockback,
                    target: target,
                    startTime: now
                });
            }

            // Apply recoil
            const recoilImpulse = direction.scale(-battle.knockback * 0.2);
            mech.pelvisBody.applyImpulse(recoilImpulse, fromPos);
        }

        // Update projectiles
        function updateProjectiles(dt) {
            const toRemove = [];
            projectiles.forEach((proj, idx) => {
                proj.mesh.position.addInPlace(proj.velocity.scale(dt));

                // Check if hit target
                const dist = BABYLON.Vector3.Distance(proj.mesh.position, proj.target.pelvis.getAbsolutePosition());
                if (dist < 1.5) {
                    // Hit!
                    applyDamage(proj.target, proj.damage, proj.knockback, proj.velocity.normalize());
                    toRemove.push(idx);
                }

                // Remove if too old or out of bounds
                if (performance.now() - proj.startTime > 3000 ||
                    Math.abs(proj.mesh.position.x) > 30 ||
                    Math.abs(proj.mesh.position.z) > 30) {
                    toRemove.push(idx);
                }
            });

            // Remove hit/expired projectiles
            toRemove.reverse().forEach(idx => {
                projectiles[idx].mesh.dispose();
                projectiles.splice(idx, 1);
            });
        }

        // Update beams
        function updateBeams(dt) {
            const now = performance.now();
            const toRemove = [];

            beams.forEach((beam, idx) => {
                if (now - beam.startTime > beam.duration) {
                    toRemove.push(idx);
                } else if (!beam.applied) {
                    // Apply damage once
                    const direction = beam.target.pelvis.getAbsolutePosition().subtract(
                        beam.mesh.position
                    ).normalize();
                    applyDamage(beam.target, beam.damage, beam.knockback, direction);
                    beam.applied = true;
                }
            });

            toRemove.reverse().forEach(idx => {
                beams[idx].mesh.dispose();
                beams.splice(idx, 1);
            });
        }

        // Apply damage to mech
        function applyDamage(mech, damage, knockback, direction) {
            mech.currentHP -= damage;

            // Apply knockback
            const impulse = direction.scale(knockback);
            mech.pelvisBody.applyImpulse(impulse, mech.pelvis.getAbsolutePosition());

            // Check death
            if (mech.currentHP <= 0) {
                mech.isDestroyed = true;
                mech.currentHP = 0;
            }

            updateBattleUI();
        }

        // Update mech AI and movement
        function updateMechAI(mech, dt) {
            if (mech.isDestroyed) return;

            const target = mech.ai.target;
            if (!target || target.isDestroyed) return;

            const myPos = mech.pelvis.getAbsolutePosition();
            const targetPos = target.pelvis.getAbsolutePosition();
            const dx = targetPos.x - myPos.x;
            const dz = targetPos.z - myPos.z;
            const distance = Math.sqrt(dx * dx + dz * dz);

            // Decision making
            mech.ai.decisionTimer -= dt;
            if (mech.ai.decisionTimer <= 0) {
                mech.ai.decisionTimer = AI_CONFIG.decisionInterval;

                // Decide to strafe
                if (Math.random() < AI_CONFIG.strafeChance) {
                    mech.ai.strafeAmount = (Math.random() - 0.5) * 2;
                } else {
                    mech.ai.strafeAmount = 0;
                }
            }

            // Movement - try to stay at ideal range
            if (distance > AI_CONFIG.maxRange) {
                mech.walkDirection = 1;  // Move forward
                mech.isWalking = true;
            } else if (distance < AI_CONFIG.minRange) {
                mech.walkDirection = -1;  // Back up
                mech.isWalking = true;
            } else {
                mech.walkDirection = 0;
                mech.isWalking = Math.abs(mech.ai.strafeAmount) > 0.3;
            }

            // Calculate facing angle
            const angleToTarget = Math.atan2(dz, dx);
            const baseAngle = Math.PI / 2;

            // Get pelvis rotation
            const body = mech.pelvisBody;
            const quat = body.transformNode.rotationQuaternion;
            let pelvisYaw = 0;
            if (quat) {
                const euler = quat.toEulerAngles();
                pelvisYaw = euler.y;
            }

            // Calculate desired yaw change
            let desiredYaw = baseAngle - angleToTarget;
            while (desiredYaw > Math.PI) desiredYaw -= Math.PI * 2;
            while (desiredYaw < -Math.PI) desiredYaw += Math.PI * 2;

            const yawError = desiredYaw - pelvisYaw;

            // Apply rotation
            const rotSpeed = AI_CONFIG.turnSpeed * dt;
            if (Math.abs(yawError) > 0.1) {
                const rot = Math.sign(yawError) * Math.min(Math.abs(yawError), rotSpeed);
                body.setAngularVelocity(new BABYLON.Vector3(0, rot * 3, 0));
            }

            // Walking animation
            if (mech.isWalking) {
                mech.walkCycle += dt * 4;
                const legSwing = Math.sin(mech.walkCycle) * 0.3;
                mech.leftLeg.rotation.x = legSwing;
                mech.rightLeg.rotation.x = -legSwing;
            }

            // Move
            if (mech.isWalking || mech.walkDirection !== 0) {
                let forwardDir = new BABYLON.Vector3(1, 0, 0);
                let rightDir = new BABYLON.Vector3(0, 0, 1);
                if (quat) {
                    const rotMatrix = new BABYLON.Matrix();
                    quat.toRotationMatrix(rotMatrix);
                    forwardDir = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(1, 0, 0), rotMatrix);
                    forwardDir.y = 0;
                    forwardDir.normalize();
                    rightDir = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(0, 0, 1), rotMatrix);
                    rightDir.y = 0;
                    rightDir.normalize();
                }

                const moveSpeed = AI_CONFIG.moveSpeed;
                let velocity = forwardDir.scale(mech.walkDirection * moveSpeed);
                velocity.addInPlace(rightDir.scale(mech.ai.strafeAmount * moveSpeed * 0.6));
                velocity.y = (2.5 - myPos.y) * 5; // Ground seeking
                body.setLinearVelocity(velocity);
            }

            // Torso twist toward target (local rotation)
            let localTorsoAngle = desiredYaw - pelvisYaw;
            while (localTorsoAngle > Math.PI) localTorsoAngle -= Math.PI * 2;
            while (localTorsoAngle < -Math.PI) localTorsoAngle += Math.PI * 2;
            localTorsoAngle = Math.max(-1.0, Math.min(1.0, localTorsoAngle));
            mech.torsoTwist = BABYLON.Scalar.Lerp(mech.torsoTwist, localTorsoAngle, dt * 5);
            mech.torso.rotation.y = mech.torsoTwist;

            // Fire weapons at target
            if (distance < 15 && mech.weapons.length > 0) {
                // Fire first available weapon
                mech.weapons.forEach(weapon => {
                    fireLoadoutWeapon(mech, weapon, target);
                });
            }
        }

        // Battle update loop
        function updateBattle(dt) {
            if (!battleActive) return;

            // Update all mechs
            battleMechs.forEach(mech => {
                updateMechAI(mech, dt);
            });

            // Update weapons
            updateProjectiles(dt);
            updateBeams(dt);

            // Check battle end
            if (playerBattleMech.isDestroyed || enemyBattleMech.isDestroyed) {
                endBattle(playerBattleMech.isDestroyed ? 'defeat' : 'victory');
            }
        }

        // Battle UI
        function updateBattleUI() {
            const playerHP = document.getElementById('playerHP');
            const enemyHP = document.getElementById('enemyHP');
            if (playerHP && playerBattleMech) {
                const pct = (playerBattleMech.currentHP / playerBattleMech.maxHP) * 100;
                playerHP.style.width = pct + '%';
            }
            if (enemyHP && enemyBattleMech) {
                const pct = (enemyBattleMech.currentHP / enemyBattleMech.maxHP) * 100;
                enemyHP.style.width = pct + '%';
            }
        }

        // End battle
        function endBattle(result) {
            battleActive = false;

            // Show result
            const overlay = document.getElementById('battleResultOverlay');
            const resultText = document.getElementById('battleResult');
            if (overlay && resultText) {
                resultText.textContent = result === 'victory' ? 'VICTORY!' : 'DEFEAT';
                resultText.style.color = result === 'victory' ? '#00ff88' : '#ff4444';
                overlay.style.display = 'flex';
            }
        }

        // Return to loadout
        function returnToLoadout() {
            battleActive = false;

            // Clean up battle scene
            if (battleScene) {
                battleScene.dispose();
                battleScene = null;
            }

            // Reset state
            battleMechs = [];
            playerBattleMech = null;
            enemyBattleMech = null;
            projectiles = [];
            beams = [];

            // Show builder UI, hide battle UI
            document.getElementById('mechBuilderUI').style.display = 'flex';
            document.getElementById('battleUI').style.display = 'none';

            // Switch to builder scene
            currentPhase = GamePhase.MECHBUILDER;
        }

        // Current hand (drawn items)
        let currentHand = [];

        // Loadout state (items placed on mech)
        let loadoutState = {
            mechId: MECH_CHASSIS.id,
            equipment: []  // Array of { itemId, slot, position: {x, y}, rotation }
        };

        // Grid occupation tracking
        let gridOccupation = {};  // slot -> 2D array of item IDs or null

        // ============================================
        // 2D GRID DATA STRUCTURE CLASS
        // ============================================
        class InventoryGrid {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.cells = [];
                for (let y = 0; y < height; y++) {
                    this.cells[y] = [];
                    for (let x = 0; x < width; x++) {
                        this.cells[y][x] = null;  // null = empty, string = item ID
                    }
                }
            }

            canPlaceItem(item, posX, posY) {
                const shape = item.gridShape;
                const h = shape.length;
                const w = shape[0].length;

                // Check bounds
                if (posX < 0 || posY < 0 || posX + w > this.width || posY + h > this.height) {
                    return false;
                }

                // Check each cell of the shape
                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        if (shape[dy][dx] === 1) {
                            if (this.cells[posY + dy][posX + dx] !== null) {
                                return false;  // Cell occupied
                            }
                        }
                    }
                }
                return true;
            }

            placeItem(item, posX, posY, instanceId) {
                const shape = item.gridShape;
                const h = shape.length;
                const w = shape[0].length;

                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        if (shape[dy][dx] === 1) {
                            this.cells[posY + dy][posX + dx] = instanceId;
                        }
                    }
                }
            }

            removeItem(instanceId) {
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        if (this.cells[y][x] === instanceId) {
                            this.cells[y][x] = null;
                        }
                    }
                }
            }

            isCellOccupied(x, y) {
                if (x < 0 || y < 0 || x >= this.width || y >= this.height) return true;
                return this.cells[y][x] !== null;
            }
        }

        // Initialize grids for each slot
        function initializeGrids() {
            gridOccupation = {};
            for (const [slotName, slotDef] of Object.entries(MECH_CHASSIS.slots)) {
                gridOccupation[slotName] = new InventoryGrid(slotDef.cols, slotDef.rows);
            }
        }

        // ============================================
        // DECK / HAND SYSTEM
        // ============================================
        function drawHand(count = 5) {
            currentHand = [];
            const allItemIds = Object.keys(ITEM_DATABASE);

            // Separate items by category to ensure variety
            const weaponIds = allItemIds.filter(id => ITEM_DATABASE[id].category === 'weapon');
            const otherIds = allItemIds.filter(id => ITEM_DATABASE[id].category !== 'weapon');

            // Guarantee at least 2 weapons
            const guaranteedWeapons = 2;
            for (let i = 0; i < guaranteedWeapons && i < count; i++) {
                const randomId = weaponIds[Math.floor(Math.random() * weaponIds.length)];
                currentHand.push({
                    instanceId: `item_${Date.now()}_${i}`,
                    itemId: randomId,
                    ...ITEM_DATABASE[randomId]
                });
            }

            // Fill rest with random items
            for (let i = guaranteedWeapons; i < count; i++) {
                const randomId = allItemIds[Math.floor(Math.random() * allItemIds.length)];
                currentHand.push({
                    instanceId: `item_${Date.now()}_${i}`,
                    itemId: randomId,
                    ...ITEM_DATABASE[randomId]
                });
            }

            return currentHand;
        }

        // ============================================
        // DRAG & DROP SYSTEM
        // ============================================
        let dragState = {
            isDragging: false,
            item: null,
            sourceType: null,  // 'bench' or 'grid'
            sourceSlot: null,
            sourcePosition: null,
            startX: 0,
            startY: 0
        };

        let gridElements = {};  // Store references to grid DOM elements
        let placedItemElements = {};  // Store references to placed item DOM elements

        function initDragAndDrop() {
            const bench = document.getElementById('bench');
            const dragGhost = document.getElementById('dragGhost');

            // Touch/Mouse event handlers
            document.addEventListener('mousedown', handleDragStart);
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);

            document.addEventListener('touchstart', handleDragStart, { passive: false });
            document.addEventListener('touchmove', handleDragMove, { passive: false });
            document.addEventListener('touchend', handleDragEnd);
        }

        function handleDragStart(e) {
            const touch = e.touches ? e.touches[0] : e;
            const target = document.elementFromPoint(touch.clientX, touch.clientY);

            // Check if we clicked on a bench item
            const benchItem = target.closest('.bench-item');
            if (benchItem) {
                e.preventDefault();
                const instanceId = benchItem.dataset.instanceId;
                const item = currentHand.find(i => i.instanceId === instanceId);
                if (item) {
                    startDrag(item, 'bench', null, null, touch.clientX, touch.clientY);
                    benchItem.classList.add('dragging');
                }
                return;
            }

            // Check if we clicked on a placed item
            const placedItem = target.closest('.placed-item');
            if (placedItem) {
                e.preventDefault();
                const instanceId = placedItem.dataset.instanceId;
                const equipment = loadoutState.equipment.find(eq => eq.instanceId === instanceId);
                if (equipment) {
                    const item = { ...ITEM_DATABASE[equipment.itemId], instanceId };
                    startDrag(item, 'grid', equipment.slot, equipment.position, touch.clientX, touch.clientY);

                    // Remove from grid temporarily
                    removeItemFromGrid(instanceId, equipment.slot);
                    placedItem.style.opacity = '0.3';
                }
                return;
            }
        }

        function startDrag(item, sourceType, sourceSlot, sourcePosition, x, y) {
            dragState = {
                isDragging: true,
                item: item,
                sourceType: sourceType,
                sourceSlot: sourceSlot,
                sourcePosition: sourcePosition,
                startX: x,
                startY: y
            };

            // Create ghost element
            const ghost = document.getElementById('dragGhost');
            ghost.innerHTML = createGhostHTML(item);
            ghost.style.display = 'block';
            ghost.style.left = x + 'px';
            ghost.style.top = y + 'px';

            // Highlight which grids are valid for this item
            updateSlotValidity(item);
        }

        function updateSlotValidity(item) {
            // Show which grids accept this item type
            const validSlots = item.constraints.validSlots || Object.keys(MECH_CHASSIS.slots);

            for (const [slotName, gridEl] of Object.entries(gridElements)) {
                gridEl.classList.remove('slot-valid', 'slot-invalid');
                if (validSlots.includes(slotName)) {
                    gridEl.classList.add('slot-valid');
                } else {
                    gridEl.classList.add('slot-invalid');
                }
            }
        }

        function createGhostHTML(item) {
            const shape = item.gridShape;
            const h = shape.length;
            const w = shape[0].length;

            let cellsHTML = '';
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    if (shape[y][x] === 1) {
                        cellsHTML += '<div class="ghost-cell"></div>';
                    }
                }
            }

            return `<div class="ghost-grid" style="grid-template-columns: repeat(${w}, 38px);">${cellsHTML}</div>`;
        }

        function handleDragMove(e) {
            if (!dragState.isDragging) return;
            e.preventDefault();

            const touch = e.touches ? e.touches[0] : e;
            const ghost = document.getElementById('dragGhost');
            ghost.style.left = touch.clientX + 'px';
            ghost.style.top = touch.clientY + 'px';

            // Check for valid drop target
            const dropInfo = getDropTarget(touch.clientX, touch.clientY);
            updateDropHighlight(dropInfo);

            // Check if over bench (for items from grid)
            const benchContainer = document.getElementById('benchContainer');
            const benchRect = benchContainer.getBoundingClientRect();
            const overBench = dragState.sourceType === 'grid' &&
                              touch.clientX >= benchRect.left &&
                              touch.clientX <= benchRect.right &&
                              touch.clientY >= benchRect.top &&
                              touch.clientY <= benchRect.bottom;

            if (overBench) {
                benchContainer.classList.add('drop-target');
                ghost.classList.remove('invalid');
            } else {
                benchContainer.classList.remove('drop-target');
            }

            // Update ghost validity
            if (dropInfo && dropInfo.valid) {
                ghost.classList.remove('invalid');
            } else if (dropInfo && !overBench) {
                ghost.classList.add('invalid');
            }
        }

        function handleDragEnd(e) {
            if (!dragState.isDragging) return;

            const touch = e.changedTouches ? e.changedTouches[0] : e;
            const dropInfo = getDropTarget(touch.clientX, touch.clientY);

            // Check if dropped on bench area
            const benchContainer = document.getElementById('benchContainer');
            const benchRect = benchContainer.getBoundingClientRect();
            const droppedOnBench = touch.clientX >= benchRect.left &&
                                   touch.clientX <= benchRect.right &&
                                   touch.clientY >= benchRect.top &&
                                   touch.clientY <= benchRect.bottom;

            if (dropInfo && dropInfo.valid) {
                // Place item on grid
                placeItemOnGrid(dragState.item, dropInfo.slot, dropInfo.gridX, dropInfo.gridY);

                // Remove from bench if it came from there
                if (dragState.sourceType === 'bench') {
                    const idx = currentHand.findIndex(i => i.instanceId === dragState.item.instanceId);
                    if (idx !== -1) currentHand.splice(idx, 1);
                }
            } else if (droppedOnBench && dragState.sourceType === 'grid') {
                // Return item to bench
                currentHand.push(dragState.item);
            } else if (dragState.sourceType === 'grid') {
                // Return to original position on grid
                placeItemOnGrid(
                    dragState.item,
                    dragState.sourceSlot,
                    dragState.sourcePosition.x,
                    dragState.sourcePosition.y
                );
            }

            // Cleanup
            cleanupDrag();
            renderBench();
            renderGridItems();
            updateStats();
        }

        function cleanupDrag() {
            document.querySelectorAll('.bench-item.dragging').forEach(el => el.classList.remove('dragging'));
            document.querySelectorAll('.placed-item').forEach(el => el.style.opacity = '1');
            document.querySelectorAll('.grid-cell').forEach(el => {
                el.classList.remove('valid-drop', 'invalid-drop');
            });
            document.querySelectorAll('.mech-grid-overlay').forEach(el => {
                el.classList.remove('slot-valid', 'slot-invalid');
            });
            document.getElementById('benchContainer').classList.remove('drop-target');

            const ghost = document.getElementById('dragGhost');
            ghost.style.display = 'none';
            ghost.classList.remove('invalid');

            dragState = {
                isDragging: false,
                item: null,
                sourceType: null,
                sourceSlot: null,
                sourcePosition: null,
                startX: 0,
                startY: 0
            };
        }

        function getDropTarget(clientX, clientY) {
            if (!dragState.item) return null;

            // Check each grid
            for (const [slotName, gridEl] of Object.entries(gridElements)) {
                const rect = gridEl.getBoundingClientRect();
                // Account for label offset (label is at top: -20px)
                const labelOffset = 20;
                const adjustedTop = rect.top + labelOffset;

                if (clientX >= rect.left && clientX <= rect.right &&
                    clientY >= adjustedTop && clientY <= rect.bottom) {

                    // Calculate grid cell position
                    // Account for: 2px border + 4px padding = 6px offset
                    const cellSize = 42;  // 40px + 2px gap
                    const borderAndPadding = 6;
                    const localX = clientX - rect.left - borderAndPadding;
                    const localY = clientY - adjustedTop - borderAndPadding;

                    const item = dragState.item;
                    const shape = item.gridShape;
                    const itemW = shape[0].length;
                    const itemH = shape.length;

                    const slotDef = MECH_CHASSIS.slots[slotName];
                    const grid = gridOccupation[slotName];

                    // Check slot constraints first
                    const validSlot = !item.constraints.validSlots ||
                                      item.constraints.validSlots.includes(slotName);

                    // Calculate the cell the cursor is over (not centered)
                    const cursorCellX = Math.floor(localX / cellSize);
                    const cursorCellY = Math.floor(localY / cellSize);

                    // Find the best position for the item nearest to cursor
                    const bestPos = findBestPosition(grid, item, cursorCellX, cursorCellY, slotDef);

                    if (bestPos) {
                        return {
                            slot: slotName,
                            gridX: bestPos.x,
                            gridY: bestPos.y,
                            valid: validSlot
                        };
                    } else {
                        // No valid position, show where cursor would place it (clamped)
                        let gridX = cursorCellX - Math.floor(itemW / 2);
                        let gridY = cursorCellY - Math.floor(itemH / 2);
                        gridX = Math.max(0, Math.min(gridX, slotDef.cols - itemW));
                        gridY = Math.max(0, Math.min(gridY, slotDef.rows - itemH));

                        return {
                            slot: slotName,
                            gridX: gridX,
                            gridY: gridY,
                            valid: false
                        };
                    }
                }
            }

            return null;
        }

        function findBestPosition(grid, item, cursorX, cursorY, slotDef) {
            const itemW = item.gridShape[0].length;
            const itemH = item.gridShape.length;

            // Generate candidate positions: center on cursor, then expand outward
            const candidates = [];

            // Centered position
            const centerX = cursorX - Math.floor(itemW / 2);
            const centerY = cursorY - Math.floor(itemH / 2);

            // Search in expanding rings around cursor
            for (let radius = 0; radius <= Math.max(slotDef.cols, slotDef.rows); radius++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        if (Math.abs(dx) !== radius && Math.abs(dy) !== radius) continue;

                        const testX = centerX + dx;
                        const testY = centerY + dy;

                        // Check bounds
                        if (testX < 0 || testY < 0 ||
                            testX + itemW > slotDef.cols ||
                            testY + itemH > slotDef.rows) continue;

                        // Check if can place
                        if (grid.canPlaceItem(item, testX, testY)) {
                            return { x: testX, y: testY };
                        }
                    }
                }
            }

            return null;  // No valid position found
        }

        function updateDropHighlight(dropInfo) {
            // Clear all highlights
            document.querySelectorAll('.grid-cell').forEach(el => {
                el.classList.remove('valid-drop', 'invalid-drop');
            });

            if (!dropInfo || !dragState.item) return;

            const gridEl = gridElements[dropInfo.slot];
            if (!gridEl) return;

            const item = dragState.item;
            const shape = item.gridShape;
            const cells = gridEl.querySelectorAll('.grid-cell');
            const slotDef = MECH_CHASSIS.slots[dropInfo.slot];

            // Highlight cells that would be covered
            for (let dy = 0; dy < shape.length; dy++) {
                for (let dx = 0; dx < shape[0].length; dx++) {
                    if (shape[dy][dx] === 1) {
                        const cellX = dropInfo.gridX + dx;
                        const cellY = dropInfo.gridY + dy;

                        // Check bounds before calculating index
                        if (cellX < 0 || cellX >= slotDef.cols || cellY < 0 || cellY >= slotDef.rows) {
                            continue;  // Skip out-of-bounds cells
                        }

                        const cellIdx = cellY * slotDef.cols + cellX;

                        if (cellIdx >= 0 && cellIdx < cells.length) {
                            cells[cellIdx].classList.add(dropInfo.valid ? 'valid-drop' : 'invalid-drop');
                        }
                    }
                }
            }
        }

        function placeItemOnGrid(item, slot, gridX, gridY) {
            const instanceId = item.instanceId;

            // Add to loadout state
            loadoutState.equipment.push({
                instanceId: instanceId,
                itemId: item.id || item.itemId,
                slot: slot,
                position: { x: gridX, y: gridY },
                rotation: 0
            });

            // Mark grid cells as occupied
            gridOccupation[slot].placeItem(item, gridX, gridY, instanceId);
        }

        function removeItemFromGrid(instanceId, slot) {
            // Remove from loadout
            const idx = loadoutState.equipment.findIndex(eq => eq.instanceId === instanceId);
            if (idx !== -1) {
                loadoutState.equipment.splice(idx, 1);
            }

            // Clear grid cells
            gridOccupation[slot].removeItem(instanceId);
        }

        // Click to remove placed item
        function handlePlacedItemClick(instanceId) {
            const equipment = loadoutState.equipment.find(eq => eq.instanceId === instanceId);
            if (!equipment) return;

            const item = { ...ITEM_DATABASE[equipment.itemId], instanceId };

            // Remove from grid
            removeItemFromGrid(instanceId, equipment.slot);

            // Add back to bench
            currentHand.push(item);

            renderBench();
            renderGridItems();
            updateStats();
        }

        // ============================================
        // UI RENDERING
        // ============================================
        function renderBench() {
            const bench = document.getElementById('bench');
            bench.innerHTML = '';

            currentHand.forEach(item => {
                const el = document.createElement('div');
                el.className = `bench-item ${item.category}`;
                el.dataset.instanceId = item.instanceId;

                // Build shape preview HTML
                const shape = item.gridShape;
                const w = shape[0].length;
                const h = shape.length;
                let shapeHTML = `<div class="shape-preview" style="grid-template-columns: repeat(${w}, 10px);">`;
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const filled = shape[y][x] === 1;
                        shapeHTML += `<div class="shape-cell${filled ? '' : ' empty'}"></div>`;
                    }
                }
                shapeHTML += '</div>';

                // Build stats HTML for tooltip
                let statsHTML = '';
                if (item.stats.weight) statsHTML += `<span>Weight: ${item.stats.weight}</span>`;
                if (item.stats.energyDraw > 0) statsHTML += `<span>Energy: ${item.stats.energyDraw}</span>`;
                if (item.stats.energyDraw < 0) statsHTML += `<span>Energy: +${-item.stats.energyDraw}</span>`;
                if (item.stats.damage) statsHTML += `<span>Damage: ${item.stats.damage}</span>`;
                if (item.stats.armorBonus) statsHTML += `<span>Armor: +${item.stats.armorBonus}</span>`;
                if (item.stats.accuracyBonus) statsHTML += `<span>Accuracy: +${item.stats.accuracyBonus}%</span>`;
                if (item.stats.heatCapacity) statsHTML += `<span>Heat Cap: +${item.stats.heatCapacity}</span>`;

                // Build valid slots string
                const validSlots = item.constraints.validSlots || ['all'];
                const slotsStr = validSlots.map(s => s.replace(/([A-Z])/g, ' $1').trim()).join(', ');

                el.innerHTML = `
                    <span class="item-icon">${item.icon}</span>
                    <span class="item-name">${item.name}</span>
                    ${shapeHTML}
                    <div class="bench-tooltip">
                        <div class="tooltip-name">${item.icon} ${item.name}</div>
                        <div class="tooltip-stats">${statsHTML}</div>
                        <div class="tooltip-slots">Fits: ${slotsStr}</div>
                    </div>
                `;
                bench.appendChild(el);
            });
        }

        function renderMissions() {
            const missionList = document.getElementById('missionList');
            missionList.innerHTML = '';

            for (const mission of Object.values(MISSIONS)) {
                const card = document.createElement('div');
                card.className = `mission-card ${mission.difficulty.toLowerCase()}`;
                card.dataset.missionId = mission.id;

                if (selectedMission === mission.id) {
                    card.classList.add('selected');
                }

                // Build equipment list for tooltip
                const enemy = mission.enemyMechs[0];
                let equipmentHTML = '';
                enemy.equipment.forEach(eq => {
                    const item = ITEM_DATABASE[eq.itemId];
                    if (item) {
                        equipmentHTML += `<div>${item.icon} ${item.name}</div>`;
                    }
                });

                card.innerHTML = `
                    <div class="mission-header">
                        <span class="mission-name">${mission.name}</span>
                        <span class="mission-difficulty ${mission.difficulty.toLowerCase()}">${mission.difficulty}</span>
                    </div>
                    <div class="mission-desc">${mission.description}</div>
                    <div class="mission-reward">
                        <span>üí∞ ${mission.reward.credits}</span>
                        <span>‚≠ê ${mission.reward.xp} XP</span>
                    </div>
                    <div class="enemy-tooltip">
                        <div class="enemy-name">‚ö†Ô∏è ${enemy.name}</div>
                        <div class="enemy-chassis">${enemy.chassis}</div>
                        <div class="enemy-stats">
                            <div>‚ù§Ô∏è Health: ${enemy.maxHealth}</div>
                            <div>‚öñÔ∏è Weight: ${enemy.stats.weight}</div>
                            <div>‚ö° Energy: ${enemy.stats.energy}</div>
                            <div>üí• Damage: ${enemy.stats.damage}</div>
                            <div>üõ°Ô∏è Armor: ${enemy.stats.armor}</div>
                        </div>
                        <div class="enemy-equipment">
                            <strong>Equipment:</strong>
                            ${equipmentHTML}
                        </div>
                    </div>
                `;

                card.addEventListener('click', () => selectMission(mission.id));
                missionList.appendChild(card);
            }
        }

        function selectMission(missionId) {
            selectedMission = missionId;
            renderMissions();
            updateStats();  // Re-check battle ready state
        }

        function renderGridOverlays() {
            const container = document.getElementById('gridOverlayContainer');
            container.innerHTML = '';
            gridElements = {};

            const containerRect = container.getBoundingClientRect();

            for (const [slotName, slotDef] of Object.entries(MECH_CHASSIS.slots)) {
                const gridEl = document.createElement('div');
                gridEl.className = 'mech-grid-overlay';
                gridEl.dataset.slot = slotName;
                gridEl.style.gridTemplateColumns = `repeat(${slotDef.cols}, 40px)`;

                // Position based on relative coords
                const left = slotDef.position.x * containerRect.width - (slotDef.cols * 21);
                const top = slotDef.position.y * containerRect.height - (slotDef.rows * 21);
                gridEl.style.left = left + 'px';
                gridEl.style.top = top + 'px';

                // Add label
                const label = document.createElement('span');
                label.className = 'grid-label';
                label.textContent = slotName.replace(/([A-Z])/g, ' $1').trim();
                gridEl.appendChild(label);

                // Create grid cells
                for (let y = 0; y < slotDef.rows; y++) {
                    for (let x = 0; x < slotDef.cols; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.x = x;
                        cell.dataset.y = y;
                        gridEl.appendChild(cell);
                    }
                }

                container.appendChild(gridEl);
                gridElements[slotName] = gridEl;
            }
        }

        function renderGridItems() {
            // Remove old placed items
            document.querySelectorAll('.placed-item').forEach(el => el.remove());

            // Update cell states
            for (const [slotName, gridEl] of Object.entries(gridElements)) {
                const cells = gridEl.querySelectorAll('.grid-cell');
                const grid = gridOccupation[slotName];
                const slotDef = MECH_CHASSIS.slots[slotName];

                cells.forEach((cell, idx) => {
                    const x = idx % slotDef.cols;
                    const y = Math.floor(idx / slotDef.cols);
                    cell.classList.toggle('occupied', grid.isCellOccupied(x, y));
                });
            }

            // Render placed items
            loadoutState.equipment.forEach(eq => {
                const item = ITEM_DATABASE[eq.itemId];
                const gridEl = gridElements[eq.slot];
                if (!gridEl || !item) return;

                const placedEl = document.createElement('div');
                placedEl.className = `placed-item ${item.category}`;
                placedEl.dataset.instanceId = eq.instanceId;

                const shape = item.gridShape;
                const w = shape[0].length;
                const h = shape.length;

                placedEl.style.gridTemplateColumns = `repeat(${w}, 36px)`;
                placedEl.style.left = (4 + eq.position.x * 42) + 'px';
                placedEl.style.top = (4 + eq.position.y * 42) + 'px';

                // Add grid cells
                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        if (shape[dy][dx] === 1) {
                            const cell = document.createElement('div');
                            cell.className = 'placed-cell';
                            placedEl.appendChild(cell);
                        }
                    }
                }

                // Add icon overlay
                const iconOverlay = document.createElement('span');
                iconOverlay.className = 'item-icon-overlay';
                iconOverlay.textContent = item.icon;
                placedEl.appendChild(iconOverlay);

                // Add tooltip with item details
                const tooltip = document.createElement('div');
                tooltip.className = 'item-tooltip';
                let statsHTML = '';
                if (item.stats.weight) statsHTML += `<span>Weight: ${item.stats.weight}</span>`;
                if (item.stats.energyDraw > 0) statsHTML += `<span>Energy: ${item.stats.energyDraw}</span>`;
                if (item.stats.energyDraw < 0) statsHTML += `<span>Energy: +${-item.stats.energyDraw}</span>`;
                if (item.stats.damage) statsHTML += `<span>Damage: ${item.stats.damage}</span>`;
                if (item.stats.armorBonus) statsHTML += `<span>Armor: +${item.stats.armorBonus}</span>`;
                if (item.stats.accuracyBonus) statsHTML += `<span>Accuracy: +${item.stats.accuracyBonus}%</span>`;
                tooltip.innerHTML = `
                    <div class="tooltip-name">${item.icon} ${item.name}</div>
                    <div class="tooltip-stats">${statsHTML}</div>
                    <div class="tooltip-hint">Click to remove</div>
                `;
                placedEl.appendChild(tooltip);

                // Click to remove
                placedEl.addEventListener('click', (e) => {
                    if (!dragState.isDragging) {
                        handlePlacedItemClick(eq.instanceId);
                    }
                });

                // Touch hold for mobile tooltip
                let holdTimer = null;
                placedEl.addEventListener('touchstart', (e) => {
                    holdTimer = setTimeout(() => {
                        placedEl.classList.add('show-tooltip');
                    }, 500);
                });
                placedEl.addEventListener('touchend', () => {
                    clearTimeout(holdTimer);
                    setTimeout(() => placedEl.classList.remove('show-tooltip'), 1500);
                });

                gridEl.appendChild(placedEl);
            });
        }

        function updateStats() {
            let totalWeight = 0;
            let energyUsed = 0;      // Positive energyDraw = consumes energy
            let energyProvided = 0;  // Negative energyDraw = provides energy (reactors)

            loadoutState.equipment.forEach(eq => {
                const item = ITEM_DATABASE[eq.itemId];
                if (item && item.stats) {
                    totalWeight += item.stats.weight || 0;
                    const draw = item.stats.energyDraw || 0;
                    if (draw > 0) {
                        energyUsed += draw;
                    } else {
                        energyProvided += Math.abs(draw);
                    }
                }
            });

            const maxWeight = MECH_CHASSIS.maxWeight;
            const maxEnergy = MECH_CHASSIS.baseEnergy + energyProvided;  // Reactors increase max energy

            // Update weight bar
            const weightFill = document.getElementById('weightFill');
            const weightText = document.getElementById('weightText');
            const weightPercent = Math.min((totalWeight / maxWeight) * 100, 100);
            weightFill.style.width = weightPercent + '%';
            weightText.textContent = `${totalWeight} / ${maxWeight}`;
            weightFill.classList.toggle('over-limit', totalWeight > maxWeight);

            // Update energy bar (energy used vs available energy)
            const energyFill = document.getElementById('energyFill');
            const energyText = document.getElementById('energyText');
            const energyPercent = Math.min((energyUsed / maxEnergy) * 100, 100);
            energyFill.style.width = energyPercent + '%';
            energyText.textContent = `${energyUsed} / ${maxEnergy}`;
            energyFill.classList.toggle('over-limit', energyUsed > maxEnergy);

            // Update battle ready button
            const btn = document.getElementById('battleReadyBtn');
            const isValid = totalWeight <= maxWeight &&
                           energyUsed <= maxEnergy &&
                           loadoutState.equipment.length > 0 &&
                           selectedMission !== null;
            btn.disabled = !isValid;
            btn.classList.toggle('ready', isValid);

            // Update button text to show what's missing
            if (!selectedMission) {
                btn.textContent = 'Select a Mission';
            } else if (loadoutState.equipment.length === 0) {
                btn.textContent = 'Equip Items';
            } else if (!isValid) {
                btn.textContent = 'Over Limit!';
            } else {
                btn.textContent = 'Battle Ready';
            }
        }

        // ============================================
        // 3D SCENE - MECHBUILDER VIEW
        // ============================================
        let builderMech = null;
        let outlineMaterial = null;

        function createBuilderScene() {
            // Create orthographic camera for blueprint view
            const aspectRatio = engine.getRenderWidth() / engine.getRenderHeight();
            const orthoSize = 4;

            builderCamera = new BABYLON.ArcRotateCamera('builderCam',
                -Math.PI/2, Math.PI/2.5, 10,
                new BABYLON.Vector3(0, 1.5, 0), scene);
            builderCamera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
            builderCamera.orthoLeft = -orthoSize * aspectRatio;
            builderCamera.orthoRight = orthoSize * aspectRatio;
            builderCamera.orthoTop = orthoSize;
            builderCamera.orthoBottom = -orthoSize;
            builderCamera.attachControl(document.getElementById('renderCanvas'), true);

            // Ambient lighting for builder
            const hemi = new BABYLON.HemisphericLight('builderHemi', new BABYLON.Vector3(0, 1, 0), scene);
            hemi.intensity = 0.8;
            hemi.groundColor = new BABYLON.Color3(0.1, 0.2, 0.15);

            // Create outline/holographic material
            outlineMaterial = new BABYLON.StandardMaterial('outlineMat', scene);
            outlineMaterial.diffuseColor = new BABYLON.Color3(0, 0.4, 0.3);
            outlineMaterial.emissiveColor = new BABYLON.Color3(0, 0.8, 0.5);
            outlineMaterial.specularColor = new BABYLON.Color3(0, 1, 0.7);
            outlineMaterial.alpha = 0.7;
            outlineMaterial.wireframe = false;

            // Create dark background plane
            const bgPlane = BABYLON.MeshBuilder.CreatePlane('bgPlane', { size: 50 }, scene);
            bgPlane.position.z = 5;
            const bgMat = new BABYLON.StandardMaterial('bgMat', scene);
            bgMat.diffuseColor = new BABYLON.Color3(0.02, 0.04, 0.03);
            bgMat.emissiveColor = new BABYLON.Color3(0.01, 0.02, 0.015);
            bgPlane.material = bgMat;

            // Create grid floor for reference
            const gridSize = 10;
            const gridLines = [];
            for (let i = -gridSize; i <= gridSize; i++) {
                gridLines.push([new BABYLON.Vector3(i, 0, -gridSize), new BABYLON.Vector3(i, 0, gridSize)]);
                gridLines.push([new BABYLON.Vector3(-gridSize, 0, i), new BABYLON.Vector3(gridSize, 0, i)]);
            }
            const gridMesh = BABYLON.MeshBuilder.CreateLineSystem('grid', { lines: gridLines }, scene);
            gridMesh.color = new BABYLON.Color3(0, 0.3, 0.2);
            gridMesh.alpha = 0.3;

            // Create the mech model for builder view
            builderMech = createBuilderMechModel();

            scene.activeCamera = builderCamera;
        }

        function createBuilderMechModel() {
            // Create a simplified mech silhouette for the builder
            const mech = new BABYLON.TransformNode('builderMech', scene);

            // Torso (main body)
            const torso = BABYLON.MeshBuilder.CreateBox('torso', {
                width: 1.2, height: 1.0, depth: 0.8
            }, scene);
            torso.position.y = 2.2;
            torso.parent = mech;
            torso.material = outlineMaterial;

            // Torso upper
            const torsoUpper = BABYLON.MeshBuilder.CreateBox('torsoUpper', {
                width: 1.4, height: 0.5, depth: 0.9
            }, scene);
            torsoUpper.position.y = 0.6;
            torsoUpper.parent = torso;
            torsoUpper.material = outlineMaterial;

            // Head/cockpit
            const head = BABYLON.MeshBuilder.CreateBox('head', {
                width: 0.5, height: 0.4, depth: 0.5
            }, scene);
            head.position.y = 0.9;
            head.parent = torso;
            head.material = outlineMaterial;

            // Cockpit glass
            const cockpit = BABYLON.MeshBuilder.CreateBox('cockpit', {
                width: 0.4, height: 0.15, depth: 0.1
            }, scene);
            cockpit.position = new BABYLON.Vector3(0, 0, 0.28);
            cockpit.parent = head;
            const cockpitMat = new BABYLON.StandardMaterial('cockpitMat', scene);
            cockpitMat.diffuseColor = new BABYLON.Color3(0, 0.5, 0.5);
            cockpitMat.emissiveColor = new BABYLON.Color3(0, 0.8, 0.9);
            cockpitMat.alpha = 0.9;
            cockpit.material = cockpitMat;

            // Left Arm
            const leftArm = createBuilderArm('left', -0.9, torso);

            // Right Arm
            const rightArm = createBuilderArm('right', 0.9, torso);

            // Pelvis
            const pelvis = BABYLON.MeshBuilder.CreateBox('pelvis', {
                width: 0.9, height: 0.4, depth: 0.6
            }, scene);
            pelvis.position.y = 1.5;
            pelvis.parent = mech;
            pelvis.material = outlineMaterial;

            // Left Leg
            const leftLeg = createBuilderLeg('left', -0.4, pelvis);

            // Right Leg
            const rightLeg = createBuilderLeg('right', 0.4, pelvis);

            // Add edge rendering for holographic effect
            addEdgeRendering(mech);

            return mech;
        }

        function createBuilderArm(side, xOffset, parent) {
            const arm = new BABYLON.TransformNode(side + 'Arm', scene);
            arm.position.x = xOffset;
            arm.position.y = 0.3;
            arm.parent = parent;

            // Shoulder
            const shoulder = BABYLON.MeshBuilder.CreateSphere(side + 'Shoulder', {
                diameter: 0.4
            }, scene);
            shoulder.parent = arm;
            shoulder.material = outlineMaterial;

            // Upper arm
            const upperArm = BABYLON.MeshBuilder.CreateBox(side + 'UpperArm', {
                width: 0.25, height: 0.6, depth: 0.25
            }, scene);
            upperArm.position.y = -0.4;
            upperArm.parent = arm;
            upperArm.material = outlineMaterial;

            // Lower arm / weapon housing
            const lowerArm = BABYLON.MeshBuilder.CreateBox(side + 'LowerArm', {
                width: 0.35, height: 0.8, depth: 0.4
            }, scene);
            lowerArm.position.y = -1.0;
            lowerArm.parent = arm;
            lowerArm.material = outlineMaterial;

            return arm;
        }

        function createBuilderLeg(side, xOffset, parent) {
            const leg = new BABYLON.TransformNode(side + 'Leg', scene);
            leg.position.x = xOffset;
            leg.position.y = -0.2;
            leg.parent = parent;

            // Hip joint
            const hip = BABYLON.MeshBuilder.CreateSphere(side + 'Hip', {
                diameter: 0.3
            }, scene);
            hip.parent = leg;
            hip.material = outlineMaterial;

            // Upper leg (thigh)
            const upperLeg = BABYLON.MeshBuilder.CreateBox(side + 'UpperLeg', {
                width: 0.25, height: 0.5, depth: 0.3
            }, scene);
            upperLeg.position.y = -0.35;
            upperLeg.rotation.x = 0.3;
            upperLeg.parent = leg;
            upperLeg.material = outlineMaterial;

            // Knee
            const knee = BABYLON.MeshBuilder.CreateSphere(side + 'Knee', {
                diameter: 0.25
            }, scene);
            knee.position.y = -0.6;
            knee.position.z = 0.15;
            knee.parent = leg;
            knee.material = outlineMaterial;

            // Lower leg (shin)
            const lowerLeg = BABYLON.MeshBuilder.CreateBox(side + 'LowerLeg', {
                width: 0.3, height: 0.7, depth: 0.35
            }, scene);
            lowerLeg.position.y = -1.0;
            lowerLeg.position.z = 0.05;
            lowerLeg.rotation.x = -0.2;
            lowerLeg.parent = leg;
            lowerLeg.material = outlineMaterial;

            // Foot
            const foot = BABYLON.MeshBuilder.CreateBox(side + 'Foot', {
                width: 0.35, height: 0.15, depth: 0.5
            }, scene);
            foot.position.y = -1.45;
            foot.position.z = 0.1;
            foot.parent = leg;
            foot.material = outlineMaterial;

            return leg;
        }

        function addEdgeRendering(rootNode) {
            // Add edge rendering to all meshes
            const meshes = rootNode.getChildMeshes();
            meshes.forEach(mesh => {
                mesh.enableEdgesRendering();
                mesh.edgesWidth = 2.0;
                mesh.edgesColor = new BABYLON.Color4(0, 1, 0.6, 1);
            });
        }

        // ============================================
        // PLAYER STATS CALCULATION
        // ============================================
        function calculatePlayerStats() {
            let totalDamage = 0;
            let totalArmor = 0;
            let totalWeight = 0;
            let baseHealth = 100;
            let weapons = [];

            loadoutState.equipment.forEach(eq => {
                const item = ITEM_DATABASE[eq.itemId];
                if (item && item.stats) {
                    totalWeight += item.stats.weight || 0;
                    totalDamage += item.stats.damage || 0;
                    totalArmor += item.stats.armorBonus || 0;
                    if (item.type === 'WEAPON') {
                        weapons.push({ itemId: eq.itemId, slot: eq.slot });
                    }
                }
            });

            const healthBonus = Math.floor(totalWeight * 0.5);
            return {
                maxHealth: baseHealth + healthBonus + totalArmor,
                currentHealth: baseHealth + healthBonus + totalArmor,
                damage: Math.max(20, totalDamage),
                armor: totalArmor,
                weapons: weapons
            };
        }

        // Create a battle mech with physics
        function createBattleMech(scene, xPos, zPos, isPlayer, stats, name) {
            const primary = isPlayer ? BATTLE_COLORS.playerPrimary : BATTLE_COLORS.enemyPrimary;
            const secondary = isPlayer ? BATTLE_COLORS.playerSecondary : BATTLE_COLORS.enemySecondary;

            // Materials
            const primaryMat = new BABYLON.StandardMaterial('mech_primary_' + name, scene);
            primaryMat.diffuseColor = primary;
            primaryMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);

            const secondaryMat = new BABYLON.StandardMaterial('mech_secondary_' + name, scene);
            secondaryMat.diffuseColor = secondary;

            const metalMat = new BABYLON.StandardMaterial('mech_metal_' + name, scene);
            metalMat.diffuseColor = BATTLE_COLORS.metal;
            metalMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);

            // Create mech body
            const torso = BABYLON.MeshBuilder.CreateBox('torso_' + name, { width: 1.5, height: 1.2, depth: 1 }, scene);
            torso.position = new BABYLON.Vector3(xPos, 2.5, zPos);
            torso.material = primaryMat;

            // Head/Cockpit
            const head = BABYLON.MeshBuilder.CreateBox('head_' + name, { width: 0.6, height: 0.5, depth: 0.6 }, scene);
            head.parent = torso;
            head.position.y = 0.85;
            head.material = secondaryMat;

            // Arms
            const leftArm = BABYLON.MeshBuilder.CreateBox('leftArm_' + name, { width: 0.4, height: 1.4, depth: 0.4 }, scene);
            leftArm.parent = torso;
            leftArm.position = new BABYLON.Vector3(-1, 0, 0);
            leftArm.material = metalMat;

            const rightArm = BABYLON.MeshBuilder.CreateBox('rightArm_' + name, { width: 0.4, height: 1.4, depth: 0.4 }, scene);
            rightArm.parent = torso;
            rightArm.position = new BABYLON.Vector3(1, 0, 0);
            rightArm.material = metalMat;

            // Weapon pods on arms
            const leftWeapon = BABYLON.MeshBuilder.CreateCylinder('leftWeapon_' + name, { diameter: 0.25, height: 0.8 }, scene);
            leftWeapon.parent = leftArm;
            leftWeapon.position = new BABYLON.Vector3(0, -0.5, 0.3);
            leftWeapon.rotation.x = Math.PI / 2;
            leftWeapon.material = metalMat;

            const rightWeapon = BABYLON.MeshBuilder.CreateCylinder('rightWeapon_' + name, { diameter: 0.25, height: 0.8 }, scene);
            rightWeapon.parent = rightArm;
            rightWeapon.position = new BABYLON.Vector3(0, -0.5, 0.3);
            rightWeapon.rotation.x = Math.PI / 2;
            rightWeapon.material = metalMat;

            // Legs
            const leftLeg = BABYLON.MeshBuilder.CreateBox('leftLeg_' + name, { width: 0.5, height: 1.8, depth: 0.5 }, scene);
            leftLeg.parent = torso;
            leftLeg.position = new BABYLON.Vector3(-0.5, -1.5, 0);
            leftLeg.material = primaryMat;

            const rightLeg = BABYLON.MeshBuilder.CreateBox('rightLeg_' + name, { width: 0.5, height: 1.8, depth: 0.5 }, scene);
            rightLeg.parent = torso;
            rightLeg.position = new BABYLON.Vector3(0.5, -1.5, 0);
            rightLeg.material = primaryMat;

            // Feet
            const leftFoot = BABYLON.MeshBuilder.CreateBox('leftFoot_' + name, { width: 0.6, height: 0.2, depth: 0.9 }, scene);
            leftFoot.parent = leftLeg;
            leftFoot.position = new BABYLON.Vector3(0, -1, 0.15);
            leftFoot.material = metalMat;

            const rightFoot = BABYLON.MeshBuilder.CreateBox('rightFoot_' + name, { width: 0.6, height: 0.2, depth: 0.9 }, scene);
            rightFoot.parent = rightLeg;
            rightFoot.position = new BABYLON.Vector3(0, -1, 0.15);
            rightFoot.material = metalMat;

            // Create mech object
            const mech = {
                name: name,
                isPlayer: isPlayer,
                torso: torso,
                leftArm: leftArm,
                rightArm: rightArm,
                leftWeapon: leftWeapon,
                rightWeapon: rightWeapon,
                maxHP: stats.maxHealth,
                currentHP: stats.currentHealth,
                damage: stats.damage,
                armor: stats.armor,
                weapons: stats.weapons || [],
                cooldowns: {},
                mechState: MechState.WALKING,
                ai: {
                    target: null,
                    lastDecision: 0,
                    moveDirection: new BABYLON.Vector3(0, 0, 0),
                    strafeDir: 0
                },
                walkCycle: 0,
                isDestroyed: false
            };

            return mech;
        }

        // Create battle arena
        function createBattleArena(scene) {
            // Ground
            const ground = BABYLON.MeshBuilder.CreateGround('battleGround', { width: 40, height: 25 }, scene);
            const groundMat = new BABYLON.StandardMaterial('groundMat', scene);
            groundMat.diffuseColor = new BABYLON.Color3(0.25, 0.3, 0.2);
            groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            ground.material = groundMat;
            ground.receiveShadows = true;
            battleGround = ground;

            // Battle lighting
            const battleLight = new BABYLON.DirectionalLight('battleLight', new BABYLON.Vector3(-1, -2, -1), scene);
            battleLight.intensity = 1.2;
            battleLight.position = new BABYLON.Vector3(10, 20, 10);

            const ambientLight = new BABYLON.HemisphericLight('battleAmbient', new BABYLON.Vector3(0, 1, 0), scene);
            ambientLight.intensity = 0.4;

            return ground;
        }

        async function startBattle() {
            if (loadoutState.equipment.length === 0 || !selectedMission) {
                return;
            }

            const mission = MISSIONS[selectedMission];
            const playerStats = calculatePlayerStats();

            // Get weapons from loadout
            const playerWeapons = getLoadoutWeapons();
            if (playerWeapons.length === 0) {
                console.warn('No weapons equipped!');
            }

            // Get enemy weapons from mission config
            const enemyConfig = mission.enemyMechs[0];
            const enemyWeapons = [];
            if (enemyConfig.equipment) {
                enemyConfig.equipment.forEach(eq => {
                    const item = ITEM_DATABASE[eq.itemId];
                    if (item && item.type === 'WEAPON' && item.battle) {
                        enemyWeapons.push({
                            itemId: eq.itemId,
                            slot: eq.slot,
                            name: item.name,
                            damage: item.stats.damage,
                            battle: item.battle,
                            lastFired: 0
                        });
                    }
                });
            }

            // Hide builder UI, show battle UI
            document.getElementById('mechBuilderUI').style.display = 'none';
            document.getElementById('battleUI').style.display = 'flex';

            // Create battle scene
            await createBattleScene();

            // Create player mech with loadout weapons
            playerBattleMech = createBattleMech(
                battleScene, -8, 0, true,
                playerWeapons,
                playerStats.maxHealth
            );

            // Create enemy mech
            enemyBattleMech = createBattleMech(
                battleScene, 8, 0, false,
                enemyWeapons,
                enemyConfig.maxHealth || 100
            );

            // Set up targets
            playerBattleMech.ai.target = enemyBattleMech;
            enemyBattleMech.ai.target = playerBattleMech;

            battleMechs = [playerBattleMech, enemyBattleMech];

            // Update UI
            document.getElementById('playerName').textContent = MECH_CHASSIS.name;
            document.getElementById('enemyName').textContent = enemyConfig.name;
            updateBattleUI();

            // Start battle
            currentPhase = GamePhase.BATTLE;
            battleActive = true;
        }

        // ============================================
        // ENGINE INITIALIZATION
        // ============================================
        async function initEngine() {
            const canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, {
                preserveDrawingBuffer: true,
                stencil: true,
                antialias: true
            });

            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.02, 0.04, 0.03, 1);

            // Initialize MechBuilder
            createBuilderScene();
            initializeGrids();

            // Draw initial hand
            drawHand(5);

            // Render UI
            renderBench();
            renderMissions();
            renderGridOverlays();
            renderGridItems();
            updateStats();

            // Initialize drag and drop
            initDragAndDrop();

            // Battle ready button
            document.getElementById('battleReadyBtn').addEventListener('click', startBattle);

            // Main render loop with delta time for battle updates
            let lastFrameTime = performance.now();
            engine.runRenderLoop(() => {
                const now = performance.now();
                const dt = (now - lastFrameTime) / 1000;
                lastFrameTime = now;

                // Render appropriate scene based on phase
                if (currentPhase === GamePhase.BATTLE && battleScene) {
                    // Update battle mechanics
                    if (battleActive) {
                        updateBattle(dt);
                    }
                    battleScene.render();
                } else if (scene) {
                    scene.render();
                }
            });

            // Handle window resize
            window.addEventListener('resize', () => {
                engine.resize();
                // Re-render grid overlays on resize
                if (currentPhase === GamePhase.MECHBUILDER) {
                    setTimeout(() => {
                        renderGridOverlays();
                        renderGridItems();
                    }, 100);
                }
            });

            console.log('MechBuilder initialized!');
        }

        // Start the game
        initEngine();
    </script>
</body>
</html>
