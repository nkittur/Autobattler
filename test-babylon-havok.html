<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon.js + Havok Physics Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            font-family: monospace;
            color: #00ff88;
            overflow: auto;
            min-height: 100vh;
        }
        #renderCanvas {
            width: 100%;
            max-width: 900px;
            height: 50vh;
            max-height: 350px;
            display: block;
            margin: 0 auto;
            border: 3px solid #00ff88;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }
        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }
        #status {
            max-width: 900px;
            margin: 20px auto;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #00ff88;
            border-radius: 8px;
        }
        .log {
            font-size: 12px;
            margin: 2px 0;
            padding: 2px 5px;
        }
        .log.info { color: #00ff88; }
        .log.warn { color: #ffaa00; }
        .log.error { color: #ff4444; }
    </style>
</head>
<body>
    <h1>Babylon.js + Havok Physics Test</h1>
    <div style="text-align: center; margin: 10px;">
        <button id="toggleAutoFire" style="padding: 10px 20px; font-size: 16px; background: #00ff88; border: none; border-radius: 5px; cursor: pointer;">
            Start Auto-Fire
        </button>
    </div>
    <canvas id="renderCanvas"></canvas>
    <div id="status">
        <div id="logs"></div>
    </div>

    <!-- Babylon.js Core -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <!-- Havok Physics -->
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>

    <script>
        // Logging system
        const logs = [];
        function log(msg, type = 'info') {
            console.log(msg);
            logs.push({ msg, type });
            const logsDiv = document.getElementById('logs');
            logsDiv.innerHTML = logs.slice(-15).map(l =>
                `<div class="log ${l.type}">${l.msg}</div>`
            ).join('');
        }

        log('Initializing Babylon.js + Havok Physics...', 'info');

        // Global references
        let engine, scene, camera, havokInstance, havokPlugin;
        let playerMech, enemyMech;
        let projectiles = [];
        let laserBeams = [];
        let autoFireEnabled = false;
        let autoFireInterval = null;

        // Colors
        const COLORS = {
            player: new BABYLON.Color3(0, 1, 0.53),     // #00ff88
            enemy: new BABYLON.Color3(1, 0.27, 0.27),   // #ff4444
            ground: new BABYLON.Color3(0.29, 0.29, 0.42), // #4a4a6a
            projectile: new BABYLON.Color3(1, 0.67, 0),  // #ffaa00
            laser: new BABYLON.Color3(1, 0, 0),          // Red
            explosion: new BABYLON.Color3(1, 0.4, 0)     // #ff6600
        };

        // Initialize Babylon.js and Havok
        async function initEngine() {
            const canvas = document.getElementById('renderCanvas');

            // Create Babylon engine (it will handle WebGL internally)
            try {
                engine = new BABYLON.Engine(canvas, true, {
                    preserveDrawingBuffer: true,
                    stencil: true
                });
                log('Babylon Engine created', 'info');
            } catch (error) {
                log('ERROR: Failed to create Babylon engine (WebGL may not be supported): ' + error.message, 'error');
                return;
            }

            log(`Canvas element CSS size: ${canvas.clientWidth}x${canvas.clientHeight}`, 'info');
            log(`Canvas buffer size: ${canvas.width}x${canvas.height}`, 'info');
            log(`Engine rendering size: ${engine.getRenderWidth()}x${engine.getRenderHeight()}`, 'info');

            // Initialize Havok Physics
            try {
                havokInstance = await HavokPhysics();
                log('Havok Physics initialized!', 'info');
            } catch (error) {
                log('Failed to load Havok: ' + error.message, 'error');
                return;
            }

            // Create scene
            scene = createScene();

            // Start render loop
            // CRITICAL FIX DOCUMENTATION:
            // The update functions (especially stabilizeMechs) MUST be wrapped in try-catch.
            // Without this, errors during mech initialization (accessing undefined physics properties)
            // would silently kill the entire render loop, causing a gray screen with no rendering.
            // The try-catch allows the render loop to continue even if update functions throw errors.
            let frameCount = 0;
            let diagnosticsLogged = false;
            let firstFrameLogged = false;

            log('Starting render loop...', 'error');

            engine.runRenderLoop(() => {
                if (!firstFrameLogged) {
                    log('RENDER LOOP FRAME 1 EXECUTING', 'error');
                    firstFrameLogged = true;
                }

                if (scene) {
                    try {
                        scene.render();
                    } catch (e) {
                        log(`ERROR in scene.render(): ${e.message}`, 'error');
                        console.error(e);
                    }

                    frameCount++;

                    // Log diagnostics immediately at frame 10 (about 0.16 seconds)
                    if (frameCount === 10 && !diagnosticsLogged) {
                        diagnosticsLogged = true;
                        log(`=== RENDER DIAGNOSTICS (Frame ${frameCount}) ===`, 'error');
                        log(`Active meshes: ${scene.getActiveMeshes().length} / Total: ${scene.meshes.length}`, 'error');
                        log(`Draw calls: ${scene.getEngine().drawCalls}`, 'error');
                    }

                    try {
                        updateProjectiles();
                        updateLaserBeams();
                        debugMechPositions();
                    } catch (e) {
                        if (!diagnosticsLogged) {
                            log(`ERROR in update functions: ${e.message}`, 'error');
                            console.error(e);
                            diagnosticsLogged = true;
                        }
                    }
                } else {
                    if (!diagnosticsLogged) {
                        log('ERROR: scene is null/undefined in render loop!', 'error');
                        diagnosticsLogged = true;
                    }
                }
            });

            // Handle resize
            window.addEventListener('resize', () => engine.resize());

            log('Scene created and render loop started!', 'info');
        }

        function createScene() {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.05, 0.05, 0.12); // Dark background

            // Create Havok physics plugin
            havokPlugin = new BABYLON.HavokPlugin(true, havokInstance);
            scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), havokPlugin);
            log('Physics enabled with Havok', 'info');

            // Create camera - fixed isometric-style view
            camera = new BABYLON.ArcRotateCamera(
                'camera',
                -Math.PI / 2,  // Alpha (horizontal rotation)
                Math.PI / 4,   // Beta (vertical angle - 45 degree isometric)
                25,            // Radius - increased from 18 to see more
                new BABYLON.Vector3(0, 3, 0), // Target
                scene
            );
            camera.attachControl(document.getElementById('renderCanvas'), true);
            camera.lowerRadiusLimit = 5;
            camera.upperRadiusLimit = 50;

            // Ensure proper clipping planes
            camera.minZ = 0.1;
            camera.maxZ = 1000;

            // Lighting - make it much brighter
            const hemisphericLight = new BABYLON.HemisphericLight(
                'hemiLight',
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            hemisphericLight.intensity = 2.0; // Very bright

            // Create ground
            createGround(scene);

            // Create boundary walls
            createWalls(scene);

            // Create mechs (spawned at x position, they will drop to ground)
            try {
                playerMech = createMech(scene, -5, true);
                enemyMech = createMech(scene, 5, false);
                log('Scene fully initialized with mechs!', 'info');

                // DEBUG: Log scene info
                log(`Scene has ${scene.meshes.length} meshes`, 'warn');
                log(`Scene has ${scene.lights.length} lights`, 'warn');
                log(`Camera alpha: ${camera.alpha.toFixed(2)}, beta: ${camera.beta.toFixed(2)}, radius: ${camera.radius.toFixed(2)}`, 'warn');
                log(`Camera position: ${camera.position.toString()}`, 'warn');
                log(`Camera target: ${camera.target.toString()}`, 'warn');

                // List all meshes
                scene.meshes.forEach(mesh => {
                    log(`Mesh: ${mesh.name} at ${mesh.position.toString()}, visible: ${mesh.isVisible}`, 'info');
                });
            } catch (error) {
                log('CRITICAL ERROR creating mechs: ' + error.message, 'error');
                console.error('Full error:', error);
            }
            return scene;
        }

        function createGround(scene) {
            const ground = BABYLON.MeshBuilder.CreateGround('ground', {
                width: 30,
                height: 15
            }, scene);

            const groundMat = new BABYLON.StandardMaterial('groundMat', scene);
            groundMat.diffuseColor = COLORS.ground;
            groundMat.emissiveColor = COLORS.ground.scale(0.3); // Add emission for visibility
            groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            ground.material = groundMat;

            // Add physics to ground (static body)
            const groundAggregate = new BABYLON.PhysicsAggregate(
                ground,
                BABYLON.PhysicsShapeType.BOX,
                { mass: 0, friction: 0.8, restitution: 0.1 },
                scene
            );

            // Set collision group (group 4 = ground)
            groundAggregate.shape.filterMembershipMask = 4;
            groundAggregate.shape.filterCollideMask = 1 | 2; // Collide with mechs and projectiles

            log('Ground created with physics', 'info');
            return ground;
        }

        function createWalls(scene) {
            // Create invisible boundary walls
            const wallHeight = 8;
            const wallThickness = 1;
            const arenaWidth = 30;
            const arenaDepth = 15;

            const wallMat = new BABYLON.StandardMaterial('wallMat', scene);
            wallMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.4);
            wallMat.alpha = 0.3;

            // Left wall
            const leftWall = BABYLON.MeshBuilder.CreateBox('leftWall', {
                width: wallThickness, height: wallHeight, depth: arenaDepth
            }, scene);
            leftWall.position = new BABYLON.Vector3(-arenaWidth/2, wallHeight/2, 0);
            leftWall.material = wallMat;
            new BABYLON.PhysicsAggregate(leftWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

            // Right wall
            const rightWall = BABYLON.MeshBuilder.CreateBox('rightWall', {
                width: wallThickness, height: wallHeight, depth: arenaDepth
            }, scene);
            rightWall.position = new BABYLON.Vector3(arenaWidth/2, wallHeight/2, 0);
            rightWall.material = wallMat;
            new BABYLON.PhysicsAggregate(rightWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

            // Front wall
            const frontWall = BABYLON.MeshBuilder.CreateBox('frontWall', {
                width: arenaWidth, height: wallHeight, depth: wallThickness
            }, scene);
            frontWall.position = new BABYLON.Vector3(0, wallHeight/2, arenaDepth/2);
            frontWall.material = wallMat;
            new BABYLON.PhysicsAggregate(frontWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

            // Back wall
            const backWall = BABYLON.MeshBuilder.CreateBox('backWall', {
                width: arenaWidth, height: wallHeight, depth: wallThickness
            }, scene);
            backWall.position = new BABYLON.Vector3(0, wallHeight/2, -arenaDepth/2);
            backWall.material = wallMat;
            new BABYLON.PhysicsAggregate(backWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

            log('Boundary walls created', 'info');
        }

        function createMech(scene, xPos, isPlayer) {
            try {
                const color = isPlayer ? COLORS.player : COLORS.enemy;
                const mechName = isPlayer ? 'player' : 'enemy';

                log(`Creating ${mechName} mech...`, 'info');

                // Create parent transform node (non-physics, just for grouping)
                const mechRoot = new BABYLON.TransformNode(`${mechName}_root`, scene);
                mechRoot.position = new BABYLON.Vector3(xPos, 0, 0);

                // Create materials with strong emission for visibility
                const bodyMat = new BABYLON.StandardMaterial(`${mechName}_bodyMat`, scene);
                bodyMat.diffuseColor = color;
                bodyMat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                bodyMat.emissiveColor = color.scale(0.5); // Increased from 0.2 for visibility

                const darkMat = new BABYLON.StandardMaterial(`${mechName}_darkMat`, scene);
                darkMat.diffuseColor = color.scale(0.5);
                darkMat.emissiveColor = color.scale(0.3); // Add emission

                const jointMat = new BABYLON.StandardMaterial(`${mechName}_jointMat`, scene);
                jointMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                jointMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);

                const spawnY = 3.5; // Spawn height

                log(`Creating ${mechName} torso...`, 'info');

                // === TORSO (Main physics body) ===
                const torso = BABYLON.MeshBuilder.CreateBox(`${mechName}_torso`, {
                    width: 1.2, height: 1.5, depth: 0.8
                }, scene);
                torso.position = new BABYLON.Vector3(xPos, spawnY, 0);
                // Don't rotate physics bodies - causes constraint issues
                torso.material = bodyMat;

                // Add physics to torso
                const torsoAggregate = new BABYLON.PhysicsAggregate(
                    torso,
                    BABYLON.PhysicsShapeType.BOX,
                    { mass: 80, friction: 1.0, restitution: 0.05 },
                    scene
                );

                log(`${mechName} torso created with physics`, 'info');

                // Set collision group (group 1 = mechs)
                // Don't collide with own limbs (they have collision:false in constraints)
                torsoAggregate.shape.filterMembershipMask = 1;
                torsoAggregate.shape.filterCollideMask = 2 | 4; // Only projectiles and ground

                // Lock X/Z rotation for upright stability
                torsoAggregate.body.setMassProperties({
                    inertia: new BABYLON.Vector3(Infinity, 1, Infinity)
                });

                // Add damping to reduce oscillation
                torsoAggregate.body.setLinearDamping(0.1);
                torsoAggregate.body.setAngularDamping(0.5);

            // === HEAD ===
            const head = BABYLON.MeshBuilder.CreateBox(`${mechName}_head`, {
                width: 0.6, height: 0.5, depth: 0.5
            }, scene);
            head.position = new BABYLON.Vector3(0, 1.2, 0);
            head.parent = torso;
            head.material = bodyMat;

            // Visor
            const visor = BABYLON.MeshBuilder.CreateBox(`${mechName}_visor`, {
                width: 0.5, height: 0.15, depth: 0.1
            }, scene);
            visor.position = new BABYLON.Vector3(0, 0.1, 0.25);
            visor.parent = head;
            const visorMat = new BABYLON.StandardMaterial(`${mechName}_visorMat`, scene);
            visorMat.diffuseColor = new BABYLON.Color3(1, 0.2, 0);
            visorMat.emissiveColor = new BABYLON.Color3(1, 0.2, 0);
            visor.material = visorMat;

            // === ARMS ===
            const createArm = (side) => {
                const xSign = side === 'left' ? -1 : 1;
                const xOffset = xSign * 0.9;
                const armHeight = 0.6;

                // Shoulder joint (visual only, parented to torso)
                const shoulder = BABYLON.MeshBuilder.CreateSphere(`${mechName}_${side}Shoulder`, {
                    diameter: 0.3
                }, scene);
                shoulder.position = new BABYLON.Vector3(xOffset, 0.65, 0);
                shoulder.parent = torso;
                shoulder.material = jointMat;

                // Calculate arm position in world space
                // Shoulder is at torso + (xOffset, 0.65, 0)
                // Arm center should be armHeight/2 below shoulder
                const armWorldX = xPos + xOffset;
                const armWorldY = spawnY + 0.65 - (armHeight / 2);
                const armWorldZ = 0;

                // Upper arm (HAS PHYSICS - not parented!)
                const upperArm = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}UpperArm`, {
                    width: 0.25, height: armHeight, depth: 0.25
                }, scene);
                upperArm.position = new BABYLON.Vector3(armWorldX, armWorldY, armWorldZ);
                upperArm.material = darkMat;

                log(`Creating ${side} arm at world pos (${armWorldX.toFixed(2)}, ${armWorldY.toFixed(2)}, ${armWorldZ.toFixed(2)})`, 'info');

                // Add physics to arm
                const armAggregate = new BABYLON.PhysicsAggregate(
                    upperArm,
                    BABYLON.PhysicsShapeType.BOX,
                    { mass: 4, friction: 0.3, restitution: 0.1 },
                    scene
                );

                // Set collision group (group 1 = mechs)
                // Don't collide with own mech parts, only other mechs and projectiles
                armAggregate.shape.filterMembershipMask = 1;
                armAggregate.shape.filterCollideMask = 2 | 4; // Only projectiles and ground

                // Add damping to arms
                armAggregate.body.setLinearDamping(0.4);
                armAggregate.body.setAngularDamping(0.6);

                // Connect arm to torso with 6DOF constraint (allows motors)
                let armConstraint = null;
                try {
                    armConstraint = new BABYLON.PhysicsConstraint(
                        BABYLON.PhysicsConstraintType.SIX_DOF,
                        {
                            pivotA: new BABYLON.Vector3(xOffset, 0.65, 0),  // Shoulder in torso space
                            pivotB: new BABYLON.Vector3(0, armHeight / 2, 0), // Top of arm in arm space
                            collision: false, // Don't collide connected bodies
                            axisA: new BABYLON.Vector3(0, 1, 0),
                            axisB: new BABYLON.Vector3(0, 1, 0)
                        },
                        scene
                    );

                    torsoAggregate.body.addConstraint(armAggregate.body, armConstraint);

                    // Set motor target (raise arms forward for firing stance)
                    // X axis - pitch (forward/back)
                    armConstraint.setMotorEnabled(BABYLON.PhysicsConstraintAxis.ANGULAR_X, true);
                    armConstraint.setMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_X, -Math.PI / 4); // Raise arms forward 45Â°
                    armConstraint.setMotorMaxForce(BABYLON.PhysicsConstraintAxis.ANGULAR_X, 100);

                    // Y axis - yaw (left/right)
                    armConstraint.setMotorEnabled(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, true);
                    armConstraint.setMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, 0);
                    armConstraint.setMotorMaxForce(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, 100);

                    // Z axis - roll (side tilt)
                    armConstraint.setMotorEnabled(BABYLON.PhysicsConstraintAxis.ANGULAR_Z, true);
                    armConstraint.setMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_Z, xSign * Math.PI / 8); // Slightly outward
                    armConstraint.setMotorMaxForce(BABYLON.PhysicsConstraintAxis.ANGULAR_Z, 100);

                    log(`${side} arm constraint with motors created successfully`, 'info');
                } catch (e) {
                    log(`ERROR creating ${side} arm constraint: ${e.message}`, 'error');
                    console.error(`${side} arm constraint error:`, e);
                }

                // Lower arm / weapon (parented to upper arm - visual only)
                const weapon = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}Weapon`, {
                    width: 0.2, height: 0.8, depth: 0.2
                }, scene);
                weapon.position = new BABYLON.Vector3(0, -0.5, 0);
                weapon.parent = upperArm;
                weapon.material = jointMat;

                // Weapon barrel
                const barrel = BABYLON.MeshBuilder.CreateCylinder(`${mechName}_${side}Barrel`, {
                    height: 0.4, diameter: 0.12
                }, scene);
                barrel.rotation.x = Math.PI / 2;
                barrel.position = new BABYLON.Vector3(0, -0.3, 0.25);
                barrel.parent = weapon;
                barrel.material = jointMat;

                return { upperArm, shoulder, weapon, barrel, armAggregate };
            };

            const leftArm = createArm('left');
            const rightArm = createArm('right');

            // === LEGS ===
            const createLeg = (side) => {
                const xSign = side === 'left' ? -1 : 1;
                const xOffset = xSign * 0.4;
                const legHeight = 0.7;

                // Hip joint (visual only, parented to torso)
                const hip = BABYLON.MeshBuilder.CreateSphere(`${mechName}_${side}Hip`, {
                    diameter: 0.25
                }, scene);
                hip.position = new BABYLON.Vector3(xOffset, -0.85, 0);
                hip.parent = torso;
                hip.material = jointMat;

                // Calculate leg position in world space
                // Hip is at torso + (xOffset, -0.85, 0)
                // Leg center should be legHeight/2 below hip
                const legWorldX = xPos + xOffset;
                const legWorldY = spawnY - 0.85 - (legHeight / 2);
                const legWorldZ = 0;

                // Upper leg (HAS PHYSICS - not parented!)
                const upperLeg = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}UpperLeg`, {
                    width: 0.3, height: legHeight, depth: 0.3
                }, scene);
                upperLeg.position = new BABYLON.Vector3(legWorldX, legWorldY, legWorldZ);
                upperLeg.material = bodyMat;

                log(`Creating ${side} leg at world pos (${legWorldX.toFixed(2)}, ${legWorldY.toFixed(2)}, ${legWorldZ.toFixed(2)})`, 'info');

                // Add physics to leg
                const legAggregate = new BABYLON.PhysicsAggregate(
                    upperLeg,
                    BABYLON.PhysicsShapeType.BOX,
                    { mass: 6, friction: 0.8, restitution: 0.1 },
                    scene
                );

                // Set collision group (group 1 = mechs)
                // Don't collide with own mech parts, only other mechs and projectiles
                legAggregate.shape.filterMembershipMask = 1;
                legAggregate.shape.filterCollideMask = 2 | 4; // Only projectiles and ground

                // Add damping to legs (higher for stability)
                legAggregate.body.setLinearDamping(0.4);
                legAggregate.body.setAngularDamping(0.6);

                // Connect leg to torso with 6DOF constraint (allows motors)
                let legConstraint = null;
                try {
                    legConstraint = new BABYLON.PhysicsConstraint(
                        BABYLON.PhysicsConstraintType.SIX_DOF,
                        {
                            pivotA: new BABYLON.Vector3(xOffset, -0.85, 0),   // Hip in torso space
                            pivotB: new BABYLON.Vector3(0, legHeight / 2, 0), // Top of leg in leg space
                            collision: false, // Don't collide connected bodies
                            axisA: new BABYLON.Vector3(0, 1, 0),
                            axisB: new BABYLON.Vector3(0, 1, 0)
                        },
                        scene
                    );

                    torsoAggregate.body.addConstraint(legAggregate.body, legConstraint);

                    // Set motor target (keep leg pointing down straight)
                    // X axis - pitch (forward/back)
                    legConstraint.setMotorEnabled(BABYLON.PhysicsConstraintAxis.ANGULAR_X, true);
                    legConstraint.setMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_X, 0);
                    legConstraint.setMotorMaxForce(BABYLON.PhysicsConstraintAxis.ANGULAR_X, 150);

                    // Y axis - yaw (left/right turn)
                    legConstraint.setMotorEnabled(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, true);
                    legConstraint.setMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, 0);
                    legConstraint.setMotorMaxForce(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, 150);

                    // Z axis - roll (side tilt)
                    legConstraint.setMotorEnabled(BABYLON.PhysicsConstraintAxis.ANGULAR_Z, true);
                    legConstraint.setMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_Z, 0);
                    legConstraint.setMotorMaxForce(BABYLON.PhysicsConstraintAxis.ANGULAR_Z, 150);

                    log(`${side} leg constraint with motors created successfully`, 'info');
                } catch (e) {
                    log(`ERROR creating ${side} leg constraint: ${e.message}`, 'error');
                    console.error(`${side} leg constraint error:`, e);
                }

                // Knee joint (visual, parented to upper leg)
                const knee = BABYLON.MeshBuilder.CreateSphere(`${mechName}_${side}Knee`, {
                    diameter: 0.2
                }, scene);
                knee.position = new BABYLON.Vector3(0, -0.45, 0);
                knee.parent = upperLeg;
                knee.material = jointMat;

                // Lower leg (parented to upper leg)
                const lowerLeg = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}LowerLeg`, {
                    width: 0.25, height: 0.6, depth: 0.25
                }, scene);
                lowerLeg.position = new BABYLON.Vector3(0, -0.85, 0);
                lowerLeg.parent = upperLeg;
                lowerLeg.material = darkMat;

                // Foot (parented to lower leg)
                const foot = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}Foot`, {
                    width: 0.35, height: 0.15, depth: 0.5
                }, scene);
                foot.position = new BABYLON.Vector3(0, -0.38, 0.1);
                foot.parent = lowerLeg;
                foot.material = jointMat;

                return { hip, upperLeg, knee, lowerLeg, foot, legAggregate };
            };

            const leftLeg = createLeg('left');
            const rightLeg = createLeg('right');

            // === SHOULDER ARMOR ===
            const createShoulderArmor = (side) => {
                const xOffset = side === 'left' ? -0.85 : 0.85;
                const shoulderArmor = BABYLON.MeshBuilder.CreateBox(`${mechName}_${side}ShoulderArmor`, {
                    width: 0.5, height: 0.35, depth: 0.6
                }, scene);
                shoulderArmor.position = new BABYLON.Vector3(xOffset, 0.8, 0);
                shoulderArmor.parent = torso;
                shoulderArmor.material = bodyMat;
                return shoulderArmor;
            };

            createShoulderArmor('left');
            createShoulderArmor('right');

            // Store mech data
            const mechData = {
                root: mechRoot,
                torso: torso,
                torsoAggregate: torsoAggregate,
                head: head,
                visor: visor,
                leftArm: leftArm,
                rightArm: rightArm,
                leftLeg: leftLeg,
                rightLeg: rightLeg,
                isPlayer: isPlayer,
                currentHP: 100,
                maxHP: 100,
                color: color
            };

                log(`${isPlayer ? 'Player' : 'Enemy'} mech created at torso: (${torso.position.x.toFixed(1)}, ${torso.position.y.toFixed(1)}, ${torso.position.z.toFixed(1)})`, 'info');
                return mechData;
            } catch (error) {
                log(`ERROR creating ${isPlayer ? 'player' : 'enemy'} mech: ${error.message}`, 'error');
                console.error('Mech creation error:', error);
                throw error;
            }
        }

        // === PROJECTILE SYSTEM ===
        function firePlayerProjectile() {
            if (!playerMech || !enemyMech) return;
            createProjectile(playerMech, enemyMech, 15);
        }

        function fireEnemyProjectile() {
            if (!playerMech || !enemyMech) return;
            createProjectile(enemyMech, playerMech, 12);
        }

        // Arm raising animation for firing - no longer needed with motor-controlled arms
        function raiseArmsToFire(mech) {
            // Arms are now controlled by motors and already in firing position
            // No manual animation needed
        }

        function createProjectile(fromMech, toMech, damage) {
            // Arms are already raised by motors, no animation needed
            // raiseArmsToFire(fromMech);

            // Get world positions (torso is parented to collisionBody, so use absolute position)
            const startPos = fromMech.torso.getAbsolutePosition().clone();
            startPos.y += 0.3; // Fire from weapon height

            const targetPos = toMech.torso.getAbsolutePosition().clone();

            log(`PROJECTILE: from (${startPos.x.toFixed(1)}, ${startPos.y.toFixed(1)}, ${startPos.z.toFixed(1)}) to (${targetPos.x.toFixed(1)}, ${targetPos.y.toFixed(1)}, ${targetPos.z.toFixed(1)})`, 'info');

            // Calculate direction
            const direction = targetPos.subtract(startPos).normalize();
            const angle = Math.atan2(direction.x, direction.z);

            // Create elongated projectile (bullet/energy bolt shape)
            const projectile = BABYLON.MeshBuilder.CreateCylinder('projectile_' + Date.now(), {
                height: 0.8,
                diameter: 0.25,
                tessellation: 8
            }, scene);
            projectile.position = startPos.clone();

            // Rotate to point in direction of travel
            projectile.rotation.x = Math.PI / 2;
            projectile.rotation.y = angle;

            // Projectile material with intense glow
            const projMat = new BABYLON.StandardMaterial('projMat_' + Date.now(), scene);
            projMat.diffuseColor = COLORS.projectile;
            projMat.emissiveColor = COLORS.projectile.scale(1.5); // Brighter glow
            projMat.specularColor = new BABYLON.Color3(1, 1, 1);
            projectile.material = projMat;

            // Create glowing trail effect
            const trail = BABYLON.MeshBuilder.CreateCylinder('trail_' + Date.now(), {
                height: 1.5,
                diameter: 0.15,
                tessellation: 8
            }, scene);
            trail.position = new BABYLON.Vector3(0, -0.5, 0);
            trail.parent = projectile;
            const trailMat = new BABYLON.StandardMaterial('trailMat_' + Date.now(), scene);
            trailMat.diffuseColor = COLORS.projectile;
            trailMat.emissiveColor = COLORS.projectile;
            trailMat.alpha = 0.6;
            trail.material = trailMat;

            // Add physics to projectile
            const projAggregate = new BABYLON.PhysicsAggregate(
                projectile,
                BABYLON.PhysicsShapeType.SPHERE,
                { mass: 0.3, friction: 0, restitution: 0.2 },
                scene
            );

            // Set collision filter so projectiles don't collide with each other
            // Group 1 = mechs, Group 2 = projectiles, Group 4 = ground
            // Projectiles collide with mechs (1) and ground (4), but not other projectiles (2)
            const projectileGroup = 2;
            const projectileMask = 1 | 4; // Collide with groups 1 (mechs) and 4 (ground)
            projAggregate.shape.filterMembershipMask = projectileGroup;
            projAggregate.shape.filterCollideMask = projectileMask;

            // Apply high velocity for fast, impactful shot
            const speed = 45;
            const velocity = direction.scale(speed);
            projAggregate.body.setLinearVelocity(velocity);

            // Store projectile data
            projectiles.push({
                mesh: projectile,
                aggregate: projAggregate,
                damage: damage,
                target: toMech,
                firedAt: Date.now(),
                fromPlayer: fromMech.isPlayer
            });

            log(`${fromMech.isPlayer ? 'Player' : 'Enemy'} fired projectile!`, 'info');
        }

        function updateProjectiles() {
            const now = Date.now();

            projectiles = projectiles.filter(proj => {
                // Remove old projectiles (after 5 seconds)
                if (now - proj.firedAt > 5000) {
                    proj.mesh.dispose();
                    return false;
                }

                // Check for collision with target - check all body parts
                const projPos = proj.mesh.position;

                // Check which body part was hit
                let hitPart = null;
                let hitPartName = 'torso';
                let minDist = Infinity;

                // Check torso
                const torsoPos = proj.target.torso.getAbsolutePosition();
                let dist = BABYLON.Vector3.Distance(projPos, torsoPos);
                if (dist < 1.2) {
                    hitPart = proj.target.torso;
                    hitPartName = 'torso';
                    minDist = dist;
                }

                // Check head
                const headPos = proj.target.head.getAbsolutePosition();
                dist = BABYLON.Vector3.Distance(projPos, headPos);
                if (dist < 0.6 && dist < minDist) {
                    hitPart = proj.target.head;
                    hitPartName = 'head';
                    minDist = dist;
                }

                // Check arms
                const leftArmPos = proj.target.leftArm.upperArm.getAbsolutePosition();
                dist = BABYLON.Vector3.Distance(projPos, leftArmPos);
                if (dist < 0.8 && dist < minDist) {
                    hitPart = proj.target.leftArm.upperArm;
                    hitPartName = 'left arm';
                    minDist = dist;
                }

                const rightArmPos = proj.target.rightArm.upperArm.getAbsolutePosition();
                dist = BABYLON.Vector3.Distance(projPos, rightArmPos);
                if (dist < 0.8 && dist < minDist) {
                    hitPart = proj.target.rightArm.upperArm;
                    hitPartName = 'right arm';
                    minDist = dist;
                }

                // Check legs
                const leftLegPos = proj.target.leftLeg.upperLeg.getAbsolutePosition();
                dist = BABYLON.Vector3.Distance(projPos, leftLegPos);
                if (dist < 0.8 && dist < minDist) {
                    hitPart = proj.target.leftLeg.upperLeg;
                    hitPartName = 'left leg';
                    minDist = dist;
                }

                const rightLegPos = proj.target.rightLeg.upperLeg.getAbsolutePosition();
                dist = BABYLON.Vector3.Distance(projPos, rightLegPos);
                if (dist < 0.8 && dist < minDist) {
                    hitPart = proj.target.rightLeg.upperLeg;
                    hitPartName = 'right leg';
                    minDist = dist;
                }

                if (hitPart) {
                    // Hit a body part!
                    proj.target.currentHP -= proj.damage;
                    log(`HIT ${hitPartName}! ${proj.fromPlayer ? 'Enemy' : 'Player'} takes ${proj.damage} damage! (${proj.target.currentHP}/${proj.target.maxHP} HP)`, 'warn');

                    // Create impact effect at hit location
                    createImpactEffect(projPos.clone());

                    // Flash the specific part that was hit
                    flashMeshOnHit(hitPart);

                    // Apply impact force to the specific limb that was hit
                    let targetAggregate = proj.target.torsoAggregate; // Default to torso
                    let impactForce = 8; // Base impact force

                    // Determine which aggregate to apply force to based on what was hit
                    if (hitPartName === 'left arm' && proj.target.leftArm.armAggregate) {
                        targetAggregate = proj.target.leftArm.armAggregate;
                        impactForce = 15; // Stronger impact on limbs
                    } else if (hitPartName === 'right arm' && proj.target.rightArm.armAggregate) {
                        targetAggregate = proj.target.rightArm.armAggregate;
                        impactForce = 15;
                    } else if (hitPartName === 'left leg' && proj.target.leftLeg.legAggregate) {
                        targetAggregate = proj.target.leftLeg.legAggregate;
                        impactForce = 15;
                    } else if (hitPartName === 'right leg' && proj.target.rightLeg.legAggregate) {
                        targetAggregate = proj.target.rightLeg.legAggregate;
                        impactForce = 15;
                    }

                    // Apply impulse to the hit part
                    const hitPartPos = hitPart.getAbsolutePosition();
                    const impactDir = projPos.subtract(hitPartPos).normalize();
                    targetAggregate.body.applyImpulse(
                        impactDir.scale(impactForce),
                        projPos // Apply at hit point for realistic rotation
                    );

                    proj.mesh.dispose();
                    return false;
                }

                // Check if projectile is out of bounds
                if (projPos.y < -5 || Math.abs(projPos.x) > 20 || Math.abs(projPos.z) > 10) {
                    proj.mesh.dispose();
                    return false;
                }

                return true;
            });
        }

        // === LASER BEAM SYSTEM ===
        function fireLaser(isPlayer) {
            const fromMech = isPlayer ? playerMech : enemyMech;
            const toMech = isPlayer ? enemyMech : playerMech;

            // Arms are already raised by motors, no animation needed
            // raiseArmsToFire(fromMech);

            // Get world positions (torso is parented to collisionBody, so use absolute position)
            const startPos = fromMech.torso.getAbsolutePosition().clone();
            startPos.y += 0.3;

            const endPos = toMech.torso.getAbsolutePosition().clone();

            log(`LASER: from (${startPos.x.toFixed(1)}, ${startPos.y.toFixed(1)}, ${startPos.z.toFixed(1)}) to (${endPos.x.toFixed(1)}, ${endPos.y.toFixed(1)}, ${endPos.z.toFixed(1)})`, 'info');

            // Create main laser beam (thick and bright)
            const points = [startPos, endPos];
            const laserBeam = BABYLON.MeshBuilder.CreateTube('laser_' + Date.now(), {
                path: points,
                radius: 0.2,
                updatable: false
            }, scene);

            // Laser material with intense glow
            const laserMat = new BABYLON.StandardMaterial('laserMat_' + Date.now(), scene);
            laserMat.diffuseColor = COLORS.laser;
            laserMat.emissiveColor = COLORS.laser.scale(2); // Very bright
            laserMat.alpha = 0.9;
            laserBeam.material = laserMat;

            // Create outer glow layer
            const glowBeam = BABYLON.MeshBuilder.CreateTube('laserGlow_' + Date.now(), {
                path: points,
                radius: 0.35,
                updatable: false
            }, scene);
            const glowMat = new BABYLON.StandardMaterial('glowMat_' + Date.now(), scene);
            glowMat.diffuseColor = COLORS.laser;
            glowMat.emissiveColor = COLORS.laser.scale(0.8);
            glowMat.alpha = 0.4;
            glowBeam.material = glowMat;

            // Detect which body part was hit by checking end position
            let hitPart = toMech.torso;
            let hitPartName = 'torso';
            let minDist = BABYLON.Vector3.Distance(endPos, toMech.torso.getAbsolutePosition());

            // Check head
            let dist = BABYLON.Vector3.Distance(endPos, toMech.head.getAbsolutePosition());
            if (dist < minDist) {
                hitPart = toMech.head;
                hitPartName = 'head';
                minDist = dist;
            }

            // Check arms
            dist = BABYLON.Vector3.Distance(endPos, toMech.leftArm.upperArm.getAbsolutePosition());
            if (dist < minDist) {
                hitPart = toMech.leftArm.upperArm;
                hitPartName = 'left arm';
                minDist = dist;
            }

            dist = BABYLON.Vector3.Distance(endPos, toMech.rightArm.upperArm.getAbsolutePosition());
            if (dist < minDist) {
                hitPart = toMech.rightArm.upperArm;
                hitPartName = 'right arm';
                minDist = dist;
            }

            // Check legs
            dist = BABYLON.Vector3.Distance(endPos, toMech.leftLeg.upperLeg.getAbsolutePosition());
            if (dist < minDist) {
                hitPart = toMech.leftLeg.upperLeg;
                hitPartName = 'left leg';
                minDist = dist;
            }

            dist = BABYLON.Vector3.Distance(endPos, toMech.rightLeg.upperLeg.getAbsolutePosition());
            if (dist < minDist) {
                hitPart = toMech.rightLeg.upperLeg;
                hitPartName = 'right leg';
            }

            // Apply damage immediately (laser is instant)
            const damage = 10;
            toMech.currentHP -= damage;
            log(`LASER HIT ${hitPartName}! ${isPlayer ? 'Enemy' : 'Player'} takes ${damage} damage! (${toMech.currentHP}/${toMech.maxHP} HP)`, 'warn');

            // Store both beams for fadeout
            laserBeams.push({
                mesh: laserBeam,
                glowMesh: glowBeam,
                material: laserMat,
                glowMaterial: glowMat,
                createdAt: Date.now(),
                duration: 200 // ms
            });

            // Create impact at target
            createImpactEffect(endPos.clone());

            // Flash the specific part that was hit
            flashMeshOnHit(hitPart);

            // Apply impact force to the specific limb that was hit
            let targetAggregate = toMech.torsoAggregate; // Default to torso
            let impactForce = 5; // Base laser impact force

            // Determine which aggregate to apply force to based on what was hit
            if (hitPartName === 'left arm' && toMech.leftArm.armAggregate) {
                targetAggregate = toMech.leftArm.armAggregate;
                impactForce = 10; // Stronger impact on limbs
            } else if (hitPartName === 'right arm' && toMech.rightArm.armAggregate) {
                targetAggregate = toMech.rightArm.armAggregate;
                impactForce = 10;
            } else if (hitPartName === 'left leg' && toMech.leftLeg.legAggregate) {
                targetAggregate = toMech.leftLeg.legAggregate;
                impactForce = 10;
            } else if (hitPartName === 'right leg' && toMech.rightLeg.legAggregate) {
                targetAggregate = toMech.rightLeg.legAggregate;
                impactForce = 10;
            }

            // Apply impulse to the hit part
            const laserDir = endPos.subtract(startPos).normalize();
            targetAggregate.body.applyImpulse(
                laserDir.scale(impactForce),
                endPos // Apply at hit point
            );
        }

        function updateLaserBeams() {
            const now = Date.now();

            laserBeams = laserBeams.filter(beam => {
                const age = now - beam.createdAt;

                if (age > beam.duration) {
                    beam.mesh.dispose();
                    beam.glowMesh.dispose();
                    return false;
                }

                // Fade out both beams
                const fadeProgress = age / beam.duration;
                beam.material.alpha = 0.9 * (1 - fadeProgress);
                beam.glowMaterial.alpha = 0.4 * (1 - fadeProgress);
                return true;
            });
        }

        // Debug: Log mech positions periodically
        let lastDebugTime = 0;
        function debugMechPositions() {
            const now = Date.now();
            if (now - lastDebugTime < 3000) return; // Log every 3 seconds
            lastDebugTime = now;

            if (playerMech) {
                const pos = playerMech.torso.getAbsolutePosition();
                log(`Player at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`, 'info');
            }
            if (enemyMech) {
                const pos = enemyMech.torso.getAbsolutePosition();
                log(`Enemy at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`, 'info');
            }
        }

        // No active stabilization needed - using single physics body per mech

        // === EFFECTS ===

        function flashMeshOnHit(mesh) {
            // Store original material properties
            const material = mesh.material;
            if (!material) return;

            const originalEmissive = material.emissiveColor ? material.emissiveColor.clone() : new BABYLON.Color3(0, 0, 0);
            const originalDiffuse = material.diffuseColor ? material.diffuseColor.clone() : new BABYLON.Color3(1, 1, 1);

            // Flash bright red/white
            material.emissiveColor = new BABYLON.Color3(1, 0.3, 0.3);
            material.diffuseColor = new BABYLON.Color3(1.8, 0.8, 0.8);

            // Quick fade back through orange to original
            setTimeout(() => {
                if (material) {
                    material.emissiveColor = new BABYLON.Color3(1, 0.5, 0);
                    material.diffuseColor = new BABYLON.Color3(1.5, 1, 0.8);
                }
            }, 50);

            // Restore original colors after a short delay
            setTimeout(() => {
                if (material) {
                    material.emissiveColor = originalEmissive;
                    material.diffuseColor = originalDiffuse;
                }
            }, 150);
        }


        function createImpactEffect(position) {
            // Create particle system for impact
            const particleSystem = new BABYLON.ParticleSystem('impact_' + Date.now(), 100, scene);

            // Texture (procedural)
            particleSystem.particleTexture = new BABYLON.Texture('https://assets.babylonjs.com/textures/flare.png', scene);

            // Emitter
            particleSystem.emitter = position;
            particleSystem.minEmitBox = new BABYLON.Vector3(-0.2, -0.2, -0.2);
            particleSystem.maxEmitBox = new BABYLON.Vector3(0.2, 0.2, 0.2);

            // Colors - bright orange/yellow explosion
            particleSystem.color1 = new BABYLON.Color4(1, 0.8, 0, 1);
            particleSystem.color2 = new BABYLON.Color4(1, 0.3, 0, 1);
            particleSystem.colorDead = new BABYLON.Color4(0.3, 0.1, 0, 0);

            // Size - larger particles
            particleSystem.minSize = 0.15;
            particleSystem.maxSize = 0.5;

            // Lifetime
            particleSystem.minLifeTime = 0.15;
            particleSystem.maxLifeTime = 0.4;

            // Emission - burst of particles
            particleSystem.emitRate = 300;
            particleSystem.manualEmitCount = 60;

            // Speed - faster explosion
            particleSystem.minEmitPower = 3;
            particleSystem.maxEmitPower = 8;
            particleSystem.updateSpeed = 0.015;

            // Direction - spherical burst
            particleSystem.direction1 = new BABYLON.Vector3(-1, -0.5, -1);
            particleSystem.direction2 = new BABYLON.Vector3(1, 1, 1);

            // Gravity
            particleSystem.gravity = new BABYLON.Vector3(0, -8, 0);

            // Add glow/blend mode for more dramatic effect
            particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;

            // Start and auto-dispose
            particleSystem.start();
            particleSystem.targetStopDuration = 0.4;
            particleSystem.disposeOnStop = true;
        }

        function resetScene() {
            const resetHeight = 3.5;

            // Reset player mech
            if (playerMech) {
                playerMech.torso.position = new BABYLON.Vector3(-5, resetHeight, 0);
                playerMech.torsoAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                playerMech.torsoAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());
                playerMech.currentHP = playerMech.maxHP;
            }

            // Reset enemy mech
            if (enemyMech) {
                enemyMech.torso.position = new BABYLON.Vector3(5, resetHeight, 0);
                enemyMech.torsoAggregate.body.setLinearVelocity(BABYLON.Vector3.Zero());
                enemyMech.torsoAggregate.body.setAngularVelocity(BABYLON.Vector3.Zero());
                enemyMech.currentHP = enemyMech.maxHP;
            }

            // Clear projectiles
            projectiles.forEach(p => p.mesh.dispose());
            projectiles = [];

            // Clear laser beams
            laserBeams.forEach(b => {
                b.mesh.dispose();
                if (b.glowMesh) b.glowMesh.dispose();
            });
            laserBeams = [];

            log('Scene reset!', 'info');
        }

        // Auto-fire weapons periodically
        function startAutoFire() {
            if (autoFireInterval) {
                clearInterval(autoFireInterval);
            }
            autoFireInterval = setInterval(() => {
                if (autoFireEnabled && playerMech && enemyMech && playerMech.currentHP > 0 && enemyMech.currentHP > 0) {
                    // Randomly fire weapons
                    if (Math.random() > 0.7) {
                        createProjectile(playerMech, enemyMech, 15);
                    }
                    if (Math.random() > 0.7) {
                        createProjectile(enemyMech, playerMech, 12);
                    }
                    if (Math.random() > 0.8) {
                        fireLaser(true);
                    }
                    if (Math.random() > 0.8) {
                        fireLaser(false);
                    }
                }
            }, 1000); // Fire every second
        }

        function toggleAutoFire() {
            autoFireEnabled = !autoFireEnabled;
            const button = document.getElementById('toggleAutoFire');
            if (autoFireEnabled) {
                button.textContent = 'Stop Auto-Fire';
                button.style.background = '#ff4444';
                log('Auto-fire ENABLED', 'warn');
            } else {
                button.textContent = 'Start Auto-Fire';
                button.style.background = '#00ff88';
                log('Auto-fire DISABLED', 'warn');
            }
        }

        // Initialize when page loads
        initEngine().then(() => {
            // Set up auto-fire interval (but it won't fire unless enabled)
            startAutoFire();
            log('Scene ready! Click "Start Auto-Fire" button to begin combat.', 'info');
        });

        // Add button event listener
        document.getElementById('toggleAutoFire').addEventListener('click', toggleAutoFire);
    </script>
</body>
</html>
